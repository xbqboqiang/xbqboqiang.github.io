<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-c-primer-14-重载运算符与类型转换" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/30/c-primer-14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" class="article-date">
  <time datetime="2020-08-30T02:51:40.000Z" itemprop="datePublished">2020-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/30/c-primer-14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/">c++ primer 14 重载运算符与类型转换</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>重载运算符与类型转换</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>重载的运算符是具有特殊名字的函数：名字由关键字operator和其后要定义的运算符号共同组成。包含返回类型、参数列表、函数体<br>对于二元运算符，左侧运算对象传递给第一个参数，右侧传递给第二个。除重载的函数调用运算符operator()外，不能含有默认实参<br>若为成员函数，左侧运算对象绑定到隐式的this指针上，所以显式参数数量比运算符的运算对象总少一个<br>不能重载内置类型的运算符    不能发明新符号<br>———————————————————— - 491</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data1 + data2;			&#x2F;&#x2F;普通的表达式</span><br><span class="line">operator+(data1, data2);&#x2F;&#x2F;等价的函数调用</span><br><span class="line"></span><br><span class="line">data1 +&#x3D; data2;			&#x2F;&#x2F;基于&quot;调用&quot;的表达式</span><br><span class="line">data1.operator+&#x3D;(data2);&#x2F;&#x2F;对成员运算符函数的等价调用</span><br></pre></td></tr></table></figure>
<p>选择作为成员或非成员<br>·赋值(= ), 下标([]), 调用(()), 和成员访问箭头(-&gt;)运算符必须是成员<br>·复合赋值运算符一般来说应该是成员<br>·改变对象状态的或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常应该是成员<br>·具有对称性的运算符可能转换任意一端的运算对象，如算术、相等性、关系和位运算符等，通常应该是普通的非成员函数<br>当把运算符定义为成员函数时，左侧运算对象必须是运算符所属类的一个对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s &#x3D; &quot;world&quot;;</span><br><span class="line">string t &#x3D; s + &quot;!&quot;;	&#x2F;&#x2F;正确：把一个const char*加到一个string对象中</span><br><span class="line">strign u &#x3D; &quot;hi&quot; + s;&#x2F;&#x2F;如果&quot;+&quot;是string成员，则错误</span><br></pre></td></tr></table></figure>
<h2 id="输入和输出运算符"><a href="#输入和输出运算符" class="headerlink" title="输入和输出运算符"></a>输入和输出运算符</h2><h3 id="重载输出运算符-lt-lt"><a href="#重载输出运算符-lt-lt" class="headerlink" title="重载输出运算符&lt;&lt;"></a>重载输出运算符&lt;&lt;</h3><p>通常情况下，输出运算符第一个形参是一个非常量ostream对象的引用<br>非常量：向流写入会改变其状态；引用：无法直接复制一个ostream对象<br>第二个参数一般是一个常量引用<br>常量：打印对象不会改变内容；引用：避免赋值实参<br>一般返回ostream形参</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ostream&amp; operator&lt;&lt;(ostream&amp; os, const Sales_data&amp; item) &#123;</span><br><span class="line">	os &lt;&lt; item.isbn() &lt;&lt; &quot; &quot; &lt;&lt; item.units_sold &lt;&lt; &quot; &quot; &lt;&lt; item.revenue &lt;&lt; &quot; &quot; &lt;&lt; item.avg_price;</span><br><span class="line">	return os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入输出运算符必须是非成员函数，否则它左侧运算对象将是我们类的一个对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sales_data data;</span><br><span class="line">data &lt;&lt; cout;</span><br></pre></td></tr></table></figure>
<p>一般被声明成友元</p>
<h3 id="重载输入运算符-gt-gt"><a href="#重载输入运算符-gt-gt" class="headerlink" title="重载输入运算符&gt;&gt;"></a>重载输入运算符&gt;&gt;</h3><p>通常情况下，第一个形参是运算符将要读取的流的引用，第二个是将要读入到的(非常量)对象的引用。通常会返回某个给定流的引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">istream&amp; operator&gt;&gt;(istream&amp; is, Sales_data&amp; item) &#123;</span><br><span class="line">	double price;	&#x2F;&#x2F;不需要初始化</span><br><span class="line">	is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;</span><br><span class="line">	if (is)</span><br><span class="line">		item.revenue &#x3D; item.units_sold * price;</span><br><span class="line">	else</span><br><span class="line">		item &#x3D; Sales_data(); &#x2F;&#x2F;输入失败：对象被赋予默认的状态</span><br><span class="line">	return is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输入时的错误：<br>当流含有错误类型的数据是读取操作可能失败；当读取操作到达文件末尾或者遇到输入流的其他错误</p>
<h2 id="算术和关系运算符"><a href="#算术和关系运算符" class="headerlink" title="算术和关系运算符"></a>算术和关系运算符</h2><p>通常定义为非成员函数，形参是常量引用<br>如果同时定义了算术运算符合相关的复合赋值运算符，通常应该用复合赋值来实现算术运算符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sales_data operator+(const Sales_data&amp; lhs, const Sales_data&amp; rhs) &#123;</span><br><span class="line">	Sales_data sum &#x3D; lhs;</span><br><span class="line">	sum +&#x3D; rhs;</span><br><span class="line">	return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="相等运算符"><a href="#相等运算符" class="headerlink" title="相等运算符"></a>相等运算符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bool operator&#x3D;&#x3D;(const Sales_data&amp; lhs, const Sales_data&amp; rhs) &#123;</span><br><span class="line">	return lhs.isbn() &#x3D;&#x3D; rhs.isbn() &amp;&amp; lhs.units_sold &#x3D;&#x3D; rhs.units_sold &amp;&amp; lhs.revenue &#x3D;&#x3D; rhs.revenue;</span><br><span class="line">&#125;</span><br><span class="line">bool operator!&#x3D;(const Sales_data&amp; lhs, const Sales_data&amp; rhs) &#123;</span><br><span class="line">	return !(lhs &#x3D;&#x3D; rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>如果存在唯一一种逻辑可靠的&lt;定义，则应该考虑为这个类定义&lt;运算符。如果类同时还包含==，则当且仅当&lt;的定义和==产生的结果一致时才定义&lt;运算符</p>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class StrVec &#123;</span><br><span class="line">public:</span><br><span class="line">	StrVec&amp; operator&#x3D;(initialized_list&lt;string&gt;);</span><br><span class="line">&#125;;</span><br><span class="line">StrVec&amp; StrVec::operator&#x3D;(initialized_list&lt;string&gt; il) &#123;</span><br><span class="line">	&#x2F;&#x2F;alloc_n_copy分配内存空间并从给定范围内拷贝元素</span><br><span class="line">	auto data &#x3D; alloc_n_copy(il.begin(), il.end());</span><br><span class="line">	free();					&#x2F;&#x2F;销毁对象中的元素并释放内存空间</span><br><span class="line">	elements &#x3D; data.first;	&#x2F;&#x2F;更新数据成员并使其指向新内存空间</span><br><span class="line">	first_free &#x3D; cap &#x3D; data.second;</span><br><span class="line">	return*this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>赋值运算符必须定义成类的成员，复合赋值运算符通常也是。两种都返回左侧运算符对象的引用</p>
<h2 id="下标运算符"><a href="#下标运算符" class="headerlink" title="下标运算符"></a>下标运算符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class StrVec &#123;</span><br><span class="line">public:</span><br><span class="line">	string&amp; operator[](size_t n) &#123;</span><br><span class="line">		return elements[n];</span><br><span class="line">	&#125;</span><br><span class="line">	const string&amp; operator[](size_t n)const &#123;</span><br><span class="line">		return elements[n];</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	string* elements;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通常定义返回普通引用和作为常量成员且返回常量引用，两个版本。返回元素的引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const StrVec cvec &#x3D; svec;</span><br><span class="line">if (svec.size() &amp;&amp; svec[0].empty()) &#123;</span><br><span class="line">	svec[0] &#x3D; &quot;zero&quot;;	&#x2F;&#x2F;正确：下标运算符返回string的引用</span><br><span class="line">	cvec[0] &#x3D; &quot;zip&quot;;	&#x2F;&#x2F;错误：对cvec取下标返回的是常量引用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="递增和递减运算符"><a href="#递增和递减运算符" class="headerlink" title="递增和递减运算符"></a>递增和递减运算符</h2><p>它们改变的正好是操作对象的状态，所以建议将其设为成员函数</p>
<p>前置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class StrBlobPtr &#123;</span><br><span class="line">public:</span><br><span class="line">	StrBlobPtr&amp; operator++();</span><br><span class="line">	StrBlobPtr&amp; operator--();</span><br><span class="line">&#125;;</span><br><span class="line">StrBlobPtr&amp; StrBlobPtr::operator++() &#123;</span><br><span class="line">	&#x2F;&#x2F;如果已经指向容器尾后，则无法递增</span><br><span class="line">	check(curr, &quot;increment past end of StrBlobPtr&quot;);</span><br><span class="line">	++curr;</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br><span class="line">StrBlobPtr&amp; StrBlobPtr::operator--() &#123;</span><br><span class="line">	--curr;</span><br><span class="line">	check(curr, &quot;decrement past begin of StrBlobPtr&quot;);</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>区分前置后置<br>后置版本接受一个额外的(不被使用)int类型的形参。使用时编译器为这个形参提供一个值为0的实参</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class StrBlobPtr &#123;</span><br><span class="line">public:</span><br><span class="line">	StrBlobPtr operator++(int);</span><br><span class="line">	StrBlobPtr operator--(int);</span><br><span class="line">&#125;;</span><br><span class="line">StrBlobPtr StrBlobPtr::operator++(int) &#123;</span><br><span class="line">	StrBlobPtr ret &#x3D; *this;	&#x2F;&#x2F;记录当前值</span><br><span class="line">	++* this;				&#x2F;&#x2F;向前移动一个元素，前置++需要检查递增的有效性</span><br><span class="line">	return ret;				&#x2F;&#x2F;返回之前记录的状态</span><br><span class="line">&#125;</span><br><span class="line">StrBlobPtr StrBlobPtr::operator--(int) &#123;</span><br><span class="line">	StrBlobPtr ret &#x3D; *this;	&#x2F;&#x2F;记录当前值</span><br><span class="line">	--* this;				&#x2F;&#x2F;向后移动一个元素，前置--需要检查递增的有效性</span><br><span class="line">	return ret;				&#x2F;&#x2F;返回之前记录的状态</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后置运算符调用各自的前置版本来完成实际的工作</p>
<p>显式调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StrBlobPtr p(a1);</span><br><span class="line">p.operator++(0);	&#x2F;&#x2F;后置</span><br><span class="line">p.operator++();		&#x2F;&#x2F;前置</span><br></pre></td></tr></table></figure>
<h2 id="成员访问运算符"><a href="#成员访问运算符" class="headerlink" title="成员访问运算符"></a>成员访问运算符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class StrBlobPtr &#123;</span><br><span class="line">public:</span><br><span class="line">	string&amp; operator*()const &#123;</span><br><span class="line">		auto p &#x3D; check(curr, &quot;dereference past end&quot;);</span><br><span class="line">		return (*p)[curr];	&#x2F;&#x2F;(*p)是对象所指的vector</span><br><span class="line">	&#125;</span><br><span class="line">	string* operator-&gt;()const &#123;</span><br><span class="line">		return&amp;this-&gt;operator*();	&#x2F;&#x2F;实际将工作委托给解引用运算符</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>解引用运算符首先检查curr是否仍在作用范围内，是则返回curr所指元素的一个引用<br>箭头运算符不执行任何自己的操作，而是调用解引用运算符并返回解引用结果元素的地址<br>箭头运算符必须是类的成员，解引用通常也是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StrBlob a1 &#x3D; &#123; &quot;hi&quot;,&quot;bye&quot;,&quot;now&quot; &#125;;</span><br><span class="line">StrBlobPtr p(a1);		&#x2F;&#x2F;p指向a1中的vector</span><br><span class="line">*p &#x3D; &quot;okay&quot;;			&#x2F;&#x2F;给a1的首元素赋值</span><br><span class="line">cout &lt;&lt; p-&gt;size();		&#x2F;&#x2F;打印4，a1首元素的大小</span><br><span class="line">cout &lt;&lt; (*p).size();	&#x2F;&#x2F;等价于p-&gt;size()</span><br></pre></td></tr></table></figure>
<p>箭头运算符永远不能丢掉成员访问这个最基本的含义<br>point-&gt;men分别等价于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(*point).mem;			&#x2F;&#x2F;point是一个内置的指针类型</span><br><span class="line">point.operator()-&gt;mem;	&#x2F;&#x2F;point是一个类的对象</span><br></pre></td></tr></table></figure>
<h2 id="函数调用运算符"><a href="#函数调用运算符" class="headerlink" title="函数调用运算符"></a>函数调用运算符</h2><p>如果类重载了函数调用运算符，则可以像使用函数一样使用该类的对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct absInt &#123;</span><br><span class="line">	int operator()(int val)const &#123;</span><br><span class="line">		return val &gt; 0 ? val : -val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int i &#x3D; 42;</span><br><span class="line">absInt absObj;		&#x2F;&#x2F;含有函数调用运算符的对象</span><br><span class="line">int ui &#x3D; absObj(i);	&#x2F;&#x2F;将i传递给absObj.operator()</span><br></pre></td></tr></table></figure>
<p>即使absObj只是一个对象而非函数，也能”调用”该对象。实际上是运行重载的调用运算符<br>如果类定义了调用运算符，则该类的对象称作函数对象(function object)。这些对象的行为像函数一样</p>
<p>含有状态的函数对象类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class PrintString &#123;</span><br><span class="line">public;</span><br><span class="line">	PrintString(ostream&amp; o &#x3D; cout, char c &#x3D; &#39; &#39;) :os(o), sep(c) &#123; &#125;</span><br><span class="line">	void operator()(const string&amp; s)const &#123; os &lt;&lt; s &lt;&lt; sep; &#125;</span><br><span class="line">private:</span><br><span class="line">	ostream&amp; os;	&#x2F;&#x2F;用于写入目的的流</span><br><span class="line">	char sep;		&#x2F;&#x2F;用于将不同输出隔开的字符</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>定义PringString对象时，分隔符及输出流可以使用默认也可以提供自己的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PrintString printer;			&#x2F;&#x2F;使用默认值，打印到cout</span><br><span class="line">printer(s);						&#x2F;&#x2F;在cout中打印s后跟空格</span><br><span class="line">PrintString errors(cerr, &#39;\n&#39;);	</span><br><span class="line">errors(s);						&#x2F;&#x2F;在cerr中打印s后跟换行符</span><br></pre></td></tr></table></figure>
<p>函数对象也作为泛型算法的实参<br>for_each(vs.begin(), vs.end(), PrintString(cerr, ‘\n’));</p>
<h3 id="lambda是函数对象"><a href="#lambda是函数对象" class="headerlink" title="lambda是函数对象"></a>lambda是函数对象</h3><p>当编写了一个lambda后，编译器将该表达式翻译成一个未命名类的未命名对象。在lambda表达式产生的类中含有一个重载的函数调用运算符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stable_sort(words.begin(), words.end(), [](const string&amp; a, const string&amp; b) &#123;return a.size() &lt; b.size(); &#125;);</span><br></pre></td></tr></table></figure>
<p>其行为类似：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class ShorterString &#123;</span><br><span class="line">public:</span><br><span class="line">	bool operator()(const string&amp; a, const string&amp; b)const &#123; return a.size() &lt; b.size(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>默认情况下，lambda不能改变它捕获的变量，所以产生的类当中的函数调用运算符是一个const成员函数；若lambda声明为可变的，则不是const<br>stable_sort(words.begin(), words.end(), ShorterString());</p>
<p>表示lambda及相应捕获行为的类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto wc &#x3D; find_if(words.begin(), words.end(), [sz](const string &amp; a) &#123;return a.size() &gt;&#x3D; sz; &#125;)</span><br></pre></td></tr></table></figure>
<p>lambda产生的类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class SizeComp &#123;</span><br><span class="line">public:</span><br><span class="line">	SizeComp(size_t n) :sz(n) &#123;&#125;</span><br><span class="line">	bool operator()(const string&amp; a)const &#123; return s.size() &gt;&#x3D; sz; &#125;</span><br><span class="line">private:</span><br><span class="line">	size_t sz;</span><br><span class="line">&#125;;</span><br><span class="line">auto wc &#x3D; find_if(words.begin(), words.end(), SizeComp(sz));</span><br></pre></td></tr></table></figure>
<h3 id="标准库定义的函数对象"><a href="#标准库定义的函数对象" class="headerlink" title="标准库定义的函数对象"></a>标准库定义的函数对象</h3><p>——————————————————510</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plus&lt;int&gt; intAdd;</span><br><span class="line">negate&lt;int&gt; intNegate;</span><br><span class="line">&#x2F;&#x2F;使用intAdd::operator(int,int)求和</span><br><span class="line">int sum &#x3D; intAdd(10, 20);		&#x2F;&#x2F;sum&#x3D;30</span><br><span class="line">sum &#x3D; intNegate(intAdd(10, 20));&#x2F;&#x2F;sum&#x3D;-30</span><br><span class="line">sum &#x3D; intAdd(10, intNegate(10));&#x2F;&#x2F;sum&#x3D;0</span><br></pre></td></tr></table></figure>
<p>传入一个临时函数对象用于执行两个string对象&gt;比较运算<br>sort(svec.begin(), svec.end(), greater<string>());    //降序</p>
<p>比较两个无关指针将产生未定义的行为。通过比较指针的内存地址来sort指针的vector</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string*&gt;nameTable;</span><br><span class="line">&#x2F;&#x2F;错误：nameTable中的指针彼此没有联系，&lt;将产生未定义的行为</span><br><span class="line">sort(nameTable.begin(), nameTable.end(), [](string* a, string* b) &#123;return a &lt; b; &#125;);</span><br><span class="line">&#x2F;&#x2F;正确：标准库规定指针的less是定义良好的</span><br><span class="line">sort(nameTable.begin(), nameTable.end(), less&lt;string*&gt;());</span><br></pre></td></tr></table></figure>
<h3 id="可调用对象与function"><a href="#可调用对象与function" class="headerlink" title="可调用对象与function"></a>可调用对象与function</h3><p>c++中可调用对象：函数、函数指针、lambda表达式、bind创建的对象以及冲在了函数调用运算符的类<br>调用形式(call signature)指明了调用返回的类型以及传递给调用的实参类型。一种调用形式对应一个函数类型</p>
<p>不同类型可能具有相同的调用形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;普通函数</span><br><span class="line">int add(int i, int j) &#123; return i + j; &#125;</span><br><span class="line">&#x2F;&#x2F;lambda，产生一个未命名的函数对象类</span><br><span class="line">auto mod &#x3D; [](int i, int j) &#123;return i % j; &#125;;</span><br><span class="line">&#x2F;&#x2F;函数对象类</span><br><span class="line">struct divide &#123;</span><br><span class="line">	int operator()(int denominator, int divisor) &#123;</span><br><span class="line">		return denominator &#x2F; divisor;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这些共享一种调用形式：int(int, int)</p>
<p>定义一个函数表(function table)用于储存指向这些可调用对象的”指针”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;构建从运算符到函数指针的映射关系</span><br><span class="line">map&lt;string, int(*)(int, int)&gt;binops;</span><br><span class="line">&#x2F;&#x2F;正确：add是一个指向正确类型的函数指针</span><br><span class="line">binops.insert(&#123; &#39;+&#39;,add &#125;);</span><br></pre></td></tr></table></figure>
<p>但不能将mod或者divide存入binops，因为mod不是一个函数指针<br>可以通过function新标准库类型来解决<br>——————————————————————– - 512<br>function是一个模板</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function&lt;int(int, int)&gt;, 声明了一个function类型，表示一个接受两个int，返回一个int的可调用对象</span><br><span class="line">function&lt;int(int, int)&gt;f1 &#x3D; add;				&#x2F;&#x2F;函数指针</span><br><span class="line">function&lt;int(int, int)&gt;f2 &#x3D; divide();			&#x2F;&#x2F;函数对象类的对象</span><br><span class="line">function&lt;int(int, int)&gt;f3 &#x3D; [](int i, int j) &#123;	&#x2F;&#x2F;lambda</span><br><span class="line">	return i * j;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>利用function可以重新定义map</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, function&lt;int(int, int)&gt;&gt;binops &#x3D; &#123;</span><br><span class="line">	&#123;&quot;+&quot;,add&#125;,</span><br><span class="line">	&#123;&quot;-&quot;,minus&lt;int&gt;()&#125;,</span><br><span class="line">	&#123;&quot;&#x2F;&quot;,divide()&#125;,</span><br><span class="line">	&#123;&quot;*&quot;,[](int i,int j) &#123;return i * j; &#125;&#125;,</span><br><span class="line">	&#123;&quot;%&quot;,mod&#125;</span><br><span class="line">&#125;</span><br><span class="line">binops[&quot;+&quot;](10, 5);</span><br></pre></td></tr></table></figure>
<p>重载的函数与function<br>不能直接将重载函数的名字存入function类型的对象中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int add(int i, int j) &#123; return i + j; &#125;</span><br><span class="line">Sales_data add(const Sales_data&amp;, const Sales_data%);</span><br><span class="line">map&lt;string, function&lt;int(int, int)&gt;&gt;binops;</span><br><span class="line">binpos.insert(&#123; &quot;+&quot;,add &#125;);	&#x2F;&#x2F;错误：哪个？</span><br></pre></td></tr></table></figure>
<p>可以通过存储函数指针而非函数名字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int (*fp)(int, int) &#x3D; add;	&#x2F;&#x2F;指针所指的add是接受两个int的版本</span><br><span class="line">binops.insert(&#123; &quot;+&quot;,fp &#125;);	&#x2F;&#x2F;正确：fp指向一个正确的add版本</span><br><span class="line">也可以通过lambda来消除二义性</span><br><span class="line">binops.insert(&#123; &quot;+&quot;,[](int a,int b) &#123;return a + b; &#125; &#125;);</span><br></pre></td></tr></table></figure>
<h2 id="重载、类型转换与运算符"><a href="#重载、类型转换与运算符" class="headerlink" title="重载、类型转换与运算符"></a>重载、类型转换与运算符</h2><h3 id="类型转换运算符-conversion-operator"><a href="#类型转换运算符-conversion-operator" class="headerlink" title="类型转换运算符(conversion operator)"></a>类型转换运算符(conversion operator)</h3><p>是类的一种特殊成员函数，负责将一个类类型的值转换成其他类型<br>operator type() const;<br>类型转换运算符可以面向任意类型(void除外)进行定义，只要该类型能作为函数的返回类型。所以不允许转换成数组或者函数<br>可以转换成指针或者引用<br>类型转换运算符没有显式的返回类型，也没有形参，一般是const成员</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class SmallInt &#123;</span><br><span class="line">public:</span><br><span class="line">	SmallInt(int i &#x3D; 0) :val(i) &#123;</span><br><span class="line">		if (i &lt; 0 || i&gt;255)throw out_of_range(&quot;bad smallInt value&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	operator int() const &#123; return val; &#125;</span><br><span class="line">private:</span><br><span class="line">	size_t val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>构造函数将算术类型的值转换为SmallInt对象，而类型转换运算符将SmallInt对象转换为int</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SmallInt si;</span><br><span class="line">si &#x3D; 4;	&#x2F;&#x2F;首先将4隐式地转换成SmallInt，然后调用operator &#x3D;</span><br><span class="line">si + 3;	&#x2F;&#x2F;首先将si隐式地转换成int，然后进行加法</span><br></pre></td></tr></table></figure>
<p>显式的类型转换运算符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class SmallInt &#123;</span><br><span class="line">public:</span><br><span class="line">	explicit operator int() const &#123; return val; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>编译器不会将一个显式的类型转换运算符用于隐式的类型转换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SmallInt si &#x3D; 3;			&#x2F;&#x2F;正确：SmallInt的构造函数不是显式的</span><br><span class="line">si + 3;						&#x2F;&#x2F;错误：此处需要隐式的类型转换，但类的运算符是显式的</span><br><span class="line">static_cast&lt;int&gt;(si) + 3;	&#x2F;&#x2F;正确：显式地请求类型转换</span><br></pre></td></tr></table></figure>
<p>例外：以下位置将隐式的进行<br>·if,while,do语句的条件部分<br>·for语句头的条件表达式<br>·逻辑非！、逻辑或运算符||、逻辑与运算符&amp;&amp;的运算对象<br>·条件运算符?:的条件表达式</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/30/c-primer-14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" data-id="ckhq93ptu000xa0ve4cqnc0p2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-primer/" rel="tag">c++ primer</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-c-primer-13-拷贝控制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/30/c-primer-13-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/" class="article-date">
  <time datetime="2020-08-30T02:46:44.000Z" itemprop="datePublished">2020-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/30/c-primer-13-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/">c++ primer 13 拷贝控制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="拷贝控制"><a href="#拷贝控制" class="headerlink" title="拷贝控制"></a>拷贝控制</h1><p>拷贝控制操作(copy control)：拷贝构造函数(copy constructor)、拷贝赋值运算符(copy-assignment operator)、<br>移动构造函数(move constructor)、移动赋值运算符(move-assignment operator)和析构函数是(destructor)<br>拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么<br>拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么<br>析构函数定义了当此类型对象销毁时做什么<br>一个类没有定义所有这些拷贝控制成员，编译器会自动为它定义缺失的操作</p>
<p>拷贝构造函数<br>如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">public:</span><br><span class="line">	Foo();           &#x2F;&#x2F;默认构造函数</span><br><span class="line">	Foo(const Foo&amp;); &#x2F;&#x2F;拷贝构造函数</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>拷贝构造函数的第一个参数必须是一个引用类型</p>
<p>如果我们没有为类定义拷贝构造函数，编译器会为我们定义一个合成拷贝构造函数(synthesized copy constructor)<br>合成拷贝构造函数通过编译器从给定对象中一次将每个非static成员拷贝到正在创建的对象中<br>类类型的成员使用其拷贝构造函数来拷贝；内置类型的成员则直接拷贝</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Sales_data &#123;</span><br><span class="line">public:</span><br><span class="line">	Sales_data(const Sales_data&amp;); &#x2F;&#x2F;与合成的拷贝构造函数等价的拷贝构造函数的声明</span><br><span class="line">private:</span><br><span class="line">	string bookNo;</span><br><span class="line">	int units_sold &#x3D; 0;</span><br><span class="line">	double revenue &#x3D; 0.0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>与Sales_data的合成拷贝构造函数等价</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sales_data::Sales_data(const Sales_data&amp; orig);</span><br><span class="line">bookNo(orig.bookNo),          &#x2F;&#x2F;使用string的拷贝构造函数</span><br><span class="line">units_sold(orig.units_sold),  &#x2F;&#x2F;拷贝orig.units_sold</span><br><span class="line">revenue(orig.revenue)         &#x2F;&#x2F;拷贝orig.revenue</span><br><span class="line">&#123; &#125;							  &#x2F;&#x2F;空函数体</span><br></pre></td></tr></table></figure>
<p>拷贝初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string dots(10, &#39;.&#39;);        &#x2F;&#x2F;直接初始化</span><br><span class="line">string s(dots);				&#x2F;&#x2F;直接初始化</span><br><span class="line">string s2 &#x3D; dots;			&#x2F;&#x2F;拷贝初始化</span><br><span class="line">string null_book &#x3D; &quot;999-9&quot;; &#x2F;&#x2F;拷贝初始化</span><br><span class="line">string nines &#x3D; string(100, &#39;9&#39;); &#x2F;&#x2F;拷贝初始化</span><br></pre></td></tr></table></figure>
<p>直接初始化是要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数；拷贝初始化是要求编译器将右侧运算对象拷贝到种族创建的对象中，需要的话进行类型转换<br>拷贝初始化除了”=”定义变量时<br>·将一个对象作为实参传递给一个非引用类型的形参<br>·从一个返回类型为非引用类型的函数返回一个对象<br>·用花括号列表初始化一个数组中的元素或一个聚合类中的成员<br>初始化标准库容器或调用其insert或push成员时，容器会对其元素进行拷贝初始化；用emplace成员创建的元素都进行直接初始化<br>拷贝构造函数被用来初始化非引用类类型参数，如果拷贝构造函数其参数不是引用类型，则调用永远不会成功–为了调用拷贝构造函数，必须拷贝它的实参，但为了拷贝实参，又需要调用拷贝构造函数，无限循环</p>
<p>vector的接受单一大小参数的构造函数是explicit的，传递实参或从函数返回一个值时，不能隐式使用一个explicit构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt;v1(10); &#x2F;&#x2F;正确：直接初始化</span><br><span class="line">vector&lt;int&gt;v2 &#x3D; 10; &#x2F;&#x2F;错误：接受大小参数的构造函数是explicit的</span><br><span class="line">void f(vector&lt;int&gt;); &#x2F;&#x2F;f参数进行拷贝初始化</span><br><span class="line">f(10);               &#x2F;&#x2F;错误：不能用一个explicit的构造函数拷贝一个实参</span><br><span class="line">f(vector&lt;int&gt;(10)); &#x2F;&#x2F;正确：从一个int直接构造一个临时vector</span><br></pre></td></tr></table></figure>
<p>编译器可以绕过拷贝构造函数，但拷贝 / 移动构造函数必须是存在且可访问的(如，不能是private的)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string null_book &#x3D; (&quot;99999&quot;);</span><br><span class="line">string null_book(&quot;99999&quot;);</span><br></pre></td></tr></table></figure>
<p>拷贝赋值运算符<br>赋值运算符通常应该返回一个指向其左侧运算对象的引用<br>合成拷贝运算符通常会将右侧运算对象的每个非static成员赋予左侧运算对象的对应成员</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Sales_data&amp; Sales_data::operator&#x3D;(const Sales_data&amp; rhs) &#123;</span><br><span class="line">	bookNo &#x3D; rhs.bookNo;		&#x2F;&#x2F;调用string::operator&#x3D;</span><br><span class="line">	units_sold &#x3D; rhs.units_sold;&#x2F;&#x2F;使用内置的int赋值</span><br><span class="line">	revenue &#x3D; rhs.revenue;		&#x2F;&#x2F;使用内置的double赋值</span><br><span class="line">	return*this;				&#x2F;&#x2F;返回一个此对象的引用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>析构函数<br>析构函数释放对象使用的资源，并销毁对象的非static数据成员。没有返回值，也不接受参数。所以不能被重载，只会有唯一一个析构函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">public:</span><br><span class="line">	~Foo();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在析构函数中，首先执行函数体，然后销毁成员，按照初始化顺序的逆序销毁<br>隐式销毁一个内置指针类型的成员不会delete它所指的对象</p>
<p>调用析构函数<br>·变量在离开其作用域时被销毁<br>·当一个对象被销毁时，其成员被销毁<br>·容器被销毁时，其元素被销毁<br>·对于动态分配的对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	Sales_data * p &#x3D; new Sales_data;	&#x2F;&#x2F;p是内置指针</span><br><span class="line">	auto p2 &#x3D; make_shared&lt;Sales_data&gt;();&#x2F;&#x2F;p2是shared_ptr</span><br><span class="line">	Sales_data item(p*);				&#x2F;&#x2F;拷贝构造函数将*p拷贝到item中</span><br><span class="line">	vector&lt;Sales_data&gt;v;				&#x2F;&#x2F;局部对象</span><br><span class="line">	v.push_back(*p2);					&#x2F;&#x2F;拷贝p2指向的对象</span><br><span class="line">	delete p;							&#x2F;&#x2F;对p指向的对象执行析构函数</span><br><span class="line">&#125;&#x2F;&#x2F;退出局部作用域，对item,v,p2调用析构函数</span><br></pre></td></tr></table></figure>
<p>当一个类未定义自己的析构函数时，编译器会为它定义一个合成析构函数(synthesized destructor)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Sales_data &#123;</span><br><span class="line">public:</span><br><span class="line">	~Sales_data() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>等价于合成析构函数<br>析构函数自身并不直接销毁成员，是在析构函数体之后隐含的析构阶段中被销毁的<br>合成析构函数不会delete一个指针数据成员<br>一个类如果需要自定义析构函数，几乎可以肯定也需要自定义拷贝赋值运算符和拷贝构造函数（指针）<br>需要一个拷贝构造函数，几乎可以肯定也需要拷贝赋值运算符，反之亦然</p>
<p>可以通过将拷贝控制成员定义为=default来显式地要求编译器生成合成的版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Sales_data &#123;</span><br><span class="line">	Sales_data() &#x3D; default;</span><br><span class="line">	Sales_data(const Sales_data&amp;) &#x3D; default;</span><br><span class="line">	Sales_data&amp; operator&#x3D;(const Sales_data&amp;);</span><br><span class="line">	~Sales_data() &#x3D; default;</span><br><span class="line">&#125;;</span><br><span class="line">Sales_data&amp; Sales_data::operator&#x3D;(const Sales_data&amp;) &#x3D; default;</span><br></pre></td></tr></table></figure>
<p>类内用=default，歌城的函数将隐式地声明为内联的</p>
<p>阻止拷贝<br>可以通过将拷贝构造函数和拷贝赋值运算符定义为删除的函数(delete function)来阻止拷贝<br>删除的函数：虽然声明了它们，但不能以任何方式使用它们。在参数列表后加上=delete</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct NoCopy &#123;</span><br><span class="line">	NoCopy() &#x3D; default;		&#x2F;&#x2F;使用合成的默认构造函数</span><br><span class="line">	NoCopy(const NoCopy&amp;) &#x3D; delete; &#x2F;&#x2F;阻止拷贝</span><br><span class="line">	NoCopy&amp; operator&#x3D;(const NoCopy&amp;) &#x3D; delete;&#x2F;&#x2F;阻止赋值</span><br><span class="line">	~NoCopy() &#x3D; default; &#x2F;&#x2F;使用合成的析构函数</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>=delete必须出现在第一次声明的时候，可以对任何函数用</p>
<p>析构函数不能是删除的成员<br>对于删除了析构函数的类型，不能定义该类型的变量或成员，但可以动态分配这种类型的对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct NoDtor &#123;</span><br><span class="line">	NoDtor() &#x3D; default;</span><br><span class="line">	~NoDtor() &#x3D; delete;</span><br><span class="line">&#125;;</span><br><span class="line">NoDtor nd;			&#x2F;&#x2F;错误：NoDtor的析构函数是删除的</span><br><span class="line">NoDtor* p &#x3D; new Dtor(); &#x2F;&#x2F;正确</span><br><span class="line">delete p;			&#x2F;&#x2F;错误：NoDtor的析构函数是删除的</span><br></pre></td></tr></table></figure>
<p>对某些类，编译器将合成的成员定义为删除的函数：<br>·类的某个成员的析构函数是删除的或不可访问的(如private)，则类的合成析构函数被定义为删除的<br>·类的某个成员的拷贝构造函数或析构函数是删除的或不可访问的，则类的合成拷贝构造函数被定义为删除的；<br>·如果类的某个成员的拷贝赋值运算符是删除的或不可访问的，或是类有一个const的或引用成员，则类的合成拷贝赋值运算符被定义为删除的<br>·如果类的某个成员的析构函数是删除的或不可访问的，或是类有一个引用成员，它没有类内初始化器，或是类有一个const成员，它没有类内<br>初始化器且其类型未显示定义默认构造函数，则该类的默认构造函数被定义为删除的<br>本质上，规则：类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的<br>删除的或不可访问的析构函数-&gt;可能会创建出无法销毁的对象；<br>引用成员或const成员-&gt;编译器不会为其合成默认构造函数</p>
<p>行为像值的类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class HasPtr &#123;</span><br><span class="line">public:</span><br><span class="line">	HasPtr(const string&amp; s &#x3D; string()):ps(new string(s)),i(0)&#123;&#125;</span><br><span class="line">	HasPtr(const HasPtr&amp; p) :ps(new string(*p.ps)), i(p.i) &#123;&#125;</span><br><span class="line">	HasPtr&amp; operator&#x3D;(const HasPtr&amp;);</span><br><span class="line">	~HasPtr() &#123; delete ps; &#125;</span><br><span class="line">private:</span><br><span class="line">	string* ps;</span><br><span class="line">	int i;</span><br><span class="line">&#125;;</span><br><span class="line">HasPtr&amp; HasPtr::operator&#x3D;(const HasPtr&amp; rhs) &#123;</span><br><span class="line">	auto newp &#x3D; new string(*rhs.ps);</span><br><span class="line">	delete ps;</span><br><span class="line">	ps &#x3D; newp;</span><br><span class="line">	i &#x3D; rhs.i;</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>赋值运算符：<br>·将一个对象赋予它自身，赋值运算符必须能正确工作<br>·大多数赋值运算符组合了析构函数和拷贝构造函数<br>先将右侧运算对象拷贝到一个局部临时对象中，拷贝完成后，销毁左侧运算对象的现有成员就是安全的了。<br>否则，若rhs和本对象是同一个对象，delete ps会释放<em>this和rhs指向的string，接下来new表达式中试图拷贝</em>(rhs.ps)时就会访问一个指向无效内存的指针，是未定义的</p>
<p>行为像指针的类<br>设计引用计数<br>·除初始化对象外，每个构造函数(拷贝构造除外)还要创建一个引用计数。创建对象时将其初始化为1<br>·拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享的计数器<br>·析构函数递减计数器。变为0则释放状态<br>·拷贝赋值运算符递增右侧运算对象计数器，递减左侧。左侧变为0则销毁状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class HasPtr &#123;</span><br><span class="line">public:</span><br><span class="line">	HasPtr(const string&amp; s &#x3D; string()):ps(new string(s)),i(0),use(new size_t(1))&#123;&#125;</span><br><span class="line">	HasPtr(const HasPtr&amp; p) :ps(p.ps), i(p.i), use(p.use) &#123; ++*use; &#125;</span><br><span class="line">	HasPtr&amp; operator&#x3D;(const HasPtr&amp;);</span><br><span class="line">	~HasPtr();</span><br><span class="line">private:</span><br><span class="line">	string* ps;</span><br><span class="line">	int i;</span><br><span class="line">	size_t* use; &#x2F;&#x2F;用来记录有多少个共享ps的成员</span><br><span class="line">&#125;;</span><br><span class="line">HasPtr::~HasPtr() &#123;</span><br><span class="line">	if (--use &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		delete ps; &#x2F;&#x2F;释放string内存</span><br><span class="line">		delete use;&#x2F;&#x2F;释放计数器内存</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">HasPtr&amp; HasPtr::operator&#x3D;(const HasPtr&amp; rhs) &#123;</span><br><span class="line">	++* rhs.use;</span><br><span class="line">	if (-- * use &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		delete ps;</span><br><span class="line">		delete use;</span><br><span class="line">	&#125;</span><br><span class="line">	ps &#x3D; rhs.ps;</span><br><span class="line">	i &#x3D; rhs.i;</span><br><span class="line">	use &#x3D; rhs.use;</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>交换操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class HasPtr &#123;</span><br><span class="line">	friend void swap(HasPtr&amp;, HasPtr&amp;);</span><br><span class="line">&#125;;</span><br><span class="line">inline void swap(HasPtr&amp; lhs, HasPtr&amp; rhs) &#123;</span><br><span class="line">	using std::swap;</span><br><span class="line">	swap(lhs.ps, rhs.ps); &#x2F;&#x2F;交换指针，而不是string数据</span><br><span class="line">	swap(lhs.i, rhs.i);   &#x2F;&#x2F;交换int成员</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本例中数据成员是内置类型的，而内置类型是没有特定版本的swap，所以调用标准库std::swap。<br>如果一个类的成员有自己类型特定的swap，调用std::swap就是错误的</p>
<p>在赋值运算符中使用swap</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HasPtr&amp; HasPtr::operator&#x3D;(HasPtr rhs) &#123;</span><br><span class="line">	swap(*this, rhs); &#x2F;&#x2F;rhs现在指向本对象曾经使用的内存</span><br><span class="line">	return *this;	  &#x2F;&#x2F;rhs被销毁，从而delete了rhs中的指针</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>rhs是按值传递，意味着HasPtr的拷贝构造函数将右侧运算对象中的string拷贝到rhs。rhs是右侧运算对象的一个副本。<br>swap调用之后，*this中的指针成员将指向新分配的string–右侧运算对象中string的一个副本<br>赋值运算符结束时，rhs被销毁，HasPtr的析构函数将执行，释放掉左侧运算对象中原来的内存。是天然异常安全的</p>
<p>拷贝控制示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">class Message &#123;</span><br><span class="line">	friend class Folder;</span><br><span class="line">public:</span><br><span class="line">	explicit Message(const string&amp; str &#x3D; &quot;&quot;) :contents(str) &#123;&#125;</span><br><span class="line">	Message(const Message&amp;);</span><br><span class="line">	Message&amp; operator&#x3D;(const Message&amp;);</span><br><span class="line">	~Message();</span><br><span class="line">	&#x2F;&#x2F;从给定Folder中添加、删除本Message</span><br><span class="line">	void save(Folder&amp;);</span><br><span class="line">	void remove(Folder&amp;);</span><br><span class="line">private:</span><br><span class="line">	string contents;</span><br><span class="line">	set&lt;Folder*&gt;folders;</span><br><span class="line">	void add_to_Folders(const Message&amp;);</span><br><span class="line">	void remove_from_Folders();</span><br><span class="line">&#125;;</span><br><span class="line">void Message::save(Folder&amp; f) &#123;</span><br><span class="line">	folders.insert(&amp;f); &#x2F;&#x2F;将给定Folder添加到我们的Folder列表中</span><br><span class="line">	f.addMsg(this);		&#x2F;&#x2F;将本Message添加到f的Message集合中</span><br><span class="line">&#125;</span><br><span class="line">void Message::remove(Folder&amp; f) &#123;</span><br><span class="line">	folders.erase(&amp;f);</span><br><span class="line">	f.remMsg(this);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;将本Message添加到指向m的Folder中</span><br><span class="line">void Message::add_to_Folders(const Message&amp; m) &#123;</span><br><span class="line">	for (auto f : m.folders) &#x2F;&#x2F;对每个包含m的Folder</span><br><span class="line">		f-&gt;addMsg(this);	 &#x2F;&#x2F;向该Folder添加一个指向本Message的指针</span><br><span class="line">&#125;</span><br><span class="line">Message::Message(const Message&amp; m) :contents(m.contents), folders(m.folders) &#123;</span><br><span class="line">	add_to_Folders(m);  &#x2F;&#x2F;将本消息添加到指向m的Folder中</span><br><span class="line">&#125;</span><br><span class="line">void Message::remove_from_Folders() &#123;</span><br><span class="line">	for (auto f : folders) &#x2F;&#x2F;对folders中每个指针</span><br><span class="line">		f-&gt;remMsg(this);   &#x2F;&#x2F;从该Folder中删除本Message</span><br><span class="line">&#125;</span><br><span class="line">Message::~Message() &#123;</span><br><span class="line">	remove_from_Folders();</span><br><span class="line">&#125;</span><br><span class="line">Message&amp; Message::operator&#x3D;(const Message&amp; rhs) &#123;</span><br><span class="line">	remove_from_Folders();	&#x2F;&#x2F;更新已有Folder</span><br><span class="line">	contents &#x3D; rhs.contents;&#x2F;&#x2F;从rhs拷贝消息内容</span><br><span class="line">	folders &#x3D; rhs.folders;  &#x2F;&#x2F;从rhs拷贝Folder指针</span><br><span class="line">	add_to_Folders(rhs);	&#x2F;&#x2F;将本Message添加到那些Folder中</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br><span class="line">void swap(Message&amp; lhs, Message&amp; rhs) &#123;</span><br><span class="line">	using std::swap;</span><br><span class="line">	&#x2F;&#x2F;将每个消息的指针从它(原来)所在Folder中删除</span><br><span class="line">	for (auto f : lhs.folders)</span><br><span class="line">		f-&gt;remMsg(&amp;lhs);</span><br><span class="line">	for (auto f : rhs.folders)</span><br><span class="line">		f-&gt;remMsg(&amp;rhs);</span><br><span class="line">	&#x2F;&#x2F;交换contents和Folder指针set</span><br><span class="line">	swap(lhs.folders, rhs.folders);</span><br><span class="line">	swap(lhs.contents, rhs.contents);</span><br><span class="line">	&#x2F;&#x2F;将每个Message的指针添加到它的(新)Folder中</span><br><span class="line">	for (auto f : lhs.folders)</span><br><span class="line">		f-&gt;addMsg(&amp;lhs);</span><br><span class="line">	for (auto f : rhs.folders)</span><br><span class="line">		f-&gt;addMsg(&amp;rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>动态内存管理类<br>vector<string>的一个简化版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">class StrVec &#123;</span><br><span class="line">public:</span><br><span class="line">	StrVec() :elements(nullptr), first_free(nullptr), cap(nullptr) &#123;&#125;</span><br><span class="line">	StrVec(const StrVec&amp;);				&#x2F;&#x2F;拷贝构造函数</span><br><span class="line">	StrVec&amp; operator&#x3D;(const StrVec&amp;);	&#x2F;&#x2F;拷贝赋值操作符</span><br><span class="line">	~StrVec();</span><br><span class="line">	void push_back(const string&amp;);</span><br><span class="line">	size_t size() const &#123; return first_free - elements; &#125;</span><br><span class="line">	size_t capacity() const &#123; return cap - elements; &#125;</span><br><span class="line">	string* begin() const &#123; return elements; &#125;</span><br><span class="line">	string* end()const &#123; return first_free; &#125;</span><br><span class="line">private:</span><br><span class="line">	Static allocator&lt;string&gt;alloc;</span><br><span class="line">	void chk_n_alloc() &#123;	&#x2F;&#x2F;被添加元素的函数所使用</span><br><span class="line">		if (size() &#x3D;&#x3D; capacity())reallocate();</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;被拷贝构造函数、赋值运算符和析构函数所使用</span><br><span class="line">	pair&lt;string*, string*&gt; alloc_n_copy(const string*, const string*);</span><br><span class="line">	void free();			&#x2F;&#x2F;销毁元素并释放内存</span><br><span class="line">	void reallocate();		&#x2F;&#x2F;获得更多内存并拷贝已有元素</span><br><span class="line">	string* elements;		&#x2F;&#x2F;指向数组首元素的指针</span><br><span class="line">	string* first_free();	&#x2F;&#x2F;指向数组第一个空闲元素的指针</span><br><span class="line">	string* cap();			&#x2F;&#x2F;指向数组尾后位置的指针</span><br><span class="line">&#125;;</span><br><span class="line">void StrVec::push_back(const string&amp; s) &#123;</span><br><span class="line">	chk_n_alloc();</span><br><span class="line">	&#x2F;&#x2F;在first_free指向的元素中构造s的副本</span><br><span class="line">	alloc.construct(first_free++, s);</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;string*,string*&gt;</span><br><span class="line">StrVec::alloc_n_copy(const string* b, const string* e) &#123;</span><br><span class="line">	auto data &#x3D; alloc.allocate(e - b);</span><br><span class="line">	return &#123; data,uninitialized_copy(b,e,data) &#125;;</span><br><span class="line">&#125;</span><br><span class="line">void StrVec::free() &#123;</span><br><span class="line">	if (elements) &#123;</span><br><span class="line">		for (auto p &#x3D; first_free; p !&#x3D; elements;)</span><br><span class="line">			alloc.destory(--p);</span><br><span class="line">		alloc.deallocate(elements, cap - elements);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">StrVec::StrVec(const StrVec&amp; s) &#123;</span><br><span class="line">	auto newdata &#x3D; alloc_n_copy(s.begin(), s.end());</span><br><span class="line">	elements &#x3D; newdata.first;</span><br><span class="line">	first_free &#x3D; cap &#x3D; newdata.second;</span><br><span class="line">&#125;</span><br><span class="line">StrVec::~StrVec() &#123;</span><br><span class="line">	free();</span><br><span class="line">&#125;</span><br><span class="line">StrVec&amp; StrVec::operator&#x3D;(const StrVec&amp; rhs) &#123;</span><br><span class="line">	&#x2F;&#x2F;调用alloc_n_copy分配内存，大小与rhs中元素占用空间一样多</span><br><span class="line">	auto data &#x3D; alloc_n_copy(rhs.begin(), rhs.end());</span><br><span class="line">	free();</span><br><span class="line">	elements &#x3D; data.first;</span><br><span class="line">	first_free &#x3D; cap &#x3D; data.second;</span><br><span class="line">	return*this;</span><br><span class="line">&#125;</span><br><span class="line">void StrVec::reallocate() &#123;</span><br><span class="line">	auto newcapacity &#x3D; size() ? 2 * size() : 1;</span><br><span class="line">	auto newdata &#x3D; alloc.allocate(newcapacity); &#x2F;&#x2F;分配新内存</span><br><span class="line">	&#x2F;&#x2F;将数据从旧内存移到新内存</span><br><span class="line">	auto dest &#x3D; newdata; &#x2F;&#x2F;指向新数组中下一个空闲位置</span><br><span class="line">	auto elem &#x3D; elements;&#x2F;&#x2F;指向旧数组中下一个元素</span><br><span class="line">	for (size_t i &#x3D; 0; i !&#x3D; size(); ++i) &#123;</span><br><span class="line">		alloc.construct(dest++, move(*elem++));</span><br><span class="line">	&#125;</span><br><span class="line">	free();</span><br><span class="line">	elements &#x3D; newdata;</span><br><span class="line">	first_free &#x3D; dest;</span><br><span class="line">	cap &#x3D; elements + newcapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>移动构造函数move，避免了string的拷贝</p>
<p>标准库容器、string和shared_ptr类既支持移动也支持拷贝。IO类和unique_ptr可以移动但不能拷贝</p>
<p>右值引用(rvalue reference) &amp;&amp;<br>必须绑定到右值的引用，只能绑定到一个将要销毁的对象<br>一般而言，左值表达式是一个对象的身份，右值表达式表示的是对象的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D; 42;</span><br><span class="line">int&amp; r &#x3D; i;			&#x2F;&#x2F;正确：r引用i</span><br><span class="line">int&amp;&amp; rr &#x3D; i;		&#x2F;&#x2F;错误：不能将一个右值引用绑定到一个左值上</span><br><span class="line">int&amp; r2 &#x3D; i * 42;	&#x2F;&#x2F;错误：i*42是一个右值</span><br><span class="line">const int&amp; r3 &#x3D; i * 42; &#x2F;&#x2F;正确：可以将一个const引用绑定到一个右值上</span><br><span class="line">int&amp;&amp; rr2 &#x3D; i * 42;	&#x2F;&#x2F;正确：将rr2绑定到乘法结果上</span><br></pre></td></tr></table></figure>
<p>返回左值表达式：返回左值引用的函数、赋值、下标、解引用、前置递增 / 递减运算符<br>返回右值表达式：返回非引用类型的函数、算术、关系、位、后置递增 / 递减运算符<br>左值有持久的状态，右值是字面常量或者表达式求值过程中创建的临时对象<br>变量是左值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int&amp;&amp; rr &#x3D; 42;	&#x2F;&#x2F;正确：字面常量是右值</span><br><span class="line">int&amp;&amp; rr2 &#x3D; rr;	&#x2F;&#x2F;错误：表达式rr是左值</span><br></pre></td></tr></table></figure>
<p>可以显式地将一个左值转换为对应右值的引用类型。可以通过调用一个move来获得绑定到左值上的右值引用，move在头文件utility中<br>int&amp;&amp; rr3 = std::move(rr1);<br>move调用告诉编译器：希望像右值一样处理一个左值。除了对rr1赋值或销毁外不再使用它。</p>
<p>移动构造函数和移动赋值运算符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StrVec::StrVec(StrVec&amp;&amp; s)noexcept &#x2F;&#x2F;移动操作不应抛出任何异常</span><br><span class="line">	:elements(s.elements), first_free(s.first_free), cap(s.cap) &#123;</span><br><span class="line">	s.elements &#x3D; s.first_free &#x3D; s.cap &#x3D; nullptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>noexcept出现在参数列表和初始化列表开始的冒号之间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class StrVec &#123;</span><br><span class="line">public:</span><br><span class="line">	StrVec(StrVec&amp;&amp;)noexcept;</span><br><span class="line">&#125;;</span><br><span class="line">StrVec::StrVec(StrVec&amp;&amp; s)noexcept :&#x2F;*初始化器*&#x2F;&#123;&#x2F;*构造函数体*&#x2F;&#125;</span><br></pre></td></tr></table></figure>
<p>若移动了部分元素后抛出异常会产生问题。</p>
<p>移动赋值运算符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">StrVec&amp; StrVec::operator&#x3D;(StrVec&amp;&amp; rhs) noexcept &#123;</span><br><span class="line">	&#x2F;&#x2F;直接检测自赋值</span><br><span class="line">	if (this !&#x3D; rhs) &#123;</span><br><span class="line">		free();</span><br><span class="line">		elements &#x3D; rhs.elements;</span><br><span class="line">		first_free &#x3D; rhs.first_free;</span><br><span class="line">		cap &#x3D; rhs.cap;</span><br><span class="line">		rhs.elements &#x3D; rhs.first_free &#x3D; rhs.cap &#x3D; nullptr;</span><br><span class="line">	&#125;</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不能在使用右侧运算对象的资源之前就释放左侧运算对象的资源(可能是相同的资源)</p>
<p>合成的移动操作<br>如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符了。会通过正常的函数匹配，用对应的拷贝操作来代替移动操作<br>只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct X &#123;</span><br><span class="line">	int i;</span><br><span class="line">	string s;</span><br><span class="line">&#125;;</span><br><span class="line">struct hasX &#123;</span><br><span class="line">	X mem;</span><br><span class="line">&#125;;</span><br><span class="line">X x, x2 &#x3D; std::move(x);			&#x2F;&#x2F;使用合成的移动构造函数</span><br><span class="line">hasX hx, hx2 &#x3D; std::move(hx);	&#x2F;&#x2F;使用合成的移动构造函数</span><br></pre></td></tr></table></figure>
<p>移动操作永远不会隐式定义为删除的函数。但如果显式地要求编译器生成=default的移动操作，且编译器不能移动所有成员，则编译器会将移动操作定义为删除的函数。<br>将合成的移动操作定义为删除的函数：<br>·移动构造函数被定义为删除的函数：有类成员定义了自己的拷贝构造函数且未定义移动构造函数；有类成员未定义自己的拷贝构造函数且编译器不能为其合成移动构造函数。移动赋值运算符的情况类似<br>·如果有类成员的移动构造函数或移动赋值运算符呗定义为删除的或是不可访问的，则类的移动构造函数或移动赋值运算符被定义为删除的<br>·如果类的析构函数被定义为删除的或不可访问的，则类的移动构造函数被定义为删除的<br>·如果有类成员是const的或引用，则类的移动赋值运算符被定义为删除的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;假定Y是一个类，定义了自己的拷贝构造函数，但未定义自己的移动构造函数</span><br><span class="line">struct hasY &#123;</span><br><span class="line">	hasY() &#x3D; default;</span><br><span class="line">	hasY(hasY&amp;&amp;) &#x3D; default;</span><br><span class="line">	Y mem;	&#x2F;&#x2F;hansY将有一个删除的移动构造函数</span><br><span class="line">&#125;;</span><br><span class="line">hanY hy, hy2 &#x3D; std::move(hy);	&#x2F;&#x2F;错误：移动构造函数是删除的</span><br></pre></td></tr></table></figure>
<p>类hasY显式地要求一个移动构造函数，但编译器无法为其生成<br>如果一个类定义了一个移动构造函数和 / 或一个移动赋值运算符，则该类的合成拷贝构造函数和拷贝赋值运算符会被定义为删除的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StrVec v1, v2;</span><br><span class="line">v1 &#x3D; v2;					&#x2F;&#x2F;v2是左值；使用拷贝赋值</span><br><span class="line">StrVec getVec(istream&amp;);	&#x2F;&#x2F;getVec返回一个右值</span><br><span class="line">v2 &#x3D; getVec(cin);			&#x2F;&#x2F;getVec(cin)是一个右值；使用移动赋值</span><br></pre></td></tr></table></figure>
<p>表达式v2是一个左值，不能隐式地将一个右值引用绑定到一个左值，所以使用拷贝赋值运算符<br>第二个中表达式是一个右值，两个赋值运算符都是可行的。但调用拷贝赋值运算符需要进行一次到const的转换，而StrVec&amp;&amp;是精确匹配。所以第二个用移动赋值运算符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">public:</span><br><span class="line">	Foo() &#x3D; default;</span><br><span class="line">	Foo(const Foo&amp;); &#x2F;&#x2F;拷贝构造函数</span><br><span class="line">&#125;;</span><br><span class="line">Foo x;</span><br><span class="line">Foo y(x);				&#x2F;&#x2F;拷贝构造函数；x是一个左值</span><br><span class="line">Foo z(std::move(x));	&#x2F;&#x2F;拷贝构造函数；未定义移动构造函数</span><br></pre></td></tr></table></figure>
<p>定义了拷贝构造函数就不会生成合成移动构造函数</p>
<p>拷贝并交换赋值运算符和移动操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class HasPtr &#123;</span><br><span class="line">public:</span><br><span class="line">	&#x2F;&#x2F;添加的移动构造函数</span><br><span class="line">	HasPtr(HasPtr&amp;&amp; p)noexcept :ps(p.ps), i(p.i) &#123; p.ps &#x3D; 0; &#125;</span><br><span class="line">	&#x2F;&#x2F;赋值运算符既是移动赋值运算符也是拷贝赋值运算符</span><br><span class="line">	HasPtr&amp; operator&#x3D;(HasPtr rhs) &#123;</span><br><span class="line">		swap(*this, rhs);</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为类添加了一个移动构造函数，接管了给定实参的值。构造体将给定的HasPtr的指针置为0，从而确保销毁移后源对象是安全的<br>赋值运算符有一个非引用参数，意味着此参数要进行拷贝初始化。依赖于实参的类型，左值被拷贝，右值被移动。因此单一的赋值运算符实现了拷贝赋值运算符和移动赋值运算符两种功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hp &#x3D; hp2;			&#x2F;&#x2F;hp2是一个左值，hp2通过拷贝构造函数来拷贝</span><br><span class="line">hp &#x3D; std::move(hp2);&#x2F;&#x2F;移动构造函数移动hp2</span><br></pre></td></tr></table></figure>
<p>Message类的移动操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;从本Message移动Folder指针</span><br><span class="line">void Message::move_Folders(Message* m) &#123;</span><br><span class="line">	folders &#x3D; std::move(m-&gt;folders);&#x2F;&#x2F;使用set的移动赋值运算符</span><br><span class="line">	for (auto f : folders) &#123; &#x2F;&#x2F;对每个Folder</span><br><span class="line">		f-&gt;remMsg(m);	&#x2F;&#x2F;从Folder中删除旧Message</span><br><span class="line">		f-&gt;addMsg(this);&#x2F;&#x2F;将本Message添加到Folder中</span><br><span class="line">	&#125;</span><br><span class="line">	m-&gt;folders.clear(); &#x2F;&#x2F;确保销毁m是无害的</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过调用move，使用了set的移动赋值运算符移动folders集合，函数遍历所有Folder，从其中删除指向原Message的指针，并添加指向新Message的指针<br>向set中插入元素要求分配内存，可能会抛出bad_alloc异常。Message的移动构造函数和移动构造运算符可能会抛出异常，所以未标记为noexcept</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Message::Message(Message&amp;&amp; m) :contents(std::move(m.contents)) &#123;</span><br><span class="line">	move_Folders(&amp;m); &#x2F;&#x2F;移动folders并更新Folder指针</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Message的移动构造函数调用move来移动contents，并默认初始化自己的folders成员</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Message&amp; Message::operator&#x3D;(Message&amp;&amp; rhs) &#123;</span><br><span class="line">	if (this !&#x3D; &amp;rhs) &#123;		&#x2F;&#x2F;直接检查自赋值情况</span><br><span class="line">		remove_from_Folders();</span><br><span class="line">		contents &#x3D; std::move(rhs.contents); &#x2F;&#x2F;移动赋值运算符</span><br><span class="line">		move_Folders(&amp;rhs);	&#x2F;&#x2F;重置Folders指向本Message</span><br><span class="line">	&#125;</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>移动迭代器(move iterator)<br>移动迭代器的解引用生成一个右值引用<br>通过调用标准库的make_move_iterator函数将一个普通迭代器转换为一个移动迭代器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void StrVec::reallovate() &#123;</span><br><span class="line">	auto newcapacity &#x3D; size() ? 2 + size() : 1;</span><br><span class="line">	auto first &#x3D; alloc.allocate(newcapacity);</span><br><span class="line">	&#x2F;&#x2F;移动元素</span><br><span class="line">	auto last &#x3D; uninitialized_copy(make_move_iterator(begin()), make_move_iterator(end()), first);</span><br><span class="line">	free();</span><br><span class="line">	elements &#x3D; first;</span><br><span class="line">	first_free &#x3D; last;</span><br><span class="line">	cap &#x3D; elements + newcapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>unitialized_copy对输入序列中的每个元素调用construct来将元素“拷贝”到目的位置。此算法使用迭代器的解引用运算符从输入序列中提取元素，生成的是一个右值引用，意味着construct将使用移动构造函数来构造元素</p>
<p>由于一个移后源对象具有不确定的状态，对其调用std::move是危险的。当我们调用move时，必须确定移后源对象没有其他用户</p>
<p>右值引用和成员函数<br>允许移动的成员函数通常使用与拷贝 / 移动构造函数和赋值运算符相同的参数模式–一个版本接受一个指向const的左值引用，一个接受一个指向非const的右值引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void push_back(const X&amp;);	&#x2F;&#x2F;拷贝：绑定到任意类型的X</span><br><span class="line">void push_back(X&amp;&amp;);		&#x2F;&#x2F;移动：只能绑定到类型X的可修改的右值</span><br></pre></td></tr></table></figure>
<p>一般来说，不需要为函数操作定义接受一个const X&amp;&amp;或是X&amp;参数的版本。<br>当我们希望从实参“窃取”数据时，通常需要传递一个右值，不能是const的；从一个对象拷贝操作不应该改变该对象，因此通常不需要X&amp;版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class StrVec &#123;</span><br><span class="line">public:</span><br><span class="line">	void push_back(const string&amp;);</span><br><span class="line">	void push_back(strng&amp;&amp;);</span><br><span class="line">&#125;;</span><br><span class="line">void StrVec::push_back(const string&amp; s) &#123;</span><br><span class="line">	chk_n_alloc();	&#x2F;&#x2F;确保有空间容纳新元素</span><br><span class="line">	&#x2F;&#x2F;在first_free指向的元素中构造s的一个副本</span><br><span class="line">	alloc.construct(first_free++, s);</span><br><span class="line">&#125;</span><br><span class="line">void StrVec::push_back(string&amp;&amp; s) &#123;</span><br><span class="line">	chk_n_alloc();</span><br><span class="line">	alloc.construct(first_free++, std::move(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>construct函数使用其第二个和随后的实参类型确定使用哪个构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StrVec vec;</span><br><span class="line">string s &#x3D; &quot;some string or another&quot;;</span><br><span class="line">vec.push_back(s);		&#x2F;&#x2F;调用push_back(const string&amp;)</span><br><span class="line">vec.push_back(&quot;done&quot;);	&#x2F;&#x2F;调用push_back(string&amp;&amp;),右值，从&quot;done&quot;创建的临时string</span><br></pre></td></tr></table></figure>
<p>右值和左值成员函数<br>通过在参数列表后放置一个引用限定符(reference qualifier)来指出左值/右值属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">public:</span><br><span class="line">	Foo&amp; operator&#x3D;(const Foo&amp;)&amp;; &#x2F;&#x2F;只能向可修改的左值赋值</span><br><span class="line">&#125;;</span><br><span class="line">Foo&amp; Foo::operator&#x3D;(const Foo&amp; rhs)&amp; &#123;</span><br><span class="line">	&#x2F;&#x2F;执行所需操作</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引用限定符可以是&amp; 或&amp;&amp; ，指出this可以指向一个左值或右值。只能用于非static成员函数，且必须同时出现在函数的声明和定义中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Foo&amp; retFoo();	&#x2F;&#x2F;返回一个引用；retFoo调用是一个左值</span><br><span class="line">Foo retVal();	&#x2F;&#x2F;返回一直值；retVal调用是一个右值</span><br><span class="line">Foo i, j;		&#x2F;&#x2F;i和j是左值</span><br><span class="line">i &#x3D; j;			&#x2F;&#x2F;正确：i是左值</span><br><span class="line">retFoo() &#x3D; j;	&#x2F;&#x2F;正确：retFoo()返回一个左值</span><br><span class="line">retVal() &#x3D; j;	&#x2F;&#x2F;错误：retVal()返回一个右值</span><br><span class="line">i &#x3D; retVal();	&#x2F;&#x2F;正确：可以将一个右值作为赋值操作的右侧运算对象</span><br></pre></td></tr></table></figure>
<p>一个函数可以同时用const和引用限定。引用限定符必须跟随在const限定符之后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">public:</span><br><span class="line">	Foo someMen()&amp; const;	&#x2F;&#x2F;错误</span><br><span class="line">	Foo anotherMen()const&amp;;	&#x2F;&#x2F;正确</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>引用限定符也可以区分重载版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">public:</span><br><span class="line">	Foo sorted()&amp;&amp;;</span><br><span class="line">	Foo sorted()const&amp;;</span><br><span class="line">private:</span><br><span class="line">	vector&lt;int&gt;data;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;本对象为右值，可以原址排序</span><br><span class="line">Foo Foo::sorted()&amp;&amp; &#123;</span><br><span class="line">	sort(data.begin(), data.end());</span><br><span class="line">	return*this;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;本对象是const或是左值，不能进行原址排序</span><br><span class="line">Foo Foo::sorted()const&amp; &#123;</span><br><span class="line">	Foo ret(*this);							&#x2F;&#x2F;拷贝一个副本</span><br><span class="line">	sort(ret.data.begin(), ret.data.end());	&#x2F;&#x2F;排序副本</span><br><span class="line">	return ret;								&#x2F;&#x2F;返回副本</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对象是一个右值意味着没有其他用户，可以改变对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">retVal().sorted();	&#x2F;&#x2F;retVal是一个右值，调用Foo::sorted()&amp;&amp;</span><br><span class="line">retFoo().sorted();	&#x2F;&#x2F;retFoo是一个左值，调用Foo::sorted()const&amp;</span><br></pre></td></tr></table></figure>
<p>如果定义两个或以上具有相同名字和相同参数列表的成员函数，就必须对所有函数都加上引用限定符，或者所有都不加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">public:</span><br><span class="line">	Foo sorted()&amp;&amp;;</span><br><span class="line">	Foo sorted() const;	&#x2F;&#x2F;错误：必须加上引用限定符</span><br><span class="line">	&#x2F;&#x2F;Comp是函数类型的类型别名，此函数类型可以用来比较int值</span><br><span class="line">	using Comp &#x3D; bool(const int&amp;, const int&amp;);</span><br><span class="line">	Foo sorted(Comp*);		&#x2F;&#x2F;正确：不同的参数列表</span><br><span class="line">	Foo sorted(Comp*)const;	&#x2F;&#x2F;正确：两个都没哟引用限定符</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/30/c-primer-13-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/" data-id="ckhq93ptu000va0ve8ocs5gvx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-primer/" rel="tag">c++ primer</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-c-primer-12-动态内存" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/30/c-primer-12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/" class="article-date">
  <time datetime="2020-08-30T02:42:59.000Z" itemprop="datePublished">2020-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/30/c-primer-12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/">c++ primer 12 动态内存</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h1><p>静态内存保存局部static对象、类static数据成员以及定义在任何函数之外的变量；栈内存用了保存定义在函数内的非static对象。<br>静态内存或栈内存中的对象由编译器自动创建和销毁。<br>栈对象仅在其定义的程序块运行时才存在；static对象在使用之前分配，程序结束时销毁</p>
<p>动态内存管理<br>new：在动态内存中为对象分配空间并返回一个指向该对象的指针，可以选择对对象进行初始化<br>delete：接受一个动态对象的指针，销毁该对象，并释放与之关联的内存</p>
<p>智能指针：shared_ptr允许多个指针指向同一个对象；unique_ptr“独占”所指向对象<br>shared_ptr<string>p1;  shared_ptr&lt;list<int>&gt;p2;<br>默认初始化的智能指针中保存着一个空指针<br>————————————————————————————– - 401</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;int&gt;p3 &#x3D; make_shared &lt;int&gt;(42);              &#x2F;&#x2F;指向一个值为42的int的shared_ptr</span><br><span class="line">shared_ptr&lt;string&gt;p4 &#x3D; make_shared&lt;string&gt;(10, &#39;9&#39;);  &#x2F;&#x2F;指向一个值为&quot;9999999999&quot;的string</span><br><span class="line">shared_ptr&lt;int&gt;p5 &#x3D; make_shared&lt;int&gt;();               &#x2F;&#x2F;指向一个值初始化的int，即0</span><br><span class="line">auto p6 &#x3D; make_shared&lt;vector&lt;int&gt;&gt;();</span><br></pre></td></tr></table></figure>
<p>make_shared用其参数来构造给定类型的对象。make_shared<string>的参数必须与string的某个构造函数相匹配，不传递任何参数，对象就会进行值初始化</p>
<p>当进行拷贝或赋值操作时，每个shared_ptr都会记录有多少个其他的shared_ptr指向相同的对象<br>可以认为每个shared_ptr都有一个关联的计数器，引用计数(reference count)。无论何时拷贝一个shared_ptr，计数器都会递增。<br>如：用一个shared_ptr初始化另一个shared_ptr、将它作为参数传递给一个函数以及作为函数的返回值<br>当给shared_ptr赋予一个新值或是shared_ptr被销毁(例如一个局部的shared_ptr离开其作用域)时，计数器递减<br>一旦一个shared_ptr的计数器变为0，它就会自动释放自己所管理的对象<br>auto r = make_shared<int>(42);<br>r = q; //给r赋值，令它指向另一个地址；递增q指向的对象的引用计数；递减r原来指向的对象的；r原来的对象已没有引用者，会自动释放</p>
<p>销毁是通过析构函数完成。shared_ptr的析构函数会递减它所指向的对象的引用计数，变为0后shared_ptr的析构函数就会销毁对象，并释放它们占用的内存<br>若将shared_ptr存在容器中，而后不再需要全部元素，记得用erase删除不再需要的元素</p>
<p>使用动态生存期的资源的类：<br>·程序不知道自己需要多少对象<br>·程序不知道所需对象的准确类型<br>·程序需要在多个对象间共享数据</p>
<p>定义StrBlob类<br>假定b1，b2是两个Blob对象，共享相同的vector。为了保证vector中的元素继续存在，将vector保存在动态内存中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class StrBlob &#123;</span><br><span class="line">public:</span><br><span class="line">	typedef vector&lt;string&gt;::size_type size_type;</span><br><span class="line">	StrBlob() :data(make_shared&lt;vector&lt;string&gt;&gt;()) &#123;&#125;;  &#x2F;&#x2F;两个构造函数都是用初始化列表来初始化其data成员，令它指向一个动态分配的vector</span><br><span class="line">	StrBlob(initializer_list&lt;string&gt;il) :data(make_shared&lt;vector&lt;string&gt;&gt;(il)) &#123;&#125;;</span><br><span class="line">	size_type size()const &#123; return data-&gt;size; &#125;</span><br><span class="line">	bool empty() const &#123; return data-&gt;empty(); &#125;</span><br><span class="line">	void push_back(const string&amp; t) &#123; data-&gt;push_back(t); &#125;</span><br><span class="line">	void pop_back() &#123;</span><br><span class="line">		check(0, &quot;pop_back on empty StrBlob&quot;);</span><br><span class="line">		return data-&gt;pop();</span><br><span class="line">	&#125;</span><br><span class="line">	string&amp; front() &#123;</span><br><span class="line">		check(0, &quot;front on empty StrBlob&quot;);</span><br><span class="line">		return data-&gt;front();</span><br><span class="line">	&#125;</span><br><span class="line">	string&amp; back() &#123;</span><br><span class="line">		check(0, &quot;back on empty StrBLob&quot;);</span><br><span class="line">		return data-&gt;back();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">private:</span><br><span class="line">	shared_ptr&lt;vector&lt;string&gt;&gt;data;</span><br><span class="line">	void check(size_type i, const string&amp; msg)const &#123;</span><br><span class="line">		if (i &gt;&#x3D; data-&gt;size())throw out_of_range(msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>直接管理内存<br>在自由空间分配的内存是无名的，因此new无法为其分配的对象命名，而是返回一个指向该对象的指针<br>默认情况下动态分配的对象是默认初始化的，意味着内置类型或组合类型的对象的值将是未定义的，类类型对象用默认构造函数进行初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int* pi &#x3D; new int; &#x2F;&#x2F;pi指向一个未初始化的int</span><br><span class="line">int* pi1 &#x3D; new int(); &#x2F;&#x2F;值初始化为0；*p2为0</span><br><span class="line">string* ps &#x3D; new string; &#x2F;&#x2F;默认初始化为空string</span><br><span class="line">string* ps1 &#x3D; new string(); &#x2F;&#x2F;值初始化为空string</span><br><span class="line">int* pi &#x3D; new int(1024);</span><br><span class="line">string* ps &#x3D; new string(10, &#39;9&#39;);</span><br><span class="line">vector&lt;int&gt;* pv &#x3D; new vector&lt;int&gt;&#123; 0,1,2,3,4,5,6,7,8,9 &#125;;</span><br><span class="line"></span><br><span class="line">auto p1 &#x3D; new auto(obj);  &#x2F;&#x2F;p指向一个与obj类型相同的对象，该对象用obj进行初始化</span><br><span class="line">auto p2 &#x3D; new auto&#123;a.b.c&#125;; &#x2F;&#x2F;错误：括号中只能有单个初始化器</span><br><span class="line"></span><br><span class="line">const int* pci &#x3D; new const int(1024); &#x2F;&#x2F;分配并初始化一个const int</span><br><span class="line">const string* pcs &#x3D; new const string; &#x2F;&#x2F;分配并默认初始化一个const的空string</span><br><span class="line">new返回的指针是一个指向const的指针</span><br><span class="line"></span><br><span class="line">int* p1 &#x3D; new int; &#x2F;&#x2F;如果内存耗尽，分配失败，抛出std:bad_alloc</span><br><span class="line">int* p1 &#x3D; new(nothrow)int; &#x2F;&#x2F;如果分配失败，new返回一个空指针</span><br></pre></td></tr></table></figure>
<p>delete表达式执行：销毁给定的指针指向的对象；释放对应的内存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int i, * pi1 &#x3D; &amp;i, * pi2 &#x3D; nullptr;</span><br><span class="line">double* pd &#x3D; new double(33), * pd2 &#x3D; pd;</span><br><span class="line">delete i;   &#x2F;&#x2F;错误：i不是一个指针</span><br><span class="line">delete pi1; &#x2F;&#x2F;未定义：pi1指向一个局部变量</span><br><span class="line">delete pd;  &#x2F;&#x2F;正确</span><br><span class="line">delete pd2; &#x2F;&#x2F;未定义：pd2指向的内存已经被释放了</span><br><span class="line">delete pi2; &#x2F;&#x2F;正确：释放一个空指针总是没有错误的</span><br><span class="line">const int* pci &#x3D; new const int(1024);</span><br><span class="line">delete pci; &#x2F;&#x2F;正确：释放一个const对象</span><br></pre></td></tr></table></figure>
<p>动态对象的生存期直到被释放时为止</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Foo* factory(T arg) &#123;</span><br><span class="line">	return new Foo(arg);</span><br><span class="line">&#125;</span><br><span class="line">void use_factory(T arg) &#123;</span><br><span class="line">	Foo* p &#x3D; factory(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>use_factory返回后，内置指针p被销毁，但动态内存不会被自动释放，p是指向该内存唯一指针，use_factory返回后，程序就没办法释放该内存了</p>
<p>改正：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Foo* use_factory(T arg) &#123;</span><br><span class="line">	Foo* p &#x3D; factory(arg);</span><br><span class="line">	return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>系统中其他代码可能使用use_factory所分配的对象，又之后来释放<br>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void use_factory(T arg) &#123;</span><br><span class="line">	Foo* p &#x3D; factory(arg);</span><br><span class="line">	delete p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>new和delete管理动态内存常见问题：<br>·忘记delete内存。导致内存泄漏，该内存永远不可能被还给自由空间<br>·使用已经释放掉的对象。通过在释放后将指针置空，有时可以检测到这种错误<br>·同一块内存释放两次。自由空间可能被破坏</p>
<p>delete指针后，指针值就变为无效了。但很多机器上指针仍然保存着(已经释放了的)动态内存的地址。<br>delete之后指针就变成悬空指针，即指向一块曾经保存数据对象但现在已经无效的内存的指针<br>在指针即将要离开其作用域之前释放掉它所关联的内存。需要保留指针可以在delete之后将nullptr赋予指针<br>int* p = new int(42); auto q = p;<br>delete p; p = nullptr;<br>重置p对q没有任何作用</p>
<p>可以用new返回的指针来初始化智能指针<br>接受指针参数的只能指针构造函数是explicit的。因此，不能将一个内置指针隐式转换为一个智能指针，必须使用直接初始化形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;int&gt;p1 &#x3D; new int(1024); &#x2F;&#x2F;错误：必须使用直接初始化形式。new返回了内置指针int*</span><br><span class="line">shared_ptr&lt;int&gt;p2(new int(1024));  &#x2F;&#x2F;正确</span><br><span class="line">shared_ptr&lt;int&gt; clone(int p) &#123;</span><br><span class="line">	return new int(p);  &#x2F;&#x2F;错误：隐式转换为shared_ptr&lt;int&gt;</span><br><span class="line">&#125;</span><br><span class="line">shared_ptr&lt;int&gt; clone(int p) &#123;</span><br><span class="line">	return shared_ptr&lt;int&gt;(new int(p))  &#x2F;&#x2F;正确：显式地用int*创建shared_ptr&lt;int&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>p421</p>
<p>不要混合使用普通指针和智能指针。使用内置指针来访问一个只能指针所负责的对象是危险的，不知道对象何时会被销毁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void process(shared_ptr&lt;int&gt; ptr) &#123;</span><br><span class="line">	&#x2F;&#x2F;使用ptr</span><br><span class="line">&#125;&#x2F;&#x2F;ptr离开作用域，被销毁</span><br><span class="line"></span><br><span class="line">shared_ptr&lt;int&gt;p(new int(42)); &#x2F;&#x2F;引用计数为1</span><br><span class="line">process(p);  &#x2F;&#x2F;拷贝p会递增它的引用计数；在process中引用计数值为2</span><br><span class="line">int i &#x3D; *p;  &#x2F;&#x2F;正确：引用计数值为1</span><br><span class="line"></span><br><span class="line">int* x(new int(1024));</span><br><span class="line">process(x);  &#x2F;&#x2F;错误：不能将int*转换为shared_ptr&lt;int&gt;</span><br><span class="line">process(share_ptr&lt;int&gt;(x)); &#x2F;&#x2F;合法，但内存会被释放</span><br><span class="line">int j &#x3D; *x;  &#x2F;&#x2F;未定义的：x是一个悬空指针</span><br></pre></td></tr></table></figure>
<p>将临时的shared_ptr传递给process，表达式结束时临时对象被销毁，销毁时递减引用计数，变为0<br>x指向已经释放的内存，从而变成一个悬空指针</p>
<p>不要使用get初始化另一个智能指针或为智能指针赋值<br>get函数返回一个内置指针，指向智能指针管理的对象。使用get返回的指针的代码不能delete此指针</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;int&gt;p(new int(42));</span><br><span class="line">int* q &#x3D; p.get();</span><br><span class="line">&#123; &#x2F;&#x2F;新程序块</span><br><span class="line">	shared_ptr&lt;int&gt;(q);</span><br><span class="line">&#125; &#x2F;&#x2F;程序块结束，q被销毁，它指向的内存被释放</span><br><span class="line">int foo &#x3D; *p;  &#x2F;&#x2F;未定义：p指向的内存已经被释放了</span><br><span class="line"></span><br><span class="line">p &#x3D; new int(1024);   &#x2F;&#x2F;错误：不能将一个指针赋予shated_ptr</span><br><span class="line">p.reset(new int(1024)); &#x2F;&#x2F;正确：p指向一个新对象</span><br><span class="line"></span><br><span class="line">if (!p.unique())p.reset(new string(*p)); &#x2F;&#x2F;不是当前对象唯一用户，分配新的拷贝</span><br><span class="line">*p +&#x3D; val; &#x2F;&#x2F;是唯一用户，可以改变对象的值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void f() &#123;</span><br><span class="line">	int* ip &#x3D; new int(42);</span><br><span class="line">	&#x2F;&#x2F;代码中间抛出异常</span><br><span class="line">	delete ip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>new和delete直接发生异常，且异常未在f中被捕获，则内存用于不会被释放了</p>
<p>不是所有的类都定义了析构函数，有的需要手动管理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct destination;</span><br><span class="line">struct connection;</span><br><span class="line">connection connect(destination*);</span><br><span class="line">void disconnect(connection);</span><br><span class="line">void f(destination&amp; d &#x2F;*其他参数*&#x2F;) &#123;</span><br><span class="line">	connection c &#x3D; connect(&amp;d);</span><br><span class="line">	&#x2F;&#x2F;使用链接</span><br><span class="line">	&#x2F;&#x2F;若退出f前忘记调用disconnect，就无法关闭c了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义一个函数来代替delete。这个删除器函数能释放shared_ptr<br>void end_connection(connection* p) { disconnection(p); }<br>void f(disconnect&amp; d /**/) {<br>    connection c = connect(&amp;d);<br>    shared_ptr<connection>p(&amp;c, end_connection);<br>    //当f退出时，connection会被正确关闭，发生异常时也会<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr</span><br><span class="line">定义时需要将其绑到一个new返回的指针上，必须采用直接初始化的形式，不能拷贝或赋值</span><br></pre></td></tr></table></figure>
<p>unique_ptr<double>p;<br>unique_ptr<int>pp(new int(42));<br>unique_ptr<string>p1(new string(“hello”));<br>unique_ptr<string>p2(p1); //错误：不支持拷贝<br>unique_ptr<string>p3; p3 = p1; //错误：不支持赋值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--------------------------------------------------------------------418</span><br></pre></td></tr></table></figure>
<p>unique_ptr<string>p2(p1.release()); //release将p1置空<br>unique_ptr<string>p3(new string(“hi”));<br>p2.reset(p3.release()); //reset释放了p2原来指向的内存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">只可以拷贝或赋值将要被销毁的unique_ptr</span><br></pre></td></tr></table></figure>
<p>unique_ptr<int> clone(int p) {<br>    return unique_ptr<int>(new int(p));<br>}<br>unique_ptr<int> clone(int p) {<br>    unique_ptr<int>ret(new int(p));<br>    return ret;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">向unique_ptr传递删除器</span><br></pre></td></tr></table></figure>
<p>void f(destination&amp; d /<em>*/) {<br>    connect c = connect(&amp;d);<br>    unique_ptr&lt;connection, decltype(end_connection)</em>&gt;p(&amp;c, end_connection);<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">使用了decltype来指明函数指针类型。必须添加一个* 来指出我们正在使用该类型的一个指针</span><br><span class="line"></span><br><span class="line">weak_ptr</span><br><span class="line">weak_ptr是一种不控制所致对象生存期的只能指针，指向一个shared_ptr管理的对象。weak_ptr绑定时不会改变shared_ptr的引用计数</span><br><span class="line">------------------------------------------------------------------ - 420</span><br><span class="line">weak_ptr创建时，要用shared_ptr来初始化它</span><br><span class="line">auto p &#x3D; make_shared&lt;int&gt;(42);</span><br><span class="line">weak_ptr&lt;int&gt;wp(p);</span><br><span class="line">由于对象可能不存在，所以不能直接访问对象，调用lock</span><br><span class="line">if(shared_ptr&lt;int&gt;np&#x3D;wp.lock())&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">动态数组</span><br><span class="line">new分配一个对象数组，要再类型名之后跟一对方括号，其中指明分配对象的数目。返回指向第一个对象的指针</span><br></pre></td></tr></table></figure>
<p>int* pia = new int[get_size()];<br>typedef int arrT[42];<br>int* p = new arrT; //分配一个42个int的数组，p指向第一个int  int* p=new int[42]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new分配一个数组时，得到一个数组元素类型的指针，并未得到一个数组类型的对象。</span><br><span class="line">所以不能调用begin或end等，也不能用for语句遍历</span><br></pre></td></tr></table></figure>
<p>int* pia = new int[10];          //10个未初始化的int<br>int* pia2 = new int<a href="">10</a>;       //10个值初始化为0的int<br>string* psa = new string[10];    //10个空string<br>string* psa2 = new string<a href="">10</a>; //10个空string<br>int* pia3 = new int[5]{ 1,2,3,6,0 };  //10个int分别用列表中对应的初始化器初始化<br>string* psa3 = new string[10]{ “a”,”an”,”the”,(5,’x’) }; //10个string，前四个用给定的初始化器初始化，后6个进行值初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">若初始化器数目大于元素数目，则new表达式失败，不会分配任何内存。此例中会抛出bad_array_new_length异常</span><br><span class="line"></span><br><span class="line">动态分配一个空数组是合法的</span><br></pre></td></tr></table></figure>
<p>char arr[0];  //错误：不能定义长度为0的数组<br>char* cp = new char[0];  //正确：但cp不能解引用<br>new分配一个大小为0的数组时，返回一个合法的空指针。类似尾后指针。可以进行比较操作、加减0、减去自身得到0。但不能解引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">释放动态数组</span><br></pre></td></tr></table></figure>
<p>delete p;    //p必须指向一个动态分配的对象或为空<br>delete[] pa; //pa必须指向一个动态分配的数组或为空</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr管理动态数组</span><br></pre></td></tr></table></figure>
<p>unique_ptr&lt;int[]&gt;up(new int[10]);<br>up.release(); //自动用delete[]销毁其指针</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">当unique_ptr指向一个数组时，不能使用点和箭头成员运算符，指向的是一个数组，而不是单个对象。可以使用下标运算符来访问数组中元素</span><br><span class="line">for (size_t i &#x3D; 0; i !&#x3D; 10; ++i)up[i] &#x3D; i;</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------426</span><br><span class="line"></span><br><span class="line">shared_ptr不直接支持管理动态数组，需要提供自定义的删除器</span><br><span class="line">shared_ptr&lt;int&gt;sp(new int[10], [](int* p) &#123;delete[] p; )&#125;;</span><br><span class="line">sp.reset();  &#x2F;&#x2F;使用提供的lambda释放数组</span><br><span class="line">访问元素，必须用get获取一个内置指针，然后用它来访问元素</span><br></pre></td></tr></table></figure>
<p>for (size_t i = 0; i != 10; ++i)<br>    * (sp.get() + i) = i;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">allocator类</span><br><span class="line">一般情况下，将内存分配和对象构造组合在一起可能会导致不必要的浪费</span><br><span class="line">allocator对象分配内存时，会根据给定的对象类型来确定个恰当的内存大小和对齐位置</span><br></pre></td></tr></table></figure>
<p>allovator<string>alloc;      //可以分配string的allocator对象<br>auto const p = alloc.allocate(n); //分配n个未初始化的string</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--------------------------------------------------------428</span><br></pre></td></tr></table></figure>
<p>auto q = p;  //q指向最后构造的元素之后的位置<br>alloc.construct(q++);        //<em>q为空字符串<br>alloc.construct(q++, 10, c); //</em>q为cccccccccc<br>alloc.construct(q++, “hi”);  //*q为hi</p>
<p>cout &lt;&lt; *p &lt;&lt; endl; //正确：使用string的输出运算符<br>cout &lt;&lt; *q &lt;&lt; endl; //错误：q指向未构造的内存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while (q !&#x3D; p)alloc.destory(--q);</span><br><span class="line">只能对真正构造了的元素进行destory</span><br><span class="line"></span><br><span class="line">alloc.deallocate(p, n); &#x2F;&#x2F;释放内存</span><br><span class="line"></span><br><span class="line">拷贝和填充未初始化内存</span><br><span class="line">------------------------------------------------------------------------429</span><br></pre></td></tr></table></figure>
<p>auto p = alloc.allocate(vi.size() * 2);    //分配比vi大一倍的空间<br>auto q = uniitialized_copy(vi.begin(), vi.end(), p); //通过拷贝vi中的元素来构造从p开始的元素，q指向最后一个构造的元素之后的位置<br>uninitialized_fill_n(q, vi.size(), 42);  //将剩余元素初始化为42</p>
<pre><code>
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/30/c-primer-12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/" data-id="ckhq93pts000qa0ve5bgw2pfj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-primer/" rel="tag">c++ primer</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-c-primer-11-关联容器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/30/c-primer-11-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/" class="article-date">
  <time datetime="2020-08-30T02:40:52.000Z" itemprop="datePublished">2020-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/30/c-primer-11-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/">c++ primer 11 关联容器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="关联容器-associative-container"><a href="#关联容器-associative-container" class="headerlink" title="关联容器(associative_container)"></a>关联容器(associative_container)</h1><p>关联容器支持高效的关键字查找和访问<br>不同的关联容器体现在：set或map；是否允许重复关键字(multi)；是否按顺序保存(unordered)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;统计单词出现次数</span><br><span class="line">map&lt;string, size_t&gt;word_count;</span><br><span class="line">string word;</span><br><span class="line">while (cin &gt;&gt; word)++word_count[word];</span><br><span class="line">for (const auto&amp; w : word_count)cout &lt;&lt; w.first &lt;&lt; &quot; occurs &quot; &lt;&lt; w.second &lt;&lt; &quot; times &quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用set</span><br><span class="line">map&lt;string, size_t&gt;word_count;</span><br><span class="line">set&lt;string&gt;exclude &#x3D; &#123; &quot;a&quot;,&quot;an&quot;,&quot;the&quot; &#125;;</span><br><span class="line">string word;</span><br><span class="line">while (cin &gt;&gt; word) &#123;</span><br><span class="line">	if (exclude.find(word) &#x3D;&#x3D; exclude.end())word_count[word]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用关键字类型的比较函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bool compareIsbn(const Sales_data &amp; lhs, const Sales_data &amp; rhs) &#123; return lhs.isbn() &lt; rhs.isbn(); &#125;</span><br><span class="line">multiset&lt;Sales_data, decltype(compareIsbn)*&gt;bookstore(compareIsbn);</span><br></pre></td></tr></table></figure>
<p>为使用自定义操作，定义时我们必须提供关键字类型Sales_data，以及比较操作类型–一种函数指针类型，可以指向compareIsbn。<br>定义对象时，提供一个指向compareIsbn的指针</p>
<h3 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h3><p>———————————–380</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;string,int&gt;</span><br><span class="line">process(vector&lt;string&gt; &amp; v) &#123;</span><br><span class="line">	if (!v.empty())return &#123; v.back(),v.back().size() &#125;;</span><br><span class="line">	else return pair&lt;string, int&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!v.empty())return pair&lt;string, int&gt;(v.back(), v.back().size());</span><br><span class="line">if (!v.empty())return make_pair(v.back(), v.back().size());</span><br><span class="line"></span><br><span class="line">map&lt;string, int&gt;::value_type v1; &#x2F;&#x2F;v1是一个pair&lt;const string,int&gt;</span><br><span class="line">map&lt;string, int&gt;::key_type v2; &#x2F;&#x2F;v2是一个string</span><br><span class="line">map&lt;string, int&gt;::mapped_type v3; &#x2F;&#x2F;v3是一个int</span><br></pre></td></tr></table></figure>
<p>初始化map时，必须提供关键字类型和值类型。将其包围在花括号中{ key,value }</p>
<p>添加元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt;v &#x3D; &#123; 2,4,6,8,2,4,6,8 &#125;;</span><br><span class="line">set&lt;int&gt;s;</span><br><span class="line">s.insert(v.begin(), v.end()); &#x2F;&#x2F;有4个元素</span><br><span class="line">s.insert(&#123; 1,3,5,7,1,3,5,7 &#125;); &#x2F;&#x2F;有8个元素</span><br><span class="line"></span><br><span class="line">word_count.insert(&#123;word,1&#125;);</span><br><span class="line">word_count.insert(make_pair(word,1));</span><br><span class="line">word_count.insert(pair&lt;string,size_t&gt;(word,1));</span><br><span class="line">word_count.insert(map&lt;string,size_t&gt;::value_type(word,1));</span><br></pre></td></tr></table></figure>
<p>——————————————————————384</p>
<p>对于不包含重复关键字的容器，添加单一元素的insert和emplace返回一个pair，first是指向给定关键字元素的迭代器，second是bool类型，是否成功</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, size_t&gt;word_count; string word;</span><br><span class="line">while (cin &gt;&gt; word) &#123;</span><br><span class="line">	auto ret &#x3D; word_count.insert(&#123; word,1 &#125;);</span><br><span class="line">	if (!ret.second)++ret-&gt;first.second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除元素<br>——————————————————387</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map的下标操作</span><br><span class="line">word_count[&quot;anna&quot;] &#x3D; 1;</span><br></pre></td></tr></table></figure>
<p>在word_count搜索关键字为anna的元素，未找到；将新关键字 - 值对插入到word_count中，关键字是一个const string，保存anna。值进行初始化，0；<br>提取出新插入的元素，并将值1赋予它<br>只能对非const的map使用下标操作</p>
<p>c[k]：返回关键字为k的元素；如果k不在c中，添加一个关键字为k的元素，对其初始化<br>c.at(k)：访问关键字为k的元素，带参数检查；若k不在c中，抛出一个out_of_range异常</p>
<p>与vector和string不同，map下标运算符返回的类型(mapped_type)与解引用map迭代器得到的类型不同(value_type)</p>
<p>———————————————————————————— - 389</p>
<p>multimap或multiset中查找元素<br>有多个元素具有给定关键字，它们会相邻储存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">string search_item(&quot;Target&quot;);</span><br><span class="line">auto entries &#x3D; authors.count(search_item);</span><br><span class="line">auto iter &#x3D; authors.find(search_item);</span><br><span class="line">while (entries) &#123;</span><br><span class="line">	cout &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">	++iter;</span><br><span class="line">	--entries;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (auto beg &#x3D; authors.lower_bound(search_item), end &#x3D; authors.upper_bound(search_item); beg !&#x3D; end; ++beg) &#123;</span><br><span class="line">	cout &lt;&lt; beg-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (auto pos &#x3D; authors.equal_range(search_item); pos.first !&#x3D; pos.second; ++pos.first;)cout &lt;&lt; pos.first-&gt;second &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>无序容器(unordered associative container)<br>使用哈希函数(hash function)和关键字类型的 == 运算符来组织元素</p>
<p>——————————————– - 395</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">size_t hasher(const Sales_data&amp; sd) &#123; return hash&lt;string&gt;()(sd.isbn()); &#125;</span><br><span class="line">bool eqOp(const Sales_data&amp; lhs, const Sales_data&amp; rhs) &#123; return lhs.isbn() &#x3D;&#x3D; rhs.isbn(); &#125;</span><br><span class="line">using SD_multiset&#x3D;unordered_multiset&lt;Sales_data, decltype(hasher)*, decltype(eqOp)*&gt;;</span><br><span class="line">SD_multiset bookStore(42, hasher, eqOp);</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/30/c-primer-11-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/" data-id="ckhq93pts000pa0ve6evg5nrs" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-primer/" rel="tag">c++ primer</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-c-primer-10-泛型算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/30/c-primer-10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/" class="article-date">
  <time datetime="2020-08-30T02:36:34.000Z" itemprop="datePublished">2020-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/30/c-primer-10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/">c++ primer 10 泛型算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="泛型算法"><a href="#泛型算法" class="headerlink" title="泛型算法"></a>泛型算法</h1><p>标准库定义了一组泛型算法来实现查找特定元素、替换或删除等操作<br>泛型：可以用于不同各类型的元素和多种容器类型<br>算法：实现了一些经典算法的公共接口，如排序和搜索等<br>大多数算法都定义在头文件algorithm中，在numeric中定义了一组数值泛型算法<br>迭代器领算法不依赖于容器，但算法依赖于元素类型的操作<br>泛型算法本身不会执行容器的操作，它们只会运行与迭代器之上，执行迭代器的操作–》算法永远不会改变底层容器的大小</p>
<p>除少数例外，标准库算法都对一个范围内的元素进行操作，“输入范围”。用要处理的第一个元素和尾元素之后位置的迭代器两个参数来表示此范围</p>
<p>只接受单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长</p>
<p>写容器元素的算法要注意确保序列原大小至少不小于要求算法写入的元素数目</p>
<p>插入迭代器(insert iterator)定义在头文件iterator中，back_inserter;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt;v;</span><br><span class="line">auto it &#x3D; back_inserter(v);</span><br><span class="line">*it &#x3D; 42; &#x2F;&#x2F;v中现在有一个元素，值为42</span><br><span class="line"></span><br><span class="line">fill_n(back_inserter(v), 10, 0); &#x2F;&#x2F;添加10个0到v</span><br></pre></td></tr></table></figure>
<p>拷贝算法是另一个向目的位置迭代器指向的输出序列中的元素写书数据的算法。接受三个迭代器，前两个表示范围，第三个表示目的序列的起始位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a1[] &#x3D; &#123; 0,1,2 &#125;;</span><br><span class="line">int a2[sizeof(a1) &#x2F; sizeof(*a1)];</span><br><span class="line">auto ret &#x3D; copy(begin(a1), end(a1), a2); &#x2F;&#x2F;把a1的内容拷贝给a2，ret指向拷贝到a2的尾元素之后的位置</span><br></pre></td></tr></table></figure>
<p>一些算法计算新元素的值，但不会将他们放置在输入序列的末尾，而是创建一个新序列保存这些结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">replace(ilst.bigin(), ilst.end(), 0, 42); &#x2F;&#x2F;将所有0替换为42</span><br><span class="line">replace(ilst.begin(), ilst.end(), back_inserter(ivec), 0, 42); &#x2F;&#x2F;ilst未改变，ivec包含ilst的一份拷贝，但其中的0替换为42</span><br></pre></td></tr></table></figure>
<h3 id="重排容器元素的算法"><a href="#重排容器元素的算法" class="headerlink" title="重排容器元素的算法"></a>重排容器元素的算法</h3><p>利用元素类型的&lt;运算符来实现排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void elimDups(vector&lt;string&gt;&amp; words) &#123;</span><br><span class="line">	sort(words.begin(), words.end());</span><br><span class="line">	auto end &#x3D; unique(words.begin(), words.end()); &#x2F;&#x2F;end指向最后一个不重复元素的下一个位置</span><br><span class="line">	erase(end, words.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>谓词是一个可调用的表达式，其返回结果是一个能用作条件的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bool isShorter(const string&amp; s1, const string&amp; s2) &#123; &#x2F;&#x2F;比较函数，按长度排序单词</span><br><span class="line">	return s1.size() &lt; s2.size();</span><br><span class="line">&#125;</span><br><span class="line">sort(words.begin(), words.end(), isShorter); &#x2F;&#x2F;由短至长排序单词</span><br><span class="line">stable_sort稳定排序算法，维持相等元素的原有顺序</span><br></pre></td></tr></table></figure>
<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>四种可调用的对象：函数、函数指针、重载了函数调用运算符的类、lambda表达式<br>一个lambda表达式表示一个可调用的代码单元。可理解为一个未命名的内联函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture list](parameter list)-&gt;return type&#123; function body &#125;</span><br></pre></td></tr></table></figure>
<p>capture list(捕获列表)是一个lambda所在函数中定义的局部变量的列表(通常为空)。lambda必须使用尾置返回来指定返回类型<br>可以忽略参数列表和返回值类型，但必须包含捕获列表和函数体</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto f &#x3D; [] &#123;return 42; &#125;</span><br></pre></td></tr></table></figure>
<p>调用方式与普通函数的调用方式相同，都是使用调用运算符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; f() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>在lambda中忽略括号和参数列表等价于指定一个空参数列表。忽略返回类型，lambda根据函数体中代码推断返回类型，返回类型可以是void<br>lambda不能有默认参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[](const string&amp; s1, const string&amp; s2) &#123;return s1.size() &lt; s2.size();&#125;</span><br></pre></td></tr></table></figure>
<p>空捕获列表表示此lambda不使用它所在函数中的任何局部变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stable_sort(words.begin(), words.end(), [](const string&amp; s1, const string&amp; s2) &#123;return s1.size() &lt; s2.size(); &#125;);</span><br></pre></td></tr></table></figure>
<p>lambda只能使用明确在捕获列表指出的局部变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto wc &#x3D; find_if(words.begin(), words.end(), [sz](const string &amp; s) &#123;return s.size() &gt;&#x3D; sz; &#125;); &#x2F;&#x2F;获取指向第一个长度不小于sz的元素的迭代器，如果不存在则返回words.end()的一个拷贝</span><br></pre></td></tr></table></figure>
<h3 id="for-each算法"><a href="#for-each算法" class="headerlink" title="for_each算法"></a>for_each算法</h3><p>打印words中长度大于等于sz的元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for_each(wc, words.end(), [](const string&amp; s) &#123;cout &lt;&lt; s &lt;&lt; &quot; &quot;; &#125;); cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h3 id="lambda捕获和返回"><a href="#lambda捕获和返回" class="headerlink" title="lambda捕获和返回"></a>lambda捕获和返回</h3><p>当定义一个lambda时，编译器生成一个与lambda对应的新的(未命名的)类类型。当向一个函数传递一个lambda时，同事定义了一个新类型和该类型的一个对象，传递的参数就是此编译器生成的类类型的未命名对象<br>默认情况下，从lambda生成的类都包含一个对应该lambda所捕获的变量的数据成员。<br>变量的捕获方式可以是值或引用<br>值捕获的前提是变量可以拷贝，在lambda创建时拷贝</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void func1() &#123;</span><br><span class="line">	size_t v1 &#x3D; 42; &#x2F;&#x2F;局部变量</span><br><span class="line">	auto f &#x3D; [v1] &#123;return v1; &#125;;</span><br><span class="line">	v1 &#x3D; 0; auto j &#x3D; f(); &#x2F;&#x2F;j为42，f保存了创建时的拷贝</span><br><span class="line">&#125;</span><br><span class="line">void func2() &#123;</span><br><span class="line">	size_t v1 &#x3D; 42;</span><br><span class="line">	auto f2 &#x3D; [&amp;v1] &#123;return v1; &#125;;</span><br><span class="line">	v1 &#x3D; 0; auto j &#x3D; f2(); &#x2F;&#x2F;j&#x3D;&#x3D;0,f2保存v1的引用而非拷贝</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当从函数返回lambda时，lambda不能包含引用捕获。</p>
<h3 id="隐式捕获"><a href="#隐式捕获" class="headerlink" title="隐式捕获"></a>隐式捕获</h3><p>[=]值捕获、[&amp;]引用捕获<br>混合捕获</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void biggies(vector&lt;string&gt;&amp; words, vector&lt;string&gt;::size_type sz, ostream&amp; os &#x3D; cout, char c &#x3D; &#39; &#39;) &#123;</span><br><span class="line">	for_each(words.begin(), words.end(), [&amp;, c](const string &amp; s) &#123;os &lt;&lt; s &lt;&lt; c; &#125;);</span><br><span class="line">	for_each(words.begin(), words.end(), [&#x3D;, &amp;os](const string &amp; s) &#123;os &lt;&lt; s &lt;&lt; c; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="10%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95_md_files/%E6%8D%95%E8%8E%B7.JPG?v=1&type=image" alt="输入图片描述"><br>可变lambda可省略参数列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void func3() &#123;</span><br><span class="line">	size_t v1 &#x3D; 42;</span><br><span class="line">	auto f &#x3D; [v1]()mutable &#123;return ++v1; &#125;;</span><br><span class="line">	v1 &#x3D; 0; auto j &#x3D; f(); &#x2F;&#x2F;j&#x3D;&#x3D;43</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个引用捕获的变量是否可以修改依赖于此引用是否指向非const类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void func4() &#123;</span><br><span class="line">	size_t v1 &#x3D; 42;</span><br><span class="line">	auto f2 &#x3D; [&amp;v1] &#123;return ++v1; &#125;;</span><br><span class="line">	v1 &#x3D; 0; auto j &#x3D; f(); &#x2F;&#x2F;j&#x3D;&#x3D;1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个lambda包含return之外的任何语句，则编译器假定此lambda返回void</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transform(vi.begin(), vi.end(), [](int i) &#123;if (i &lt; 0)return -i; else return i; &#125;); &#x2F;&#x2F;错误：不能推断lambda的返回类型</span><br><span class="line">transform(vi.begin(),vi.end(),[](int i)-&gt;int&#123;if (i &lt; 0)return -i; else return i; &#125;</span><br></pre></td></tr></table></figure>
<h3 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto newCallable &#x3D; bind(callable, arg_list);</span><br><span class="line">&#x2F;&#x2F;check6是一个可调用对象，接受一个string类型的参数</span><br><span class="line">auto check6 &#x3D; bind(check_size, _1, 6);</span><br></pre></td></tr></table></figure>
<p>_1为占位符，表示check6只接受单一参数。出现在arg_list的第一个位置，表示check6的此参数对应check_size的第一个参数。<br>此参数是一个const string&amp; ，因此，调用check6必须传给他一个string类型的参数，check6会将此参数传递给check_size</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string s &#x3D; &quot;hello&quot;;</span><br><span class="line">bool b1 &#x3D; check6(s); &#x2F;&#x2F;check6(s)会调用check_size(s,6)</span><br><span class="line">可以将lambda的find_if变为check_size版本</span><br><span class="line">auto wc &#x3D; find_if(words.begin(), words.end(), [](const string&amp; a));</span><br><span class="line">auto wc &#x3D; find_if(words.begin(), words.end(), bind(check_size, _1, sz));</span><br></pre></td></tr></table></figure>
<p>using std::placeholders::_1;<br>_1定义在命名空间placeholders中，它又定义在std中<br>另一种声明：using namespace namespace_name;<br>说明希望所有来自namespace_name的名字都可以直接使用<br>using namespace std::placeholders;</p>
<p>可以用bind绑定可调用对象中的参数或重新安排其顺序<br>auto g = bind(f, a, b, _2, c, _1);<br>生成一个新的可调用对象，有2个参数（_1, _2）。将它自己的参数作为第三个和第五个参数传递给f。调用g时，第一个参数传递给f作为最后一个参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;按单词长度由短至长排序</span><br><span class="line">sort(words.begin(), words.end(), isShorter); l</span><br><span class="line">&#x2F;&#x2F;由长至短</span><br><span class="line">sort(words.begin(), words.end(), bind(isShorter, _2, _1);</span><br><span class="line"></span><br><span class="line">bind拷贝其参数，对于不想拷贝的，使用ref函数</span><br><span class="line">for_each(words.begin(), words.end(), bind(print, ref(os), _1, &#39; &#39;));</span><br></pre></td></tr></table></figure>

<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h3 id="插入迭代器-insert-iterator"><a href="#插入迭代器-insert-iterator" class="headerlink" title="插入迭代器(insert iterator)"></a>插入迭代器(insert iterator)</h3><p>这些迭代器被绑定到一个容器上，可用来向容器插入元素<br>——————————————————–图358</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">back_inserter &#x2F; front_inserter &#x2F; inserter</span><br><span class="line"></span><br><span class="line">list&lt;int&gt;lst &#x3D; &#123; 1,2,3,4 &#125;, lst2, lst3;</span><br><span class="line">copy(lst.begin(), lst, end(), front_inserter(lst2)); &#x2F;&#x2F;4 3 2 1 </span><br><span class="line">copy(lst.begin(), lst.end(), inserter(lst3, lst3.begin())); &#x2F;&#x2F;1 2 3 4</span><br></pre></td></tr></table></figure>
<h3 id="流迭代器-stream-iterator"><a href="#流迭代器-stream-iterator" class="headerlink" title="流迭代器(stream iterator)"></a>流迭代器(stream iterator)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">istream_iterator&lt;int&gt;int_it(cin); &#x2F;&#x2F;从cin读取int</span><br><span class="line">istream_iterator&lt;int&gt;eof; &#x2F;&#x2F;istream尾后迭代器</span><br><span class="line">ifstream in(&quot;afile&quot;);</span><br><span class="line">istream_iterator&lt;string&gt;str_it(in); &#x2F;&#x2F;从&quot;afile&quot;读取字符串</span><br><span class="line"></span><br><span class="line">istream_iterator&lt;int&gt;in_iter(cin); &#x2F;&#x2F;从cin读取int</span><br><span class="line">istream_iterator&lt;int&gt;eof; &#x2F;&#x2F;istream尾后迭代器</span><br><span class="line">while (in_iter !&#x3D; eof)vec.push_back(*in_iter++); &#x2F;&#x2F;后置递增运算读取流，返回迭代器的旧值，解引用迭代器，获得从流读取的前一个值</span><br></pre></td></tr></table></figure>
<h3 id="反向迭代器-reverse-iterator"><a href="#反向迭代器-reverse-iterator" class="headerlink" title="反向迭代器(reverse iterator)"></a>反向迭代器(reverse iterator)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt;v &#x3D; &#123; 1,2,3,4,5 &#125;;</span><br><span class="line">for (auto r_iter &#x3D; v.crbegin(); r_iter !&#x3D; v.crend(); ++r_iter;) &#123;</span><br><span class="line">	cout &lt;&lt; *r_iter &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort(v.begin(), v.end()); &#x2F;&#x2F;正常排序v</span><br><span class="line">sort(v.rbegin(), v.rend()); &#x2F;&#x2F;逆序排序v</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;打印最后一个单词</span><br><span class="line">auto comma &#x3D; find(line.rbegin(), line.rend(), &#39;,&#39;);</span><br><span class="line">cout &lt;&lt; string(rcomma.base(), line.end()) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h2 id="泛型算法结构"><a href="#泛型算法结构" class="headerlink" title="泛型算法结构"></a>泛型算法结构</h2><p>输入、输出、前向、双向、随机访问，5种迭代器</p>
<p>返回void<br>图——————————————————–369</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/30/c-primer-10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/" data-id="ckhq93ptp000ma0ve117saoz3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-c-primer-09-顺序容器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/30/c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/" class="article-date">
  <time datetime="2020-08-30T01:40:30.000Z" itemprop="datePublished">2020-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/30/c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/">c++ primer 09 顺序容器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="顺序容器-sequential-container"><a href="#顺序容器-sequential-container" class="headerlink" title="顺序容器(sequential container)"></a>顺序容器(sequential container)</h1><p>vector:可变大小数组。支持快速随机访问。在尾部之外位置插入删除元素可能很慢<br>deque:双端队列。支持快速随机访问。在头尾位置插入删除速度很快<br>list;双向列表。只支持双向顺序访问。在任何位置插入删除操作速度都很快<br>forward_list:单向列表。只支持单向顺序访问。在任何位置插入删除操作速度都很快<br>array:固定大小数组。支持快速随机访问。不能添加或删除元素<br>string:与vector相似，但专门用于保存字符。随机访问快。在尾部插入删除速度快</p>
<p>选择容器基本原则：<br>首选vector<br>有很多小元素，空间的额外开销很重要，不要用list或forward_list<br>在中间插入或删除，用list或forward_list<br>只在头尾插入或删除，用deque</p>
<h3 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h3><p><img src="./c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/%E6%8D%95%E8%8E%B7.png" alt="输入图片描述"></p>
<p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/%E6%8D%95%E8%8E%B71.PNG?v=1&type=image" alt="输入图片描述"></p>
<p>使用左闭合范围<br>如果begin与end相等，则范围为空；begin与end不等，则至少包含一个元素，且begin指向范围中的第一个元素；可以对begin递增若干次，使得begin==end</p>
<h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt;::iterator iter;    vector&lt;int&gt;::difference_type count;</span><br><span class="line"></span><br><span class="line">a.begin() &#x2F; rbegin() &#x2F; cbegin() &#x2F; crbegin()</span><br><span class="line">auto it &#x3D; a.begin(); &#x2F;&#x2F;仅当a是const时，it是const_iterator</span><br></pre></td></tr></table></figure>
<h3 id="容器定义和初始化"><a href="#容器定义和初始化" class="headerlink" title="容器定义和初始化"></a>容器定义和初始化</h3><p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/2%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"></p>
<p>创建一个容器为另一个的拷贝，两个容器的类型及元素类型必须匹配，传递迭代器参数拷贝范围时不要求，能转换即可;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt; authors &#x3D; &#123; &quot;ab&quot;,&quot;cd&quot;,&quot;ef&quot;&#125;;</span><br><span class="line">vector&lt;const char*&gt;articles &#x3D; &#123; &quot;a&quot;,&quot;an&quot;,&quot;the&quot; &#125;;</span><br><span class="line">list&lt;string&gt;list2(authors); &#x2F;&#x2F;正确：类型匹配</span><br><span class="line">deque&lt;string&gt;authList(authors); &#x2F;&#x2F;错误：容器类型不匹配</span><br><span class="line">vector&lt;string&gt;words(atricles); &#x2F;&#x2F;错误：容器类型必须匹配</span><br><span class="line">forward_list&lt;string&gt;words(articles.begin(), articles.end()); &#x2F;&#x2F;正确：可以将const char*转换为string</span><br></pre></td></tr></table></figure>
<p>如果元素类型是内置类型或者具有默认构造函数的类类型，可以值为构造函数提供一个容器大小参数；如果没有默认构造函数，还必须指定一个显式的元素初始值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">array&lt;string, 10&gt; &#x2F;&#x2F;类型为保存10个string的数组</span><br><span class="line">array&lt;int, 10&gt;::size_type i; &#x2F;&#x2F;正确  </span><br><span class="line">array&lt;int&gt;::size_type j; &#x2F;&#x2F;错误：array&lt;int&gt;不是一个类型</span><br><span class="line">array&lt;int,3&gt;ia1; &#x2F;&#x2F;10个默认初始化的int</span><br><span class="line">array&lt;int,3&gt;ia2 &#x3D; &#123; 0,1,2 &#125;; &#x2F;&#x2F;列表初始化</span><br><span class="line">array&lt;int, 3&gt;ia3 &#x3D; &#123; 1 &#125;; &#x2F;&#x2F;ia3[0]为1，其余元素为0</span><br><span class="line">不能对内置数组类型进行拷贝或对象赋值，但array可以</span><br><span class="line">array&lt;int, 3&gt;digs &#x3D; &#123; 1,2,3 &#125;;</span><br><span class="line">array&lt;int, 3&gt;copy &#x3D; digs;</span><br></pre></td></tr></table></figure>
<h3 id="赋值和swap"><a href="#赋值和swap" class="headerlink" title="赋值和swap"></a>赋值和swap</h3><p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/3%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c1 &#x3D; c2; &#x2F;&#x2F;将c1的内存替换为c2中元素的拷贝，c1大小变为c2的大小</span><br><span class="line">c1 &#x3D; &#123; a,b,c &#125;;</span><br><span class="line">array&lt;int, 3&gt;a1 &#x3D; &#123; 1,2,3 &#125;;</span><br><span class="line">array&lt;int, 3&gt;a2 &#x3D; &#123; 0 &#125;;</span><br><span class="line">a1 &#x3D; a2; &#x2F;&#x2F;替换a1中的元素</span><br><span class="line">a2 &#x3D; &#123; 0 &#125;; &#x2F;&#x2F;错误：不能讲一个花括号列表赋予数组</span><br></pre></td></tr></table></figure>
<p>赋值相关运算会导致指向左边容器内部的迭代器、引用和指针失效，而swap操作不会(array和string除外)</p>
<p>顺序容器(array除外)定义了一个assign成员，允许从一个不同但相容的类型赋值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt;names; vector&lt;const char*&gt;oldstyle;</span><br><span class="line">names &#x3D; oldstyle; &#x2F;&#x2F;错误：容器类型不匹配</span><br><span class="line">names.assign(oldstyle.begin(), oldstyle.end()); &#x2F;&#x2F;正确：可以将const char*转换成string</span><br><span class="line"></span><br><span class="line">list&lt;string&gt;slist1(1); &#x2F;&#x2F;1个元素，为空string</span><br><span class="line">slist1.assign(10, &quot;hi&quot;); &#x2F;&#x2F;10个元素，“hi”</span><br><span class="line">等价于slist1.clear(); slist1.insert(slist1.begin(), 10, &quot;hi&quot;);</span><br></pre></td></tr></table></figure>
<p>swap操作交换两个相同类型容器的内容。除array外，操作会很快，元素本身并未交换，只是交换了内部数据结构<br>除string外，指向容器的迭代器、引用和指针在swap后都不会失效</p>
<p>除forward_list外，都有size, empty, max_size(返回一个大于或等于该类型容器所能容纳的最大元素的值)。forward_list只有max_size和empty</p>
<p>每个容器类型都支持相等运算符(==/!=)；除无序关联容器外都支持关系运算符(&gt;/&gt;=/&lt;/&lt;=)。必须是相同类型容器，相同类型的元素<br>比较结果取决于第一个不相等的元素的比较结果</p>
<h3 id="向顺序容器中添加元素"><a href="#向顺序容器中添加元素" class="headerlink" title="向顺序容器中添加元素"></a>向顺序容器中添加元素</h3><p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/4%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"></p>
<p>插入容器后若容器没有扩容、该元素没有改变位置，不会使其失效<br>当我们用一个对象来初始化容器，或将一个对象插入到容器中时，实际上放入到容器中的是对象的一个拷贝，而不是对象本身</p>
<p>当调用push或insert成员函数时，我们将元素类型的对象传递给它们，这些对象被拷贝到容器中。<br>当我们调用emplace成员函数时，则是将参数传递给元素类型的构造函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c.emplace_back(&quot;99-9999&quot;,25,15.99); &#x2F;&#x2F;使用三个参数的Sales_data构造函数</span><br><span class="line">c.push_back((&quot;99-9999&quot;, 25, 15.99); &#x2F;&#x2F;错误：没有接受三个参数的push_back版本</span><br><span class="line">c.push_back(Sales_data((&quot;99-9999&quot;, 25, 15.99)); &#x2F;&#x2F;正确：创建一个临时的Sales_data对象传递给push_back</span><br></pre></td></tr></table></figure>
<p>调用emplace_back时会在容器管理的内存空间中直接创建对象；而调用push_back则会创建一个局部临时对象，并将其压入容器中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">emplace函数的参数根据元素类型而变化，参数必须与元素类型的构造函数相匹配</span><br><span class="line">c.emplace_back(); &#x2F;&#x2F;使用Sales_data的默认构造函数</span><br><span class="line">c.emplace(iter, &quot;99-9999&quot;); &#x2F;&#x2F;使用Sales_data(string)</span><br><span class="line">c.emplace_front(&quot;99-9999&quot;, 25, 15.99); &#x2F;&#x2F;使用Sales_data的接受一个ISBN、一个count和一个price的构造函数</span><br></pre></td></tr></table></figure>
<h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/5%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (!c.empty()) &#123;</span><br><span class="line">	auto val &#x3D; *c.begin(); val2 &#x3D; c.front();</span><br><span class="line">	auto last &#x3D; c.end();</span><br><span class="line">	auto val3 &#x3D; *(--c.end());</span><br><span class="line">	auto val4 &#x3D; c.back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在容器中访问元素的成员函数(fornt,back,下标和at)返回的都是引用，容器是一个const对象则返回值是const的引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (!c.empty()) &#123;</span><br><span class="line">	c.front() &#x3D; 42;</span><br><span class="line">	auto&amp; v &#x3D; c.back(); &#x2F;&#x2F;获得指向最后一个元素的引用</span><br><span class="line">	v &#x3D; 1024; &#x2F;&#x2F;改变c中元素</span><br><span class="line">	auto v2 &#x3D; c.back(); &#x2F;&#x2F;v2不是引用，是c.back()的一个拷贝</span><br><span class="line">	v2 &#x3D; 0; &#x2F;&#x2F;不改变c中元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>at成员函数类似下标运算符，但越界是会抛出一个out_of_range异常</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt;v;</span><br><span class="line">cout &lt;&lt; v[0]; &#x2F;&#x2F;运行时错误</span><br><span class="line">cout &lt;&lt; v.at(0); &#x2F;&#x2F;抛出一个out_of_range异常</span><br></pre></td></tr></table></figure>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/6%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"><br><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/7%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"></p>
<h3 id="改变容器大小"><a href="#改变容器大小" class="headerlink" title="改变容器大小"></a>改变容器大小</h3><p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/8%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"></p>
<h3 id="管理容量的成员函数"><a href="#管理容量的成员函数" class="headerlink" title="管理容量的成员函数"></a>管理容量的成员函数</h3><p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/9%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"><br>reserve分配的大小小于等于当前容量时，reserve什么也不错。resize成员函数值改变容器中元素的数目，而不是容量</p>
<h3 id="构造string的其他方法"><a href="#构造string的其他方法" class="headerlink" title="构造string的其他方法"></a>构造string的其他方法</h3><p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/10%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const char* cp &#x3D; &quot;hello world!!!&quot;;</span><br><span class="line">char noNull[] &#x3D; &#123; &#39;h&#39;,&#39;i&#39; &#125;;</span><br><span class="line">string s1(cp); &#x2F;&#x2F;拷贝cp重点字符直到遇到空字符；s1&#x3D;&#x3D;&quot;hello world!!!&quot;</span><br><span class="line">string s2(noNull, 2); &#x2F;&#x2F;从noNull拷贝两个字符 &quot;hi&quot;</span><br><span class="line">string s3(noNUll); &#x2F;&#x2F;未定义：noNull不是以空字符结束</span><br><span class="line">string s4(cp + 6, 5); &#x2F;&#x2F;从cp[6]开始拷贝5个字符 &quot;world&quot;</span><br><span class="line">string s5(s1, 6, 5); &#x2F;&#x2F;从s1[6]开始拷贝5个字符 &quot;world&quot;</span><br><span class="line">string s6(s1, 6); &#x2F;&#x2F;从s1[6]开始拷贝到末尾 &quot;world!!!&quot;</span><br><span class="line">string s7(s1, 6, 20); </span><br><span class="line">string s8(s1, 16); &#x2F;&#x2F;抛出out_of_range异常</span><br><span class="line">从const char* 创建string时，指针指向的数组必须以空字符结尾，或者再传递一个合适的计数值</span><br></pre></td></tr></table></figure>
<h3 id="substr操作"><a href="#substr操作" class="headerlink" title="substr操作"></a>substr操作</h3><p>s.substr(pos, n) 返回一个string，包含s中从pos开始的n个字符的拷贝。pos的默认值为0。n的默认值为s.size() - pos，即拷贝从pos开始的所有字符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">string s(&quot;hello world&quot;);</span><br><span class="line">string s2 &#x3D; s.substr(0, 5); &#x2F;&#x2F;hello</span><br><span class="line">string s3 &#x3D; s.substr(6); &#x2F;&#x2F;world</span><br><span class="line">string s4 &#x3D; s.substr(6, 11); &#x2F;&#x2F;world</span><br><span class="line">string s5 &#x3D; s.substr(12); &#x2F;&#x2F;out_of_range</span><br><span class="line"></span><br><span class="line">s.insert(s.size(), 5, &#39;!&#39;); &#x2F;&#x2F;在s末尾插入5个&#39;!&#39;</span><br><span class="line">s.erase(s.size() - 5, 5); &#x2F;&#x2F;从s删除最后5个字符</span><br><span class="line"></span><br><span class="line">const char* cp &#x3D; &quot;Stately, plump Buck&quot;;</span><br><span class="line">s.assign(cp, 7); &#x2F;&#x2F;s&#x3D;&#x3D;&quot;Stately&quot; 赋值从cp开始的7个字符</span><br><span class="line">s.insert(s.size(), cp + 7); &#x2F;&#x2F;s&#x3D;&#x3D;&quot;Stately, plump Buck&quot;  将cp+7开始的字符拷贝到s后面</span><br><span class="line"></span><br><span class="line">string s &#x3D; &quot;Some string&quot;, s2 &#x3D; &quot;some other string&quot;;</span><br><span class="line">s.insert(0, s2); &#x2F;&#x2F;在s的0位置前插入s2</span><br><span class="line">s.insert(0, s2, 0, s2.size()); &#x2F;&#x2F;在s的0位置前插入s2的从0开始s2.size()个字符</span><br></pre></td></tr></table></figure>
<p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/11%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"><br><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/image.png?v=1&type=image" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.replace(a, b, s2); &#x2F;&#x2F;从s的a位置开始删除b个字符，并在该位置插入s2</span><br></pre></td></tr></table></figure>
<h3 id="string搜索操作"><a href="#string搜索操作" class="headerlink" title="string搜索操作"></a>string搜索操作</h3><p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/12%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"><br><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/13%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"><br>每个搜索操作都返回一个string::size_type值，表示匹配发生位置的下标。搜索失败则返回名为string::nops的static成员。nops等于任何string最大的可能大小<br>返回值是unsigned类型，一般不用int或其他带符号类型来保存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string name(&quot;AnnaBelle&quot;); </span><br><span class="line">auto pos &#x3D; name.find(&quot;Anna&quot;); &#x2F;&#x2F;pos&#x3D;&#x3D;0</span><br><span class="line">auto pos1 &#x3D; name.find(&quot;anna&quot;); &#x2F;&#x2F;pos&#x3D;&#x3D;nops</span><br><span class="line"></span><br><span class="line">string numbers(&quot;0123456789&quot;), name(&quot;r2d2&quot;), dept(&quot;01714p3&quot;);</span><br><span class="line">auto pos &#x3D; name.find_first_of(numbers); &#x2F;&#x2F;pos&#x3D;&#x3D;1</span><br><span class="line">auto pos &#x3D; name.find_first_not_of(numbers); &#x2F;&#x2F;pos&#x3D;&#x3D;5</span><br></pre></td></tr></table></figure>
<h3 id="指定开始搜索的位置"><a href="#指定开始搜索的位置" class="headerlink" title="指定开始搜索的位置"></a>指定开始搜索的位置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string::size_type pos &#x3D; 0;</span><br><span class="line">while ((pos &#x3D; name.find_first_of(numbers, pos)) !&#x3D; string::nops) &#123;</span><br><span class="line">	cout &lt;&lt; &quot;found number at index: &quot; &lt;&lt; pos &lt;&lt; &quot; elem is &quot; &lt;&lt; name[pos] &lt;&lt; endl;</span><br><span class="line">	++pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="逆向搜索"><a href="#逆向搜索" class="headerlink" title="逆向搜索"></a>逆向搜索</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string river(&quot;Mississippi&quot;);</span><br><span class="line">auto first_pos&#x3D;river.find_first(&quot;is&quot;); &#x2F;&#x2F;返回1</span><br><span class="line">auto last_pos &#x3D; river.find_last(&quot;is&quot;); &#x2F;&#x2F;返回4</span><br></pre></td></tr></table></figure>
<h3 id="compare函数"><a href="#compare函数" class="headerlink" title="compare函数"></a>compare函数</h3><p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/14%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"><br>返回负数、0、正数</p>
<h3 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D; 42;</span><br><span class="line">string s &#x3D; to_string(i); &#x2F;&#x2F;将整数i转换为字符表示形式</span><br><span class="line">double d &#x3D; stod(s); &#x2F;&#x2F;将字符串s转换为浮点数</span><br></pre></td></tr></table></figure>
<p>要转换为数值的string中第一个非空白符必须是数值中可能出现的字符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s2 &#x3D; &quot;pi&#x3D;3.14&quot;;</span><br><span class="line">d &#x3D; stod(s2.substr(s2.find_first_of(&quot;+-.0123456789&quot;))); &#x2F;&#x2F;d&#x3D;3.14</span><br></pre></td></tr></table></figure>
<p>如果string不能转换为一个数值，则抛出一个invalid_argument异常；数值无法用任何类型来表示则抛出out_of_range异常<br><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/15%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"></p>
<h3 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h3><p>标准库还定义了三个顺序容器适配器：stack、queue和priority_queue。本质上一个适配器是一种机制，能使某种事物的行为看起来像另外一种事物<br><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/16%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"><br>默认情况下，stack和queue是基于deque实现的，priority_queue是在vector之上实现的<br>定义一个适配器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;int&gt;deq;</span><br><span class="line">stack&lt;int&gt; stk(deq); &#x2F;&#x2F;从deq拷贝元素到stk</span><br></pre></td></tr></table></figure>
<p>我们可以再创建一个适配器时将一个命名的顺序容器作为第二个类型参数，来重载默认容器类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;int, vector&lt;string&gt;&gt;str_stk(sevc); &#x2F;&#x2F;str_stk在vector上实现，初始化时保存svec的拷贝</span><br></pre></td></tr></table></figure>
<p>因为所有适配器都要求容器具有添加、删除以及访问尾元素的能力，所以不能用array和forward_list来构造适配器<br>stack只要求push_back、pop_back和back操作–》使用除array和forward_list之外的任何容器类型来构造<br>queue要求back、push_back, front和push_front–》list或deque，不能用vector<br>priority_queue要求front, push_back, pop_back和随机访问能力–》vector或deque，不能用list</p>
<h3 id="栈适配器"><a href="#栈适配器" class="headerlink" title="栈适配器"></a>栈适配器</h3><p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/17%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;int&gt; intStack;</span><br><span class="line">for (size_t ix &#x3D; 0; ix &lt; 10; ++ix) </span><br><span class="line">	intStack.push(ix);</span><br><span class="line">while (!intStack.empty()) &#123;</span><br><span class="line">	int value &#x3D; intStack.top();</span><br><span class="line">	intStack.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="队列适配器"><a href="#队列适配器" class="headerlink" title="队列适配器"></a>队列适配器</h3><p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/18%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"><br><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/19%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/30/c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/" data-id="ckhq93ptn000ka0ve0bv5b0ei" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-primer/" rel="tag">c++ primer</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-problem-library-哈希-02" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/12/problem-library-%E5%93%88%E5%B8%8C-02/" class="article-date">
  <time datetime="2020-08-12T03:31:29.000Z" itemprop="datePublished">2020-08-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/12/problem-library-%E5%93%88%E5%B8%8C-02/">problem library 哈希 02</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="#739.每日温度"></a>#739.每日温度</h2><p>请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p>
<p>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p>
<p>提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/daily-temperatures" target="_blank" rel="noopener">https://leetcode-cn.com/problems/daily-temperatures</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; T) &#123;</span><br><span class="line">		vector&lt;int&gt;res(T.size(), 0);</span><br><span class="line">		for (int i &#x3D; T.size() - 2; i &gt;&#x3D; 0; --i) &#123;</span><br><span class="line">			if (T[i] &lt; T[i + 1])res[i] &#x3D; 1;</span><br><span class="line">			else &#123;</span><br><span class="line">				int tmp &#x3D; i + 1 + res[i + 1];</span><br><span class="line">				if (res[i + 1] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">					res[i] &#x3D; 0;</span><br><span class="line">					continue;</span><br><span class="line">				&#125;</span><br><span class="line">				while (T[i] &gt;&#x3D; T[tmp] &amp;&amp; tmp &lt; T.size()) &#123;</span><br><span class="line">					if (res[tmp] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">					tmp +&#x3D; res[tmp];</span><br><span class="line">				&#125;</span><br><span class="line">				if (T[i] &lt; T[tmp])res[i] &#x3D; tmp - i;</span><br><span class="line">				else res[i] &#x3D; 0;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="347-前k个高频元素"><a href="#347-前k个高频元素" class="headerlink" title="#347.前k个高频元素"></a>#347.前k个高频元素</h2><p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p>
<p>示例 1:</p>
<p>输入: nums = [1,1,1,2,2,3], k = 2<br>输出: [1,2]<br>示例 2:</p>
<p>输入: nums = [1], k = 1<br>输出: [1]</p>
<p>提示：</p>
<p>你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。<br>你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。<br>题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。<br>你可以按任意顺序返回答案。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/top-k-frequent-elements" target="_blank" rel="noopener">https://leetcode-cn.com/problems/top-k-frequent-elements</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">		vector&lt;int&gt;res;</span><br><span class="line">		unordered_map&lt;int, int&gt;m;</span><br><span class="line">		for (auto i : nums)m[i]++;</span><br><span class="line">		vector&lt;pair&lt;int, int&gt;&gt;tmp;</span><br><span class="line">		for (auto it &#x3D; m.begin(); it !&#x3D; m.end(); ++it) &#123;</span><br><span class="line">			tmp.emplace_back(make_pair(it-&gt;second, it-&gt;first));</span><br><span class="line">		&#125;</span><br><span class="line">		sort(tmp.begin(), tmp.end(), compare);</span><br><span class="line">		int i &#x3D; tmp.size() - 1;</span><br><span class="line">		while (k &gt; 0) &#123;</span><br><span class="line">			res.emplace_back(tmp[i].second);</span><br><span class="line">			k--; i--;</span><br><span class="line">		&#125;</span><br><span class="line">		return res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	static bool compare(pair&lt;int, int&gt; i, pair&lt;int, int&gt; j) &#123;</span><br><span class="line">		return i.second &gt; j.second;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">		vector&lt;int&gt;res;</span><br><span class="line">		unordered_map&lt;int, int&gt;m;</span><br><span class="line">		for (auto i : nums)m[i]++;</span><br><span class="line">		vector&lt;pair&lt;int, int&gt;&gt;tmp(m.begin(), m.end());</span><br><span class="line">		sort(tmp.begin(), tmp.end(), compare);</span><br><span class="line">		for (int i &#x3D; 0; i &lt; k; ++i) &#123;</span><br><span class="line">			res.emplace_back(tmp[i].first);</span><br><span class="line">		&#125;</span><br><span class="line">		return res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="36-有效的数独"><a href="#36-有效的数独" class="headerlink" title="#36.有效的数独"></a>#36.有效的数独</h2><p>判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。</p>
<p>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">	[&quot;5&quot;, &quot;3&quot;, &quot;.&quot;, &quot;.&quot;, &quot;7&quot;, &quot;.&quot;, &quot;.&quot;, &quot;.&quot;, &quot;.&quot;],</span><br><span class="line">	[&quot;6&quot;, &quot;.&quot;, &quot;.&quot;, &quot;1&quot;, &quot;9&quot;, &quot;5&quot;, &quot;.&quot;, &quot;.&quot;, &quot;.&quot;],</span><br><span class="line">	[&quot;.&quot;, &quot;9&quot;, &quot;8&quot;, &quot;.&quot;, &quot;.&quot;, &quot;.&quot;, &quot;.&quot;, &quot;6&quot;, &quot;.&quot;],</span><br><span class="line">	[&quot;8&quot;, &quot;.&quot;, &quot;.&quot;, &quot;.&quot;, &quot;6&quot;, &quot;.&quot;, &quot;.&quot;, &quot;.&quot;, &quot;3&quot;],</span><br><span class="line">	[&quot;4&quot;, &quot;.&quot;, &quot;.&quot;, &quot;8&quot;, &quot;.&quot;, &quot;3&quot;, &quot;.&quot;, &quot;.&quot;, &quot;1&quot;],</span><br><span class="line">	[&quot;7&quot;, &quot;.&quot;, &quot;.&quot;, &quot;.&quot;, &quot;2&quot;, &quot;.&quot;, &quot;.&quot;, &quot;.&quot;, &quot;6&quot;],</span><br><span class="line">	[&quot;.&quot;, &quot;6&quot;, &quot;.&quot;, &quot;.&quot;, &quot;.&quot;, &quot;.&quot;, &quot;2&quot;, &quot;8&quot;, &quot;.&quot;],</span><br><span class="line">	[&quot;.&quot;, &quot;.&quot;, &quot;.&quot;, &quot;4&quot;, &quot;1&quot;, &quot;9&quot;, &quot;.&quot;, &quot;.&quot;, &quot;5&quot;],</span><br><span class="line">	[&quot;.&quot;, &quot;.&quot;, &quot;.&quot;, &quot;.&quot;, &quot;8&quot;, &quot;.&quot;, &quot;.&quot;, &quot;7&quot;, &quot;9&quot;]</span><br><span class="line">]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/valid-sudoku" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-sudoku</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;</span><br><span class="line">		int row[9][10] &#x3D; &#123; 0 &#125;, col[9][10] &#x3D; &#123; 0 &#125;, box[9][10] &#x3D; &#123; 0 &#125;;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; 9; ++i) &#123;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; 9; ++j) &#123;</span><br><span class="line">				if (board[i][j] &#x3D;&#x3D; &#39;.&#39;)continue;</span><br><span class="line">				int num &#x3D; board[i][j] - &#39;0&#39;;</span><br><span class="line">				if (row[i][num] + col[j][num] + box[j &#x2F; 3 + i &#x2F; 3 * 3][num] &gt; 0)return false;</span><br><span class="line">				++row[i][num]; ++col[j][num]; ++box[j &#x2F; 3 + i &#x2F; 3 * 3][num];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="560-和为k的子数组"><a href="#560-和为k的子数组" class="headerlink" title="#560.和为k的子数组"></a>#560.和为k的子数组</h2><p>给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。</p>
<p>示例 1 :</p>
<p>输入:nums = [1,1,1], k = 2<br>输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。<br>说明 :</p>
<p>数组的长度为 [1, 20,000]。<br>数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/subarray-sum-equals-k" target="_blank" rel="noopener">https://leetcode-cn.com/problems/subarray-sum-equals-k</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">		queue&lt;int&gt;tmp;</span><br><span class="line">		int sum &#x3D; 0, count &#x3D; 0;</span><br><span class="line">		for (auto i : nums) &#123;</span><br><span class="line">			tmp.push(i);</span><br><span class="line">			sum +&#x3D; i;</span><br><span class="line">			while (sum &gt; k) &#123;</span><br><span class="line">				sum -&#x3D; tmp.front();</span><br><span class="line">				tmp.pop();</span><br><span class="line">			&#125;</span><br><span class="line">			if (sum &#x3D;&#x3D; k &amp;&amp; !tmp.empty()) &#123;</span><br><span class="line">				sum -&#x3D; tmp.front();</span><br><span class="line">				tmp.pop();</span><br><span class="line">				++count;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return count;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="187-重复的DNA序列"><a href="#187-重复的DNA序列" class="headerlink" title="#187.重复的DNA序列"></a>#187.重复的DNA序列</h2><p>所有 DNA 都由一系列缩写为 A，C，G 和 T 的核苷酸组成，例如：“ACGAATTCCG”。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。</p>
<p>编写一个函数来查找目标子串，目标子串的长度为 10，且在 DNA 字符串 s 中出现次数超过一次。</p>
<p>示例：</p>
<p>输入：s = “AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT”<br>输出：[“AAAAACCCCC”, “CCCCCAAAAA”]</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/repeated-dna-sequences" target="_blank" rel="noopener">https://leetcode-cn.com/problems/repeated-dna-sequences</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	vector&lt;string&gt; findRepeatedDnaSequences(string s) &#123;</span><br><span class="line">		if (s.size() &lt; +10)return &#123;&#125;;</span><br><span class="line">		unordered_map&lt;string, int&gt;m;</span><br><span class="line">		vector&lt;string&gt;res;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; s.size() - 9; ++i) &#123;</span><br><span class="line">			string tmp(s.begin() + i, s.begin() + 10 + i);</span><br><span class="line">			if (m[tmp] &#x3D;&#x3D; 1)res.emplace_back(tmp);</span><br><span class="line">			++m[tmp];</span><br><span class="line">		&#125;</span><br><span class="line">		return res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="84-柱状图中最大矩形"><a href="#84-柱状图中最大矩形" class="headerlink" title="#84.柱状图中最大矩形"></a>#84.柱状图中最大矩形</h2><p>给定  <em>n</em>  个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<p><strong>示例:</strong></p>
<p><strong>输入:</strong> [2,1,5,6,2,3]<br><strong>输出:</strong> 10</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;</span><br><span class="line">        int sz &#x3D; heights.size(), res &#x3D; 0;</span><br><span class="line">        stack&lt;int&gt;tmp;</span><br><span class="line">        vector&lt;int&gt;left(sz), right(sz, sz);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; sz; ++i) &#123;</span><br><span class="line">            while (!tmp.empty() &amp;&amp; heights[i] &lt;&#x3D; heights[tmp.top()]) &#123;</span><br><span class="line">                right[tmp.top()] &#x3D; i;</span><br><span class="line">                tmp.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            left[i] &#x3D; tmp.empty() ? -1 : tmp.top();</span><br><span class="line">            tmp.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; sz; ++i) &#123;</span><br><span class="line">            res &#x3D; max(res, heights[i] * (right[i] - left[i] - 1));</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/12/problem-library-%E5%93%88%E5%B8%8C-02/" data-id="ckhq93puc002ra0vee0arc2t4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/problem-library/" rel="tag">problem library</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-cocos2d-x-02-动作" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/10/cocos2d-x-02-%E5%8A%A8%E4%BD%9C/" class="article-date">
  <time datetime="2020-08-10T14:48:41.000Z" itemprop="datePublished">2020-08-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/10/cocos2d-x-02-%E5%8A%A8%E4%BD%9C/">cocos2d-x 02 动作</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">bool HelloWorld::init()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 1. super init first</span><br><span class="line">    if ( !Scene::init() )</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    auto visibleSize &#x3D; Director::getInstance()-&gt;getVisibleSize();</span><br><span class="line">    Vec2 origin &#x3D; Director::getInstance()-&gt;getVisibleOrigin();</span><br><span class="line"></span><br><span class="line">	LabelTTF* label &#x3D; LabelTTF::create(&quot;text text text&quot;, &quot;Courier&quot;, 30);</span><br><span class="line">	addChild(label);</span><br><span class="line">	label-&gt;setPosition(visibleSize.width &#x2F; 2, visibleSize.height &#x2F; 2);</span><br><span class="line"></span><br><span class="line">	auto listener &#x3D; EventListenerTouchOneByOne::create();</span><br><span class="line">	listener-&gt;onTouchBegan &#x3D; [label](Touch * t, Event * e) &#123;</span><br><span class="line">		if (label-&gt;getBoundingBox().containsPoint(t-&gt;getLocation())) &#123;</span><br><span class="line">			&#x2F;&#x2F;label-&gt;runAction(MoveTo::create(1, Point(100, 100)));</span><br><span class="line">			&#x2F;&#x2F;label-&gt;runAction(MoveBy::create(1, Point(100, 100))-&gt;reverse());</span><br><span class="line">			label-&gt;runAction(Sequence::create(</span><br><span class="line">				MoveBy::create(1, Point(50, 50)),</span><br><span class="line">				RotateBy::create(1, 360),</span><br><span class="line">				CallFunc::create([]() &#123;</span><br><span class="line">					MessageBox(&quot;Action Complete&quot;, &quot;complete&quot;);</span><br><span class="line">					&#125;), NULL));</span><br><span class="line">		&#125;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;;</span><br><span class="line">	Director::getInstance()-&gt;getEventDispatcher()-&gt;addEventListenerWithSceneGraphPriority(listener, label);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;label-&gt;runAction(Repeat::create(RotateBy::create(1, 180),3));</span><br><span class="line">	&#x2F;&#x2F;label-&gt;runAction(RepeatForever::create(RotateBy::create(1, 180)));</span><br><span class="line">	&#x2F;&#x2F;label-&gt;runAction(Spawn::create(MoveBy::create(1, Point(50, 50)), RotateBy::create(2, 360),NULL));</span><br><span class="line">	&#x2F;&#x2F;label-&gt;runAction(Sequence::create(MoveBy::create(1, Point(50, 50)), RotateBy::create(1, 360), NULL));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/10/cocos2d-x-02-%E5%8A%A8%E4%BD%9C/" data-id="ckhq93ptz001ea0ve7umx2gvd" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cocos2d-x/" rel="tag">cocos2d-x</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-cocos2d-x-01" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/10/cocos2d-x-01/" class="article-date">
  <time datetime="2020-08-10T14:47:11.000Z" itemprop="datePublished">2020-08-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/10/cocos2d-x-01/">cocos2d-x 01</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">bool HelloWorld::init()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 1. super init first</span><br><span class="line">    if ( !Scene::init() )</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;菜单</span><br><span class="line">	auto menu &#x3D; Menu::create(MenuItemImage::create(&quot;normal.png&quot;, &quot;selected.png&quot;, [](object * obj) &#123;</span><br><span class="line">		log(&quot;menu item touched&quot;);</span><br><span class="line">		&#125;), NULL);</span><br><span class="line">	addChild(menu);</span><br><span class="line">	&#x2F;&#x2F;场景切换</span><br><span class="line">	LabelTTF* label &#x3D; LabelTTF::create(&quot;show next scene&quot;, &quot;Courier&quot;, 30);</span><br><span class="line">	addChild(label);</span><br><span class="line">	label-&gt;setPosition(visibleSize.width &#x2F; 2, visibleSize.height &#x2F; 2);</span><br><span class="line">	auto listener &#x3D; EventListenerTouchOneByOne::create();</span><br><span class="line">	listener-&gt;onTouchBegan &#x3D; [label](Touch * t, Event * e) &#123;</span><br><span class="line">		if (label-&gt;getBoundingBox().containsPoint(t-&gt;getLocation())) &#123;</span><br><span class="line">			Director::getInstance()-&gt;replaceScene(Imagescene::createScene());</span><br><span class="line">		&#125;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;;</span><br><span class="line">	Director::getInstance()-&gt;getEventDispatcher()-&gt;addEventListenerWithSceneGraphPriority(listener, label);</span><br><span class="line">   </span><br><span class="line">	</span><br><span class="line">	return true; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="场景切换"><a href="#场景切换" class="headerlink" title="场景切换"></a>场景切换</h2><h3 id="ImageScene-cpp"><a href="#ImageScene-cpp" class="headerlink" title="ImageScene.cpp"></a>ImageScene.cpp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Imagescene.h&quot;</span><br><span class="line"></span><br><span class="line">Scene* Imagescene::createScene() &#123;</span><br><span class="line">	Scene* scene &#x3D; Scene::create();</span><br><span class="line">	Imagescene* layer &#x3D; Imagescene::create();</span><br><span class="line">	scene-&gt;addChild(layer);</span><br><span class="line">	return scene;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Imagescene::init() &#123;</span><br><span class="line">	auto visibleSize &#x3D; Director::getInstance()-&gt;getVisibleSize();</span><br><span class="line">	Sprite* s &#x3D; Sprite::create(&quot;HelloWorld.png&quot;);</span><br><span class="line">	s-&gt;setPosition(visibleSize.width &#x2F; 2, visibleSize.height &#x2F; 2);</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Imagescene-h"><a href="#Imagescene-h" class="headerlink" title="Imagescene.h"></a>Imagescene.h</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&quot;Imagescene.h&quot;</span><br><span class="line">#include&lt;cocos2d.h&gt;</span><br><span class="line">USING_NS_CC;</span><br><span class="line">class Imagescene:public Layer</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual bool init();</span><br><span class="line">	static Scene* createScene();</span><br><span class="line">	CREATE_FUNC(Imagescene);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/10/cocos2d-x-01/" data-id="ckhq93ptw0013a0ve0ln082vq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cocos2d-x/" rel="tag">cocos2d-x</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-problem-library-哈希" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/09/problem-library-%E5%93%88%E5%B8%8C/" class="article-date">
  <time datetime="2020-08-09T12:09:23.000Z" itemprop="datePublished">2020-08-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/09/problem-library-%E5%93%88%E5%B8%8C/">problem library 哈希</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="#1.两数之和"></a>#1.两数之和</h2><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>
<p>示例:</p>
<p>给定 nums = [2, 7, 11, 15], target = 9</p>
<p>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/two-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        map&lt;int, int&gt;m;</span><br><span class="line">        vector&lt;int&gt;v;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; nums.size(); ++i)m.insert(map&lt;int, int&gt;::value_type(nums[i], i));</span><br><span class="line">        for (int i &#x3D; 0; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            if (m.count(target - nums[i]) &gt; 0 &amp;&amp; m[target - nums[i]] !&#x3D; i) &#123;</span><br><span class="line">                v.emplace_back(i);</span><br><span class="line">                v.emplace_back(m[target - nums[i]]);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="#136.只出现一次的数字"></a>#136.只出现一次的数字</h2><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p>说明：</p>
<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<p>示例 1:</p>
<p>输入: [2,2,1]<br>输出: 1<br>示例 2:</p>
<p>输入: [4,1,2,1,2]<br>输出: 4</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/single-number" target="_blank" rel="noopener">https://leetcode-cn.com/problems/single-number</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        map&lt;int, int&gt;m;</span><br><span class="line">        for (auto i : nums)m[i]++;</span><br><span class="line">        for (auto it &#x3D; m.begin(); it !&#x3D; m.end(); ++it) &#123;</span><br><span class="line">            if (it-&gt;second &#x3D;&#x3D; 1)return it-&gt;first;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int res &#x3D; 0;</span><br><span class="line">        for (auto i : nums)res ^&#x3D; i;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="#202.快乐数"></a>#202.快乐数</h2><p>编写一个算法来判断一个数 n 是不是快乐数。</p>
<p>「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。</p>
<p>如果 n 是快乐数就返回 True ；不是，则返回 False 。</p>
<p>示例：</p>
<p>输入：19<br>输出：true<br>解释：<br>12 + 92 = 82<br>82 + 22 = 68<br>62 + 82 = 100<br>12 + 02 + 02 = 1</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/happy-number" target="_blank" rel="noopener">https://leetcode-cn.com/problems/happy-number</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="哈希-1"><a href="#哈希-1" class="headerlink" title="哈希"></a>哈希</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int getN(int n) &#123;</span><br><span class="line">        int res &#x3D; 0;</span><br><span class="line">        while (n) &#123;</span><br><span class="line">            int a &#x3D; n % 10;</span><br><span class="line">            n &#x3D; n &#x2F; 10;</span><br><span class="line">            res +&#x3D; a * a;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    bool isHappy(int n) &#123;</span><br><span class="line">        unordered_map&lt;int, bool&gt;m;</span><br><span class="line">        while (n !&#x3D; 1) &#123;</span><br><span class="line">            n &#x3D; getN(n);</span><br><span class="line">            if (m[n] &#x3D;&#x3D; true)return false;</span><br><span class="line">            m[n] &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="快慢针"><a href="#快慢针" class="headerlink" title="快慢针"></a>快慢针</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int getN(int n) &#123;</span><br><span class="line">        int res &#x3D; 0;</span><br><span class="line">        while (n) &#123;</span><br><span class="line">            int a &#x3D; n % 10;</span><br><span class="line">            n &#x3D; n &#x2F; 10;</span><br><span class="line">            res +&#x3D; a * a;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    bool isHappy(int n) &#123;</span><br><span class="line">        int i &#x3D; n, j &#x3D; getN(n);</span><br><span class="line">        while (i !&#x3D; j) &#123;</span><br><span class="line">            i &#x3D; getN(i);</span><br><span class="line">            j &#x3D; getN(getN(j));</span><br><span class="line">        &#125;</span><br><span class="line">        return i &#x3D;&#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="219-存在重复的元素II"><a href="#219-存在重复的元素II" class="headerlink" title="#219.存在重复的元素II"></a>#219.存在重复的元素II</h2><p>给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的 绝对值 至多为 k。</p>
<p>示例 1:</p>
<p>输入: nums = [1,2,3,1], k = 3<br>输出: true<br>示例 2:</p>
<p>输入: nums = [1,0,1,1], k = 1<br>输出: true<br>示例 3:</p>
<p>输入: nums = [1,2,3,1,2,3], k = 2<br>输出: false</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/contains-duplicate-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/contains-duplicate-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        unordered_set&lt;int&gt;tmp;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            if (tmp.find(nums[i]) !&#x3D; tmp.end())return true;</span><br><span class="line">            tmp.emplace(nums[i]);</span><br><span class="line">            if (tmp.size() &gt; k)tmp.erase(nums[i - k]);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="217-存在重复元素"><a href="#217-存在重复元素" class="headerlink" title="#217.存在重复元素"></a>#217.存在重复元素</h2><p>给定一个整数数组，判断是否存在重复元素。</p>
<p>如果任意一值在数组中出现至少两次，函数返回  <code>true</code>  。如果数组中每个元素都不相同，则返回  <code>false</code>  。</p>
<p><strong>示例 1:</strong></p>
<p><strong>输入:</strong> [1,2,3,1]<br><strong>输出:</strong> true</p>
<p><strong>示例 2:</strong></p>
<p><strong>输入:</strong> [1,2,3,4]<br><strong>输出:</strong> false</p>
<p><strong>示例 3:</strong></p>
<p><strong>输入:</strong> [1,1,1,3,3,4,3,2,4,2]<br><strong>输出:</strong> true</p>
<h3 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        unordered_set&lt;int&gt;tmp;</span><br><span class="line">        for (auto i : nums) &#123;</span><br><span class="line">            if (tmp.find(i) !&#x3D; tmp.end())return true;</span><br><span class="line">            tmp.emplace(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        unordered_map&lt;int, int&gt;m;</span><br><span class="line">        for (auto i : nums) &#123;</span><br><span class="line">            m[i]++;</span><br><span class="line">            if (m[i] &gt; 1)return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="#349.两个数组的交集"></a>#349.两个数组的交集</h2><p>给定两个数组，编写一个函数来计算它们的交集。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong>nums1 = [1,2,2,1], nums2 = [2,2]<br><strong>输出：</strong>[2]</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>nums1 = [4,9,5], nums2 = [9,4,9,8,4]<br><strong>输出：</strong>[9,4]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">        unordered_set&lt;int&gt;res1, num11(nums1.begin(), nums1.end());</span><br><span class="line">        for (auto i : nums2) &#123;</span><br><span class="line">            if (num11.find(i) !&#x3D; num11.end())res1.emplace(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return vector&lt;int&gt;(res1.begin(), res1.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="#242.有效的字母异位词"></a>#242.有效的字母异位词</h2><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p>
<p>示例 1:</p>
<p>输入: s = “anagram”, t = “nagaram”<br>输出: true<br>示例 2:</p>
<p>输入: s = “rat”, t = “car”<br>输出: false<br>说明:<br>你可以假设字符串只包含小写字母。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/valid-anagram" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-anagram</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isAnagram(string s, string t) &#123;</span><br><span class="line">        if (s.size() !&#x3D; t.size())return false;</span><br><span class="line">        int words[26] &#x3D; &#123;&#125;;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            ++words[s[i] - &#39;a&#39;];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; t.size(); ++j) &#123;</span><br><span class="line">            if (--words[t[j] - &#39;a&#39;] &lt; 0)return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/09/problem-library-%E5%93%88%E5%B8%8C/" data-id="ckhq93pud002wa0vecpqc6sgq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/problem-library/" rel="tag">problem library</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/02-cpp-primer/" rel="tag">02 cpp primer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c-primer/" rel="tag">c++ primer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cocos2d-x/" rel="tag">cocos2d-x</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpp-notes/" rel="tag">cpp notes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/problem-library/" rel="tag">problem library</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reading-notes-DS/" rel="tag">reading notes DS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%82%93%E4%BF%8A%E8%BE%89/" rel="tag">数据结构 邓俊辉</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/02-cpp-primer/" style="font-size: 14px;">02 cpp primer</a> <a href="/tags/c-primer/" style="font-size: 16px;">c++ primer</a> <a href="/tags/cocos2d-x/" style="font-size: 12px;">cocos2d-x</a> <a href="/tags/cpp-notes/" style="font-size: 20px;">cpp notes</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/problem-library/" style="font-size: 16px;">problem library</a> <a href="/tags/reading-notes-DS/" style="font-size: 10px;">reading notes DS</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%82%93%E4%BF%8A%E8%BE%89/" style="font-size: 18px;">数据结构 邓俊辉</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/11/20/ncpp-07/">第7章 类</a>
          </li>
        
          <li>
            <a href="/2020/11/19/ncpp-06/">第6章 函数</a>
          </li>
        
          <li>
            <a href="/2020/11/18/ncpp-05/">第5章 语句</a>
          </li>
        
          <li>
            <a href="/2020/11/17/ncpp-04/">第4章 表达式</a>
          </li>
        
          <li>
            <a href="/2020/11/16/%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/">操作方法</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>
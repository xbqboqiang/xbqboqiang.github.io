<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-c-primer-16-模板与泛型编程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/30/c-primer-16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/" class="article-date">
  <time datetime="2020-08-30T03:01:44.000Z" itemprop="datePublished">2020-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/30/c-primer-16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/">c++ primer 16 模板与泛型编程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="模板与泛型编程"><a href="#模板与泛型编程" class="headerlink" title="模板与泛型编程"></a>模板与泛型编程</h1><p>模板是泛型编程的基础。使用时提供足够的信息，将蓝图转换为特定的类或函数。转换发生在编译时</p>
<h2 id="定义模板"><a href="#定义模板" class="headerlink" title="定义模板"></a>定义模板</h2><h3 id="函数模板-function-template"><a href="#函数模板-function-template" class="headerlink" title="函数模板(function template)"></a>函数模板(function template)</h3><p>一个函数模板就是一个公式，可用来生成针对特定类型的函数版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">int compare(const T&amp; v1, const T&amp; v2) &#123;</span><br><span class="line">	if (v1 &lt; v2)return -1;</span><br><span class="line">	if (v2 &lt; v1)return 1;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以template开始，跟一个模板参数列表(template parameter list)，包括若干个逗号分隔的模板参数(template parameter)<br>使用模板时，指定模板实参，将其绑定到模板参数上</p>
<p>实例化函数模板<br>调用函数模板时，编译器用函数实参来推断模板实参<br>cout &lt;&lt; compare(1, 0) &lt;&lt; endl;<br>编译器用推断出的模板参数来实例化(instantiate)一个特点版本的函数</p>
<p>模板类型参数<br>可以将类型参数看做类型说明符，类型参数前必须使用关键字class或typename</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;正确：返回类型和参数类型相同</span><br><span class="line">template&lt;typename T&gt;T foo(T* p) &#123;</span><br><span class="line">	T tmp &#x3D; *p;	&#x2F;&#x2F;tmp的类型将是指针p指向的类型</span><br><span class="line">	return tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;错误：U之前必须加上class或typename</span><br><span class="line">template&lt;typename T, U&gt;T calc(const T&amp;, const T&amp;);</span><br><span class="line">在模板参数列表中这两个关键字的含义相同</span><br><span class="line">template&lt;typename T, class U&gt;calc(const T&amp;, const U&amp;);</span><br></pre></td></tr></table></figure>
<p>非类型模板参数(nontype parameter)<br>一个非类型模板参数表示一个值而非一个类型。通过一个特定的类型名关键字来指定非类型参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;模板参数表示数组的长度</span><br><span class="line">template&lt;unsigned N,unsigned M&gt;</span><br><span class="line">int compare(const char&amp; p1[n], const char&amp; p2[M]) &#123;</span><br><span class="line">	return strcmp(p1, p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用时：compare(“hi”, “hello”); 编译器会在字符串字面常量的末尾插入一个空字符作为终结符<br>int compare(const char(&amp;p1)[3], const char(&amp;p2)[6])<br>一个非类型参数可以是一个整型，或者一个指向对象或函数类型的指针或(左值)引用<br>绑定到非类型参数的实参必须是常量表达式；绑定到指针或引用的必须具有静态的生命周期，不能用普通(非静态)局部变量或动态对象作为指针或引用非类型模板参数的实参</p>
<p>模板函数可以声明为inline或constexpr的，说明符放在模板参数列表之后<br>template<typename T>inline T min(const T&amp;, const T&amp;);</p>
<p>模板中的函数参数是const的引用，保证了函数可以用于不能拷贝的类型(unique_ptr和IO类型等)</p>
<p>为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义，所以模板的头文件通常既包括声明也包括定义</p>
<p>模板直到实例化才会生成代码。编译器会在三个阶段报告错误：<br>·编译模板本身时。检查语法错误<br>·编译器遇到模板使用时。检查实参数目、类型等<br>·模板实例化时。大多数编译错误在实例化期间报告<br>if (v1 &lt; v2)return -1;<br>到实例化时才知道v1&lt;v2是否合法</p>
<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>编译器不能为类模板推断模板参数信息</p>
<p>定义类模板</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;class Blob &#123;</span><br><span class="line">public:</span><br><span class="line">	typedef T value_type;</span><br><span class="line">	typedef typename vector&lt;T&gt;::size_type size_type;</span><br><span class="line">	&#x2F;&#x2F;构造函数</span><br><span class="line">	Blob();</span><br><span class="line">	Blob(initializer_list&lt;T&gt; il);</span><br><span class="line">	&#x2F;&#x2F;Blob中元素数目</span><br><span class="line">	size_type size() const &#123; return data-&gt;size(); &#125;</span><br><span class="line">	bool empty() const &#123; return data-&gt;empty(); &#125;</span><br><span class="line">	&#x2F;&#x2F;删除和添加元素</span><br><span class="line">	void push_back(const T&amp; t) &#123; data-&gt;push_back(t); &#125;</span><br><span class="line">	&#x2F;&#x2F;移动版本</span><br><span class="line">	void push_back(T&amp;&amp; t) &#123; data-&gt;push_back(move(t)); &#125;</span><br><span class="line">	void pop_back();</span><br><span class="line">	&#x2F;&#x2F;元素访问</span><br><span class="line">	T&amp; back();</span><br><span class="line">	T&amp; operator[](size_type i);</span><br><span class="line">private:</span><br><span class="line">	shared_ptr&lt;vector&lt;T&gt;&gt;data;</span><br><span class="line">	&#x2F;&#x2F;若data[i]无效，抛出msg</span><br><span class="line">	void check(size_type i, const string&amp; msg)const;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>实例化类模板<br>提供显示模板实参(explicit template argument)列表，他们被绑定到模板参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Blob&lt;int&gt; ia;					&#x2F;&#x2F;空Blob&lt;int&gt;</span><br><span class="line">Blob&lt;int&gt; ia2 &#x3D; &#123; 0,1,2,3,4 &#125;;	&#x2F;&#x2F;有5个元素的Blob&lt;int&gt;</span><br></pre></td></tr></table></figure>
<p>编译器会实例出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">template&lt;&gt;class Blob&lt;int&gt; &#123;</span><br><span class="line">	typedef typename vector&lt;int&gt;::size_type size_type;</span><br><span class="line">	Blob();</span><br><span class="line">	Blob(initializer_list&lt;int&gt; il);</span><br><span class="line">	&#x2F;&#x2F;...</span><br><span class="line">	int&amp; operator[](size_type i);</span><br><span class="line">private:</span><br><span class="line">	shared_ptr&lt;vector&lt;int&gt;&gt; data;</span><br><span class="line">	void check(size_type i, const string&amp; msg)const;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一个类模板的每个实例都形成一个独立的类。Blob<int>与其他Bolb类没有关联</p>
<p>类模板的成员函数<br>定义在类模板内的成员喊被隐式声明为内联函数<br>定义在类模板之外的成员函数就必须以关键字template开始，后接类模板参数列表</p>
<p>check和元素访问成员</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void Blob&lt;T&gt;::check(size_type i, const string&amp; msg)const &#123;</span><br><span class="line">	if (i &gt;&#x3D; data-&gt;size())</span><br><span class="line">		throw out_of_range(msg);</span><br><span class="line">&#125;</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">T&amp; Blog&lt;T&gt;::back() &#123;</span><br><span class="line">	check(0, &quot;back on empty Blob&quot;);</span><br><span class="line">	return data-&gt;check();</span><br><span class="line">&#125;</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">T&amp; Blob&lt;T&gt;::operator[](size_type i) &#123;</span><br><span class="line">	check(i, &quot;subscript out of range&quot;);</span><br><span class="line">	return (*data)[i];</span><br><span class="line">&#125;</span><br><span class="line">返回一个引用，指向用来实例化BLob的类型</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void Blob&lt;T&gt;::pop_back() &#123;</span><br><span class="line">	check(0, &quot;pop_back on empty Blob&quot;);</span><br><span class="line">	data-&gt;pop_back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Blob构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">Blob&lt;T&gt;::Blob() :data(make_shared&lt;vector&lt;T&gt;&gt;()) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数分配一个空vector，并将指向vector的指针保存在data中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">Blob&lt;T&gt;::Blob(initializer_list&lt;T&gt; il) : data(make_shared&lt;vector&lt;T&gt;&gt;(il)) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>为了使用这个构造函数，必须传给它一个initializer_list</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Blob&lt;string&gt;articals &#x3D; &#123; &quot;a&quot;,&quot;an&quot;,&quot;the&quot; &#125;;</span><br></pre></td></tr></table></figure>
<p>列表中每个字符串字面常量隐式地转换为一个string</p>
<p>类模板成员函数的实例化<br>默认情况下，一个类模板的成员函数只有当程序用到它时才进行实例化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;实例化Blob&lt;int&gt;和接受initializer_list&lt;int&gt;的构造函数</span><br><span class="line">Blob&lt;int&gt;squares &#x3D; &#123; 0,1,2,3,4,5,6,7,8,9 &#125;;</span><br><span class="line">&#x2F;&#x2F;实例化Blob&lt;int&gt;::size()const</span><br><span class="line">for (size_t i &#x3D; 0; i !&#x3D; squares.size(); ++i)</span><br><span class="line">	squares[i] &#x3D; i * i;		&#x2F;&#x2F;实例化Blob&lt;int&gt;::operator[](size_t)</span><br></pre></td></tr></table></figure>
<p>这一特性使得即使某种类型不能完全符合模板操作的要求，扔能用该类型实例化类</p>
<p>在类代码内简化模板类名的使用<br>在类模板自己的作用域中，可以直接使用模板名而不提供实参</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;class BlobPtr &#123;</span><br><span class="line">public:</span><br><span class="line">	BlobPtr() :curr(0) &#123;&#125;</span><br><span class="line">	BlobPtr(Blob&lt;T&gt;&amp; a, size_t sz &#x3D; 0) :wptr(a.data), curr(sz) &#123;&#125;</span><br><span class="line">	T&amp; operator*()const &#123;</span><br><span class="line">		auto p &#x3D; check(curr, &quot;dereference past end&quot;);</span><br><span class="line">		return (*p)[curr];	&#x2F;&#x2F;(*p)为本对象指向的vector</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;递增和递减</span><br><span class="line">	BlobPtr&amp; operator++();	&#x2F;&#x2F;前置运算符</span><br><span class="line">	BlobPtr&amp; operator--();</span><br><span class="line">private:</span><br><span class="line">	&#x2F;&#x2F;若检查成功，返回一个指向vector的shared_ptr</span><br><span class="line">	shared_ptr&lt;vector&lt;T&gt;&gt;check(size_t, const string&amp;)const;</span><br><span class="line">	&#x2F;&#x2F;保存一个weak_ptr，表示底层vector可能被销毁</span><br><span class="line">	weak_ptr&lt;vector&lt;T&gt;&gt;wptr;</span><br><span class="line">	size_t curr;	&#x2F;&#x2F;数组中的当前位置</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在类模板外使用类模板名<br>在类模板外定义成员时，直到遇到类名才表示进入类的作用域</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;后置：递增&#x2F;递减对象但返回原值</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">BlobPtr&lt;T&gt; BlobPtr&lt;T&gt;::operator(int) &#123;</span><br><span class="line">	&#x2F;&#x2F;无需检查，调用前置时会检查</span><br><span class="line">	BlobPtr ret &#x3D; *this;</span><br><span class="line">	++* this;</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ret的定义与BlobPtr<int>ret = *this等价</p>
<p>类模板和友元<br>类包含友元声明是，类与友元各自是否是模板是无关的<br>类模板包含一个非模板友元，则友元被授权访问所有模板实例<br>友元自身是模板，类可以授权给所有友元模板实例，也可以授权给特定的</p>
<p>一对一友好关系<br>类模板与另一个(类或函数)模板间友好关系的最常见形式是建立对应实例及其友元间的友好关系</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;前置声明，在Blob中声明友元所需要的</span><br><span class="line">template&lt;typename T&gt;class BlobPtr;</span><br><span class="line">template&lt;typename T&gt;class Blob;	&#x2F;&#x2F;运算符&#x3D;&#x3D;中的参数所需要的</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">bool operator&#x3D;&#x3D;(const Blob&lt;T&gt;&amp;, const Blob&lt;T&gt;&amp;);</span><br><span class="line">template&lt;typename T&gt;class Blob &#123;</span><br><span class="line">	&#x2F;&#x2F;每个Blob实例将访问权限授予用相同类型实例化的BlobPtr和相等运算符</span><br><span class="line">	friend class BlobPtr&lt;T&gt;;</span><br><span class="line">	friend bool operator&#x3D;&#x3D;&lt;T&gt;(const Blob&lt;T&gt;&amp;, const Blob&lt;T&gt;&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>友元的声明用Blob的模板形参作为他们自己的模板实参。因此，友好关系被限定在用相同类型实例化的Blob与BlobPtr相等运算符之间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Blob&lt;char&gt;ca;	&#x2F;&#x2F;BlobPtr&lt;char&gt;和operator&#x3D;&#x3D;&lt;char&gt;都是本对象的友元</span><br><span class="line">Blob&lt;int&gt;ia;	&#x2F;&#x2F;BlobPtr&lt;int&gt;和operator&#x3D;&#x3D;&lt;int&gt;都是本对象的友元</span><br></pre></td></tr></table></figure>
<p>BlobPtr<char>的成员可以访问ca(或任何其他BlobPtr<char>对象)的非public部分，但ca对ia或Blob的任何其他实例都没有特殊访问权限</p>
<p>通用和特定的模板友好关系<br>一个类可以将另一个模板的每个实例都声明为自己的友元，或限定特定的实例为友元</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;class Pal;</span><br><span class="line">class C &#123;	&#x2F;&#x2F;C是一个普通非模板类</span><br><span class="line">	friend class Pal&lt;C&gt;;	&#x2F;&#x2F;用类C实例化的Pal是C的一个友元</span><br><span class="line">	&#x2F;&#x2F;Pal2的所实例都是C的友元</span><br><span class="line">	template&lt;typename T&gt;friend class Pal2;</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;typename T&gt; class C2 &#123;</span><br><span class="line">	&#x2F;&#x2F;C2的每个实例将相同实例化的Pal声明为友元</span><br><span class="line">	friend class Pal&lt;T&gt;;	&#x2F;&#x2F;Pal的模板声明必须在作用域之内</span><br><span class="line">	&#x2F;&#x2F;Pal2的所有实例都是iC2的每个实例的友元，不需要前置声明</span><br><span class="line">	template&lt;typename X&gt;friend class Pal2;</span><br><span class="line">	&#x2F;&#x2F;Pal3是一个非模板类，它是C2所有实例的友元</span><br><span class="line">	friend class Pal3;		&#x2F;&#x2F;不需要Pal3的前置声明</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为了让所有实例成为友元，友元声明中必须使用与类模板本身不同的模板参数</p>
<p>令模板自己的类型参数为友元</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;class Bar &#123;</span><br><span class="line">	friend Type;	&#x2F;&#x2F;将访问权限授予用来实例化Bar的类型</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于某个类型名Foo，Foo将成为Bar<Foo>的友元</p>
<p>模板类型别名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;using twin &#x3D; pair&lt;T, T&gt;;</span><br><span class="line">twin&lt;string&gt; authors;	&#x2F;&#x2F;authors是一个pair&lt;string,string&gt;</span><br><span class="line">也可以固定一个或多个模板参数</span><br><span class="line">template&lt;typename T&gt;using partNo &#x3D; pair&lt;T, unsigned&gt;;</span><br><span class="line">partNo&lt;string&gt;books;	&#x2F;&#x2F;books是一个pair&lt;string,unsigned&gt;</span><br><span class="line">partNo&lt;Vehicle&gt;cars;	&#x2F;&#x2F;cars是一个pair&lt;Vehicle,unsigned&gt;</span><br></pre></td></tr></table></figure>
<p>类模板的static成员</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;class Foo &#123;</span><br><span class="line">public:</span><br><span class="line">	static size_t count() &#123; return ctr; &#125;</span><br><span class="line">private:</span><br><span class="line">	static size_t ctr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对任意给定类型X，都有一个Foo<X>::ctr和一个Foo<X>::count成员<br>所有Foo<X>类型对象共享相同的ctr对象和count函数<br>将static数据成员也定义成模板</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt; size_t Foo&lt;T&gt;::ctr &#x3D; 0;	&#x2F;&#x2F;定义并初始化str</span><br></pre></td></tr></table></figure>
<p>一个static成员函数只有在使用时才会实例化</p>
<h3 id="模板参数"><a href="#模板参数" class="headerlink" title="模板参数"></a>模板参数</h3><p>一个模板参数名的可用范围是在其声明之后至模板声明或定义结束之前<br>模板参数会隐藏外层作用域中声明的相同名字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef double A;</span><br><span class="line">template&lt;typename A, typename B&gt;void f(A a, B b) &#123;</span><br><span class="line">	A tmp &#x3D; a;	&#x2F;&#x2F;tmp的类型为模板参数A的类型而非double</span><br><span class="line">	double B;	&#x2F;&#x2F;错误：重声明模板参数B</span><br><span class="line">&#125;</span><br><span class="line">template&lt;typename V,typename V&gt;&#x2F;&#x2F;错误：只能出现一次</span><br></pre></td></tr></table></figure>
<p>模板声明<br>模板声明必须包含模板参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;声明但不定义</span><br><span class="line">template&lt;typename T&gt;int compare(const T&amp;, const T&amp;);</span><br><span class="line">template&lt;typename T&gt;class Blob;</span><br><span class="line">声明中的模板参数的名字不必与定义中相同</span><br><span class="line">&#x2F;&#x2F;指向相同的函数模板</span><br><span class="line">template&lt;typename T&gt;T calc(const T&amp;, constT&amp;);</span><br><span class="line">template&lt;typename U&gt;U calc(const U&amp;, constU&amp;);</span><br></pre></td></tr></table></figure>
<p>使用类的类型成员<br>假定T是一个类型参数的名字，编译器遇到T::size_t*p时，需要知道是定义还是相乘<br>默认情况下，c++假定通过作用域运算符访问的名字不是类型。因此希望使用一个模板类型参数的类型成员，<br>必须显式地告诉编译器该名字是一个类型。 通过关键字typename</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">typename T::value_type top(const T&amp; c) &#123;</span><br><span class="line">	if (!c.empty())return c.back();</span><br><span class="line">	else return typename T::value_type();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认模板实参<br>compare有一个默认模板实参less<T>和一个默认函数实参F()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T,typename F&#x3D;less&lt;T&gt;&gt;</span><br><span class="line">int compare(const T&amp; v1, const T&amp; v2, F f &#x3D; F()) &#123;</span><br><span class="line">	if (f(v1, v2))return -1;</span><br><span class="line">	if (f(v2, v1))return 1;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认模板实参指出compare将使用标准库中的less函数对象类，它是使用与compare一样的类型参数实例化的<br>默认函数实参指出f将是类型F的一个默认初始化对象<br>调用compare时，可以提供自己的比较操作，但不是必须的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bool i &#x3D; compare(0, 42);</span><br><span class="line">&#x2F;&#x2F;结果依赖于item1和item2中的isbn</span><br><span class="line">Sales_data item1(cin), item2(cin);</span><br><span class="line">bool j &#x3D; compare(item1, item2, compareIsbn);</span><br></pre></td></tr></table></figure>
<p>对于一个模板参数，只有当它右侧的所有参数都有默认实参时，它才可以有默认实参</p>
<p>模板默认实参与类模板<br>一个类模板为其所有模板参数都提供了默认实参，而且我们希望使用这些默认实参，就必须在模板名之后跟一个空尖括号对</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T &#x3D; int&gt;class Numbers &#123;</span><br><span class="line">public:</span><br><span class="line">	Numbers(T v &#x3D; 0) :val(v) &#123;&#125;</span><br><span class="line">private:</span><br><span class="line">	T val;</span><br><span class="line">&#125;;</span><br><span class="line">Numbers&lt;long long&gt;lots_of_precision;</span><br><span class="line">Numbers&lt;&gt;avertage_precision;	&#x2F;&#x2F;空&lt;&gt;表示使用默认类型</span><br></pre></td></tr></table></figure>
<h3 id="成员模板-member-template"><a href="#成员模板-member-template" class="headerlink" title="成员模板(member template)"></a>成员模板(member template)</h3><p>一个类可以包含本身是模板的成员函数，被称为成员模板。成员模板不能是虚函数</p>
<p>普通类的成员模板</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class DebugDelete &#123;</span><br><span class="line">public:</span><br><span class="line">	DebugDelete(ostream&amp; s &#x3D; cerr) :os(s) &#123;&#125;</span><br><span class="line">	template&lt;typename T&gt;void operator()(T* p)const &#123;</span><br><span class="line">		os &lt;&lt; &quot;deleting unique_ptr&quot; &lt;&lt; endl;</span><br><span class="line">		delete p;</span><br><span class="line">	&#125;</span><br><span class="line">private:ostream&amp; os;</span><br><span class="line">&#125;;</span><br><span class="line">double* p &#x3D; new double;</span><br><span class="line">DebugDelete d;	&#x2F;&#x2F;可像delete表达式一样使用对象</span><br><span class="line">d(p);			&#x2F;&#x2F;调用DebugDelete::operator()(double*),释放p</span><br><span class="line">int* ip &#x3D; new int;</span><br><span class="line">&#x2F;&#x2F;在一个临时DebugDelete对象上调用operator()(int*)</span><br><span class="line">DebugDelete()(ip);</span><br><span class="line">调用一个DebugDelete对象会delete其指针，可以将其用作unique_ptr的删除器</span><br><span class="line">为了重载unique_ptr的删除器，在尖括号内给出</span><br><span class="line">&#x2F;&#x2F;销毁p指向的对象</span><br><span class="line">&#x2F;&#x2F;实例化DebugDelete::operator()&lt;int*&gt;(int*)</span><br><span class="line">unique_ptr&lt;int, DebugDelete&gt;p(new int, DebugDelete());</span><br><span class="line">&#x2F;&#x2F;销毁sp指向的对象</span><br><span class="line">&#x2F;&#x2F;实例化DebugDelete::operator()&lt;string&gt;(string*)</span><br><span class="line">unique_ptr&lt;string, DebugDelete&gt;sp(new string, DebugDelete());</span><br><span class="line">unique_ptr的析构函数会调用DebugDelete的调用运算符。unique_ptr的析构函数实例化时，DebugDelete的调用运算符会实例化</span><br><span class="line">void DebugDelete::operator()(int* p)const &#123; delete p; &#125;</span><br><span class="line">void DebugDelete::operator()(string* p)const &#123; delete p; &#125;</span><br></pre></td></tr></table></figure>
<p>类模板的成员模板<br>类和成员各有自己的、独立的模板参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;class Blob &#123;</span><br><span class="line">	template&lt;typename It&gt;Blob(It b, It e);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在类模板外定义时</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;	&#x2F;&#x2F;类的类型参数</span><br><span class="line">template&lt;typename It&gt;	&#x2F;&#x2F;构造函数的类型参数</span><br><span class="line">Blob&lt;T&gt;::Blob(It b, It e) :data(make_shared&lt;vector&lt;T&gt;&gt;(b, e)) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>实例化与成员模板<br>实例化一个类模板的成员模板，必须同时提供类和函数模板的实参</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int ia[] &#x3D; &#123; 1,2,3,4,5 &#125;;</span><br><span class="line">vector&lt;int&gt;vi &#x3D; &#123; 1,2,3,4,5 &#125;;</span><br><span class="line">list&lt;const char*&gt;w &#x3D; &#123; &quot;now&quot;,&quot;is&quot;,&quot;the&quot;,&quot;time&quot; &#125;;</span><br><span class="line">&#x2F;&#x2F;实例化Blob&lt;int&gt;类及接受两个int*参数的构造函数</span><br><span class="line">Blob&lt;int&gt;a1(begin(ia), end(ia));</span><br><span class="line">&#x2F;&#x2F;实例化Blob&lt;int&gt;类的接受两个vector&lt;long&gt;::iterator的构造参数</span><br><span class="line">Blob&lt;int&gt;a2(vi.begin(), vi.end());</span><br><span class="line">Blob&lt;string&gt;a3(w.begin(), w.end());</span><br><span class="line">a1实例化了Blob&lt;int&gt;::Blob(int*, int*);</span><br><span class="line">a2使用了已经实例化的Blob&lt;int&gt;类，并用vector&lt;short&gt;::iterator替换It来实例化构造函数</span><br><span class="line">a3的定义(显式地)实例化了一个string版本的Blob，并(隐式地)实例化了该类成员模板构造函数，其模板参数绑定到list&lt;const char*&gt;</span><br></pre></td></tr></table></figure>
<h3 id="控制实例化"><a href="#控制实例化" class="headerlink" title="控制实例化"></a>控制实例化</h3><p>模板被使用才会实例化，所以相同的实例可能出现在多个对象文件中<br>可以通过显式实例化(explicit instantiation)来避免这种开销</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extern template declaration;	&#x2F;&#x2F;实例化声明</span><br><span class="line">template declaratino;			&#x2F;&#x2F;实例化定义</span><br><span class="line">declaration中所有模板参数已被替换为模板实参</span><br><span class="line">extern template class Blob&lt;string&gt;;				&#x2F;&#x2F;声明</span><br><span class="line">template int compare(const int&amp;, const int&amp;);	&#x2F;&#x2F;定义</span><br></pre></td></tr></table></figure>
<p>编译器遇到extern时，不会在本文件中生成实例化代码。extern表示承诺在程序其他位置有该实例化的一个非extern声明<br>extern声明必须出现在任何使用此实例化版本的代码之前</p>
<p>实例化定义会实例化该模板的所有成员</p>
<h3 id="效率与灵活性"><a href="#效率与灵活性" class="headerlink" title="效率与灵活性"></a>效率与灵活性</h3><p>shared_ptr共享指针所有权；unique_ptr独占指针<br>重载shared_ptr删除器只需要创建或rest指针时传递给它一个可调用对象即可；<br>删除器的类型是unique_ptr对象的一部分，必须在定义unique_ptr时以显式模板实参形式提供删除器的类型</p>
<p>在运行时绑定删除器<br>shared_ptr删除器的类型知道运行时才会知道。假定shared_ptr将它管理的指针保存在成员p中，删除器是通过del成员来访问的<br>则析构函数必须包含：del ? del(p) : delete p; 调用del(p)需要一次运行时的跳转操作，转到del中保存的地址来执行对应代码</p>
<p>unique_ptr在编译时绑定删除器</p>
<h2 id="模板实参推断"><a href="#模板实参推断" class="headerlink" title="模板实参推断"></a>模板实参推断</h2><p>从函数实参来确定模板实参的过程被称为模板实参推断(template argument deduction)</p>
<h3 id="类型转换与模板类型参数"><a href="#类型转换与模板类型参数" class="headerlink" title="类型转换与模板类型参数"></a>类型转换与模板类型参数</h3><p>类型转换中，能在调用中应用于模板函数的：<br>·const转换：将一个非const对象的引用或指针传递给一个const的引用或指针形参<br>·数组或函数指针转换：如果函数形参不是引用类型，可以对数组或函数类型的实参应用正常的指针转换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;T fobj(T, T);	&#x2F;&#x2F;实参被拷贝</span><br><span class="line">template&lt;typename T&gt;T fref(const T&amp;, const T&amp;);	&#x2F;&#x2F;引用</span><br><span class="line">string s1(&quot;a value&quot;);</span><br><span class="line">const string s2(&quot;another value&quot;);</span><br><span class="line">fobj(s1, s2);	&#x2F;&#x2F;调用fobj(string,string) const被忽略</span><br><span class="line">fref(s1, s2);	&#x2F;&#x2F;调用fref(const string&amp;,const string&amp;) 将s1转换为const是允许的</span><br><span class="line">int a[10],b[42];</span><br><span class="line">fobj(a, b);	&#x2F;&#x2F;调用fobj(int*,int*)</span><br><span class="line">fref(a, b);	&#x2F;&#x2F;错误：数组类型不匹配</span><br></pre></td></tr></table></figure>
<p>如果形参是一个引用，则数组不会转换为指针</p>
<p>使用相同模板参数类型的函数形参</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">long lng;</span><br><span class="line">compare(lng, 1024);	&#x2F;&#x2F;错误：不能实例化compare(long,int)</span><br></pre></td></tr></table></figure>
<p>传递给compare的实参类型不同</p>
<p>正常类型转换应用于普通函数实参</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt; ostream&amp; print(ostream&amp; os, const T&amp; obj) &#123;</span><br><span class="line">	return os &lt;&lt; obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>os的类型是固定的，调用print时，传递给它的实参会进行正常的类型转换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(cout, 42);	&#x2F;&#x2F;实例化print(ostream&amp;,int)</span><br><span class="line">ofstream f(&quot;output&quot;);</span><br><span class="line">print(f, 10);		&#x2F;&#x2F;使用print(ostream&amp;,int) 将f转换为ostream&amp;</span><br></pre></td></tr></table></figure>
<p>第二个中，第一个参数的类型不依赖于模板参数，因此编译器会将f隐式转换为ostream&amp;</p>
<h3 id="函数模板显式实参"><a href="#函数模板显式实参" class="headerlink" title="函数模板显式实参"></a>函数模板显式实参</h3><p>指定显式模板实参(explicit template argument)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T1, typename T2, typename T3&gt;T1 sum(T2, T3);</span><br></pre></td></tr></table></figure>
<p>每次调用必须为T1提供一个显示模板实参</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto val3 &#x3D; sum&lt;long long&gt;(i, lng);	&#x2F;&#x2F;long long sum(int,long)</span><br></pre></td></tr></table></figure>
<p>显式模板实参按照由左至右的顺序与对应的模板参数匹配<br>只有尾部(最右)参数的显示模板实参才可以忽略</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T1,typename T2,typename T3&gt;</span><br><span class="line">T3 alternative_sum(T2, T1);</span><br></pre></td></tr></table></figure>
<p>用户必须制定所有三个模板参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;错误：不能推断前几个模板参数</span><br><span class="line">auto val3 &#x3D; alternative_sum&lt;long long&gt;(i, lng);</span><br><span class="line">&#x2F;&#x2F;正确：显式指定了所有三个参数</span><br><span class="line">auto val2 &#x3D; alternativa_sum&lt;long long, int, long&gt;(i, lng);</span><br></pre></td></tr></table></figure>
<p>正常类型转换应用于显式指定的实参</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">long lng;</span><br><span class="line">compare(lng, 1024);		&#x2F;&#x2F;错误：模板参数不匹配</span><br><span class="line">compare&lt;long&gt;(lng, 1024);	&#x2F;&#x2F;正确：实例化compare(long,long)</span><br><span class="line">compare&lt;int&gt;(lng, 1024);	&#x2F;&#x2F;正确：实例化compare(int,int)</span><br></pre></td></tr></table></figure>
<h3 id="尾置返回类型与类型转换"><a href="#尾置返回类型与类型转换" class="headerlink" title="尾置返回类型与类型转换"></a>尾置返回类型与类型转换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename It&gt; ? ? ? &amp;fcn(It beg, It end) &#123;</span><br><span class="line">	&#x2F;&#x2F;...</span><br><span class="line">	return *beg;	&#x2F;&#x2F;返回序列中一个元素的引用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并不知道返回结果的准确类型，但知道所需类型是所处理的序列的元素类型<br>使用尾置返回类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename It&gt;</span><br><span class="line">auto fcn(It beg, It end)-&gt;decltype(*beg) &#123;</span><br><span class="line">	&#x2F;&#x2F;...</span><br><span class="line">	return *beg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通知编译器fcn的返回类型与解引用beg参数的结果类型相同。解引用运算符返回一个左值，<br>因此通过decltype推断的类型为beg表示的元素的类型的引用</p>
<p>进行类型转换的标准库模板类<br>标准库的类型转换(type transformation)定义在头文件type_traits中<br>————————————————————————606</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename It&gt;</span><br><span class="line">auto fcn2(It beg, It end)-&gt;typename remove_reference&lt;decltype(*beg)&gt;::type &#123;</span><br><span class="line">	&#x2F;&#x2F;...</span><br><span class="line">	return *beg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回beg引用的元素的类型</p>
<h3 id="函数指针和实参推断"><a href="#函数指针和实参推断" class="headerlink" title="函数指针和实参推断"></a>函数指针和实参推断</h3><p>用函数模板初始化一个函数指针或为一个函数指针赋值时，编译器使用指针的类型来推断模板实参</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;int compare(const T&amp;, const T&amp;);</span><br><span class="line">int (*pf1)(const int&amp;, const int&amp;) &#x3D; compare;</span><br><span class="line">pf1指向实例int compare(const int&amp;, const int&amp;)</span><br><span class="line">pf1中的参数类型决定了T的模板参数类型</span><br><span class="line">&#x2F;&#x2F;func的重载版本，每个版本接受一个不同的函数指针类型</span><br><span class="line">void func(int(*)(const string&amp;, const string&amp;));</span><br><span class="line">void func(int(*)(const int&amp;, const int&amp;));</span><br><span class="line">func(compare)	&#x2F;&#x2F;错误</span><br><span class="line">通过func的参数类型无法确定模板实参的唯一类型</span><br><span class="line">&#x2F;&#x2F;正确：显式指出实例化哪个compare版本</span><br><span class="line">func(compare&lt;int&gt;);	&#x2F;&#x2F;传递compare(const int&amp;,const int&amp;)</span><br></pre></td></tr></table></figure>
<h3 id="模板实参推断和引用"><a href="#模板实参推断和引用" class="headerlink" title="模板实参推断和引用"></a>模板实参推断和引用</h3><p>template<typename T>void f(T&amp; p);<br>编译器会应用正常的引用绑定规则；const是底层的，不是顶层的</p>
<p>从左值引用函数参数推断类型<br>函数参数是模板类型参数的一个普通引用时(T&amp;)，只能传给它一个左值(变量或返回引用类型的表达式)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;void f1(T&amp;);	&#x2F;&#x2F;实参必须是一个左值</span><br><span class="line">f1(i);	&#x2F;&#x2F;i是一个int，模板参数类型T是int</span><br><span class="line">f1(ci);	&#x2F;&#x2F;ci是一个const int，T是const int</span><br><span class="line">f1(5);	&#x2F;&#x2F;错误：传递给一个&amp;参数的实参必须是左值</span><br></pre></td></tr></table></figure>
<p>如果函数参数类型是const T&amp; ，可以给它传递一个对象(const或非const)、一个临时对象或是字面常量值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;void f2(const T&amp;);	&#x2F;&#x2F;可以接受一个右值</span><br><span class="line">f2(i);	&#x2F;&#x2F;i是int，T是int</span><br><span class="line">f2(ci);	&#x2F;&#x2F;ci是const int，T是int</span><br><span class="line">f2(5);	&#x2F;&#x2F;T是int</span><br></pre></td></tr></table></figure>
<p>从右值引用函数参数推断参数类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;void f3(T&amp;&amp;);</span><br><span class="line">f3(42);	&#x2F;&#x2F;实参是一个int类型的右值，T是int</span><br></pre></td></tr></table></figure>
<p>引用折叠和右值引用<br>可以允许f3(i)，即将一个右值引用绑定到一个左值i上。只有2种情况<br>·将左值i传递给函数的右值引用参数，且此右值引用指向模板类型参数(T&amp;&amp;)时，编译器推断T的类型为int&amp; ，而非int<br>通常不能直接定义一个引用的引用，但通过类型别名或通过模板类型参数间接定义是可以的<br>·间接创建一个引用的引用，这些引用形成了折叠。除右值引用的右值引用外，引用会折叠成一个普通的左值引用<br>X&amp;&amp;, X&amp;&amp;&amp;, X&amp;&amp;&amp; 都折叠成X&amp; ；X&amp;&amp;&amp;&amp; 折叠成X&amp;&amp;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f3(i);	&#x2F;&#x2F;实参是一个左值，T是int&amp;</span><br><span class="line">f3(ci);	&#x2F;&#x2F;实参是一个左值，T是const int&amp;</span><br></pre></td></tr></table></figure>
<p>·如果一个函数参数是一个指向模板类型参数的右值引用(T&amp;&amp;)，则它可以被绑定到一个左值，且<br>·如果实参是一个左值，则推断出的模板实参类型是一个左值引用，且函数参数将被实例化为一个左值引用参数(T&amp;)</p>
<p>编写接受右值引用参数的模板函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;void f3(T&amp;&amp; val) &#123;</span><br><span class="line">	T t &#x3D; val;	&#x2F;&#x2F;拷贝还是绑定一个引用？</span><br><span class="line">	t &#x3D; fcn(t);	&#x2F;&#x2F;赋值是只改变t还是也改变val？</span><br><span class="line">	if(val&#x3D;&#x3D;t)&#123;&#x2F;*........*&#x2F; &#125;	&#x2F;&#x2F;若T是引用类型则一直为true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="理解std-move"><a href="#理解std-move" class="headerlink" title="理解std::move"></a>理解std::move</h3><p>定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">typename remove_reference&lt;T&gt;::type&amp;&amp; move(type&amp;&amp; t) &#123;</span><br><span class="line">	return static_cast&lt;typename remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br><span class="line">string s1(&quot;hi&quot;), s2;</span><br><span class="line">s2 &#x3D; move(string(&quot;bye&quot;));	&#x2F;&#x2F;正确：从一个右值移动数据</span><br><span class="line">s2 &#x3D; move(s1);				&#x2F;&#x2F;正确：但赋值后s1的值是不确定的</span><br></pre></td></tr></table></figure>
<p>第一个中传递给s2的实参是string构造函数的右值结果，因此在move(string(“bye”))中<br>T的类型为string；remove_reference用string实例化；remove_reference<string>的type成员是string<br>move的返回类型是string&amp;&amp; ；move的函数参数t类型为string&amp;&amp;<br>因此string&amp;&amp; move(string&amp;&amp; t)<br>函数体返回castic_cast&lt;string&amp;&amp;&gt;(t)，t的类型是string&amp;&amp; ，于是转换什么也不做<br>第二个中传递给move的实参是一个左值<br>推断出T类型是string&amp; ；remove_reference用string&amp; 实例化；<br>remove_reference&lt;string&amp;&gt;的type成员是string；move返回类型仍是string&amp;&amp; ；<br>move的函数参数t实例化为string&amp;&amp;&amp; ，折叠为string&amp;<br>因此string&amp;&amp; move(string&amp; t)<br>即将右值引用绑定到左值</p>
<p>从一个左值static_cast到一个右值引用是允许的<br>虽然不能隐式地将一个左值转换为右值引用，但可以用static_cast显式地将左值转换为右值引用</p>
<h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T,typename T1,typename T2&gt;</span><br><span class="line">void flip1(F f, T1 t1, T2 t2)&#123;</span><br><span class="line">	f(t2, t1);</span><br><span class="line">&#125;</span><br><span class="line">void f(int v1, int&amp; v2) &#123;</span><br><span class="line">	cout &lt;&lt; v1 &lt;&lt; &quot; &quot; &lt;&lt; ++v2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">f(42, i);			&#x2F;&#x2F;f改变了实参i</span><br><span class="line">flip1(f, j, 42);	&#x2F;&#x2F;通过flip1调用f不会改变j</span><br></pre></td></tr></table></figure>
<p>j被传递给flip1的参数t1，此参数是个普通的、非引用的类型int，而非int&amp; ，flip1实例化为<br>void flip1(void(*fcn)(int, int&amp;), int t1, int t2);<br>j的值被拷贝到t1中，f中的引用参数绑定到t1，而非j</p>
<p>定义能保持类型信息的函数参数<br>通过将函数参数定义为一直指向模板类型的右值引用，可以保持其实参类型信息；使用引用可以保持const属性<br>因为在引用类型中const是底层的，右值引用通过折叠可以保持实参的左右值属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename F,typename T1,typename T2&gt;</span><br><span class="line">void flip2(F f, T1&amp;&amp; t1, T2&amp;&amp; t2) &#123;</span><br><span class="line">	f(t2, t1);</span><br><span class="line">&#125;</span><br><span class="line">但不能用于接受右值引用参数的函数</span><br><span class="line">void g(int&amp;&amp; i, int&amp; j) &#123; cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl; &#125;</span><br><span class="line">通过flip2调用g，则t2将被传递给g的右值引用参数</span><br><span class="line">flip2(g, i, 42);	&#x2F;&#x2F;错误：不能从一个左值实例化int&amp;&amp;</span><br></pre></td></tr></table></figure>
<p>使用std::forward保持类型信息<br>forward定义在头文件utility中，必须通过显式模板实参来调用，返回该实参类型的右值引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename Type&gt;intermediary(Type&amp;&amp; arg) &#123;</span><br><span class="line">	finalFcn(forward&lt;Type&gt;(arg));</span><br><span class="line">&#125;</span><br><span class="line">当用于一个模板参数类型的右值引用函数参数(T&amp;&amp;)时，forward会保持实参类型的所有细节</span><br><span class="line">template&lt;typename F,typename T1,typename T2&gt;</span><br><span class="line">void flip(F f, T1 t1, T2 t2) &#123;</span><br><span class="line">	f(forward&lt;T2&gt;(t2), forward&lt;T1&gt;(t1));</span><br><span class="line">&#125;</span><br><span class="line">调用flip(g,i,42),i将以int&amp;类型传递给g，42将以int&amp;&amp;类型传递给g</span><br></pre></td></tr></table></figure>
<h2 id="重载与模板"><a href="#重载与模板" class="headerlink" title="重载与模板"></a>重载与模板</h2><p>函数模板可以被另一个模板或普通非模板函数重载<br>匹配规则：<br>·对于一个调用，其候选函数包括所有模板实参推断成功的函数模板实例<br>·候选的函数模板总是可行的，因为模板实参推断会排除任何不可行的模板<br>·可行函数(模板与非模板)按类型转换(如果需要)来排序<br>·如果恰有一个函数提供比其他任何函数都更好的匹配，则选择此函数。但是，<br>如果有多个函数提供同样好的匹配，则：<br>– 如果同样好的函数中只有一个是非模板函数，则选择此函数<br>– 如果没有非模板函数，而有多个模板，且其中一个模板比其他的更特例话，则选此<br>– 否则调用有歧义</p>
<p>编写重载模板</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;string debug_rep(const T&amp; t) &#123;</span><br><span class="line">	ostringstream ret;</span><br><span class="line">	ret &lt;&lt; t;	&#x2F;&#x2F;使用T的输出运算符打印t的一个表示形式</span><br><span class="line">	return ret.str();	&#x2F;&#x2F;返回ret绑定的string的一个副本</span><br><span class="line">&#125;</span><br><span class="line">此函数生成一个对象对应的string表示，该对象可以是任意具备输出运算符的类型</span><br><span class="line">打印指针的版本</span><br><span class="line">&#x2F;&#x2F;打印指针的值，后跟指针指向的对象</span><br><span class="line">template&lt;typename T&gt;string debug_rep(T* p) &#123;</span><br><span class="line">	ostringstream ret;</span><br><span class="line">	ret &lt;&lt; &quot;pointer: &quot; &lt;&lt; p;	&#x2F;&#x2F;打印指针本身的值</span><br><span class="line">	if (p)ret &lt;&lt; &quot; &quot; &lt;&lt; debug_rep(*p);&#x2F;&#x2F;打印p指向的值</span><br><span class="line">	else ret &lt;&lt; &quot; null pointer&quot;;	&#x2F;&#x2F;或指出p为空</span><br><span class="line">	return ret.str();		&#x2F;&#x2F;返回ret绑定的string的一个副本</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成一个string，包含指针本身的值和调用debug_rep获得的指针指向的值<br>不能打印字符指针，因为IO库为char* 定义了一个 &lt;&lt; 版本，假定指针表示一个空字符结尾的字符数组，<br>打印数组的内容而非地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s(&quot;hi&quot;);</span><br><span class="line">cout &lt;&lt; debug_rep(s) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>只有第一个版本的debug_rep是可行的。第二个要求一个指针参数，但传递了非指针对象。<br>编译器无法从一个非指针参数实例化一个期望指针类型参数的函数模板，实参推断失败</p>
<p>若cout &lt;&lt; debug_rep(&amp;s) &lt;&lt; endl; 则两个函数都生成可行的实例<br>·debug_rep(const string<em>&amp;), T被绑定到string</em><br>·debug_rep(string*), T被绑定到string<br>第二个是精确匹配，第一个需要普通指针到const指针的转换</p>
<p>多个可行模板<br>const string* sp = &s;<br>cout &lt;&lt; debug_rep(sp) &lt;&lt; endl;<br>两个都可行，都是精确匹配<br>·debug_rep(const string<em>&amp;),T被绑定到string</em><br>·debug_rep(const string<em>),T被绑定到string<br>第二个是更特例化的版本，被解析为debug_rep(T</em>)</p>
<p>模板重载和类型转换</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/30/c-primer-16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/" data-id="ckhua8ro40011xsve633c7fm2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-primer/" rel="tag">c++ primer</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-c-primer-15-面向对象程序设计" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/30/c-primer-15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" class="article-date">
  <time datetime="2020-08-30T02:55:38.000Z" itemprop="datePublished">2020-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/30/c-primer-15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">c++ primer 15 面向对象程序设计</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h1><h2 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h2><p>面向对象程序设计(object-oriented programming)的核心思想是数据抽象、继承和动态绑定<br>数据抽象：将类的接口与实现分离<br>继承：可以定义相似的类型并对其相似关系建模<br>动态绑定：可以在一定程度上忽略相似类型的区别，以统一的方式使用它们的对象</p>
<p>继承<br>层次关系的根部有一个基类(base class)，其他为派生类(derived class)。<br>基类负责定义所有类共有的成员，派生类定义各自特有的成员<br>对于某些函数，基类希望它的派生类个自定义合适自身的版本，则将其声明成虚函数(virtuan function)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Quote &#123;</span><br><span class="line">public:</span><br><span class="line">	string isbn() const;</span><br><span class="line">	virtual double net_price(size_t n)const;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>派生类必须通过类派生列表(class derivation list)明确指出是从哪基类继承而来的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Bulk_quote :public Quote &#123;</span><br><span class="line">public:</span><br><span class="line">	double net_price(size_t)const override;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>派生类必须在其内部对所有重新定义的虚函数进行声明</p>
<p>动态绑定<br>通过动态绑定可以用同一段代码分别处理Quote和Bulk_quote的对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">double print_total(ostream&amp; os, const Quote&amp; item, size_t n) &#123;</span><br><span class="line">	&#x2F;&#x2F;根据传入item形参的对象类型调用Quote::net_price或者Bulk_quote::net_price</span><br><span class="line">	double ret &#x3D; item.net_price(n);</span><br><span class="line">	os &lt;&lt; item.isbn() &lt;&lt; &quot; &quot; &lt;&lt; n &lt;&lt; &quot; &quot; &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据实际传入print_total的对象类型决定执行net_price的哪个版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print_total(cout, basic, 20);	&#x2F;&#x2F;调用Quote的net_price</span><br><span class="line">print_total(cout, bulk, 20);	&#x2F;&#x2F;调用Bulk_quote的net_price</span><br></pre></td></tr></table></figure>
<p>当我们使用基类的引用(或指针)调用一个虚函数时将发生动态绑定</p>
<h2 id="定义基类和派生类"><a href="#定义基类和派生类" class="headerlink" title="定义基类和派生类"></a>定义基类和派生类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Quote &#123;</span><br><span class="line">public:</span><br><span class="line">	Quote() &#x3D; default;</span><br><span class="line">	Quote(const string&amp; book, double sales_price) :bookNo(book), price(sales_price) &#123;&#125;</span><br><span class="line">	string isbn()const &#123; return bookNo; &#125;</span><br><span class="line">	&#x2F;&#x2F;返回给定数量书籍的总销售额  派生类负责改写并使用不同的折扣计算法</span><br><span class="line">	virtual double net_price(size_t n)const &#123; return n * price; &#125;</span><br><span class="line">	virtual ~Quote() &#x3D; default;	&#x2F;&#x2F;对析构函数进行动态绑定</span><br><span class="line">private:</span><br><span class="line">	string bookNo;	&#x2F;&#x2F;书籍的isbn编号</span><br><span class="line">protected:</span><br><span class="line">	double price &#x3D; 0.0;	&#x2F;&#x2F;代表普通状态下不打折的价格</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>成员函数与继承<br>基类将希望其派生类进行覆盖的函数定义为虚函数。当使用指针或引用调用虚函数时，该调用将被动态绑定。<br>根据所绑定对象的版本来调用对应执行的版本<br>构造函数之外的非静态函数都可以是虚函数。关键字virtual只能出现在类内部的声明语句之前不能用于外部定义</p>
<h3 id="定义派生类"><a href="#定义派生类" class="headerlink" title="定义派生类"></a>定义派生类</h3><p>派生类必须将其继承而来的成员函数中需要覆盖的那些重新声明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Bulk_quote :public Quote &#123;</span><br><span class="line">public;</span><br><span class="line">	Bulk_quote() &#x3D; default;</span><br><span class="line">	Bulk_quote(const string&amp;, double, size_t, double);</span><br><span class="line">	&#x2F;&#x2F;覆盖基类的函数版本以实现基于大量购买的折扣政策</span><br><span class="line">	double net_price(size_t)const override;</span><br><span class="line">private:</span><br><span class="line">	size_t min_qty &#x3D; 0;		&#x2F;&#x2F;使用折扣政策的最低购买量</span><br><span class="line">	double discount &#x3D; 0.0;	&#x2F;&#x2F;以小数表示折扣额</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他普通成员，派生类会直接继承其在基类中的版本</p>
<p>派生类对象及派生类向基类的类型转换<br>一个派生类的对象包含：含有派生类自己定义的(非静态)成员的子对象及与该派生类继承的基类对应的子对象<br>可以把派生类的对象当成基类对象来使用，也可以把基类的指针或引用绑定到派生类对象中的基类部分上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Quote item;			&#x2F;&#x2F;基类对象</span><br><span class="line">Bulk_quote bulk;	&#x2F;&#x2F;派生类对象</span><br><span class="line">Quote* p &#x3D; &amp;item;	&#x2F;&#x2F;p指向Quote对象</span><br><span class="line">p &#x3D; &amp;bulk;			&#x2F;&#x2F;p指向bulk的Quote部分</span><br><span class="line">Quote&amp; r &#x3D; bulk;	&#x2F;&#x2F;r绑定到bulk的Quote部分</span><br></pre></td></tr></table></figure>
<p>Bulk_quote的构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bulk_quote(const string&amp; book, double p, size_t qty, double disc) :Quote(book, p), min_qty(qty), discount(disc) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>该函数将它前两个参数传递给Quote的构造函数，由Quote的构造函数负责初始化Bulk_quote的基类部分<br>接下来由派生类直接定义其它的成员，最后运行Bulk_quote构造函数的函数体</p>
<p>派生类可以访问基类的公有成员和受保护成员</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">double Bulk_quote::net_price(size_t cnt)const &#123;</span><br><span class="line">	if (cnt &gt;&#x3D; min_qty)</span><br><span class="line">		return cnt * (1 - discount) * price;</span><br><span class="line">	else</span><br><span class="line">		return cnt * price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继承与静态成员<br>如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">public:</span><br><span class="line">	static void statmem();</span><br><span class="line">&#125;;</span><br><span class="line">class Derived :public Base &#123;</span><br><span class="line">	void f(const Derived&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>假设某静态成员是可以访问的，就既能通过基类使用它也能通过派生类使用它</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void Derived::f(const Derived&amp; derived_obj) &#123;</span><br><span class="line">	Base::statmem();		&#x2F;&#x2F;正确：Base定义了statmem</span><br><span class="line">	Derived::statmem();		&#x2F;&#x2F;正确：Derived继承了statmem</span><br><span class="line">	&#x2F;&#x2F;正确：派生类的对象能访问基类的静态成员</span><br><span class="line">	derived_obj.statmem();	&#x2F;&#x2F;通过Derived对象访问</span><br><span class="line">	statmem();				&#x2F;&#x2F;通过this对象访问</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>派生类声明中包含类名但不包含它的派生列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Bulk_quote :public Quote;	&#x2F;&#x2F;错误</span><br><span class="line">class Bulk_quote;				&#x2F;&#x2F;正确</span><br></pre></td></tr></table></figure>
<p>想将有个类用作基类，必须已经定义而非仅仅声明</p>
<p>防止基类发生<br>在类名后跟一个关键字final</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class NoDerived final &#123;&#125;;</span><br><span class="line">class Base &#123;&#125;;</span><br><span class="line">class Last final :Base &#123;&#125;;</span><br><span class="line">class Bad :NeDerived &#123;&#125;;	&#x2F;&#x2F;错误：NoDerived是final的</span><br><span class="line">class Bad2 :Last &#123;&#125;;		&#x2F;&#x2F;错误：Last是final的</span><br></pre></td></tr></table></figure>
<h3 id="类型转换与继承"><a href="#类型转换与继承" class="headerlink" title="类型转换与继承"></a>类型转换与继承</h3><p>可以将基类的指针或引用绑定到派生类对象上<br>当使用基类的引用或指针时，实际上我们并不清楚该引用或指针所绑定对象的真实类型<br>基类的指针或引用的静态类型可能与其动态类型不一致</p>
<p>不存在基类向派生类的隐式类型转换<br>一个基类的对象可能是派生类对象的一部分，也可能不是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Quote base;</span><br><span class="line">Bulk_quote* bulkP &#x3D; &amp;base;	&#x2F;&#x2F;错误</span><br><span class="line">Bulk_quote&amp; bulkR &#x3D; base;	&#x2F;&#x2F;错误</span><br></pre></td></tr></table></figure>
<p>如果上述是合法的，则可能用其访问base中不存在的成员<br>即使一个基类指针或引用绑定在派生类对象上，也不能执行从基类向派生类的转换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bulk_quote bulk;</span><br><span class="line">Quote* itemP &#x3D; &amp;bulk;		&#x2F;&#x2F;正确：动态类型是Bulk_quote</span><br><span class="line">Bulk_quote* bulkP &#x3D; itemP;	&#x2F;&#x2F;错误：不能将基类转换成派生类</span><br></pre></td></tr></table></figure>
<p>派生类向基类的自动类型转换至针对指针或引用类型有效<br>当用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，派生类部分将被忽略掉</p>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>使用基类的引用或指针调用一个虚成员函数时会执行动态绑定。虚函数都必须有定义</p>
<p>对虚函数的调用可能在运行时才被解析<br>被调用的函数是与绑定到指针或引用上的对象的动态类型匹配的那个</p>
<p>引用或指针的静态类型与动态类型不听这一事实是c++语言支持多态性的根本所在<br>使用基类的引用或指针调用基类中定义的一个函数时，并不知道该函数真正作用的对象是什么类型，可能是基类的对象也可能是派生类的对象<br>如果该函数是虚函数，知道运行时才会决定到底执行那个版本，判断的依据是引用或指针所绑定对象的真实类型<br>对非虚函数的调用在编译时进行绑定。通过对象进行的函数调用也在编译时绑定。对象的类型是确定不变的，不可能动态类型和静态类型不一致</p>
<p>当且仅当通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有这种情况下对象的动态类型才可能与静态类型不同</p>
<p>派生类中的虚函数<br>一旦某个函数被声明为虚函数，则在所有的派生类中都是虚函数<br>一个派生类的函数如果覆盖了某个继承来的虚函数，它的形参类型必须与被覆盖的基类函数完全一致<br>派生类中虚函数的返回类型也必须与基类函数匹配。有一例外：当类的虚函数返回类型是类本身的指针或引用时。不过要求派生类到基类的类型转换是可以访问的</p>
<p>可以使用override关键字来说明派生类中的虚函数<br>可以使程序员的意图更清晰，也可以让编译器为我们发现错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct B &#123;</span><br><span class="line">	virtual void f1(int)const;</span><br><span class="line">	virtual void f2();</span><br><span class="line">	void f3();</span><br><span class="line">&#125;;</span><br><span class="line">struct D1 :B &#123;</span><br><span class="line">	void f1(int)const override;	&#x2F;&#x2F;正确：f1与基类中f1匹配</span><br><span class="line">	void f2(int) override;		&#x2F;&#x2F;错误：B没有形如f2(int)的函数</span><br><span class="line">	void f3() override;			&#x2F;&#x2F;错误：f3不是虚函数</span><br><span class="line">	void f4() override;			&#x2F;&#x2F;错误：B没有f4</span><br><span class="line">&#125;;</span><br><span class="line">struct D2 :B &#123;</span><br><span class="line">	void f1(int)const final;	&#x2F;&#x2F;不允许后续的其他类覆盖f1(int)</span><br><span class="line">&#125;;</span><br><span class="line">struct D3 :D2 &#123;</span><br><span class="line">	void f2();			&#x2F;&#x2F;正确：覆盖从间接基类B继承而来的f2</span><br><span class="line">	void f1(int)const;	&#x2F;&#x2F;错误：D2已将f1(int)声明成final</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>虚函数与默认实参<br>如果某次函数调用使用了默认实参，则该实参值由本次调用的静态类型决定<br>如果通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即使实际中运行的是派生类中的版本也是如此<br>此时传入派生类函数的将是基类函数定义的默认实参，如果派生类函数依赖不同的实参，则结果将与我们的预期不符</p>
<p>回避虚函数的机制<br>希望对虚函数的调用不要进行动态绑定，强迫执行虚函数的某个特定版本，使用作用域运算符来实现<br>double undiscounted = baseP-&gt;Quote::net_price(42);<br>该调用将在编译时完成解析</p>
<h2 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h2><p>纯虚函数(pure virtual)，无须定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;用于保存折扣值和购买量的类，派生类使用这些数据可以实现不同的价格策略</span><br><span class="line">class Disc_quote :public Quote &#123;</span><br><span class="line">public:</span><br><span class="line">	Disc_quote() &#x3D; default;</span><br><span class="line">	Disc_quote(const string&amp; book, double price, size_t qty, double disc) :</span><br><span class="line">		Quote(book, price), quantity(qty), discount(disc) &#123;&#125;</span><br><span class="line">	double net_price(size_t)const &#x3D; 0;</span><br><span class="line">protected:</span><br><span class="line">	size_t quantity &#x3D; 0;	&#x2F;&#x2F;折扣适用的购买量</span><br><span class="line">	double discount &#x3D; 0.0;	&#x2F;&#x2F;表示折扣的小数值</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以为纯虚函数提供定义，不过函数体必须定义在类的外部</p>
<p>含有纯虚函数的类是抽象基类(abstract base class)<br>抽象基类负责定义接口，不能直接创建一个抽象基类的对象<br>派生类必须给出自己的net_price定义，否则他们仍是抽象基类</p>
<p>派生类构造函数只初始化它的直接基类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Bulk_quote :public Disc_quote &#123;</span><br><span class="line">public:</span><br><span class="line">	Bulk_quote() &#x3D; default;</span><br><span class="line">	Bulk_quote(const string&amp; book, double price, size_t qty, double disc) :</span><br><span class="line">		Disc_quote(book, price, qyt, disc) &#123;&#125;</span><br><span class="line">	&#x2F;&#x2F;覆盖基类中的函数版本以实现一种新的折扣策略</span><br><span class="line">	double net_price(size_t)const override;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>重构负责重新设计类的体系以便将操作和 / 或数据从一个类移动到另一个类中</p>
<h2 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h2><p>受保护的成员<br>一个类使用protected关键字来声明那些它希望与派生类分享但是不想被其它公共访问的成员<br>·受保护的成员对于类的用户来说是不可访问的<br>·受保护的成员也对于派生类的成员和友元来说是可访问的<br>·派生类的成员和或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问特权</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">protected:</span><br><span class="line">	int prot_mem;</span><br><span class="line">&#125;;</span><br><span class="line">class Sneaky :public Base &#123;</span><br><span class="line">	friend void clobber(Sneaky&amp;);	&#x2F;&#x2F;能访问Sneaky::prot_mem</span><br><span class="line">	friend void clobber(Base&amp;);		&#x2F;&#x2F;能访问Base::prot_mem</span><br><span class="line">	int j;							&#x2F;&#x2F;j默认是private</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;正确：clobber能访问Sneaky对象的private和protected成员</span><br><span class="line">void clobber(Sneaky&amp; s) &#123; s.j &#x3D; s.prot_mem &#x3D; 0; &#125;</span><br><span class="line">&#x2F;&#x2F;错误：clobber不能访问Base的protected成员</span><br><span class="line">void clovver(Base&amp; b) &#123; b.prot_mem &#x3D; 0; &#125;</span><br></pre></td></tr></table></figure>
<p>公有、私有和受保护继承</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">public:</span><br><span class="line">	void pub_mem();</span><br><span class="line">protected:</span><br><span class="line">	int prot_mem;</span><br><span class="line">private:</span><br><span class="line">	char priv_mem;</span><br><span class="line">&#125;;</span><br><span class="line">struct Pub_Derv :public Base &#123;</span><br><span class="line">	&#x2F;&#x2F;正确：派生类能访问protected成员</span><br><span class="line">	int f() &#123; return prot_mem; &#125;</span><br><span class="line">	&#x2F;&#x2F;错误：private成员对于派生类是不可访问的</span><br><span class="line">	char g() &#123; return priv_mem; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">struct Priv_Derv :private Base &#123;</span><br><span class="line">	&#x2F;&#x2F;private不影响派生类的访问权限</span><br><span class="line">	int f1() &#123; return prot_mem; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>派生类访问说明符对于派生类的成员(及友元)能否访问其直接基类的成员没什么影响，对于基类成员的访问权限只与基类中的访问说明符有关<br>派生访问说明符的目的是控制派生类用户(包括派生类的派生类)对于基类成员的访问权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Pub_Derv d1;	&#x2F;&#x2F;继承自Base的成员是public的</span><br><span class="line">Priv_Derv d2;	&#x2F;&#x2F;继承自Base的成员是private的</span><br><span class="line">d1.pub_mem();	&#x2F;&#x2F;正确：pub_mem在派生类中是public的</span><br><span class="line">d2.pub_mem();	&#x2F;&#x2F;错误：pub_mem在派生类中是private的</span><br></pre></td></tr></table></figure>
<p>派生访问说明符还可以控制继承自派生类的新类的访问权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct Derived_from_Public :public Pub_Derv &#123;</span><br><span class="line">	&#x2F;&#x2F;正确：Base::prot_mem在Pub_Derv中仍然是protected的</span><br><span class="line">	int use_base() &#123; return prot_mem; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">struct Derived_from_Prevate :public Priv_Derv &#123;</span><br><span class="line">	&#x2F;&#x2F;错误：Base::prot_mem在PrivDerv中是private的</span><br><span class="line">	int use_base() &#123; return prot_mem; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>派生类向基类转换的可访问性<br>·只有当D公有地继承B时，用户代码才能使用派生类向基类的转换<br>·无论什么方式继承，D的成员函数和友元都能使用派生类向基类的转换<br>·如果继承方式是公有或者受保护的，则D的派生类的成员和友元可以使用D向B的类型转换</p>
<p>友元与继承<br>友元关系不能继承。基类的友元访问派生类成员时不具有特殊性，派生类的友元也不能随意访问基类的成员</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">	friend class Pal;</span><br><span class="line">&#125;;</span><br><span class="line">class Pal &#123;</span><br><span class="line">public:</span><br><span class="line">	int f(Base b) &#123; return b.prot_mem; &#125;	&#x2F;&#x2F;正确：pal是Base的友元</span><br><span class="line">	int f2(Sneaky s) &#123; return s.j; &#125;		&#x2F;&#x2F;错误：Pal不是Sneaky的友元</span><br><span class="line">	&#x2F;&#x2F;对基类的访问权限由基类本身控制，即使对于派生类的基类部分也是如此</span><br><span class="line">	int f3(Sneaky s) &#123; return s.prot_mem; &#125;	&#x2F;&#x2F;正确：Pal是Base的友元</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当一个类将另一个类声明为友元时，这种友元关系只能对做出声明的类有效。对于原来那个类来说，其友元的基类或者派生类不具有特殊的访问能力</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class D2 :public Pal &#123;</span><br><span class="line">public:</span><br><span class="line">	int mem(Base b) &#123; return b.prot_mem; &#125;	&#x2F;&#x2F;错误：友元关系不能继承</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>改变个别成员的可访问性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">public:</span><br><span class="line">	size_t size()const &#123; return n; &#125;</span><br><span class="line">protected:</span><br><span class="line">	size_t n;</span><br><span class="line">&#125;;</span><br><span class="line">class Derived :private Base &#123;</span><br><span class="line">public:</span><br><span class="line">	using Base::size;</span><br><span class="line">protected:</span><br><span class="line">	using Base::n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>默认情况下，class关键字定义的派生类是私有继承；struct是公有继承<br>class和struct唯一的差别就是默认成员访问说明符和默认派生访问说明符</p>
<h2 id="继承中的作用域"><a href="#继承中的作用域" class="headerlink" title="继承中的作用域"></a>继承中的作用域</h2><p>派生类的做哟用于嵌套在其基类的作用域之内。如果一个名字在派生类的作用域内无法解析，则编译器将继续在外层的基类作用域中寻找该名字的定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bulk_quote bulk;</span><br><span class="line">cout &lt;&lt; bulk.isbn();</span><br><span class="line">isbn()先在Bulk_quote中查找，再在Disc_quote中找，最后在Quote中找</span><br></pre></td></tr></table></figure>
<p>一个对象、引用或指针的静态类型决定了该对象的哪些成员是可见的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Disc_quote :public Quote &#123;</span><br><span class="line">public:</span><br><span class="line">	pair&lt;size_t, double&gt;discount_policy()const &#123; return &#123; quantity,discount &#125;; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>只能通过Disc_quote及其派生类的对象、引用或指针使用discount_policy</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Bulk_quote bulk;</span><br><span class="line">Bulk_quote* bulkP &#x3D; &amp;bulk;	&#x2F;&#x2F;静态类型与动态类型一直</span><br><span class="line">Quote* itemP &#x3D; &amp;bulk;		&#x2F;&#x2F;静态类型与动态类型不一致</span><br><span class="line">bulkP-&gt;discount_policy();	&#x2F;&#x2F;正确：bulkP的类型是Bulk_quote*</span><br><span class="line">itemP-&gt;discount_policy();	&#x2F;&#x2F;错误：itemP的类型是Quote*</span><br></pre></td></tr></table></figure>
<p>名字冲突与继承</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct Base &#123;</span><br><span class="line">	Base() :mem(0) &#123;&#125;</span><br><span class="line">protected:</span><br><span class="line">	int mem;</span><br><span class="line">&#125;;</span><br><span class="line">struct Derived :Base &#123;</span><br><span class="line">	Derived(int i) :mem(i) &#123;&#125;		&#x2F;&#x2F;用i初始化Derived::mem， Base::mem进行默认初始化</span><br><span class="line">	int get_mem() &#123; return mem; &#125;	&#x2F;&#x2F;返回Derived::mem</span><br><span class="line">protected:</span><br><span class="line">	int mem;						&#x2F;&#x2F;隐藏基类中的mem</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过作用域运算符来使用隐藏的成员</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct Derived :Base &#123;</span><br><span class="line">	int get_base_mem() &#123; return Base::mem; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>函数调用的解析过程，调用p-&gt;mem()：<br>·先确定p的静态类型<br>·在p的静态类型对象的类中查找mem。找不到则在其基类中继续。扔找不到则编译器报错<br>·一旦找到mem则进行常规的类型检查，确认对于当前找到的mem，本次调用是否合法<br>·假设调用合法，编译器根据是否是虚函数而产生不同代码：<br>–是虚函数且通过引用或指针进行的调用，则编译器产生的代码将在运行时确定运行该虚函数的哪个版本，依据是对象动态类型<br>–反之则产生一个常规函数调用</p>
<p>如果派生类的成员与基类的某个成员同名，则派生类在其作用域内隐藏掉该基类成员，即使形参列表不一致</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct Base &#123;</span><br><span class="line">	int memfcn();</span><br><span class="line">&#125;;</span><br><span class="line">struct Derived :Base &#123;</span><br><span class="line">	int memfcn(int);</span><br><span class="line">&#125;;</span><br><span class="line">Derived d; Base b;</span><br><span class="line">b.memfcn();			&#x2F;&#x2F;调用Base::memfcn</span><br><span class="line">d.memfcn(10);		&#x2F;&#x2F;调用Derived::memfcn</span><br><span class="line">d.memfcn();			&#x2F;&#x2F;错误：参数列表为空的memfcn被隐藏了</span><br><span class="line">d.Base::memfcn();	&#x2F;&#x2F;正确：调用Base::memfcn</span><br></pre></td></tr></table></figure>
<p>虚函数与作用域<br>如果基类与派生类的虚函数接受的实参不同，则无法通过基类的引用或指针调用派生类的虚函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">public:</span><br><span class="line">	virtual int fcn();</span><br><span class="line">&#125;;</span><br><span class="line">class D1 :public Base &#123;</span><br><span class="line">public:</span><br><span class="line">	&#x2F;&#x2F;隐藏基类的fcn，这个fcn不是虚函数</span><br><span class="line">	int fcn(int);		&#x2F;&#x2F;形参列表与Base中的不一致</span><br><span class="line">	virtual void f2();	&#x2F;&#x2F;是一个新的虚函数，Base中不存在</span><br><span class="line">&#125;;</span><br><span class="line">class D2 :public D1 &#123;</span><br><span class="line">public:</span><br><span class="line">	int fcn(int);	&#x2F;&#x2F;一个非虚函数，隐藏了D1::fcn(int)</span><br><span class="line">	int fcn();		&#x2F;&#x2F;覆盖了Base中的虚函数fcn</span><br><span class="line">	void f2();		&#x2F;&#x2F;覆盖了D1中的虚函数f2</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过基类调用隐藏的虚函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Base bobj; D1 d1obj; D2 d2obj;</span><br><span class="line">Base* bp1 &#x3D; &amp;bobj, * bp2 &#x3D; &amp;d1obj, * bp3 &#x3D; &amp;d2obj;</span><br><span class="line">bp1-&gt;fcn();	&#x2F;&#x2F;虚调用，将在运行时调用Base::fcn</span><br><span class="line">bp2-&gt;fcn(); &#x2F;&#x2F;虚调用，将在运行时调用Base::fcn</span><br><span class="line">bp3-&gt;fcn();	&#x2F;&#x2F;&#x2F;虚调用，将在运行时调用D2::fcn</span><br><span class="line"></span><br><span class="line">D1* d1p &#x3D; &amp;d1obj; D2* d2p &#x3D; &amp;d2obj;</span><br><span class="line">bp2-&gt;f2();	&#x2F;&#x2F;错误：Base没有名为f2的成员</span><br><span class="line">d1p-&gt;f2(); &#x2F;&#x2F;虚调用，将在运行时调用D1::f2()</span><br><span class="line">d2p-&gt;f2(); &#x2F;&#x2F;虚调用，将在运行时调用D2::f2()</span><br><span class="line"></span><br><span class="line">Base* p1 &#x3D; &amp;d2obj; D1* p2 &#x3D; &amp;d2obj; D2* p3 &#x3D; &amp;d2obj;</span><br><span class="line">p1-&gt;fcn(42);	&#x2F;&#x2F;错误：Base中没有fcn(int)</span><br><span class="line">p2-&gt;fcn(42);	&#x2F;&#x2F;正确：调用D1:fcn(int)</span><br><span class="line">p3-&gt;fcn(42);	&#x2F;&#x2F;正确：调用D2:fcn(int)</span><br></pre></td></tr></table></figure>
<h2 id="构造函数与拷贝控制"><a href="#构造函数与拷贝控制" class="headerlink" title="构造函数与拷贝控制"></a>构造函数与拷贝控制</h2><h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p>通常基类应该定义一个虚析构函数，这样就能动态分配继承体系中的对象了<br>如果delete一个Quote* 类型的指针，该指针实际指向了一个Bulk_quote类型的对象。编译器就必须要清楚它应该执行Bulk_quote的析构函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Quote &#123;</span><br><span class="line">public:</span><br><span class="line">	virtual ~Quote() &#x3D; default;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>析构函数的虚属性会被继承</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Quote* itemP &#x3D; new Quote;	&#x2F;&#x2F;静态类型与动态类型一致</span><br><span class="line">delete itemP;				&#x2F;&#x2F;调用Quote的析构函数</span><br><span class="line">itemp &#x3D; new Bulk_quote;		&#x2F;&#x2F;静态类型与动态类型不一致</span><br><span class="line">delete itemP;				&#x2F;&#x2F;调用Bulk_quote的析构函数</span><br></pre></td></tr></table></figure>
<p>如果基类的析构函数不是虚函数，则delete一个指向派生类对象的指针将产生未定义的行为</p>
<p>如果一个类定义了析构函数，则编译器不会为这个类合成移动操作，因此移动基类对象时，实际使用的是合成和拷贝的操作</p>
<h3 id="合成拷贝控制与继承"><a href="#合成拷贝控制与继承" class="headerlink" title="合成拷贝控制与继承"></a>合成拷贝控制与继承</h3><p>基类或派生类的合成拷贝控制成员的行为：对类本身的成员依次进行初始化、赋值或销毁的操作，还负责使用直接基类中对应的操作对一个对象的直接基类部分进行初始化、赋值或销毁的操作<br>·合成的Bulk_quote默认构造函数运行Disc_quote的默认构造函数，后又运行Quote的默认构造函数<br>·Quote的默认构造函数将bookNo成员默认初始化为空字符串，同时使用类内初始值将price初始化为0<br>·Quote的构造函数完成后，继续执行Disc_quote的构造函数，使用类内初始值初始化qty和discount<br>·继续执行Bulk_quote的构造函数，但它什么也不做</p>
<p>派生类中删除的拷贝控制与基类的关系<br>·如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的函数或不可访问，则派生类中对象的成员将是被删除的，<br>原因是编译器不能使用基类成员来执行派生类对象基类部分的构造赋值或销毁操作<br>·如果在基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认和拷贝构造函数将是被删除的，因为编译器无法销毁派生类对象的基类部分<br>·编译器将不会合成一个删除掉的操作。当使用 = default请求一个移动操作时，如果基类中的对应操作是删除的或不可访问的，<br>那么派生类中该函数将是被删除的，因为派生类对象的基类部分不可移动。同样，基类的析构函数是删除的或不可访问的，<br>则派生类的移动构造函数也是被删除的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class B &#123;</span><br><span class="line">public:</span><br><span class="line">	B();</span><br><span class="line">	B(const&amp;) &#x3D; delete;</span><br><span class="line">&#125;;</span><br><span class="line">class D :public B &#123;</span><br><span class="line">	&#x2F;&#x2F;没有声明任何构造函数</span><br><span class="line">&#125;;</span><br><span class="line">D d;			&#x2F;&#x2F;正确：D的合成默认构造函数使用B的默认构造函数</span><br><span class="line">D d2(d);		&#x2F;&#x2F;错误：D的合成拷贝构造函数是被删除的</span><br><span class="line">D d3(move(d));	&#x2F;&#x2F;错误：隐式地使用D的被删除的拷贝构造函数</span><br></pre></td></tr></table></figure>
<p>因为定义了拷贝构造函数，所以编译器不会为B合成一个移动构造函数，因此既不能拷贝也不能移动B的对象</p>
<p>移动操作与继承<br>大多数基类会定义一个虚析构函数，因此在默认情况下基类通常不含有合成的移动操作，而且派生类中也没有<br>所以需要执行移动时应首先在基类中进行定义，一旦定义了自己的移动操作，又必须显式地定义拷贝操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Quote &#123;</span><br><span class="line">public:</span><br><span class="line">	Quote(); &#x3D; default;</span><br><span class="line">	Quote(const Quote&amp;) &#x3D; default;</span><br><span class="line">	Quote(Quote&amp;&amp;) &#x3D; default;</span><br><span class="line">	Quote&amp; operator&#x3D;(const Quote&amp;) &#x3D; default;</span><br><span class="line">	Quote&amp; operator(Quote&amp;&amp;) &#x3D; default;</span><br><span class="line">	virtual ~Quote() &#x3D; default;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="派生类的拷贝控制成员"><a href="#派生类的拷贝控制成员" class="headerlink" title="派生类的拷贝控制成员"></a>派生类的拷贝控制成员</h3><p>派生类的拷贝和移动构造函数在拷贝和移动自有成员的同时，也要拷贝和移动基类部分的成员<br>析构函数只负责销毁派生类自己分配的资源</p>
<p>定义派生类的拷贝或移动构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;&#x2F;* *&#x2F; &#125;;</span><br><span class="line">class D :public Base &#123;</span><br><span class="line">public:</span><br><span class="line">	&#x2F;&#x2F;默认情况下，基类的默认构造函数初始化对象的基类部分</span><br><span class="line">	&#x2F;&#x2F;想要使用拷贝或移动构造函数，必须在构造函数初始值列表中显式地调用该构造函数</span><br><span class="line">	D(const D&amp; d) :Base(d)&#x2F;*D成员的初始值*&#x2F; &#123;&#125;</span><br><span class="line">	D(D&amp;&amp; d) :Base(move(d))&#x2F;*D成员的初始值*&#x2F; &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>派生类赋值运算符<br>派生类的赋值运算符也必须显式地为其基类部分赋值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Base::operator&#x3D;(const Base&amp;)不会被自动调用</span><br><span class="line">D&amp; D::operator&#x3D;(const D&amp; rhs) &#123;</span><br><span class="line">	Base::operator(rhs);&#x2F;&#x2F;为基类部分赋值</span><br><span class="line">	return*this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先显式调用基类赋值运算符，令其为派生类对象的基类部分赋值。</p>
<p>派生类析构函数<br>派生类析构函数只负责销毁由派生类自己分配的资源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class D :public Base &#123;</span><br><span class="line">	public;</span><br><span class="line">	&#x2F;&#x2F;Base::~Base被自动调用执行</span><br><span class="line">	~D() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对象销毁的顺序与创建的相反：派生类析构函数首先执行，然后是基类的析构函数</p>
<h3 id="继承的构造函数"><a href="#继承的构造函数" class="headerlink" title="继承的构造函数"></a>继承的构造函数</h3><p>通过注明了基类名的using声明语句来为派生类继承基类构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Bulk_quote :public Disc_quote &#123;</span><br><span class="line">	public;</span><br><span class="line">	using Disc_quote::Disc_quote;	&#x2F;&#x2F;继承Disc_quote的构造函数</span><br><span class="line">	double net_price(size_t)const;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>编译器生成的构造函数形如：<br>derived(parms) :base(args) {}<br>Bulk_quote类中继承的构造函数等价于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bulk_quote(const string&amp; book, double price, size_t qty, double disc) : Disc_quote(book, price, qty, disc) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>如果派生类含有自己的数据成员，则这些成员将被默认初始化</p>
<p>继承的构造函数的特点<br>一个构造函数的using声明不会改变该构造函数的访问级别。基类的私有构造函数在派生类中还是一个私有构造函数<br>一个using声明语句不能指定explicit或constexpr<br>当一个基类构造函数含有默认实参时，这些实参不会被继承。相反，派生类将会获得多个继承的构造函数，每个构造函数分别省略掉一个含有默认实参的形参<br>派生类可以继承一部分构造函数，而为其它的构造函数定义自己的版本。如果派生类定义的构造函数与基类的有相同的参数列表，则该构造函数不会被继承<br>默认、拷贝和移动构造函数不会被继承。继承的构造函数不会被作为用户定义的构造函数来使用，如果一个类只含有继承的构造函数，它也将拥有合成的默认构造函数</p>
<h2 id="容器与继承"><a href="#容器与继承" class="headerlink" title="容器与继承"></a>容器与继承</h2><p>当使用容器存放继承体系中的对象时，必须采用简洁储存的方式。不允许在容器中保存不同类型的元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;Quote&gt;basket;</span><br><span class="line">basket.push_back(Quote(&quot;999-99&quot;, 50);</span><br><span class="line">&#x2F;&#x2F;正确：但只能把对象的Quote部分拷贝给basket</span><br><span class="line">basket.push_balk(Bulk_quote(&quot;999-9999&quot;, 50, 10, .25));</span><br><span class="line">&#x2F;&#x2F;调用Quote定义的版本，打印750</span><br><span class="line">cout &lt;&lt; basket.back().net_price(15) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>在容器中放置(智能)指针而非对象<br>当我们希望在容器中存放具有继承关系的对象时，实际上存放的通常是基类的指针。这些指针所指的对象的动态类型可能是基类或者派生类类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;shared_ptr&lt;Quote&gt;&gt;basket;</span><br><span class="line">basket.push_back(make_shared&lt;Quote&gt;(&quot;999-99&quot;, 50);</span><br><span class="line">basket.push_back(make_shared&lt;Bulk_quote&gt;(&quot;999-9999&quot;, 50, 10, .25));</span><br><span class="line">cout &lt;&lt; basket.back()-&gt;net_price(15) &lt;&lt; endl;	&#x2F;&#x2F;打印562.5，即15*50*.75</span><br></pre></td></tr></table></figure>
<p>实际调用的net_price版本依赖于指针所指对象的动态类型<br>在第二个push_back中，我们可以把一个派生类的智能指针转换成基类的智能指针<br>make_shared<Bulk_quote>返回一个shared_ptr<Bulk_quote>对象。调用push_back时该对象被转换成shared_ptr<Quote></p>
<h3 id="编写Basket类"><a href="#编写Basket类" class="headerlink" title="编写Basket类"></a>编写Basket类</h3><p>对于c++面向对象编程来说，一个悖论是无法直接使用对象进行面向对象编程。必须使用指针和引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Basket &#123;</span><br><span class="line">public:</span><br><span class="line">	&#x2F;&#x2F;Basket使用合成的默认构造函数和拷贝控制成员</span><br><span class="line">	void add_item(const shared_ptr&lt;Quote&gt;&amp; sale) &#123; items.insert(sale); &#125;</span><br><span class="line">	double total_receipt(ostream&amp;)const;</span><br><span class="line">private:</span><br><span class="line">	static bool compare(const shared_ptr&lt;Quote&gt;&amp; lhs, const shared_ptr&lt;Quote&gt;&amp; rhs) &#123;</span><br><span class="line">		return lhs-&gt;isbn() &lt; rhs-&gt;isbn();</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;multiset保存多个报价，按照compare成员排序</span><br><span class="line">	multiset&lt;shared_ptr&lt;Quote&gt;, decltype(compare)*&gt;items&#123; compare &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>定义了一个指向Quote的shared_ptr的multiset。这个multiset将使用一个与compare成员类型相同的函数来对其中的元素进行排序。<br>multiset成员的名字是items，初始化items并令其使用我们的compare函数</p>
<p>定义Basket的成员<br>total_receipt成员负责量购物篮的内容逐项打印成清单，然后返回购物篮中所有物品的总价格</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">double Basket::total_receipt(ostream&amp; os)const &#123;</span><br><span class="line">	double sum &#x3D; 0.0;</span><br><span class="line">	&#x2F;&#x2F;iter指向ISBN相同的一批元素的第一个</span><br><span class="line">	&#x2F;&#x2F;uooer_bound返回一个迭代器，指向这批元素的尾后位置</span><br><span class="line">	for (auto iter &#x3D; items.cbegin(); iter !&#x3D; items.cend(); iter &#x3D; items.upper_bound(*iter)) &#123;</span><br><span class="line">		&#x2F;&#x2F;在当前的Basket中至少有一个该关键字的元素，打印该书籍对应的项目</span><br><span class="line">		sum +&#x3D; print_total(os, **iter, items.count(*iter));</span><br><span class="line">	&#125;</span><br><span class="line">	os &lt;&lt; &quot;Total Sale: &quot; &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">	return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用upper_bound函数可以令我们跳过与当前关键字相同的所有元素<br>它返回的是一个迭代器，指向所有与iter关键字相等的元素中最后一个元素的下一位置<br>解引用iter后将得到一个准备打印对象的shared_ptr，所以需要再解引用该shared_ptr。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">** iter是一个Quote对象(或QUote的派生类的对象)</span><br><span class="line">print_total调用了虚函数net_price，因此最终的计算结果依赖于** iter的动态类型</span><br></pre></td></tr></table></figure>
<p>隐藏指针<br>Basket用户需要处理动态内存，add_item需要接受一个shared_ptr参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Basket bsk;</span><br><span class="line">bsk.add_item(make_shared&lt;Quote&gt;(&quot;999-99&quot;, 45));</span><br><span class="line">bsk.add_item(make_shared&lt;Bulk_quote&gt;(&quot;999-9999&quot;, 50, 10, .25));</span><br><span class="line">重新定义add_item，使得它接受一个Quote对象，而非shared_ptr</span><br><span class="line">void add_item(const Quote&amp; sale);	&#x2F;&#x2F;拷贝给定对象</span><br><span class="line">void add_item(Quote&amp;&amp; sale);		&#x2F;&#x2F;移动给定对象</span><br></pre></td></tr></table></figure>
<p>但add_item不知道要分配的类型，进行内存分配时，某处可能会有：new Quote(sale)。但sale指向Bulk_quote对象时，会被迫切掉一部分</p>
<p>模拟虚拷贝<br>所以给Quote添加一个虚函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Quote &#123;</span><br><span class="line">	&#x2F;&#x2F;该虚函数返回当前对象的一份动态分配的拷贝</span><br><span class="line">	virtual Quote* clone()const&amp; &#123; return new Quote(*this); &#125;</span><br><span class="line">	virtual Quote* clone()&amp;&amp; &#123; return new Quote(move(*this)); &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Bulk_quote :public Quote &#123;</span><br><span class="line">	Bulk_quote* clone()const&amp; &#123; return new Bulk_quote(*this); &#125;</span><br><span class="line">	Bulk_quote* clone()&amp;&amp; &#123; return new Bulk_quote(move(*this)); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>const左值引用成员将它自己拷贝给新分配的对象；右值引用成员将自己移动到新数据中<br>新版本add_item：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Basket &#123;</span><br><span class="line">public:</span><br><span class="line">	void add_item(const Quote&amp; sale) &#123; items.insert(shared_ptr&lt;Quote&gt;(sale.clone())); &#125;	&#x2F;&#x2F;拷贝给定的对象</span><br><span class="line">	void add_item(Quote&amp;&amp; sale) &#123; items.insert(shared_ptr&lt;Quote&gt;(move(sale).clone())); &#125;&#x2F;&#x2F;移动给定的对象</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>clone函数是一个虚函数。sale的动态类型决定了运行Quote的函数还是Bulk_quote的函数。clone返回一个新分配对象的指针，<br>该对象与clone所属的类型一致。把一个shared_ptr绑定到这个对象上，调用insert将新分配对象添加到items中。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/30/c-primer-15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" data-id="ckhua8ro50012xsvefiyt0c3d" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-primer/" rel="tag">c++ primer</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-c-primer-14-重载运算符与类型转换" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/30/c-primer-14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" class="article-date">
  <time datetime="2020-08-30T02:51:40.000Z" itemprop="datePublished">2020-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/30/c-primer-14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/">c++ primer 14 重载运算符与类型转换</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>重载运算符与类型转换</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>重载的运算符是具有特殊名字的函数：名字由关键字operator和其后要定义的运算符号共同组成。包含返回类型、参数列表、函数体<br>对于二元运算符，左侧运算对象传递给第一个参数，右侧传递给第二个。除重载的函数调用运算符operator()外，不能含有默认实参<br>若为成员函数，左侧运算对象绑定到隐式的this指针上，所以显式参数数量比运算符的运算对象总少一个<br>不能重载内置类型的运算符    不能发明新符号<br>———————————————————— - 491</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data1 + data2;			&#x2F;&#x2F;普通的表达式</span><br><span class="line">operator+(data1, data2);&#x2F;&#x2F;等价的函数调用</span><br><span class="line"></span><br><span class="line">data1 +&#x3D; data2;			&#x2F;&#x2F;基于&quot;调用&quot;的表达式</span><br><span class="line">data1.operator+&#x3D;(data2);&#x2F;&#x2F;对成员运算符函数的等价调用</span><br></pre></td></tr></table></figure>
<p>选择作为成员或非成员<br>·赋值(= ), 下标([]), 调用(()), 和成员访问箭头(-&gt;)运算符必须是成员<br>·复合赋值运算符一般来说应该是成员<br>·改变对象状态的或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常应该是成员<br>·具有对称性的运算符可能转换任意一端的运算对象，如算术、相等性、关系和位运算符等，通常应该是普通的非成员函数<br>当把运算符定义为成员函数时，左侧运算对象必须是运算符所属类的一个对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s &#x3D; &quot;world&quot;;</span><br><span class="line">string t &#x3D; s + &quot;!&quot;;	&#x2F;&#x2F;正确：把一个const char*加到一个string对象中</span><br><span class="line">strign u &#x3D; &quot;hi&quot; + s;&#x2F;&#x2F;如果&quot;+&quot;是string成员，则错误</span><br></pre></td></tr></table></figure>
<h2 id="输入和输出运算符"><a href="#输入和输出运算符" class="headerlink" title="输入和输出运算符"></a>输入和输出运算符</h2><h3 id="重载输出运算符-lt-lt"><a href="#重载输出运算符-lt-lt" class="headerlink" title="重载输出运算符&lt;&lt;"></a>重载输出运算符&lt;&lt;</h3><p>通常情况下，输出运算符第一个形参是一个非常量ostream对象的引用<br>非常量：向流写入会改变其状态；引用：无法直接复制一个ostream对象<br>第二个参数一般是一个常量引用<br>常量：打印对象不会改变内容；引用：避免赋值实参<br>一般返回ostream形参</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ostream&amp; operator&lt;&lt;(ostream&amp; os, const Sales_data&amp; item) &#123;</span><br><span class="line">	os &lt;&lt; item.isbn() &lt;&lt; &quot; &quot; &lt;&lt; item.units_sold &lt;&lt; &quot; &quot; &lt;&lt; item.revenue &lt;&lt; &quot; &quot; &lt;&lt; item.avg_price;</span><br><span class="line">	return os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入输出运算符必须是非成员函数，否则它左侧运算对象将是我们类的一个对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sales_data data;</span><br><span class="line">data &lt;&lt; cout;</span><br></pre></td></tr></table></figure>
<p>一般被声明成友元</p>
<h3 id="重载输入运算符-gt-gt"><a href="#重载输入运算符-gt-gt" class="headerlink" title="重载输入运算符&gt;&gt;"></a>重载输入运算符&gt;&gt;</h3><p>通常情况下，第一个形参是运算符将要读取的流的引用，第二个是将要读入到的(非常量)对象的引用。通常会返回某个给定流的引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">istream&amp; operator&gt;&gt;(istream&amp; is, Sales_data&amp; item) &#123;</span><br><span class="line">	double price;	&#x2F;&#x2F;不需要初始化</span><br><span class="line">	is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;</span><br><span class="line">	if (is)</span><br><span class="line">		item.revenue &#x3D; item.units_sold * price;</span><br><span class="line">	else</span><br><span class="line">		item &#x3D; Sales_data(); &#x2F;&#x2F;输入失败：对象被赋予默认的状态</span><br><span class="line">	return is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输入时的错误：<br>当流含有错误类型的数据是读取操作可能失败；当读取操作到达文件末尾或者遇到输入流的其他错误</p>
<h2 id="算术和关系运算符"><a href="#算术和关系运算符" class="headerlink" title="算术和关系运算符"></a>算术和关系运算符</h2><p>通常定义为非成员函数，形参是常量引用<br>如果同时定义了算术运算符合相关的复合赋值运算符，通常应该用复合赋值来实现算术运算符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sales_data operator+(const Sales_data&amp; lhs, const Sales_data&amp; rhs) &#123;</span><br><span class="line">	Sales_data sum &#x3D; lhs;</span><br><span class="line">	sum +&#x3D; rhs;</span><br><span class="line">	return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="相等运算符"><a href="#相等运算符" class="headerlink" title="相等运算符"></a>相等运算符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bool operator&#x3D;&#x3D;(const Sales_data&amp; lhs, const Sales_data&amp; rhs) &#123;</span><br><span class="line">	return lhs.isbn() &#x3D;&#x3D; rhs.isbn() &amp;&amp; lhs.units_sold &#x3D;&#x3D; rhs.units_sold &amp;&amp; lhs.revenue &#x3D;&#x3D; rhs.revenue;</span><br><span class="line">&#125;</span><br><span class="line">bool operator!&#x3D;(const Sales_data&amp; lhs, const Sales_data&amp; rhs) &#123;</span><br><span class="line">	return !(lhs &#x3D;&#x3D; rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>如果存在唯一一种逻辑可靠的&lt;定义，则应该考虑为这个类定义&lt;运算符。如果类同时还包含==，则当且仅当&lt;的定义和==产生的结果一致时才定义&lt;运算符</p>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class StrVec &#123;</span><br><span class="line">public:</span><br><span class="line">	StrVec&amp; operator&#x3D;(initialized_list&lt;string&gt;);</span><br><span class="line">&#125;;</span><br><span class="line">StrVec&amp; StrVec::operator&#x3D;(initialized_list&lt;string&gt; il) &#123;</span><br><span class="line">	&#x2F;&#x2F;alloc_n_copy分配内存空间并从给定范围内拷贝元素</span><br><span class="line">	auto data &#x3D; alloc_n_copy(il.begin(), il.end());</span><br><span class="line">	free();					&#x2F;&#x2F;销毁对象中的元素并释放内存空间</span><br><span class="line">	elements &#x3D; data.first;	&#x2F;&#x2F;更新数据成员并使其指向新内存空间</span><br><span class="line">	first_free &#x3D; cap &#x3D; data.second;</span><br><span class="line">	return*this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>赋值运算符必须定义成类的成员，复合赋值运算符通常也是。两种都返回左侧运算符对象的引用</p>
<h2 id="下标运算符"><a href="#下标运算符" class="headerlink" title="下标运算符"></a>下标运算符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class StrVec &#123;</span><br><span class="line">public:</span><br><span class="line">	string&amp; operator[](size_t n) &#123;</span><br><span class="line">		return elements[n];</span><br><span class="line">	&#125;</span><br><span class="line">	const string&amp; operator[](size_t n)const &#123;</span><br><span class="line">		return elements[n];</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	string* elements;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通常定义返回普通引用和作为常量成员且返回常量引用，两个版本。返回元素的引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const StrVec cvec &#x3D; svec;</span><br><span class="line">if (svec.size() &amp;&amp; svec[0].empty()) &#123;</span><br><span class="line">	svec[0] &#x3D; &quot;zero&quot;;	&#x2F;&#x2F;正确：下标运算符返回string的引用</span><br><span class="line">	cvec[0] &#x3D; &quot;zip&quot;;	&#x2F;&#x2F;错误：对cvec取下标返回的是常量引用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="递增和递减运算符"><a href="#递增和递减运算符" class="headerlink" title="递增和递减运算符"></a>递增和递减运算符</h2><p>它们改变的正好是操作对象的状态，所以建议将其设为成员函数</p>
<p>前置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class StrBlobPtr &#123;</span><br><span class="line">public:</span><br><span class="line">	StrBlobPtr&amp; operator++();</span><br><span class="line">	StrBlobPtr&amp; operator--();</span><br><span class="line">&#125;;</span><br><span class="line">StrBlobPtr&amp; StrBlobPtr::operator++() &#123;</span><br><span class="line">	&#x2F;&#x2F;如果已经指向容器尾后，则无法递增</span><br><span class="line">	check(curr, &quot;increment past end of StrBlobPtr&quot;);</span><br><span class="line">	++curr;</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br><span class="line">StrBlobPtr&amp; StrBlobPtr::operator--() &#123;</span><br><span class="line">	--curr;</span><br><span class="line">	check(curr, &quot;decrement past begin of StrBlobPtr&quot;);</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>区分前置后置<br>后置版本接受一个额外的(不被使用)int类型的形参。使用时编译器为这个形参提供一个值为0的实参</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class StrBlobPtr &#123;</span><br><span class="line">public:</span><br><span class="line">	StrBlobPtr operator++(int);</span><br><span class="line">	StrBlobPtr operator--(int);</span><br><span class="line">&#125;;</span><br><span class="line">StrBlobPtr StrBlobPtr::operator++(int) &#123;</span><br><span class="line">	StrBlobPtr ret &#x3D; *this;	&#x2F;&#x2F;记录当前值</span><br><span class="line">	++* this;				&#x2F;&#x2F;向前移动一个元素，前置++需要检查递增的有效性</span><br><span class="line">	return ret;				&#x2F;&#x2F;返回之前记录的状态</span><br><span class="line">&#125;</span><br><span class="line">StrBlobPtr StrBlobPtr::operator--(int) &#123;</span><br><span class="line">	StrBlobPtr ret &#x3D; *this;	&#x2F;&#x2F;记录当前值</span><br><span class="line">	--* this;				&#x2F;&#x2F;向后移动一个元素，前置--需要检查递增的有效性</span><br><span class="line">	return ret;				&#x2F;&#x2F;返回之前记录的状态</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后置运算符调用各自的前置版本来完成实际的工作</p>
<p>显式调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StrBlobPtr p(a1);</span><br><span class="line">p.operator++(0);	&#x2F;&#x2F;后置</span><br><span class="line">p.operator++();		&#x2F;&#x2F;前置</span><br></pre></td></tr></table></figure>
<h2 id="成员访问运算符"><a href="#成员访问运算符" class="headerlink" title="成员访问运算符"></a>成员访问运算符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class StrBlobPtr &#123;</span><br><span class="line">public:</span><br><span class="line">	string&amp; operator*()const &#123;</span><br><span class="line">		auto p &#x3D; check(curr, &quot;dereference past end&quot;);</span><br><span class="line">		return (*p)[curr];	&#x2F;&#x2F;(*p)是对象所指的vector</span><br><span class="line">	&#125;</span><br><span class="line">	string* operator-&gt;()const &#123;</span><br><span class="line">		return&amp;this-&gt;operator*();	&#x2F;&#x2F;实际将工作委托给解引用运算符</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>解引用运算符首先检查curr是否仍在作用范围内，是则返回curr所指元素的一个引用<br>箭头运算符不执行任何自己的操作，而是调用解引用运算符并返回解引用结果元素的地址<br>箭头运算符必须是类的成员，解引用通常也是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StrBlob a1 &#x3D; &#123; &quot;hi&quot;,&quot;bye&quot;,&quot;now&quot; &#125;;</span><br><span class="line">StrBlobPtr p(a1);		&#x2F;&#x2F;p指向a1中的vector</span><br><span class="line">*p &#x3D; &quot;okay&quot;;			&#x2F;&#x2F;给a1的首元素赋值</span><br><span class="line">cout &lt;&lt; p-&gt;size();		&#x2F;&#x2F;打印4，a1首元素的大小</span><br><span class="line">cout &lt;&lt; (*p).size();	&#x2F;&#x2F;等价于p-&gt;size()</span><br></pre></td></tr></table></figure>
<p>箭头运算符永远不能丢掉成员访问这个最基本的含义<br>point-&gt;men分别等价于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(*point).mem;			&#x2F;&#x2F;point是一个内置的指针类型</span><br><span class="line">point.operator()-&gt;mem;	&#x2F;&#x2F;point是一个类的对象</span><br></pre></td></tr></table></figure>
<h2 id="函数调用运算符"><a href="#函数调用运算符" class="headerlink" title="函数调用运算符"></a>函数调用运算符</h2><p>如果类重载了函数调用运算符，则可以像使用函数一样使用该类的对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct absInt &#123;</span><br><span class="line">	int operator()(int val)const &#123;</span><br><span class="line">		return val &gt; 0 ? val : -val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int i &#x3D; 42;</span><br><span class="line">absInt absObj;		&#x2F;&#x2F;含有函数调用运算符的对象</span><br><span class="line">int ui &#x3D; absObj(i);	&#x2F;&#x2F;将i传递给absObj.operator()</span><br></pre></td></tr></table></figure>
<p>即使absObj只是一个对象而非函数，也能”调用”该对象。实际上是运行重载的调用运算符<br>如果类定义了调用运算符，则该类的对象称作函数对象(function object)。这些对象的行为像函数一样</p>
<p>含有状态的函数对象类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class PrintString &#123;</span><br><span class="line">public;</span><br><span class="line">	PrintString(ostream&amp; o &#x3D; cout, char c &#x3D; &#39; &#39;) :os(o), sep(c) &#123; &#125;</span><br><span class="line">	void operator()(const string&amp; s)const &#123; os &lt;&lt; s &lt;&lt; sep; &#125;</span><br><span class="line">private:</span><br><span class="line">	ostream&amp; os;	&#x2F;&#x2F;用于写入目的的流</span><br><span class="line">	char sep;		&#x2F;&#x2F;用于将不同输出隔开的字符</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>定义PringString对象时，分隔符及输出流可以使用默认也可以提供自己的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PrintString printer;			&#x2F;&#x2F;使用默认值，打印到cout</span><br><span class="line">printer(s);						&#x2F;&#x2F;在cout中打印s后跟空格</span><br><span class="line">PrintString errors(cerr, &#39;\n&#39;);	</span><br><span class="line">errors(s);						&#x2F;&#x2F;在cerr中打印s后跟换行符</span><br></pre></td></tr></table></figure>
<p>函数对象也作为泛型算法的实参<br>for_each(vs.begin(), vs.end(), PrintString(cerr, ‘\n’));</p>
<h3 id="lambda是函数对象"><a href="#lambda是函数对象" class="headerlink" title="lambda是函数对象"></a>lambda是函数对象</h3><p>当编写了一个lambda后，编译器将该表达式翻译成一个未命名类的未命名对象。在lambda表达式产生的类中含有一个重载的函数调用运算符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stable_sort(words.begin(), words.end(), [](const string&amp; a, const string&amp; b) &#123;return a.size() &lt; b.size(); &#125;);</span><br></pre></td></tr></table></figure>
<p>其行为类似：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class ShorterString &#123;</span><br><span class="line">public:</span><br><span class="line">	bool operator()(const string&amp; a, const string&amp; b)const &#123; return a.size() &lt; b.size(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>默认情况下，lambda不能改变它捕获的变量，所以产生的类当中的函数调用运算符是一个const成员函数；若lambda声明为可变的，则不是const<br>stable_sort(words.begin(), words.end(), ShorterString());</p>
<p>表示lambda及相应捕获行为的类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto wc &#x3D; find_if(words.begin(), words.end(), [sz](const string &amp; a) &#123;return a.size() &gt;&#x3D; sz; &#125;)</span><br></pre></td></tr></table></figure>
<p>lambda产生的类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class SizeComp &#123;</span><br><span class="line">public:</span><br><span class="line">	SizeComp(size_t n) :sz(n) &#123;&#125;</span><br><span class="line">	bool operator()(const string&amp; a)const &#123; return s.size() &gt;&#x3D; sz; &#125;</span><br><span class="line">private:</span><br><span class="line">	size_t sz;</span><br><span class="line">&#125;;</span><br><span class="line">auto wc &#x3D; find_if(words.begin(), words.end(), SizeComp(sz));</span><br></pre></td></tr></table></figure>
<h3 id="标准库定义的函数对象"><a href="#标准库定义的函数对象" class="headerlink" title="标准库定义的函数对象"></a>标准库定义的函数对象</h3><p>——————————————————510</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plus&lt;int&gt; intAdd;</span><br><span class="line">negate&lt;int&gt; intNegate;</span><br><span class="line">&#x2F;&#x2F;使用intAdd::operator(int,int)求和</span><br><span class="line">int sum &#x3D; intAdd(10, 20);		&#x2F;&#x2F;sum&#x3D;30</span><br><span class="line">sum &#x3D; intNegate(intAdd(10, 20));&#x2F;&#x2F;sum&#x3D;-30</span><br><span class="line">sum &#x3D; intAdd(10, intNegate(10));&#x2F;&#x2F;sum&#x3D;0</span><br></pre></td></tr></table></figure>
<p>传入一个临时函数对象用于执行两个string对象&gt;比较运算<br>sort(svec.begin(), svec.end(), greater<string>());    //降序</p>
<p>比较两个无关指针将产生未定义的行为。通过比较指针的内存地址来sort指针的vector</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string*&gt;nameTable;</span><br><span class="line">&#x2F;&#x2F;错误：nameTable中的指针彼此没有联系，&lt;将产生未定义的行为</span><br><span class="line">sort(nameTable.begin(), nameTable.end(), [](string* a, string* b) &#123;return a &lt; b; &#125;);</span><br><span class="line">&#x2F;&#x2F;正确：标准库规定指针的less是定义良好的</span><br><span class="line">sort(nameTable.begin(), nameTable.end(), less&lt;string*&gt;());</span><br></pre></td></tr></table></figure>
<h3 id="可调用对象与function"><a href="#可调用对象与function" class="headerlink" title="可调用对象与function"></a>可调用对象与function</h3><p>c++中可调用对象：函数、函数指针、lambda表达式、bind创建的对象以及冲在了函数调用运算符的类<br>调用形式(call signature)指明了调用返回的类型以及传递给调用的实参类型。一种调用形式对应一个函数类型</p>
<p>不同类型可能具有相同的调用形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;普通函数</span><br><span class="line">int add(int i, int j) &#123; return i + j; &#125;</span><br><span class="line">&#x2F;&#x2F;lambda，产生一个未命名的函数对象类</span><br><span class="line">auto mod &#x3D; [](int i, int j) &#123;return i % j; &#125;;</span><br><span class="line">&#x2F;&#x2F;函数对象类</span><br><span class="line">struct divide &#123;</span><br><span class="line">	int operator()(int denominator, int divisor) &#123;</span><br><span class="line">		return denominator &#x2F; divisor;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这些共享一种调用形式：int(int, int)</p>
<p>定义一个函数表(function table)用于储存指向这些可调用对象的”指针”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;构建从运算符到函数指针的映射关系</span><br><span class="line">map&lt;string, int(*)(int, int)&gt;binops;</span><br><span class="line">&#x2F;&#x2F;正确：add是一个指向正确类型的函数指针</span><br><span class="line">binops.insert(&#123; &#39;+&#39;,add &#125;);</span><br></pre></td></tr></table></figure>
<p>但不能将mod或者divide存入binops，因为mod不是一个函数指针<br>可以通过function新标准库类型来解决<br>——————————————————————– - 512<br>function是一个模板</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function&lt;int(int, int)&gt;, 声明了一个function类型，表示一个接受两个int，返回一个int的可调用对象</span><br><span class="line">function&lt;int(int, int)&gt;f1 &#x3D; add;				&#x2F;&#x2F;函数指针</span><br><span class="line">function&lt;int(int, int)&gt;f2 &#x3D; divide();			&#x2F;&#x2F;函数对象类的对象</span><br><span class="line">function&lt;int(int, int)&gt;f3 &#x3D; [](int i, int j) &#123;	&#x2F;&#x2F;lambda</span><br><span class="line">	return i * j;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>利用function可以重新定义map</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, function&lt;int(int, int)&gt;&gt;binops &#x3D; &#123;</span><br><span class="line">	&#123;&quot;+&quot;,add&#125;,</span><br><span class="line">	&#123;&quot;-&quot;,minus&lt;int&gt;()&#125;,</span><br><span class="line">	&#123;&quot;&#x2F;&quot;,divide()&#125;,</span><br><span class="line">	&#123;&quot;*&quot;,[](int i,int j) &#123;return i * j; &#125;&#125;,</span><br><span class="line">	&#123;&quot;%&quot;,mod&#125;</span><br><span class="line">&#125;</span><br><span class="line">binops[&quot;+&quot;](10, 5);</span><br></pre></td></tr></table></figure>
<p>重载的函数与function<br>不能直接将重载函数的名字存入function类型的对象中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int add(int i, int j) &#123; return i + j; &#125;</span><br><span class="line">Sales_data add(const Sales_data&amp;, const Sales_data%);</span><br><span class="line">map&lt;string, function&lt;int(int, int)&gt;&gt;binops;</span><br><span class="line">binpos.insert(&#123; &quot;+&quot;,add &#125;);	&#x2F;&#x2F;错误：哪个？</span><br></pre></td></tr></table></figure>
<p>可以通过存储函数指针而非函数名字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int (*fp)(int, int) &#x3D; add;	&#x2F;&#x2F;指针所指的add是接受两个int的版本</span><br><span class="line">binops.insert(&#123; &quot;+&quot;,fp &#125;);	&#x2F;&#x2F;正确：fp指向一个正确的add版本</span><br><span class="line">也可以通过lambda来消除二义性</span><br><span class="line">binops.insert(&#123; &quot;+&quot;,[](int a,int b) &#123;return a + b; &#125; &#125;);</span><br></pre></td></tr></table></figure>
<h2 id="重载、类型转换与运算符"><a href="#重载、类型转换与运算符" class="headerlink" title="重载、类型转换与运算符"></a>重载、类型转换与运算符</h2><h3 id="类型转换运算符-conversion-operator"><a href="#类型转换运算符-conversion-operator" class="headerlink" title="类型转换运算符(conversion operator)"></a>类型转换运算符(conversion operator)</h3><p>是类的一种特殊成员函数，负责将一个类类型的值转换成其他类型<br>operator type() const;<br>类型转换运算符可以面向任意类型(void除外)进行定义，只要该类型能作为函数的返回类型。所以不允许转换成数组或者函数<br>可以转换成指针或者引用<br>类型转换运算符没有显式的返回类型，也没有形参，一般是const成员</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class SmallInt &#123;</span><br><span class="line">public:</span><br><span class="line">	SmallInt(int i &#x3D; 0) :val(i) &#123;</span><br><span class="line">		if (i &lt; 0 || i&gt;255)throw out_of_range(&quot;bad smallInt value&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	operator int() const &#123; return val; &#125;</span><br><span class="line">private:</span><br><span class="line">	size_t val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>构造函数将算术类型的值转换为SmallInt对象，而类型转换运算符将SmallInt对象转换为int</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SmallInt si;</span><br><span class="line">si &#x3D; 4;	&#x2F;&#x2F;首先将4隐式地转换成SmallInt，然后调用operator &#x3D;</span><br><span class="line">si + 3;	&#x2F;&#x2F;首先将si隐式地转换成int，然后进行加法</span><br></pre></td></tr></table></figure>
<p>显式的类型转换运算符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class SmallInt &#123;</span><br><span class="line">public:</span><br><span class="line">	explicit operator int() const &#123; return val; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>编译器不会将一个显式的类型转换运算符用于隐式的类型转换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SmallInt si &#x3D; 3;			&#x2F;&#x2F;正确：SmallInt的构造函数不是显式的</span><br><span class="line">si + 3;						&#x2F;&#x2F;错误：此处需要隐式的类型转换，但类的运算符是显式的</span><br><span class="line">static_cast&lt;int&gt;(si) + 3;	&#x2F;&#x2F;正确：显式地请求类型转换</span><br></pre></td></tr></table></figure>
<p>例外：以下位置将隐式的进行<br>·if,while,do语句的条件部分<br>·for语句头的条件表达式<br>·逻辑非！、逻辑或运算符||、逻辑与运算符&amp;&amp;的运算对象<br>·条件运算符?:的条件表达式</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/30/c-primer-14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" data-id="ckhua8rnu000txsvec2y7cugn" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-primer/" rel="tag">c++ primer</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-c-primer-13-拷贝控制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/30/c-primer-13-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/" class="article-date">
  <time datetime="2020-08-30T02:46:44.000Z" itemprop="datePublished">2020-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/30/c-primer-13-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/">c++ primer 13 拷贝控制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="拷贝控制"><a href="#拷贝控制" class="headerlink" title="拷贝控制"></a>拷贝控制</h1><p>拷贝控制操作(copy control)：拷贝构造函数(copy constructor)、拷贝赋值运算符(copy-assignment operator)、<br>移动构造函数(move constructor)、移动赋值运算符(move-assignment operator)和析构函数是(destructor)<br>拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么<br>拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么<br>析构函数定义了当此类型对象销毁时做什么<br>一个类没有定义所有这些拷贝控制成员，编译器会自动为它定义缺失的操作</p>
<p>拷贝构造函数<br>如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">public:</span><br><span class="line">	Foo();           &#x2F;&#x2F;默认构造函数</span><br><span class="line">	Foo(const Foo&amp;); &#x2F;&#x2F;拷贝构造函数</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>拷贝构造函数的第一个参数必须是一个引用类型</p>
<p>如果我们没有为类定义拷贝构造函数，编译器会为我们定义一个合成拷贝构造函数(synthesized copy constructor)<br>合成拷贝构造函数通过编译器从给定对象中一次将每个非static成员拷贝到正在创建的对象中<br>类类型的成员使用其拷贝构造函数来拷贝；内置类型的成员则直接拷贝</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Sales_data &#123;</span><br><span class="line">public:</span><br><span class="line">	Sales_data(const Sales_data&amp;); &#x2F;&#x2F;与合成的拷贝构造函数等价的拷贝构造函数的声明</span><br><span class="line">private:</span><br><span class="line">	string bookNo;</span><br><span class="line">	int units_sold &#x3D; 0;</span><br><span class="line">	double revenue &#x3D; 0.0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>与Sales_data的合成拷贝构造函数等价</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sales_data::Sales_data(const Sales_data&amp; orig);</span><br><span class="line">bookNo(orig.bookNo),          &#x2F;&#x2F;使用string的拷贝构造函数</span><br><span class="line">units_sold(orig.units_sold),  &#x2F;&#x2F;拷贝orig.units_sold</span><br><span class="line">revenue(orig.revenue)         &#x2F;&#x2F;拷贝orig.revenue</span><br><span class="line">&#123; &#125;							  &#x2F;&#x2F;空函数体</span><br></pre></td></tr></table></figure>
<p>拷贝初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string dots(10, &#39;.&#39;);        &#x2F;&#x2F;直接初始化</span><br><span class="line">string s(dots);				&#x2F;&#x2F;直接初始化</span><br><span class="line">string s2 &#x3D; dots;			&#x2F;&#x2F;拷贝初始化</span><br><span class="line">string null_book &#x3D; &quot;999-9&quot;; &#x2F;&#x2F;拷贝初始化</span><br><span class="line">string nines &#x3D; string(100, &#39;9&#39;); &#x2F;&#x2F;拷贝初始化</span><br></pre></td></tr></table></figure>
<p>直接初始化是要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数；拷贝初始化是要求编译器将右侧运算对象拷贝到种族创建的对象中，需要的话进行类型转换<br>拷贝初始化除了”=”定义变量时<br>·将一个对象作为实参传递给一个非引用类型的形参<br>·从一个返回类型为非引用类型的函数返回一个对象<br>·用花括号列表初始化一个数组中的元素或一个聚合类中的成员<br>初始化标准库容器或调用其insert或push成员时，容器会对其元素进行拷贝初始化；用emplace成员创建的元素都进行直接初始化<br>拷贝构造函数被用来初始化非引用类类型参数，如果拷贝构造函数其参数不是引用类型，则调用永远不会成功–为了调用拷贝构造函数，必须拷贝它的实参，但为了拷贝实参，又需要调用拷贝构造函数，无限循环</p>
<p>vector的接受单一大小参数的构造函数是explicit的，传递实参或从函数返回一个值时，不能隐式使用一个explicit构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt;v1(10); &#x2F;&#x2F;正确：直接初始化</span><br><span class="line">vector&lt;int&gt;v2 &#x3D; 10; &#x2F;&#x2F;错误：接受大小参数的构造函数是explicit的</span><br><span class="line">void f(vector&lt;int&gt;); &#x2F;&#x2F;f参数进行拷贝初始化</span><br><span class="line">f(10);               &#x2F;&#x2F;错误：不能用一个explicit的构造函数拷贝一个实参</span><br><span class="line">f(vector&lt;int&gt;(10)); &#x2F;&#x2F;正确：从一个int直接构造一个临时vector</span><br></pre></td></tr></table></figure>
<p>编译器可以绕过拷贝构造函数，但拷贝 / 移动构造函数必须是存在且可访问的(如，不能是private的)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string null_book &#x3D; (&quot;99999&quot;);</span><br><span class="line">string null_book(&quot;99999&quot;);</span><br></pre></td></tr></table></figure>
<p>拷贝赋值运算符<br>赋值运算符通常应该返回一个指向其左侧运算对象的引用<br>合成拷贝运算符通常会将右侧运算对象的每个非static成员赋予左侧运算对象的对应成员</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Sales_data&amp; Sales_data::operator&#x3D;(const Sales_data&amp; rhs) &#123;</span><br><span class="line">	bookNo &#x3D; rhs.bookNo;		&#x2F;&#x2F;调用string::operator&#x3D;</span><br><span class="line">	units_sold &#x3D; rhs.units_sold;&#x2F;&#x2F;使用内置的int赋值</span><br><span class="line">	revenue &#x3D; rhs.revenue;		&#x2F;&#x2F;使用内置的double赋值</span><br><span class="line">	return*this;				&#x2F;&#x2F;返回一个此对象的引用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>析构函数<br>析构函数释放对象使用的资源，并销毁对象的非static数据成员。没有返回值，也不接受参数。所以不能被重载，只会有唯一一个析构函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">public:</span><br><span class="line">	~Foo();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在析构函数中，首先执行函数体，然后销毁成员，按照初始化顺序的逆序销毁<br>隐式销毁一个内置指针类型的成员不会delete它所指的对象</p>
<p>调用析构函数<br>·变量在离开其作用域时被销毁<br>·当一个对象被销毁时，其成员被销毁<br>·容器被销毁时，其元素被销毁<br>·对于动态分配的对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	Sales_data * p &#x3D; new Sales_data;	&#x2F;&#x2F;p是内置指针</span><br><span class="line">	auto p2 &#x3D; make_shared&lt;Sales_data&gt;();&#x2F;&#x2F;p2是shared_ptr</span><br><span class="line">	Sales_data item(p*);				&#x2F;&#x2F;拷贝构造函数将*p拷贝到item中</span><br><span class="line">	vector&lt;Sales_data&gt;v;				&#x2F;&#x2F;局部对象</span><br><span class="line">	v.push_back(*p2);					&#x2F;&#x2F;拷贝p2指向的对象</span><br><span class="line">	delete p;							&#x2F;&#x2F;对p指向的对象执行析构函数</span><br><span class="line">&#125;&#x2F;&#x2F;退出局部作用域，对item,v,p2调用析构函数</span><br></pre></td></tr></table></figure>
<p>当一个类未定义自己的析构函数时，编译器会为它定义一个合成析构函数(synthesized destructor)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Sales_data &#123;</span><br><span class="line">public:</span><br><span class="line">	~Sales_data() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>等价于合成析构函数<br>析构函数自身并不直接销毁成员，是在析构函数体之后隐含的析构阶段中被销毁的<br>合成析构函数不会delete一个指针数据成员<br>一个类如果需要自定义析构函数，几乎可以肯定也需要自定义拷贝赋值运算符和拷贝构造函数（指针）<br>需要一个拷贝构造函数，几乎可以肯定也需要拷贝赋值运算符，反之亦然</p>
<p>可以通过将拷贝控制成员定义为=default来显式地要求编译器生成合成的版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Sales_data &#123;</span><br><span class="line">	Sales_data() &#x3D; default;</span><br><span class="line">	Sales_data(const Sales_data&amp;) &#x3D; default;</span><br><span class="line">	Sales_data&amp; operator&#x3D;(const Sales_data&amp;);</span><br><span class="line">	~Sales_data() &#x3D; default;</span><br><span class="line">&#125;;</span><br><span class="line">Sales_data&amp; Sales_data::operator&#x3D;(const Sales_data&amp;) &#x3D; default;</span><br></pre></td></tr></table></figure>
<p>类内用=default，歌城的函数将隐式地声明为内联的</p>
<p>阻止拷贝<br>可以通过将拷贝构造函数和拷贝赋值运算符定义为删除的函数(delete function)来阻止拷贝<br>删除的函数：虽然声明了它们，但不能以任何方式使用它们。在参数列表后加上=delete</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct NoCopy &#123;</span><br><span class="line">	NoCopy() &#x3D; default;		&#x2F;&#x2F;使用合成的默认构造函数</span><br><span class="line">	NoCopy(const NoCopy&amp;) &#x3D; delete; &#x2F;&#x2F;阻止拷贝</span><br><span class="line">	NoCopy&amp; operator&#x3D;(const NoCopy&amp;) &#x3D; delete;&#x2F;&#x2F;阻止赋值</span><br><span class="line">	~NoCopy() &#x3D; default; &#x2F;&#x2F;使用合成的析构函数</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>=delete必须出现在第一次声明的时候，可以对任何函数用</p>
<p>析构函数不能是删除的成员<br>对于删除了析构函数的类型，不能定义该类型的变量或成员，但可以动态分配这种类型的对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct NoDtor &#123;</span><br><span class="line">	NoDtor() &#x3D; default;</span><br><span class="line">	~NoDtor() &#x3D; delete;</span><br><span class="line">&#125;;</span><br><span class="line">NoDtor nd;			&#x2F;&#x2F;错误：NoDtor的析构函数是删除的</span><br><span class="line">NoDtor* p &#x3D; new Dtor(); &#x2F;&#x2F;正确</span><br><span class="line">delete p;			&#x2F;&#x2F;错误：NoDtor的析构函数是删除的</span><br></pre></td></tr></table></figure>
<p>对某些类，编译器将合成的成员定义为删除的函数：<br>·类的某个成员的析构函数是删除的或不可访问的(如private)，则类的合成析构函数被定义为删除的<br>·类的某个成员的拷贝构造函数或析构函数是删除的或不可访问的，则类的合成拷贝构造函数被定义为删除的；<br>·如果类的某个成员的拷贝赋值运算符是删除的或不可访问的，或是类有一个const的或引用成员，则类的合成拷贝赋值运算符被定义为删除的<br>·如果类的某个成员的析构函数是删除的或不可访问的，或是类有一个引用成员，它没有类内初始化器，或是类有一个const成员，它没有类内<br>初始化器且其类型未显示定义默认构造函数，则该类的默认构造函数被定义为删除的<br>本质上，规则：类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的<br>删除的或不可访问的析构函数-&gt;可能会创建出无法销毁的对象；<br>引用成员或const成员-&gt;编译器不会为其合成默认构造函数</p>
<p>行为像值的类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class HasPtr &#123;</span><br><span class="line">public:</span><br><span class="line">	HasPtr(const string&amp; s &#x3D; string()):ps(new string(s)),i(0)&#123;&#125;</span><br><span class="line">	HasPtr(const HasPtr&amp; p) :ps(new string(*p.ps)), i(p.i) &#123;&#125;</span><br><span class="line">	HasPtr&amp; operator&#x3D;(const HasPtr&amp;);</span><br><span class="line">	~HasPtr() &#123; delete ps; &#125;</span><br><span class="line">private:</span><br><span class="line">	string* ps;</span><br><span class="line">	int i;</span><br><span class="line">&#125;;</span><br><span class="line">HasPtr&amp; HasPtr::operator&#x3D;(const HasPtr&amp; rhs) &#123;</span><br><span class="line">	auto newp &#x3D; new string(*rhs.ps);</span><br><span class="line">	delete ps;</span><br><span class="line">	ps &#x3D; newp;</span><br><span class="line">	i &#x3D; rhs.i;</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>赋值运算符：<br>·将一个对象赋予它自身，赋值运算符必须能正确工作<br>·大多数赋值运算符组合了析构函数和拷贝构造函数<br>先将右侧运算对象拷贝到一个局部临时对象中，拷贝完成后，销毁左侧运算对象的现有成员就是安全的了。<br>否则，若rhs和本对象是同一个对象，delete ps会释放<em>this和rhs指向的string，接下来new表达式中试图拷贝</em>(rhs.ps)时就会访问一个指向无效内存的指针，是未定义的</p>
<p>行为像指针的类<br>设计引用计数<br>·除初始化对象外，每个构造函数(拷贝构造除外)还要创建一个引用计数。创建对象时将其初始化为1<br>·拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享的计数器<br>·析构函数递减计数器。变为0则释放状态<br>·拷贝赋值运算符递增右侧运算对象计数器，递减左侧。左侧变为0则销毁状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class HasPtr &#123;</span><br><span class="line">public:</span><br><span class="line">	HasPtr(const string&amp; s &#x3D; string()):ps(new string(s)),i(0),use(new size_t(1))&#123;&#125;</span><br><span class="line">	HasPtr(const HasPtr&amp; p) :ps(p.ps), i(p.i), use(p.use) &#123; ++*use; &#125;</span><br><span class="line">	HasPtr&amp; operator&#x3D;(const HasPtr&amp;);</span><br><span class="line">	~HasPtr();</span><br><span class="line">private:</span><br><span class="line">	string* ps;</span><br><span class="line">	int i;</span><br><span class="line">	size_t* use; &#x2F;&#x2F;用来记录有多少个共享ps的成员</span><br><span class="line">&#125;;</span><br><span class="line">HasPtr::~HasPtr() &#123;</span><br><span class="line">	if (--use &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		delete ps; &#x2F;&#x2F;释放string内存</span><br><span class="line">		delete use;&#x2F;&#x2F;释放计数器内存</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">HasPtr&amp; HasPtr::operator&#x3D;(const HasPtr&amp; rhs) &#123;</span><br><span class="line">	++* rhs.use;</span><br><span class="line">	if (-- * use &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		delete ps;</span><br><span class="line">		delete use;</span><br><span class="line">	&#125;</span><br><span class="line">	ps &#x3D; rhs.ps;</span><br><span class="line">	i &#x3D; rhs.i;</span><br><span class="line">	use &#x3D; rhs.use;</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>交换操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class HasPtr &#123;</span><br><span class="line">	friend void swap(HasPtr&amp;, HasPtr&amp;);</span><br><span class="line">&#125;;</span><br><span class="line">inline void swap(HasPtr&amp; lhs, HasPtr&amp; rhs) &#123;</span><br><span class="line">	using std::swap;</span><br><span class="line">	swap(lhs.ps, rhs.ps); &#x2F;&#x2F;交换指针，而不是string数据</span><br><span class="line">	swap(lhs.i, rhs.i);   &#x2F;&#x2F;交换int成员</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本例中数据成员是内置类型的，而内置类型是没有特定版本的swap，所以调用标准库std::swap。<br>如果一个类的成员有自己类型特定的swap，调用std::swap就是错误的</p>
<p>在赋值运算符中使用swap</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HasPtr&amp; HasPtr::operator&#x3D;(HasPtr rhs) &#123;</span><br><span class="line">	swap(*this, rhs); &#x2F;&#x2F;rhs现在指向本对象曾经使用的内存</span><br><span class="line">	return *this;	  &#x2F;&#x2F;rhs被销毁，从而delete了rhs中的指针</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>rhs是按值传递，意味着HasPtr的拷贝构造函数将右侧运算对象中的string拷贝到rhs。rhs是右侧运算对象的一个副本。<br>swap调用之后，*this中的指针成员将指向新分配的string–右侧运算对象中string的一个副本<br>赋值运算符结束时，rhs被销毁，HasPtr的析构函数将执行，释放掉左侧运算对象中原来的内存。是天然异常安全的</p>
<p>拷贝控制示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">class Message &#123;</span><br><span class="line">	friend class Folder;</span><br><span class="line">public:</span><br><span class="line">	explicit Message(const string&amp; str &#x3D; &quot;&quot;) :contents(str) &#123;&#125;</span><br><span class="line">	Message(const Message&amp;);</span><br><span class="line">	Message&amp; operator&#x3D;(const Message&amp;);</span><br><span class="line">	~Message();</span><br><span class="line">	&#x2F;&#x2F;从给定Folder中添加、删除本Message</span><br><span class="line">	void save(Folder&amp;);</span><br><span class="line">	void remove(Folder&amp;);</span><br><span class="line">private:</span><br><span class="line">	string contents;</span><br><span class="line">	set&lt;Folder*&gt;folders;</span><br><span class="line">	void add_to_Folders(const Message&amp;);</span><br><span class="line">	void remove_from_Folders();</span><br><span class="line">&#125;;</span><br><span class="line">void Message::save(Folder&amp; f) &#123;</span><br><span class="line">	folders.insert(&amp;f); &#x2F;&#x2F;将给定Folder添加到我们的Folder列表中</span><br><span class="line">	f.addMsg(this);		&#x2F;&#x2F;将本Message添加到f的Message集合中</span><br><span class="line">&#125;</span><br><span class="line">void Message::remove(Folder&amp; f) &#123;</span><br><span class="line">	folders.erase(&amp;f);</span><br><span class="line">	f.remMsg(this);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;将本Message添加到指向m的Folder中</span><br><span class="line">void Message::add_to_Folders(const Message&amp; m) &#123;</span><br><span class="line">	for (auto f : m.folders) &#x2F;&#x2F;对每个包含m的Folder</span><br><span class="line">		f-&gt;addMsg(this);	 &#x2F;&#x2F;向该Folder添加一个指向本Message的指针</span><br><span class="line">&#125;</span><br><span class="line">Message::Message(const Message&amp; m) :contents(m.contents), folders(m.folders) &#123;</span><br><span class="line">	add_to_Folders(m);  &#x2F;&#x2F;将本消息添加到指向m的Folder中</span><br><span class="line">&#125;</span><br><span class="line">void Message::remove_from_Folders() &#123;</span><br><span class="line">	for (auto f : folders) &#x2F;&#x2F;对folders中每个指针</span><br><span class="line">		f-&gt;remMsg(this);   &#x2F;&#x2F;从该Folder中删除本Message</span><br><span class="line">&#125;</span><br><span class="line">Message::~Message() &#123;</span><br><span class="line">	remove_from_Folders();</span><br><span class="line">&#125;</span><br><span class="line">Message&amp; Message::operator&#x3D;(const Message&amp; rhs) &#123;</span><br><span class="line">	remove_from_Folders();	&#x2F;&#x2F;更新已有Folder</span><br><span class="line">	contents &#x3D; rhs.contents;&#x2F;&#x2F;从rhs拷贝消息内容</span><br><span class="line">	folders &#x3D; rhs.folders;  &#x2F;&#x2F;从rhs拷贝Folder指针</span><br><span class="line">	add_to_Folders(rhs);	&#x2F;&#x2F;将本Message添加到那些Folder中</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br><span class="line">void swap(Message&amp; lhs, Message&amp; rhs) &#123;</span><br><span class="line">	using std::swap;</span><br><span class="line">	&#x2F;&#x2F;将每个消息的指针从它(原来)所在Folder中删除</span><br><span class="line">	for (auto f : lhs.folders)</span><br><span class="line">		f-&gt;remMsg(&amp;lhs);</span><br><span class="line">	for (auto f : rhs.folders)</span><br><span class="line">		f-&gt;remMsg(&amp;rhs);</span><br><span class="line">	&#x2F;&#x2F;交换contents和Folder指针set</span><br><span class="line">	swap(lhs.folders, rhs.folders);</span><br><span class="line">	swap(lhs.contents, rhs.contents);</span><br><span class="line">	&#x2F;&#x2F;将每个Message的指针添加到它的(新)Folder中</span><br><span class="line">	for (auto f : lhs.folders)</span><br><span class="line">		f-&gt;addMsg(&amp;lhs);</span><br><span class="line">	for (auto f : rhs.folders)</span><br><span class="line">		f-&gt;addMsg(&amp;rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>动态内存管理类<br>vector<string>的一个简化版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">class StrVec &#123;</span><br><span class="line">public:</span><br><span class="line">	StrVec() :elements(nullptr), first_free(nullptr), cap(nullptr) &#123;&#125;</span><br><span class="line">	StrVec(const StrVec&amp;);				&#x2F;&#x2F;拷贝构造函数</span><br><span class="line">	StrVec&amp; operator&#x3D;(const StrVec&amp;);	&#x2F;&#x2F;拷贝赋值操作符</span><br><span class="line">	~StrVec();</span><br><span class="line">	void push_back(const string&amp;);</span><br><span class="line">	size_t size() const &#123; return first_free - elements; &#125;</span><br><span class="line">	size_t capacity() const &#123; return cap - elements; &#125;</span><br><span class="line">	string* begin() const &#123; return elements; &#125;</span><br><span class="line">	string* end()const &#123; return first_free; &#125;</span><br><span class="line">private:</span><br><span class="line">	Static allocator&lt;string&gt;alloc;</span><br><span class="line">	void chk_n_alloc() &#123;	&#x2F;&#x2F;被添加元素的函数所使用</span><br><span class="line">		if (size() &#x3D;&#x3D; capacity())reallocate();</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;被拷贝构造函数、赋值运算符和析构函数所使用</span><br><span class="line">	pair&lt;string*, string*&gt; alloc_n_copy(const string*, const string*);</span><br><span class="line">	void free();			&#x2F;&#x2F;销毁元素并释放内存</span><br><span class="line">	void reallocate();		&#x2F;&#x2F;获得更多内存并拷贝已有元素</span><br><span class="line">	string* elements;		&#x2F;&#x2F;指向数组首元素的指针</span><br><span class="line">	string* first_free();	&#x2F;&#x2F;指向数组第一个空闲元素的指针</span><br><span class="line">	string* cap();			&#x2F;&#x2F;指向数组尾后位置的指针</span><br><span class="line">&#125;;</span><br><span class="line">void StrVec::push_back(const string&amp; s) &#123;</span><br><span class="line">	chk_n_alloc();</span><br><span class="line">	&#x2F;&#x2F;在first_free指向的元素中构造s的副本</span><br><span class="line">	alloc.construct(first_free++, s);</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;string*,string*&gt;</span><br><span class="line">StrVec::alloc_n_copy(const string* b, const string* e) &#123;</span><br><span class="line">	auto data &#x3D; alloc.allocate(e - b);</span><br><span class="line">	return &#123; data,uninitialized_copy(b,e,data) &#125;;</span><br><span class="line">&#125;</span><br><span class="line">void StrVec::free() &#123;</span><br><span class="line">	if (elements) &#123;</span><br><span class="line">		for (auto p &#x3D; first_free; p !&#x3D; elements;)</span><br><span class="line">			alloc.destory(--p);</span><br><span class="line">		alloc.deallocate(elements, cap - elements);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">StrVec::StrVec(const StrVec&amp; s) &#123;</span><br><span class="line">	auto newdata &#x3D; alloc_n_copy(s.begin(), s.end());</span><br><span class="line">	elements &#x3D; newdata.first;</span><br><span class="line">	first_free &#x3D; cap &#x3D; newdata.second;</span><br><span class="line">&#125;</span><br><span class="line">StrVec::~StrVec() &#123;</span><br><span class="line">	free();</span><br><span class="line">&#125;</span><br><span class="line">StrVec&amp; StrVec::operator&#x3D;(const StrVec&amp; rhs) &#123;</span><br><span class="line">	&#x2F;&#x2F;调用alloc_n_copy分配内存，大小与rhs中元素占用空间一样多</span><br><span class="line">	auto data &#x3D; alloc_n_copy(rhs.begin(), rhs.end());</span><br><span class="line">	free();</span><br><span class="line">	elements &#x3D; data.first;</span><br><span class="line">	first_free &#x3D; cap &#x3D; data.second;</span><br><span class="line">	return*this;</span><br><span class="line">&#125;</span><br><span class="line">void StrVec::reallocate() &#123;</span><br><span class="line">	auto newcapacity &#x3D; size() ? 2 * size() : 1;</span><br><span class="line">	auto newdata &#x3D; alloc.allocate(newcapacity); &#x2F;&#x2F;分配新内存</span><br><span class="line">	&#x2F;&#x2F;将数据从旧内存移到新内存</span><br><span class="line">	auto dest &#x3D; newdata; &#x2F;&#x2F;指向新数组中下一个空闲位置</span><br><span class="line">	auto elem &#x3D; elements;&#x2F;&#x2F;指向旧数组中下一个元素</span><br><span class="line">	for (size_t i &#x3D; 0; i !&#x3D; size(); ++i) &#123;</span><br><span class="line">		alloc.construct(dest++, move(*elem++));</span><br><span class="line">	&#125;</span><br><span class="line">	free();</span><br><span class="line">	elements &#x3D; newdata;</span><br><span class="line">	first_free &#x3D; dest;</span><br><span class="line">	cap &#x3D; elements + newcapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>移动构造函数move，避免了string的拷贝</p>
<p>标准库容器、string和shared_ptr类既支持移动也支持拷贝。IO类和unique_ptr可以移动但不能拷贝</p>
<p>右值引用(rvalue reference) &amp;&amp;<br>必须绑定到右值的引用，只能绑定到一个将要销毁的对象<br>一般而言，左值表达式是一个对象的身份，右值表达式表示的是对象的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D; 42;</span><br><span class="line">int&amp; r &#x3D; i;			&#x2F;&#x2F;正确：r引用i</span><br><span class="line">int&amp;&amp; rr &#x3D; i;		&#x2F;&#x2F;错误：不能将一个右值引用绑定到一个左值上</span><br><span class="line">int&amp; r2 &#x3D; i * 42;	&#x2F;&#x2F;错误：i*42是一个右值</span><br><span class="line">const int&amp; r3 &#x3D; i * 42; &#x2F;&#x2F;正确：可以将一个const引用绑定到一个右值上</span><br><span class="line">int&amp;&amp; rr2 &#x3D; i * 42;	&#x2F;&#x2F;正确：将rr2绑定到乘法结果上</span><br></pre></td></tr></table></figure>
<p>返回左值表达式：返回左值引用的函数、赋值、下标、解引用、前置递增 / 递减运算符<br>返回右值表达式：返回非引用类型的函数、算术、关系、位、后置递增 / 递减运算符<br>左值有持久的状态，右值是字面常量或者表达式求值过程中创建的临时对象<br>变量是左值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int&amp;&amp; rr &#x3D; 42;	&#x2F;&#x2F;正确：字面常量是右值</span><br><span class="line">int&amp;&amp; rr2 &#x3D; rr;	&#x2F;&#x2F;错误：表达式rr是左值</span><br></pre></td></tr></table></figure>
<p>可以显式地将一个左值转换为对应右值的引用类型。可以通过调用一个move来获得绑定到左值上的右值引用，move在头文件utility中<br>int&amp;&amp; rr3 = std::move(rr1);<br>move调用告诉编译器：希望像右值一样处理一个左值。除了对rr1赋值或销毁外不再使用它。</p>
<p>移动构造函数和移动赋值运算符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StrVec::StrVec(StrVec&amp;&amp; s)noexcept &#x2F;&#x2F;移动操作不应抛出任何异常</span><br><span class="line">	:elements(s.elements), first_free(s.first_free), cap(s.cap) &#123;</span><br><span class="line">	s.elements &#x3D; s.first_free &#x3D; s.cap &#x3D; nullptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>noexcept出现在参数列表和初始化列表开始的冒号之间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class StrVec &#123;</span><br><span class="line">public:</span><br><span class="line">	StrVec(StrVec&amp;&amp;)noexcept;</span><br><span class="line">&#125;;</span><br><span class="line">StrVec::StrVec(StrVec&amp;&amp; s)noexcept :&#x2F;*初始化器*&#x2F;&#123;&#x2F;*构造函数体*&#x2F;&#125;</span><br></pre></td></tr></table></figure>
<p>若移动了部分元素后抛出异常会产生问题。</p>
<p>移动赋值运算符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">StrVec&amp; StrVec::operator&#x3D;(StrVec&amp;&amp; rhs) noexcept &#123;</span><br><span class="line">	&#x2F;&#x2F;直接检测自赋值</span><br><span class="line">	if (this !&#x3D; rhs) &#123;</span><br><span class="line">		free();</span><br><span class="line">		elements &#x3D; rhs.elements;</span><br><span class="line">		first_free &#x3D; rhs.first_free;</span><br><span class="line">		cap &#x3D; rhs.cap;</span><br><span class="line">		rhs.elements &#x3D; rhs.first_free &#x3D; rhs.cap &#x3D; nullptr;</span><br><span class="line">	&#125;</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不能在使用右侧运算对象的资源之前就释放左侧运算对象的资源(可能是相同的资源)</p>
<p>合成的移动操作<br>如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符了。会通过正常的函数匹配，用对应的拷贝操作来代替移动操作<br>只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct X &#123;</span><br><span class="line">	int i;</span><br><span class="line">	string s;</span><br><span class="line">&#125;;</span><br><span class="line">struct hasX &#123;</span><br><span class="line">	X mem;</span><br><span class="line">&#125;;</span><br><span class="line">X x, x2 &#x3D; std::move(x);			&#x2F;&#x2F;使用合成的移动构造函数</span><br><span class="line">hasX hx, hx2 &#x3D; std::move(hx);	&#x2F;&#x2F;使用合成的移动构造函数</span><br></pre></td></tr></table></figure>
<p>移动操作永远不会隐式定义为删除的函数。但如果显式地要求编译器生成=default的移动操作，且编译器不能移动所有成员，则编译器会将移动操作定义为删除的函数。<br>将合成的移动操作定义为删除的函数：<br>·移动构造函数被定义为删除的函数：有类成员定义了自己的拷贝构造函数且未定义移动构造函数；有类成员未定义自己的拷贝构造函数且编译器不能为其合成移动构造函数。移动赋值运算符的情况类似<br>·如果有类成员的移动构造函数或移动赋值运算符呗定义为删除的或是不可访问的，则类的移动构造函数或移动赋值运算符被定义为删除的<br>·如果类的析构函数被定义为删除的或不可访问的，则类的移动构造函数被定义为删除的<br>·如果有类成员是const的或引用，则类的移动赋值运算符被定义为删除的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;假定Y是一个类，定义了自己的拷贝构造函数，但未定义自己的移动构造函数</span><br><span class="line">struct hasY &#123;</span><br><span class="line">	hasY() &#x3D; default;</span><br><span class="line">	hasY(hasY&amp;&amp;) &#x3D; default;</span><br><span class="line">	Y mem;	&#x2F;&#x2F;hansY将有一个删除的移动构造函数</span><br><span class="line">&#125;;</span><br><span class="line">hanY hy, hy2 &#x3D; std::move(hy);	&#x2F;&#x2F;错误：移动构造函数是删除的</span><br></pre></td></tr></table></figure>
<p>类hasY显式地要求一个移动构造函数，但编译器无法为其生成<br>如果一个类定义了一个移动构造函数和 / 或一个移动赋值运算符，则该类的合成拷贝构造函数和拷贝赋值运算符会被定义为删除的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StrVec v1, v2;</span><br><span class="line">v1 &#x3D; v2;					&#x2F;&#x2F;v2是左值；使用拷贝赋值</span><br><span class="line">StrVec getVec(istream&amp;);	&#x2F;&#x2F;getVec返回一个右值</span><br><span class="line">v2 &#x3D; getVec(cin);			&#x2F;&#x2F;getVec(cin)是一个右值；使用移动赋值</span><br></pre></td></tr></table></figure>
<p>表达式v2是一个左值，不能隐式地将一个右值引用绑定到一个左值，所以使用拷贝赋值运算符<br>第二个中表达式是一个右值，两个赋值运算符都是可行的。但调用拷贝赋值运算符需要进行一次到const的转换，而StrVec&amp;&amp;是精确匹配。所以第二个用移动赋值运算符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">public:</span><br><span class="line">	Foo() &#x3D; default;</span><br><span class="line">	Foo(const Foo&amp;); &#x2F;&#x2F;拷贝构造函数</span><br><span class="line">&#125;;</span><br><span class="line">Foo x;</span><br><span class="line">Foo y(x);				&#x2F;&#x2F;拷贝构造函数；x是一个左值</span><br><span class="line">Foo z(std::move(x));	&#x2F;&#x2F;拷贝构造函数；未定义移动构造函数</span><br></pre></td></tr></table></figure>
<p>定义了拷贝构造函数就不会生成合成移动构造函数</p>
<p>拷贝并交换赋值运算符和移动操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class HasPtr &#123;</span><br><span class="line">public:</span><br><span class="line">	&#x2F;&#x2F;添加的移动构造函数</span><br><span class="line">	HasPtr(HasPtr&amp;&amp; p)noexcept :ps(p.ps), i(p.i) &#123; p.ps &#x3D; 0; &#125;</span><br><span class="line">	&#x2F;&#x2F;赋值运算符既是移动赋值运算符也是拷贝赋值运算符</span><br><span class="line">	HasPtr&amp; operator&#x3D;(HasPtr rhs) &#123;</span><br><span class="line">		swap(*this, rhs);</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为类添加了一个移动构造函数，接管了给定实参的值。构造体将给定的HasPtr的指针置为0，从而确保销毁移后源对象是安全的<br>赋值运算符有一个非引用参数，意味着此参数要进行拷贝初始化。依赖于实参的类型，左值被拷贝，右值被移动。因此单一的赋值运算符实现了拷贝赋值运算符和移动赋值运算符两种功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hp &#x3D; hp2;			&#x2F;&#x2F;hp2是一个左值，hp2通过拷贝构造函数来拷贝</span><br><span class="line">hp &#x3D; std::move(hp2);&#x2F;&#x2F;移动构造函数移动hp2</span><br></pre></td></tr></table></figure>
<p>Message类的移动操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;从本Message移动Folder指针</span><br><span class="line">void Message::move_Folders(Message* m) &#123;</span><br><span class="line">	folders &#x3D; std::move(m-&gt;folders);&#x2F;&#x2F;使用set的移动赋值运算符</span><br><span class="line">	for (auto f : folders) &#123; &#x2F;&#x2F;对每个Folder</span><br><span class="line">		f-&gt;remMsg(m);	&#x2F;&#x2F;从Folder中删除旧Message</span><br><span class="line">		f-&gt;addMsg(this);&#x2F;&#x2F;将本Message添加到Folder中</span><br><span class="line">	&#125;</span><br><span class="line">	m-&gt;folders.clear(); &#x2F;&#x2F;确保销毁m是无害的</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过调用move，使用了set的移动赋值运算符移动folders集合，函数遍历所有Folder，从其中删除指向原Message的指针，并添加指向新Message的指针<br>向set中插入元素要求分配内存，可能会抛出bad_alloc异常。Message的移动构造函数和移动构造运算符可能会抛出异常，所以未标记为noexcept</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Message::Message(Message&amp;&amp; m) :contents(std::move(m.contents)) &#123;</span><br><span class="line">	move_Folders(&amp;m); &#x2F;&#x2F;移动folders并更新Folder指针</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Message的移动构造函数调用move来移动contents，并默认初始化自己的folders成员</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Message&amp; Message::operator&#x3D;(Message&amp;&amp; rhs) &#123;</span><br><span class="line">	if (this !&#x3D; &amp;rhs) &#123;		&#x2F;&#x2F;直接检查自赋值情况</span><br><span class="line">		remove_from_Folders();</span><br><span class="line">		contents &#x3D; std::move(rhs.contents); &#x2F;&#x2F;移动赋值运算符</span><br><span class="line">		move_Folders(&amp;rhs);	&#x2F;&#x2F;重置Folders指向本Message</span><br><span class="line">	&#125;</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>移动迭代器(move iterator)<br>移动迭代器的解引用生成一个右值引用<br>通过调用标准库的make_move_iterator函数将一个普通迭代器转换为一个移动迭代器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void StrVec::reallovate() &#123;</span><br><span class="line">	auto newcapacity &#x3D; size() ? 2 + size() : 1;</span><br><span class="line">	auto first &#x3D; alloc.allocate(newcapacity);</span><br><span class="line">	&#x2F;&#x2F;移动元素</span><br><span class="line">	auto last &#x3D; uninitialized_copy(make_move_iterator(begin()), make_move_iterator(end()), first);</span><br><span class="line">	free();</span><br><span class="line">	elements &#x3D; first;</span><br><span class="line">	first_free &#x3D; last;</span><br><span class="line">	cap &#x3D; elements + newcapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>unitialized_copy对输入序列中的每个元素调用construct来将元素“拷贝”到目的位置。此算法使用迭代器的解引用运算符从输入序列中提取元素，生成的是一个右值引用，意味着construct将使用移动构造函数来构造元素</p>
<p>由于一个移后源对象具有不确定的状态，对其调用std::move是危险的。当我们调用move时，必须确定移后源对象没有其他用户</p>
<p>右值引用和成员函数<br>允许移动的成员函数通常使用与拷贝 / 移动构造函数和赋值运算符相同的参数模式–一个版本接受一个指向const的左值引用，一个接受一个指向非const的右值引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void push_back(const X&amp;);	&#x2F;&#x2F;拷贝：绑定到任意类型的X</span><br><span class="line">void push_back(X&amp;&amp;);		&#x2F;&#x2F;移动：只能绑定到类型X的可修改的右值</span><br></pre></td></tr></table></figure>
<p>一般来说，不需要为函数操作定义接受一个const X&amp;&amp;或是X&amp;参数的版本。<br>当我们希望从实参“窃取”数据时，通常需要传递一个右值，不能是const的；从一个对象拷贝操作不应该改变该对象，因此通常不需要X&amp;版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class StrVec &#123;</span><br><span class="line">public:</span><br><span class="line">	void push_back(const string&amp;);</span><br><span class="line">	void push_back(strng&amp;&amp;);</span><br><span class="line">&#125;;</span><br><span class="line">void StrVec::push_back(const string&amp; s) &#123;</span><br><span class="line">	chk_n_alloc();	&#x2F;&#x2F;确保有空间容纳新元素</span><br><span class="line">	&#x2F;&#x2F;在first_free指向的元素中构造s的一个副本</span><br><span class="line">	alloc.construct(first_free++, s);</span><br><span class="line">&#125;</span><br><span class="line">void StrVec::push_back(string&amp;&amp; s) &#123;</span><br><span class="line">	chk_n_alloc();</span><br><span class="line">	alloc.construct(first_free++, std::move(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>construct函数使用其第二个和随后的实参类型确定使用哪个构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StrVec vec;</span><br><span class="line">string s &#x3D; &quot;some string or another&quot;;</span><br><span class="line">vec.push_back(s);		&#x2F;&#x2F;调用push_back(const string&amp;)</span><br><span class="line">vec.push_back(&quot;done&quot;);	&#x2F;&#x2F;调用push_back(string&amp;&amp;),右值，从&quot;done&quot;创建的临时string</span><br></pre></td></tr></table></figure>
<p>右值和左值成员函数<br>通过在参数列表后放置一个引用限定符(reference qualifier)来指出左值/右值属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">public:</span><br><span class="line">	Foo&amp; operator&#x3D;(const Foo&amp;)&amp;; &#x2F;&#x2F;只能向可修改的左值赋值</span><br><span class="line">&#125;;</span><br><span class="line">Foo&amp; Foo::operator&#x3D;(const Foo&amp; rhs)&amp; &#123;</span><br><span class="line">	&#x2F;&#x2F;执行所需操作</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引用限定符可以是&amp; 或&amp;&amp; ，指出this可以指向一个左值或右值。只能用于非static成员函数，且必须同时出现在函数的声明和定义中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Foo&amp; retFoo();	&#x2F;&#x2F;返回一个引用；retFoo调用是一个左值</span><br><span class="line">Foo retVal();	&#x2F;&#x2F;返回一直值；retVal调用是一个右值</span><br><span class="line">Foo i, j;		&#x2F;&#x2F;i和j是左值</span><br><span class="line">i &#x3D; j;			&#x2F;&#x2F;正确：i是左值</span><br><span class="line">retFoo() &#x3D; j;	&#x2F;&#x2F;正确：retFoo()返回一个左值</span><br><span class="line">retVal() &#x3D; j;	&#x2F;&#x2F;错误：retVal()返回一个右值</span><br><span class="line">i &#x3D; retVal();	&#x2F;&#x2F;正确：可以将一个右值作为赋值操作的右侧运算对象</span><br></pre></td></tr></table></figure>
<p>一个函数可以同时用const和引用限定。引用限定符必须跟随在const限定符之后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">public:</span><br><span class="line">	Foo someMen()&amp; const;	&#x2F;&#x2F;错误</span><br><span class="line">	Foo anotherMen()const&amp;;	&#x2F;&#x2F;正确</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>引用限定符也可以区分重载版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">public:</span><br><span class="line">	Foo sorted()&amp;&amp;;</span><br><span class="line">	Foo sorted()const&amp;;</span><br><span class="line">private:</span><br><span class="line">	vector&lt;int&gt;data;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;本对象为右值，可以原址排序</span><br><span class="line">Foo Foo::sorted()&amp;&amp; &#123;</span><br><span class="line">	sort(data.begin(), data.end());</span><br><span class="line">	return*this;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;本对象是const或是左值，不能进行原址排序</span><br><span class="line">Foo Foo::sorted()const&amp; &#123;</span><br><span class="line">	Foo ret(*this);							&#x2F;&#x2F;拷贝一个副本</span><br><span class="line">	sort(ret.data.begin(), ret.data.end());	&#x2F;&#x2F;排序副本</span><br><span class="line">	return ret;								&#x2F;&#x2F;返回副本</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对象是一个右值意味着没有其他用户，可以改变对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">retVal().sorted();	&#x2F;&#x2F;retVal是一个右值，调用Foo::sorted()&amp;&amp;</span><br><span class="line">retFoo().sorted();	&#x2F;&#x2F;retFoo是一个左值，调用Foo::sorted()const&amp;</span><br></pre></td></tr></table></figure>
<p>如果定义两个或以上具有相同名字和相同参数列表的成员函数，就必须对所有函数都加上引用限定符，或者所有都不加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">public:</span><br><span class="line">	Foo sorted()&amp;&amp;;</span><br><span class="line">	Foo sorted() const;	&#x2F;&#x2F;错误：必须加上引用限定符</span><br><span class="line">	&#x2F;&#x2F;Comp是函数类型的类型别名，此函数类型可以用来比较int值</span><br><span class="line">	using Comp &#x3D; bool(const int&amp;, const int&amp;);</span><br><span class="line">	Foo sorted(Comp*);		&#x2F;&#x2F;正确：不同的参数列表</span><br><span class="line">	Foo sorted(Comp*)const;	&#x2F;&#x2F;正确：两个都没哟引用限定符</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/30/c-primer-13-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/" data-id="ckhua8rnu000vxsved3ynb3u4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-primer/" rel="tag">c++ primer</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-c-primer-12-动态内存" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/30/c-primer-12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/" class="article-date">
  <time datetime="2020-08-30T02:42:59.000Z" itemprop="datePublished">2020-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/30/c-primer-12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/">c++ primer 12 动态内存</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h1><p>静态内存保存局部static对象、类static数据成员以及定义在任何函数之外的变量；栈内存用了保存定义在函数内的非static对象。<br>静态内存或栈内存中的对象由编译器自动创建和销毁。<br>栈对象仅在其定义的程序块运行时才存在；static对象在使用之前分配，程序结束时销毁</p>
<p>动态内存管理<br>new：在动态内存中为对象分配空间并返回一个指向该对象的指针，可以选择对对象进行初始化<br>delete：接受一个动态对象的指针，销毁该对象，并释放与之关联的内存</p>
<p>智能指针：shared_ptr允许多个指针指向同一个对象；unique_ptr“独占”所指向对象<br>shared_ptr<string>p1;  shared_ptr&lt;list<int>&gt;p2;<br>默认初始化的智能指针中保存着一个空指针<br>————————————————————————————– - 401</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;int&gt;p3 &#x3D; make_shared &lt;int&gt;(42);              &#x2F;&#x2F;指向一个值为42的int的shared_ptr</span><br><span class="line">shared_ptr&lt;string&gt;p4 &#x3D; make_shared&lt;string&gt;(10, &#39;9&#39;);  &#x2F;&#x2F;指向一个值为&quot;9999999999&quot;的string</span><br><span class="line">shared_ptr&lt;int&gt;p5 &#x3D; make_shared&lt;int&gt;();               &#x2F;&#x2F;指向一个值初始化的int，即0</span><br><span class="line">auto p6 &#x3D; make_shared&lt;vector&lt;int&gt;&gt;();</span><br></pre></td></tr></table></figure>
<p>make_shared用其参数来构造给定类型的对象。make_shared<string>的参数必须与string的某个构造函数相匹配，不传递任何参数，对象就会进行值初始化</p>
<p>当进行拷贝或赋值操作时，每个shared_ptr都会记录有多少个其他的shared_ptr指向相同的对象<br>可以认为每个shared_ptr都有一个关联的计数器，引用计数(reference count)。无论何时拷贝一个shared_ptr，计数器都会递增。<br>如：用一个shared_ptr初始化另一个shared_ptr、将它作为参数传递给一个函数以及作为函数的返回值<br>当给shared_ptr赋予一个新值或是shared_ptr被销毁(例如一个局部的shared_ptr离开其作用域)时，计数器递减<br>一旦一个shared_ptr的计数器变为0，它就会自动释放自己所管理的对象<br>auto r = make_shared<int>(42);<br>r = q; //给r赋值，令它指向另一个地址；递增q指向的对象的引用计数；递减r原来指向的对象的；r原来的对象已没有引用者，会自动释放</p>
<p>销毁是通过析构函数完成。shared_ptr的析构函数会递减它所指向的对象的引用计数，变为0后shared_ptr的析构函数就会销毁对象，并释放它们占用的内存<br>若将shared_ptr存在容器中，而后不再需要全部元素，记得用erase删除不再需要的元素</p>
<p>使用动态生存期的资源的类：<br>·程序不知道自己需要多少对象<br>·程序不知道所需对象的准确类型<br>·程序需要在多个对象间共享数据</p>
<p>定义StrBlob类<br>假定b1，b2是两个Blob对象，共享相同的vector。为了保证vector中的元素继续存在，将vector保存在动态内存中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class StrBlob &#123;</span><br><span class="line">public:</span><br><span class="line">	typedef vector&lt;string&gt;::size_type size_type;</span><br><span class="line">	StrBlob() :data(make_shared&lt;vector&lt;string&gt;&gt;()) &#123;&#125;;  &#x2F;&#x2F;两个构造函数都是用初始化列表来初始化其data成员，令它指向一个动态分配的vector</span><br><span class="line">	StrBlob(initializer_list&lt;string&gt;il) :data(make_shared&lt;vector&lt;string&gt;&gt;(il)) &#123;&#125;;</span><br><span class="line">	size_type size()const &#123; return data-&gt;size; &#125;</span><br><span class="line">	bool empty() const &#123; return data-&gt;empty(); &#125;</span><br><span class="line">	void push_back(const string&amp; t) &#123; data-&gt;push_back(t); &#125;</span><br><span class="line">	void pop_back() &#123;</span><br><span class="line">		check(0, &quot;pop_back on empty StrBlob&quot;);</span><br><span class="line">		return data-&gt;pop();</span><br><span class="line">	&#125;</span><br><span class="line">	string&amp; front() &#123;</span><br><span class="line">		check(0, &quot;front on empty StrBlob&quot;);</span><br><span class="line">		return data-&gt;front();</span><br><span class="line">	&#125;</span><br><span class="line">	string&amp; back() &#123;</span><br><span class="line">		check(0, &quot;back on empty StrBLob&quot;);</span><br><span class="line">		return data-&gt;back();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">private:</span><br><span class="line">	shared_ptr&lt;vector&lt;string&gt;&gt;data;</span><br><span class="line">	void check(size_type i, const string&amp; msg)const &#123;</span><br><span class="line">		if (i &gt;&#x3D; data-&gt;size())throw out_of_range(msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>直接管理内存<br>在自由空间分配的内存是无名的，因此new无法为其分配的对象命名，而是返回一个指向该对象的指针<br>默认情况下动态分配的对象是默认初始化的，意味着内置类型或组合类型的对象的值将是未定义的，类类型对象用默认构造函数进行初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int* pi &#x3D; new int; &#x2F;&#x2F;pi指向一个未初始化的int</span><br><span class="line">int* pi1 &#x3D; new int(); &#x2F;&#x2F;值初始化为0；*p2为0</span><br><span class="line">string* ps &#x3D; new string; &#x2F;&#x2F;默认初始化为空string</span><br><span class="line">string* ps1 &#x3D; new string(); &#x2F;&#x2F;值初始化为空string</span><br><span class="line">int* pi &#x3D; new int(1024);</span><br><span class="line">string* ps &#x3D; new string(10, &#39;9&#39;);</span><br><span class="line">vector&lt;int&gt;* pv &#x3D; new vector&lt;int&gt;&#123; 0,1,2,3,4,5,6,7,8,9 &#125;;</span><br><span class="line"></span><br><span class="line">auto p1 &#x3D; new auto(obj);  &#x2F;&#x2F;p指向一个与obj类型相同的对象，该对象用obj进行初始化</span><br><span class="line">auto p2 &#x3D; new auto&#123;a.b.c&#125;; &#x2F;&#x2F;错误：括号中只能有单个初始化器</span><br><span class="line"></span><br><span class="line">const int* pci &#x3D; new const int(1024); &#x2F;&#x2F;分配并初始化一个const int</span><br><span class="line">const string* pcs &#x3D; new const string; &#x2F;&#x2F;分配并默认初始化一个const的空string</span><br><span class="line">new返回的指针是一个指向const的指针</span><br><span class="line"></span><br><span class="line">int* p1 &#x3D; new int; &#x2F;&#x2F;如果内存耗尽，分配失败，抛出std:bad_alloc</span><br><span class="line">int* p1 &#x3D; new(nothrow)int; &#x2F;&#x2F;如果分配失败，new返回一个空指针</span><br></pre></td></tr></table></figure>
<p>delete表达式执行：销毁给定的指针指向的对象；释放对应的内存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int i, * pi1 &#x3D; &amp;i, * pi2 &#x3D; nullptr;</span><br><span class="line">double* pd &#x3D; new double(33), * pd2 &#x3D; pd;</span><br><span class="line">delete i;   &#x2F;&#x2F;错误：i不是一个指针</span><br><span class="line">delete pi1; &#x2F;&#x2F;未定义：pi1指向一个局部变量</span><br><span class="line">delete pd;  &#x2F;&#x2F;正确</span><br><span class="line">delete pd2; &#x2F;&#x2F;未定义：pd2指向的内存已经被释放了</span><br><span class="line">delete pi2; &#x2F;&#x2F;正确：释放一个空指针总是没有错误的</span><br><span class="line">const int* pci &#x3D; new const int(1024);</span><br><span class="line">delete pci; &#x2F;&#x2F;正确：释放一个const对象</span><br></pre></td></tr></table></figure>
<p>动态对象的生存期直到被释放时为止</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Foo* factory(T arg) &#123;</span><br><span class="line">	return new Foo(arg);</span><br><span class="line">&#125;</span><br><span class="line">void use_factory(T arg) &#123;</span><br><span class="line">	Foo* p &#x3D; factory(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>use_factory返回后，内置指针p被销毁，但动态内存不会被自动释放，p是指向该内存唯一指针，use_factory返回后，程序就没办法释放该内存了</p>
<p>改正：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Foo* use_factory(T arg) &#123;</span><br><span class="line">	Foo* p &#x3D; factory(arg);</span><br><span class="line">	return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>系统中其他代码可能使用use_factory所分配的对象，又之后来释放<br>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void use_factory(T arg) &#123;</span><br><span class="line">	Foo* p &#x3D; factory(arg);</span><br><span class="line">	delete p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>new和delete管理动态内存常见问题：<br>·忘记delete内存。导致内存泄漏，该内存永远不可能被还给自由空间<br>·使用已经释放掉的对象。通过在释放后将指针置空，有时可以检测到这种错误<br>·同一块内存释放两次。自由空间可能被破坏</p>
<p>delete指针后，指针值就变为无效了。但很多机器上指针仍然保存着(已经释放了的)动态内存的地址。<br>delete之后指针就变成悬空指针，即指向一块曾经保存数据对象但现在已经无效的内存的指针<br>在指针即将要离开其作用域之前释放掉它所关联的内存。需要保留指针可以在delete之后将nullptr赋予指针<br>int* p = new int(42); auto q = p;<br>delete p; p = nullptr;<br>重置p对q没有任何作用</p>
<p>可以用new返回的指针来初始化智能指针<br>接受指针参数的只能指针构造函数是explicit的。因此，不能将一个内置指针隐式转换为一个智能指针，必须使用直接初始化形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;int&gt;p1 &#x3D; new int(1024); &#x2F;&#x2F;错误：必须使用直接初始化形式。new返回了内置指针int*</span><br><span class="line">shared_ptr&lt;int&gt;p2(new int(1024));  &#x2F;&#x2F;正确</span><br><span class="line">shared_ptr&lt;int&gt; clone(int p) &#123;</span><br><span class="line">	return new int(p);  &#x2F;&#x2F;错误：隐式转换为shared_ptr&lt;int&gt;</span><br><span class="line">&#125;</span><br><span class="line">shared_ptr&lt;int&gt; clone(int p) &#123;</span><br><span class="line">	return shared_ptr&lt;int&gt;(new int(p))  &#x2F;&#x2F;正确：显式地用int*创建shared_ptr&lt;int&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>p421</p>
<p>不要混合使用普通指针和智能指针。使用内置指针来访问一个只能指针所负责的对象是危险的，不知道对象何时会被销毁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void process(shared_ptr&lt;int&gt; ptr) &#123;</span><br><span class="line">	&#x2F;&#x2F;使用ptr</span><br><span class="line">&#125;&#x2F;&#x2F;ptr离开作用域，被销毁</span><br><span class="line"></span><br><span class="line">shared_ptr&lt;int&gt;p(new int(42)); &#x2F;&#x2F;引用计数为1</span><br><span class="line">process(p);  &#x2F;&#x2F;拷贝p会递增它的引用计数；在process中引用计数值为2</span><br><span class="line">int i &#x3D; *p;  &#x2F;&#x2F;正确：引用计数值为1</span><br><span class="line"></span><br><span class="line">int* x(new int(1024));</span><br><span class="line">process(x);  &#x2F;&#x2F;错误：不能将int*转换为shared_ptr&lt;int&gt;</span><br><span class="line">process(share_ptr&lt;int&gt;(x)); &#x2F;&#x2F;合法，但内存会被释放</span><br><span class="line">int j &#x3D; *x;  &#x2F;&#x2F;未定义的：x是一个悬空指针</span><br></pre></td></tr></table></figure>
<p>将临时的shared_ptr传递给process，表达式结束时临时对象被销毁，销毁时递减引用计数，变为0<br>x指向已经释放的内存，从而变成一个悬空指针</p>
<p>不要使用get初始化另一个智能指针或为智能指针赋值<br>get函数返回一个内置指针，指向智能指针管理的对象。使用get返回的指针的代码不能delete此指针</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;int&gt;p(new int(42));</span><br><span class="line">int* q &#x3D; p.get();</span><br><span class="line">&#123; &#x2F;&#x2F;新程序块</span><br><span class="line">	shared_ptr&lt;int&gt;(q);</span><br><span class="line">&#125; &#x2F;&#x2F;程序块结束，q被销毁，它指向的内存被释放</span><br><span class="line">int foo &#x3D; *p;  &#x2F;&#x2F;未定义：p指向的内存已经被释放了</span><br><span class="line"></span><br><span class="line">p &#x3D; new int(1024);   &#x2F;&#x2F;错误：不能将一个指针赋予shated_ptr</span><br><span class="line">p.reset(new int(1024)); &#x2F;&#x2F;正确：p指向一个新对象</span><br><span class="line"></span><br><span class="line">if (!p.unique())p.reset(new string(*p)); &#x2F;&#x2F;不是当前对象唯一用户，分配新的拷贝</span><br><span class="line">*p +&#x3D; val; &#x2F;&#x2F;是唯一用户，可以改变对象的值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void f() &#123;</span><br><span class="line">	int* ip &#x3D; new int(42);</span><br><span class="line">	&#x2F;&#x2F;代码中间抛出异常</span><br><span class="line">	delete ip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>new和delete直接发生异常，且异常未在f中被捕获，则内存用于不会被释放了</p>
<p>不是所有的类都定义了析构函数，有的需要手动管理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct destination;</span><br><span class="line">struct connection;</span><br><span class="line">connection connect(destination*);</span><br><span class="line">void disconnect(connection);</span><br><span class="line">void f(destination&amp; d &#x2F;*其他参数*&#x2F;) &#123;</span><br><span class="line">	connection c &#x3D; connect(&amp;d);</span><br><span class="line">	&#x2F;&#x2F;使用链接</span><br><span class="line">	&#x2F;&#x2F;若退出f前忘记调用disconnect，就无法关闭c了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义一个函数来代替delete。这个删除器函数能释放shared_ptr<br>void end_connection(connection* p) { disconnection(p); }<br>void f(disconnect&amp; d /**/) {<br>    connection c = connect(&amp;d);<br>    shared_ptr<connection>p(&amp;c, end_connection);<br>    //当f退出时，connection会被正确关闭，发生异常时也会<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr</span><br><span class="line">定义时需要将其绑到一个new返回的指针上，必须采用直接初始化的形式，不能拷贝或赋值</span><br></pre></td></tr></table></figure>
<p>unique_ptr<double>p;<br>unique_ptr<int>pp(new int(42));<br>unique_ptr<string>p1(new string(“hello”));<br>unique_ptr<string>p2(p1); //错误：不支持拷贝<br>unique_ptr<string>p3; p3 = p1; //错误：不支持赋值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--------------------------------------------------------------------418</span><br></pre></td></tr></table></figure>
<p>unique_ptr<string>p2(p1.release()); //release将p1置空<br>unique_ptr<string>p3(new string(“hi”));<br>p2.reset(p3.release()); //reset释放了p2原来指向的内存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">只可以拷贝或赋值将要被销毁的unique_ptr</span><br></pre></td></tr></table></figure>
<p>unique_ptr<int> clone(int p) {<br>    return unique_ptr<int>(new int(p));<br>}<br>unique_ptr<int> clone(int p) {<br>    unique_ptr<int>ret(new int(p));<br>    return ret;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">向unique_ptr传递删除器</span><br></pre></td></tr></table></figure>
<p>void f(destination&amp; d /<em>*/) {<br>    connect c = connect(&amp;d);<br>    unique_ptr&lt;connection, decltype(end_connection)</em>&gt;p(&amp;c, end_connection);<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">使用了decltype来指明函数指针类型。必须添加一个* 来指出我们正在使用该类型的一个指针</span><br><span class="line"></span><br><span class="line">weak_ptr</span><br><span class="line">weak_ptr是一种不控制所致对象生存期的只能指针，指向一个shared_ptr管理的对象。weak_ptr绑定时不会改变shared_ptr的引用计数</span><br><span class="line">------------------------------------------------------------------ - 420</span><br><span class="line">weak_ptr创建时，要用shared_ptr来初始化它</span><br><span class="line">auto p &#x3D; make_shared&lt;int&gt;(42);</span><br><span class="line">weak_ptr&lt;int&gt;wp(p);</span><br><span class="line">由于对象可能不存在，所以不能直接访问对象，调用lock</span><br><span class="line">if(shared_ptr&lt;int&gt;np&#x3D;wp.lock())&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">动态数组</span><br><span class="line">new分配一个对象数组，要再类型名之后跟一对方括号，其中指明分配对象的数目。返回指向第一个对象的指针</span><br></pre></td></tr></table></figure>
<p>int* pia = new int[get_size()];<br>typedef int arrT[42];<br>int* p = new arrT; //分配一个42个int的数组，p指向第一个int  int* p=new int[42]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new分配一个数组时，得到一个数组元素类型的指针，并未得到一个数组类型的对象。</span><br><span class="line">所以不能调用begin或end等，也不能用for语句遍历</span><br></pre></td></tr></table></figure>
<p>int* pia = new int[10];          //10个未初始化的int<br>int* pia2 = new int<a href="">10</a>;       //10个值初始化为0的int<br>string* psa = new string[10];    //10个空string<br>string* psa2 = new string<a href="">10</a>; //10个空string<br>int* pia3 = new int[5]{ 1,2,3,6,0 };  //10个int分别用列表中对应的初始化器初始化<br>string* psa3 = new string[10]{ “a”,”an”,”the”,(5,’x’) }; //10个string，前四个用给定的初始化器初始化，后6个进行值初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">若初始化器数目大于元素数目，则new表达式失败，不会分配任何内存。此例中会抛出bad_array_new_length异常</span><br><span class="line"></span><br><span class="line">动态分配一个空数组是合法的</span><br></pre></td></tr></table></figure>
<p>char arr[0];  //错误：不能定义长度为0的数组<br>char* cp = new char[0];  //正确：但cp不能解引用<br>new分配一个大小为0的数组时，返回一个合法的空指针。类似尾后指针。可以进行比较操作、加减0、减去自身得到0。但不能解引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">释放动态数组</span><br></pre></td></tr></table></figure>
<p>delete p;    //p必须指向一个动态分配的对象或为空<br>delete[] pa; //pa必须指向一个动态分配的数组或为空</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr管理动态数组</span><br></pre></td></tr></table></figure>
<p>unique_ptr&lt;int[]&gt;up(new int[10]);<br>up.release(); //自动用delete[]销毁其指针</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">当unique_ptr指向一个数组时，不能使用点和箭头成员运算符，指向的是一个数组，而不是单个对象。可以使用下标运算符来访问数组中元素</span><br><span class="line">for (size_t i &#x3D; 0; i !&#x3D; 10; ++i)up[i] &#x3D; i;</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------426</span><br><span class="line"></span><br><span class="line">shared_ptr不直接支持管理动态数组，需要提供自定义的删除器</span><br><span class="line">shared_ptr&lt;int&gt;sp(new int[10], [](int* p) &#123;delete[] p; )&#125;;</span><br><span class="line">sp.reset();  &#x2F;&#x2F;使用提供的lambda释放数组</span><br><span class="line">访问元素，必须用get获取一个内置指针，然后用它来访问元素</span><br></pre></td></tr></table></figure>
<p>for (size_t i = 0; i != 10; ++i)<br>    * (sp.get() + i) = i;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">allocator类</span><br><span class="line">一般情况下，将内存分配和对象构造组合在一起可能会导致不必要的浪费</span><br><span class="line">allocator对象分配内存时，会根据给定的对象类型来确定个恰当的内存大小和对齐位置</span><br></pre></td></tr></table></figure>
<p>allovator<string>alloc;      //可以分配string的allocator对象<br>auto const p = alloc.allocate(n); //分配n个未初始化的string</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--------------------------------------------------------428</span><br></pre></td></tr></table></figure>
<p>auto q = p;  //q指向最后构造的元素之后的位置<br>alloc.construct(q++);        //<em>q为空字符串<br>alloc.construct(q++, 10, c); //</em>q为cccccccccc<br>alloc.construct(q++, “hi”);  //*q为hi</p>
<p>cout &lt;&lt; *p &lt;&lt; endl; //正确：使用string的输出运算符<br>cout &lt;&lt; *q &lt;&lt; endl; //错误：q指向未构造的内存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while (q !&#x3D; p)alloc.destory(--q);</span><br><span class="line">只能对真正构造了的元素进行destory</span><br><span class="line"></span><br><span class="line">alloc.deallocate(p, n); &#x2F;&#x2F;释放内存</span><br><span class="line"></span><br><span class="line">拷贝和填充未初始化内存</span><br><span class="line">------------------------------------------------------------------------429</span><br></pre></td></tr></table></figure>
<p>auto p = alloc.allocate(vi.size() * 2);    //分配比vi大一倍的空间<br>auto q = uniitialized_copy(vi.begin(), vi.end(), p); //通过拷贝vi中的元素来构造从p开始的元素，q指向最后一个构造的元素之后的位置<br>uninitialized_fill_n(q, vi.size(), 42);  //将剩余元素初始化为42</p>
<pre><code>
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/30/c-primer-12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/" data-id="ckhua8rns000mxsve16er5zn1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-primer/" rel="tag">c++ primer</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-c-primer-11-关联容器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/30/c-primer-11-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/" class="article-date">
  <time datetime="2020-08-30T02:40:52.000Z" itemprop="datePublished">2020-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/30/c-primer-11-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/">c++ primer 11 关联容器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="关联容器-associative-container"><a href="#关联容器-associative-container" class="headerlink" title="关联容器(associative_container)"></a>关联容器(associative_container)</h1><p>关联容器支持高效的关键字查找和访问<br>不同的关联容器体现在：set或map；是否允许重复关键字(multi)；是否按顺序保存(unordered)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;统计单词出现次数</span><br><span class="line">map&lt;string, size_t&gt;word_count;</span><br><span class="line">string word;</span><br><span class="line">while (cin &gt;&gt; word)++word_count[word];</span><br><span class="line">for (const auto&amp; w : word_count)cout &lt;&lt; w.first &lt;&lt; &quot; occurs &quot; &lt;&lt; w.second &lt;&lt; &quot; times &quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用set</span><br><span class="line">map&lt;string, size_t&gt;word_count;</span><br><span class="line">set&lt;string&gt;exclude &#x3D; &#123; &quot;a&quot;,&quot;an&quot;,&quot;the&quot; &#125;;</span><br><span class="line">string word;</span><br><span class="line">while (cin &gt;&gt; word) &#123;</span><br><span class="line">	if (exclude.find(word) &#x3D;&#x3D; exclude.end())word_count[word]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用关键字类型的比较函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bool compareIsbn(const Sales_data &amp; lhs, const Sales_data &amp; rhs) &#123; return lhs.isbn() &lt; rhs.isbn(); &#125;</span><br><span class="line">multiset&lt;Sales_data, decltype(compareIsbn)*&gt;bookstore(compareIsbn);</span><br></pre></td></tr></table></figure>
<p>为使用自定义操作，定义时我们必须提供关键字类型Sales_data，以及比较操作类型–一种函数指针类型，可以指向compareIsbn。<br>定义对象时，提供一个指向compareIsbn的指针</p>
<h3 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h3><p>———————————–380</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;string,int&gt;</span><br><span class="line">process(vector&lt;string&gt; &amp; v) &#123;</span><br><span class="line">	if (!v.empty())return &#123; v.back(),v.back().size() &#125;;</span><br><span class="line">	else return pair&lt;string, int&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!v.empty())return pair&lt;string, int&gt;(v.back(), v.back().size());</span><br><span class="line">if (!v.empty())return make_pair(v.back(), v.back().size());</span><br><span class="line"></span><br><span class="line">map&lt;string, int&gt;::value_type v1; &#x2F;&#x2F;v1是一个pair&lt;const string,int&gt;</span><br><span class="line">map&lt;string, int&gt;::key_type v2; &#x2F;&#x2F;v2是一个string</span><br><span class="line">map&lt;string, int&gt;::mapped_type v3; &#x2F;&#x2F;v3是一个int</span><br></pre></td></tr></table></figure>
<p>初始化map时，必须提供关键字类型和值类型。将其包围在花括号中{ key,value }</p>
<p>添加元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt;v &#x3D; &#123; 2,4,6,8,2,4,6,8 &#125;;</span><br><span class="line">set&lt;int&gt;s;</span><br><span class="line">s.insert(v.begin(), v.end()); &#x2F;&#x2F;有4个元素</span><br><span class="line">s.insert(&#123; 1,3,5,7,1,3,5,7 &#125;); &#x2F;&#x2F;有8个元素</span><br><span class="line"></span><br><span class="line">word_count.insert(&#123;word,1&#125;);</span><br><span class="line">word_count.insert(make_pair(word,1));</span><br><span class="line">word_count.insert(pair&lt;string,size_t&gt;(word,1));</span><br><span class="line">word_count.insert(map&lt;string,size_t&gt;::value_type(word,1));</span><br></pre></td></tr></table></figure>
<p>——————————————————————384</p>
<p>对于不包含重复关键字的容器，添加单一元素的insert和emplace返回一个pair，first是指向给定关键字元素的迭代器，second是bool类型，是否成功</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, size_t&gt;word_count; string word;</span><br><span class="line">while (cin &gt;&gt; word) &#123;</span><br><span class="line">	auto ret &#x3D; word_count.insert(&#123; word,1 &#125;);</span><br><span class="line">	if (!ret.second)++ret-&gt;first.second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除元素<br>——————————————————387</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map的下标操作</span><br><span class="line">word_count[&quot;anna&quot;] &#x3D; 1;</span><br></pre></td></tr></table></figure>
<p>在word_count搜索关键字为anna的元素，未找到；将新关键字 - 值对插入到word_count中，关键字是一个const string，保存anna。值进行初始化，0；<br>提取出新插入的元素，并将值1赋予它<br>只能对非const的map使用下标操作</p>
<p>c[k]：返回关键字为k的元素；如果k不在c中，添加一个关键字为k的元素，对其初始化<br>c.at(k)：访问关键字为k的元素，带参数检查；若k不在c中，抛出一个out_of_range异常</p>
<p>与vector和string不同，map下标运算符返回的类型(mapped_type)与解引用map迭代器得到的类型不同(value_type)</p>
<p>———————————————————————————— - 389</p>
<p>multimap或multiset中查找元素<br>有多个元素具有给定关键字，它们会相邻储存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">string search_item(&quot;Target&quot;);</span><br><span class="line">auto entries &#x3D; authors.count(search_item);</span><br><span class="line">auto iter &#x3D; authors.find(search_item);</span><br><span class="line">while (entries) &#123;</span><br><span class="line">	cout &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">	++iter;</span><br><span class="line">	--entries;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (auto beg &#x3D; authors.lower_bound(search_item), end &#x3D; authors.upper_bound(search_item); beg !&#x3D; end; ++beg) &#123;</span><br><span class="line">	cout &lt;&lt; beg-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (auto pos &#x3D; authors.equal_range(search_item); pos.first !&#x3D; pos.second; ++pos.first;)cout &lt;&lt; pos.first-&gt;second &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>无序容器(unordered associative container)<br>使用哈希函数(hash function)和关键字类型的 == 运算符来组织元素</p>
<p>——————————————– - 395</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">size_t hasher(const Sales_data&amp; sd) &#123; return hash&lt;string&gt;()(sd.isbn()); &#125;</span><br><span class="line">bool eqOp(const Sales_data&amp; lhs, const Sales_data&amp; rhs) &#123; return lhs.isbn() &#x3D;&#x3D; rhs.isbn(); &#125;</span><br><span class="line">using SD_multiset&#x3D;unordered_multiset&lt;Sales_data, decltype(hasher)*, decltype(eqOp)*&gt;;</span><br><span class="line">SD_multiset bookStore(42, hasher, eqOp);</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/30/c-primer-11-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/" data-id="ckhua8rnt000qxsvec9r4fjwq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-primer/" rel="tag">c++ primer</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-c-primer-10-泛型算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/30/c-primer-10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/" class="article-date">
  <time datetime="2020-08-30T02:36:34.000Z" itemprop="datePublished">2020-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/30/c-primer-10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/">c++ primer 10 泛型算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="泛型算法"><a href="#泛型算法" class="headerlink" title="泛型算法"></a>泛型算法</h1><p>标准库定义了一组泛型算法来实现查找特定元素、替换或删除等操作<br>泛型：可以用于不同各类型的元素和多种容器类型<br>算法：实现了一些经典算法的公共接口，如排序和搜索等<br>大多数算法都定义在头文件algorithm中，在numeric中定义了一组数值泛型算法<br>迭代器领算法不依赖于容器，但算法依赖于元素类型的操作<br>泛型算法本身不会执行容器的操作，它们只会运行与迭代器之上，执行迭代器的操作–》算法永远不会改变底层容器的大小</p>
<p>除少数例外，标准库算法都对一个范围内的元素进行操作，“输入范围”。用要处理的第一个元素和尾元素之后位置的迭代器两个参数来表示此范围</p>
<p>只接受单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长</p>
<p>写容器元素的算法要注意确保序列原大小至少不小于要求算法写入的元素数目</p>
<p>插入迭代器(insert iterator)定义在头文件iterator中，back_inserter;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt;v;</span><br><span class="line">auto it &#x3D; back_inserter(v);</span><br><span class="line">*it &#x3D; 42; &#x2F;&#x2F;v中现在有一个元素，值为42</span><br><span class="line"></span><br><span class="line">fill_n(back_inserter(v), 10, 0); &#x2F;&#x2F;添加10个0到v</span><br></pre></td></tr></table></figure>
<p>拷贝算法是另一个向目的位置迭代器指向的输出序列中的元素写书数据的算法。接受三个迭代器，前两个表示范围，第三个表示目的序列的起始位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a1[] &#x3D; &#123; 0,1,2 &#125;;</span><br><span class="line">int a2[sizeof(a1) &#x2F; sizeof(*a1)];</span><br><span class="line">auto ret &#x3D; copy(begin(a1), end(a1), a2); &#x2F;&#x2F;把a1的内容拷贝给a2，ret指向拷贝到a2的尾元素之后的位置</span><br></pre></td></tr></table></figure>
<p>一些算法计算新元素的值，但不会将他们放置在输入序列的末尾，而是创建一个新序列保存这些结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">replace(ilst.bigin(), ilst.end(), 0, 42); &#x2F;&#x2F;将所有0替换为42</span><br><span class="line">replace(ilst.begin(), ilst.end(), back_inserter(ivec), 0, 42); &#x2F;&#x2F;ilst未改变，ivec包含ilst的一份拷贝，但其中的0替换为42</span><br></pre></td></tr></table></figure>
<h3 id="重排容器元素的算法"><a href="#重排容器元素的算法" class="headerlink" title="重排容器元素的算法"></a>重排容器元素的算法</h3><p>利用元素类型的&lt;运算符来实现排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void elimDups(vector&lt;string&gt;&amp; words) &#123;</span><br><span class="line">	sort(words.begin(), words.end());</span><br><span class="line">	auto end &#x3D; unique(words.begin(), words.end()); &#x2F;&#x2F;end指向最后一个不重复元素的下一个位置</span><br><span class="line">	erase(end, words.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>谓词是一个可调用的表达式，其返回结果是一个能用作条件的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bool isShorter(const string&amp; s1, const string&amp; s2) &#123; &#x2F;&#x2F;比较函数，按长度排序单词</span><br><span class="line">	return s1.size() &lt; s2.size();</span><br><span class="line">&#125;</span><br><span class="line">sort(words.begin(), words.end(), isShorter); &#x2F;&#x2F;由短至长排序单词</span><br><span class="line">stable_sort稳定排序算法，维持相等元素的原有顺序</span><br></pre></td></tr></table></figure>
<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>四种可调用的对象：函数、函数指针、重载了函数调用运算符的类、lambda表达式<br>一个lambda表达式表示一个可调用的代码单元。可理解为一个未命名的内联函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture list](parameter list)-&gt;return type&#123; function body &#125;</span><br></pre></td></tr></table></figure>
<p>capture list(捕获列表)是一个lambda所在函数中定义的局部变量的列表(通常为空)。lambda必须使用尾置返回来指定返回类型<br>可以忽略参数列表和返回值类型，但必须包含捕获列表和函数体</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto f &#x3D; [] &#123;return 42; &#125;</span><br></pre></td></tr></table></figure>
<p>调用方式与普通函数的调用方式相同，都是使用调用运算符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; f() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>在lambda中忽略括号和参数列表等价于指定一个空参数列表。忽略返回类型，lambda根据函数体中代码推断返回类型，返回类型可以是void<br>lambda不能有默认参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[](const string&amp; s1, const string&amp; s2) &#123;return s1.size() &lt; s2.size();&#125;</span><br></pre></td></tr></table></figure>
<p>空捕获列表表示此lambda不使用它所在函数中的任何局部变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stable_sort(words.begin(), words.end(), [](const string&amp; s1, const string&amp; s2) &#123;return s1.size() &lt; s2.size(); &#125;);</span><br></pre></td></tr></table></figure>
<p>lambda只能使用明确在捕获列表指出的局部变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto wc &#x3D; find_if(words.begin(), words.end(), [sz](const string &amp; s) &#123;return s.size() &gt;&#x3D; sz; &#125;); &#x2F;&#x2F;获取指向第一个长度不小于sz的元素的迭代器，如果不存在则返回words.end()的一个拷贝</span><br></pre></td></tr></table></figure>
<h3 id="for-each算法"><a href="#for-each算法" class="headerlink" title="for_each算法"></a>for_each算法</h3><p>打印words中长度大于等于sz的元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for_each(wc, words.end(), [](const string&amp; s) &#123;cout &lt;&lt; s &lt;&lt; &quot; &quot;; &#125;); cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h3 id="lambda捕获和返回"><a href="#lambda捕获和返回" class="headerlink" title="lambda捕获和返回"></a>lambda捕获和返回</h3><p>当定义一个lambda时，编译器生成一个与lambda对应的新的(未命名的)类类型。当向一个函数传递一个lambda时，同事定义了一个新类型和该类型的一个对象，传递的参数就是此编译器生成的类类型的未命名对象<br>默认情况下，从lambda生成的类都包含一个对应该lambda所捕获的变量的数据成员。<br>变量的捕获方式可以是值或引用<br>值捕获的前提是变量可以拷贝，在lambda创建时拷贝</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void func1() &#123;</span><br><span class="line">	size_t v1 &#x3D; 42; &#x2F;&#x2F;局部变量</span><br><span class="line">	auto f &#x3D; [v1] &#123;return v1; &#125;;</span><br><span class="line">	v1 &#x3D; 0; auto j &#x3D; f(); &#x2F;&#x2F;j为42，f保存了创建时的拷贝</span><br><span class="line">&#125;</span><br><span class="line">void func2() &#123;</span><br><span class="line">	size_t v1 &#x3D; 42;</span><br><span class="line">	auto f2 &#x3D; [&amp;v1] &#123;return v1; &#125;;</span><br><span class="line">	v1 &#x3D; 0; auto j &#x3D; f2(); &#x2F;&#x2F;j&#x3D;&#x3D;0,f2保存v1的引用而非拷贝</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当从函数返回lambda时，lambda不能包含引用捕获。</p>
<h3 id="隐式捕获"><a href="#隐式捕获" class="headerlink" title="隐式捕获"></a>隐式捕获</h3><p>[=]值捕获、[&amp;]引用捕获<br>混合捕获</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void biggies(vector&lt;string&gt;&amp; words, vector&lt;string&gt;::size_type sz, ostream&amp; os &#x3D; cout, char c &#x3D; &#39; &#39;) &#123;</span><br><span class="line">	for_each(words.begin(), words.end(), [&amp;, c](const string &amp; s) &#123;os &lt;&lt; s &lt;&lt; c; &#125;);</span><br><span class="line">	for_each(words.begin(), words.end(), [&#x3D;, &amp;os](const string &amp; s) &#123;os &lt;&lt; s &lt;&lt; c; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="10%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95_md_files/%E6%8D%95%E8%8E%B7.JPG?v=1&type=image" alt="输入图片描述"><br>可变lambda可省略参数列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void func3() &#123;</span><br><span class="line">	size_t v1 &#x3D; 42;</span><br><span class="line">	auto f &#x3D; [v1]()mutable &#123;return ++v1; &#125;;</span><br><span class="line">	v1 &#x3D; 0; auto j &#x3D; f(); &#x2F;&#x2F;j&#x3D;&#x3D;43</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个引用捕获的变量是否可以修改依赖于此引用是否指向非const类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void func4() &#123;</span><br><span class="line">	size_t v1 &#x3D; 42;</span><br><span class="line">	auto f2 &#x3D; [&amp;v1] &#123;return ++v1; &#125;;</span><br><span class="line">	v1 &#x3D; 0; auto j &#x3D; f(); &#x2F;&#x2F;j&#x3D;&#x3D;1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个lambda包含return之外的任何语句，则编译器假定此lambda返回void</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transform(vi.begin(), vi.end(), [](int i) &#123;if (i &lt; 0)return -i; else return i; &#125;); &#x2F;&#x2F;错误：不能推断lambda的返回类型</span><br><span class="line">transform(vi.begin(),vi.end(),[](int i)-&gt;int&#123;if (i &lt; 0)return -i; else return i; &#125;</span><br></pre></td></tr></table></figure>
<h3 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto newCallable &#x3D; bind(callable, arg_list);</span><br><span class="line">&#x2F;&#x2F;check6是一个可调用对象，接受一个string类型的参数</span><br><span class="line">auto check6 &#x3D; bind(check_size, _1, 6);</span><br></pre></td></tr></table></figure>
<p>_1为占位符，表示check6只接受单一参数。出现在arg_list的第一个位置，表示check6的此参数对应check_size的第一个参数。<br>此参数是一个const string&amp; ，因此，调用check6必须传给他一个string类型的参数，check6会将此参数传递给check_size</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string s &#x3D; &quot;hello&quot;;</span><br><span class="line">bool b1 &#x3D; check6(s); &#x2F;&#x2F;check6(s)会调用check_size(s,6)</span><br><span class="line">可以将lambda的find_if变为check_size版本</span><br><span class="line">auto wc &#x3D; find_if(words.begin(), words.end(), [](const string&amp; a));</span><br><span class="line">auto wc &#x3D; find_if(words.begin(), words.end(), bind(check_size, _1, sz));</span><br></pre></td></tr></table></figure>
<p>using std::placeholders::_1;<br>_1定义在命名空间placeholders中，它又定义在std中<br>另一种声明：using namespace namespace_name;<br>说明希望所有来自namespace_name的名字都可以直接使用<br>using namespace std::placeholders;</p>
<p>可以用bind绑定可调用对象中的参数或重新安排其顺序<br>auto g = bind(f, a, b, _2, c, _1);<br>生成一个新的可调用对象，有2个参数（_1, _2）。将它自己的参数作为第三个和第五个参数传递给f。调用g时，第一个参数传递给f作为最后一个参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;按单词长度由短至长排序</span><br><span class="line">sort(words.begin(), words.end(), isShorter); l</span><br><span class="line">&#x2F;&#x2F;由长至短</span><br><span class="line">sort(words.begin(), words.end(), bind(isShorter, _2, _1);</span><br><span class="line"></span><br><span class="line">bind拷贝其参数，对于不想拷贝的，使用ref函数</span><br><span class="line">for_each(words.begin(), words.end(), bind(print, ref(os), _1, &#39; &#39;));</span><br></pre></td></tr></table></figure>

<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h3 id="插入迭代器-insert-iterator"><a href="#插入迭代器-insert-iterator" class="headerlink" title="插入迭代器(insert iterator)"></a>插入迭代器(insert iterator)</h3><p>这些迭代器被绑定到一个容器上，可用来向容器插入元素<br>——————————————————–图358</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">back_inserter &#x2F; front_inserter &#x2F; inserter</span><br><span class="line"></span><br><span class="line">list&lt;int&gt;lst &#x3D; &#123; 1,2,3,4 &#125;, lst2, lst3;</span><br><span class="line">copy(lst.begin(), lst, end(), front_inserter(lst2)); &#x2F;&#x2F;4 3 2 1 </span><br><span class="line">copy(lst.begin(), lst.end(), inserter(lst3, lst3.begin())); &#x2F;&#x2F;1 2 3 4</span><br></pre></td></tr></table></figure>
<h3 id="流迭代器-stream-iterator"><a href="#流迭代器-stream-iterator" class="headerlink" title="流迭代器(stream iterator)"></a>流迭代器(stream iterator)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">istream_iterator&lt;int&gt;int_it(cin); &#x2F;&#x2F;从cin读取int</span><br><span class="line">istream_iterator&lt;int&gt;eof; &#x2F;&#x2F;istream尾后迭代器</span><br><span class="line">ifstream in(&quot;afile&quot;);</span><br><span class="line">istream_iterator&lt;string&gt;str_it(in); &#x2F;&#x2F;从&quot;afile&quot;读取字符串</span><br><span class="line"></span><br><span class="line">istream_iterator&lt;int&gt;in_iter(cin); &#x2F;&#x2F;从cin读取int</span><br><span class="line">istream_iterator&lt;int&gt;eof; &#x2F;&#x2F;istream尾后迭代器</span><br><span class="line">while (in_iter !&#x3D; eof)vec.push_back(*in_iter++); &#x2F;&#x2F;后置递增运算读取流，返回迭代器的旧值，解引用迭代器，获得从流读取的前一个值</span><br></pre></td></tr></table></figure>
<h3 id="反向迭代器-reverse-iterator"><a href="#反向迭代器-reverse-iterator" class="headerlink" title="反向迭代器(reverse iterator)"></a>反向迭代器(reverse iterator)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt;v &#x3D; &#123; 1,2,3,4,5 &#125;;</span><br><span class="line">for (auto r_iter &#x3D; v.crbegin(); r_iter !&#x3D; v.crend(); ++r_iter;) &#123;</span><br><span class="line">	cout &lt;&lt; *r_iter &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort(v.begin(), v.end()); &#x2F;&#x2F;正常排序v</span><br><span class="line">sort(v.rbegin(), v.rend()); &#x2F;&#x2F;逆序排序v</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;打印最后一个单词</span><br><span class="line">auto comma &#x3D; find(line.rbegin(), line.rend(), &#39;,&#39;);</span><br><span class="line">cout &lt;&lt; string(rcomma.base(), line.end()) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h2 id="泛型算法结构"><a href="#泛型算法结构" class="headerlink" title="泛型算法结构"></a>泛型算法结构</h2><p>输入、输出、前向、双向、随机访问，5种迭代器</p>
<p>返回void<br>图——————————————————–369</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/30/c-primer-10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/" data-id="ckhua8rns000oxsveefjo5kwr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-c-primer-09-顺序容器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/30/c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/" class="article-date">
  <time datetime="2020-08-30T01:40:30.000Z" itemprop="datePublished">2020-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/30/c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/">c++ primer 09 顺序容器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="顺序容器-sequential-container"><a href="#顺序容器-sequential-container" class="headerlink" title="顺序容器(sequential container)"></a>顺序容器(sequential container)</h1><p>vector:可变大小数组。支持快速随机访问。在尾部之外位置插入删除元素可能很慢<br>deque:双端队列。支持快速随机访问。在头尾位置插入删除速度很快<br>list;双向列表。只支持双向顺序访问。在任何位置插入删除操作速度都很快<br>forward_list:单向列表。只支持单向顺序访问。在任何位置插入删除操作速度都很快<br>array:固定大小数组。支持快速随机访问。不能添加或删除元素<br>string:与vector相似，但专门用于保存字符。随机访问快。在尾部插入删除速度快</p>
<p>选择容器基本原则：<br>首选vector<br>有很多小元素，空间的额外开销很重要，不要用list或forward_list<br>在中间插入或删除，用list或forward_list<br>只在头尾插入或删除，用deque</p>
<h3 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h3><p><img src="./c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/%E6%8D%95%E8%8E%B7.png" alt="输入图片描述"></p>
<p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/%E6%8D%95%E8%8E%B71.PNG?v=1&type=image" alt="输入图片描述"></p>
<p>使用左闭合范围<br>如果begin与end相等，则范围为空；begin与end不等，则至少包含一个元素，且begin指向范围中的第一个元素；可以对begin递增若干次，使得begin==end</p>
<h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt;::iterator iter;    vector&lt;int&gt;::difference_type count;</span><br><span class="line"></span><br><span class="line">a.begin() &#x2F; rbegin() &#x2F; cbegin() &#x2F; crbegin()</span><br><span class="line">auto it &#x3D; a.begin(); &#x2F;&#x2F;仅当a是const时，it是const_iterator</span><br></pre></td></tr></table></figure>
<h3 id="容器定义和初始化"><a href="#容器定义和初始化" class="headerlink" title="容器定义和初始化"></a>容器定义和初始化</h3><p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/2%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"></p>
<p>创建一个容器为另一个的拷贝，两个容器的类型及元素类型必须匹配，传递迭代器参数拷贝范围时不要求，能转换即可;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt; authors &#x3D; &#123; &quot;ab&quot;,&quot;cd&quot;,&quot;ef&quot;&#125;;</span><br><span class="line">vector&lt;const char*&gt;articles &#x3D; &#123; &quot;a&quot;,&quot;an&quot;,&quot;the&quot; &#125;;</span><br><span class="line">list&lt;string&gt;list2(authors); &#x2F;&#x2F;正确：类型匹配</span><br><span class="line">deque&lt;string&gt;authList(authors); &#x2F;&#x2F;错误：容器类型不匹配</span><br><span class="line">vector&lt;string&gt;words(atricles); &#x2F;&#x2F;错误：容器类型必须匹配</span><br><span class="line">forward_list&lt;string&gt;words(articles.begin(), articles.end()); &#x2F;&#x2F;正确：可以将const char*转换为string</span><br></pre></td></tr></table></figure>
<p>如果元素类型是内置类型或者具有默认构造函数的类类型，可以值为构造函数提供一个容器大小参数；如果没有默认构造函数，还必须指定一个显式的元素初始值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">array&lt;string, 10&gt; &#x2F;&#x2F;类型为保存10个string的数组</span><br><span class="line">array&lt;int, 10&gt;::size_type i; &#x2F;&#x2F;正确  </span><br><span class="line">array&lt;int&gt;::size_type j; &#x2F;&#x2F;错误：array&lt;int&gt;不是一个类型</span><br><span class="line">array&lt;int,3&gt;ia1; &#x2F;&#x2F;10个默认初始化的int</span><br><span class="line">array&lt;int,3&gt;ia2 &#x3D; &#123; 0,1,2 &#125;; &#x2F;&#x2F;列表初始化</span><br><span class="line">array&lt;int, 3&gt;ia3 &#x3D; &#123; 1 &#125;; &#x2F;&#x2F;ia3[0]为1，其余元素为0</span><br><span class="line">不能对内置数组类型进行拷贝或对象赋值，但array可以</span><br><span class="line">array&lt;int, 3&gt;digs &#x3D; &#123; 1,2,3 &#125;;</span><br><span class="line">array&lt;int, 3&gt;copy &#x3D; digs;</span><br></pre></td></tr></table></figure>
<h3 id="赋值和swap"><a href="#赋值和swap" class="headerlink" title="赋值和swap"></a>赋值和swap</h3><p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/3%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c1 &#x3D; c2; &#x2F;&#x2F;将c1的内存替换为c2中元素的拷贝，c1大小变为c2的大小</span><br><span class="line">c1 &#x3D; &#123; a,b,c &#125;;</span><br><span class="line">array&lt;int, 3&gt;a1 &#x3D; &#123; 1,2,3 &#125;;</span><br><span class="line">array&lt;int, 3&gt;a2 &#x3D; &#123; 0 &#125;;</span><br><span class="line">a1 &#x3D; a2; &#x2F;&#x2F;替换a1中的元素</span><br><span class="line">a2 &#x3D; &#123; 0 &#125;; &#x2F;&#x2F;错误：不能讲一个花括号列表赋予数组</span><br></pre></td></tr></table></figure>
<p>赋值相关运算会导致指向左边容器内部的迭代器、引用和指针失效，而swap操作不会(array和string除外)</p>
<p>顺序容器(array除外)定义了一个assign成员，允许从一个不同但相容的类型赋值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt;names; vector&lt;const char*&gt;oldstyle;</span><br><span class="line">names &#x3D; oldstyle; &#x2F;&#x2F;错误：容器类型不匹配</span><br><span class="line">names.assign(oldstyle.begin(), oldstyle.end()); &#x2F;&#x2F;正确：可以将const char*转换成string</span><br><span class="line"></span><br><span class="line">list&lt;string&gt;slist1(1); &#x2F;&#x2F;1个元素，为空string</span><br><span class="line">slist1.assign(10, &quot;hi&quot;); &#x2F;&#x2F;10个元素，“hi”</span><br><span class="line">等价于slist1.clear(); slist1.insert(slist1.begin(), 10, &quot;hi&quot;);</span><br></pre></td></tr></table></figure>
<p>swap操作交换两个相同类型容器的内容。除array外，操作会很快，元素本身并未交换，只是交换了内部数据结构<br>除string外，指向容器的迭代器、引用和指针在swap后都不会失效</p>
<p>除forward_list外，都有size, empty, max_size(返回一个大于或等于该类型容器所能容纳的最大元素的值)。forward_list只有max_size和empty</p>
<p>每个容器类型都支持相等运算符(==/!=)；除无序关联容器外都支持关系运算符(&gt;/&gt;=/&lt;/&lt;=)。必须是相同类型容器，相同类型的元素<br>比较结果取决于第一个不相等的元素的比较结果</p>
<h3 id="向顺序容器中添加元素"><a href="#向顺序容器中添加元素" class="headerlink" title="向顺序容器中添加元素"></a>向顺序容器中添加元素</h3><p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/4%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"></p>
<p>插入容器后若容器没有扩容、该元素没有改变位置，不会使其失效<br>当我们用一个对象来初始化容器，或将一个对象插入到容器中时，实际上放入到容器中的是对象的一个拷贝，而不是对象本身</p>
<p>当调用push或insert成员函数时，我们将元素类型的对象传递给它们，这些对象被拷贝到容器中。<br>当我们调用emplace成员函数时，则是将参数传递给元素类型的构造函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c.emplace_back(&quot;99-9999&quot;,25,15.99); &#x2F;&#x2F;使用三个参数的Sales_data构造函数</span><br><span class="line">c.push_back((&quot;99-9999&quot;, 25, 15.99); &#x2F;&#x2F;错误：没有接受三个参数的push_back版本</span><br><span class="line">c.push_back(Sales_data((&quot;99-9999&quot;, 25, 15.99)); &#x2F;&#x2F;正确：创建一个临时的Sales_data对象传递给push_back</span><br></pre></td></tr></table></figure>
<p>调用emplace_back时会在容器管理的内存空间中直接创建对象；而调用push_back则会创建一个局部临时对象，并将其压入容器中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">emplace函数的参数根据元素类型而变化，参数必须与元素类型的构造函数相匹配</span><br><span class="line">c.emplace_back(); &#x2F;&#x2F;使用Sales_data的默认构造函数</span><br><span class="line">c.emplace(iter, &quot;99-9999&quot;); &#x2F;&#x2F;使用Sales_data(string)</span><br><span class="line">c.emplace_front(&quot;99-9999&quot;, 25, 15.99); &#x2F;&#x2F;使用Sales_data的接受一个ISBN、一个count和一个price的构造函数</span><br></pre></td></tr></table></figure>
<h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/5%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (!c.empty()) &#123;</span><br><span class="line">	auto val &#x3D; *c.begin(); val2 &#x3D; c.front();</span><br><span class="line">	auto last &#x3D; c.end();</span><br><span class="line">	auto val3 &#x3D; *(--c.end());</span><br><span class="line">	auto val4 &#x3D; c.back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在容器中访问元素的成员函数(fornt,back,下标和at)返回的都是引用，容器是一个const对象则返回值是const的引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (!c.empty()) &#123;</span><br><span class="line">	c.front() &#x3D; 42;</span><br><span class="line">	auto&amp; v &#x3D; c.back(); &#x2F;&#x2F;获得指向最后一个元素的引用</span><br><span class="line">	v &#x3D; 1024; &#x2F;&#x2F;改变c中元素</span><br><span class="line">	auto v2 &#x3D; c.back(); &#x2F;&#x2F;v2不是引用，是c.back()的一个拷贝</span><br><span class="line">	v2 &#x3D; 0; &#x2F;&#x2F;不改变c中元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>at成员函数类似下标运算符，但越界是会抛出一个out_of_range异常</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt;v;</span><br><span class="line">cout &lt;&lt; v[0]; &#x2F;&#x2F;运行时错误</span><br><span class="line">cout &lt;&lt; v.at(0); &#x2F;&#x2F;抛出一个out_of_range异常</span><br></pre></td></tr></table></figure>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/6%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"><br><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/7%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"></p>
<h3 id="改变容器大小"><a href="#改变容器大小" class="headerlink" title="改变容器大小"></a>改变容器大小</h3><p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/8%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"></p>
<h3 id="管理容量的成员函数"><a href="#管理容量的成员函数" class="headerlink" title="管理容量的成员函数"></a>管理容量的成员函数</h3><p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/9%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"><br>reserve分配的大小小于等于当前容量时，reserve什么也不错。resize成员函数值改变容器中元素的数目，而不是容量</p>
<h3 id="构造string的其他方法"><a href="#构造string的其他方法" class="headerlink" title="构造string的其他方法"></a>构造string的其他方法</h3><p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/10%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const char* cp &#x3D; &quot;hello world!!!&quot;;</span><br><span class="line">char noNull[] &#x3D; &#123; &#39;h&#39;,&#39;i&#39; &#125;;</span><br><span class="line">string s1(cp); &#x2F;&#x2F;拷贝cp重点字符直到遇到空字符；s1&#x3D;&#x3D;&quot;hello world!!!&quot;</span><br><span class="line">string s2(noNull, 2); &#x2F;&#x2F;从noNull拷贝两个字符 &quot;hi&quot;</span><br><span class="line">string s3(noNUll); &#x2F;&#x2F;未定义：noNull不是以空字符结束</span><br><span class="line">string s4(cp + 6, 5); &#x2F;&#x2F;从cp[6]开始拷贝5个字符 &quot;world&quot;</span><br><span class="line">string s5(s1, 6, 5); &#x2F;&#x2F;从s1[6]开始拷贝5个字符 &quot;world&quot;</span><br><span class="line">string s6(s1, 6); &#x2F;&#x2F;从s1[6]开始拷贝到末尾 &quot;world!!!&quot;</span><br><span class="line">string s7(s1, 6, 20); </span><br><span class="line">string s8(s1, 16); &#x2F;&#x2F;抛出out_of_range异常</span><br><span class="line">从const char* 创建string时，指针指向的数组必须以空字符结尾，或者再传递一个合适的计数值</span><br></pre></td></tr></table></figure>
<h3 id="substr操作"><a href="#substr操作" class="headerlink" title="substr操作"></a>substr操作</h3><p>s.substr(pos, n) 返回一个string，包含s中从pos开始的n个字符的拷贝。pos的默认值为0。n的默认值为s.size() - pos，即拷贝从pos开始的所有字符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">string s(&quot;hello world&quot;);</span><br><span class="line">string s2 &#x3D; s.substr(0, 5); &#x2F;&#x2F;hello</span><br><span class="line">string s3 &#x3D; s.substr(6); &#x2F;&#x2F;world</span><br><span class="line">string s4 &#x3D; s.substr(6, 11); &#x2F;&#x2F;world</span><br><span class="line">string s5 &#x3D; s.substr(12); &#x2F;&#x2F;out_of_range</span><br><span class="line"></span><br><span class="line">s.insert(s.size(), 5, &#39;!&#39;); &#x2F;&#x2F;在s末尾插入5个&#39;!&#39;</span><br><span class="line">s.erase(s.size() - 5, 5); &#x2F;&#x2F;从s删除最后5个字符</span><br><span class="line"></span><br><span class="line">const char* cp &#x3D; &quot;Stately, plump Buck&quot;;</span><br><span class="line">s.assign(cp, 7); &#x2F;&#x2F;s&#x3D;&#x3D;&quot;Stately&quot; 赋值从cp开始的7个字符</span><br><span class="line">s.insert(s.size(), cp + 7); &#x2F;&#x2F;s&#x3D;&#x3D;&quot;Stately, plump Buck&quot;  将cp+7开始的字符拷贝到s后面</span><br><span class="line"></span><br><span class="line">string s &#x3D; &quot;Some string&quot;, s2 &#x3D; &quot;some other string&quot;;</span><br><span class="line">s.insert(0, s2); &#x2F;&#x2F;在s的0位置前插入s2</span><br><span class="line">s.insert(0, s2, 0, s2.size()); &#x2F;&#x2F;在s的0位置前插入s2的从0开始s2.size()个字符</span><br></pre></td></tr></table></figure>
<p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/11%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"><br><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/image.png?v=1&type=image" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.replace(a, b, s2); &#x2F;&#x2F;从s的a位置开始删除b个字符，并在该位置插入s2</span><br></pre></td></tr></table></figure>
<h3 id="string搜索操作"><a href="#string搜索操作" class="headerlink" title="string搜索操作"></a>string搜索操作</h3><p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/12%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"><br><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/13%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"><br>每个搜索操作都返回一个string::size_type值，表示匹配发生位置的下标。搜索失败则返回名为string::nops的static成员。nops等于任何string最大的可能大小<br>返回值是unsigned类型，一般不用int或其他带符号类型来保存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string name(&quot;AnnaBelle&quot;); </span><br><span class="line">auto pos &#x3D; name.find(&quot;Anna&quot;); &#x2F;&#x2F;pos&#x3D;&#x3D;0</span><br><span class="line">auto pos1 &#x3D; name.find(&quot;anna&quot;); &#x2F;&#x2F;pos&#x3D;&#x3D;nops</span><br><span class="line"></span><br><span class="line">string numbers(&quot;0123456789&quot;), name(&quot;r2d2&quot;), dept(&quot;01714p3&quot;);</span><br><span class="line">auto pos &#x3D; name.find_first_of(numbers); &#x2F;&#x2F;pos&#x3D;&#x3D;1</span><br><span class="line">auto pos &#x3D; name.find_first_not_of(numbers); &#x2F;&#x2F;pos&#x3D;&#x3D;5</span><br></pre></td></tr></table></figure>
<h3 id="指定开始搜索的位置"><a href="#指定开始搜索的位置" class="headerlink" title="指定开始搜索的位置"></a>指定开始搜索的位置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string::size_type pos &#x3D; 0;</span><br><span class="line">while ((pos &#x3D; name.find_first_of(numbers, pos)) !&#x3D; string::nops) &#123;</span><br><span class="line">	cout &lt;&lt; &quot;found number at index: &quot; &lt;&lt; pos &lt;&lt; &quot; elem is &quot; &lt;&lt; name[pos] &lt;&lt; endl;</span><br><span class="line">	++pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="逆向搜索"><a href="#逆向搜索" class="headerlink" title="逆向搜索"></a>逆向搜索</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string river(&quot;Mississippi&quot;);</span><br><span class="line">auto first_pos&#x3D;river.find_first(&quot;is&quot;); &#x2F;&#x2F;返回1</span><br><span class="line">auto last_pos &#x3D; river.find_last(&quot;is&quot;); &#x2F;&#x2F;返回4</span><br></pre></td></tr></table></figure>
<h3 id="compare函数"><a href="#compare函数" class="headerlink" title="compare函数"></a>compare函数</h3><p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/14%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"><br>返回负数、0、正数</p>
<h3 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D; 42;</span><br><span class="line">string s &#x3D; to_string(i); &#x2F;&#x2F;将整数i转换为字符表示形式</span><br><span class="line">double d &#x3D; stod(s); &#x2F;&#x2F;将字符串s转换为浮点数</span><br></pre></td></tr></table></figure>
<p>要转换为数值的string中第一个非空白符必须是数值中可能出现的字符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s2 &#x3D; &quot;pi&#x3D;3.14&quot;;</span><br><span class="line">d &#x3D; stod(s2.substr(s2.find_first_of(&quot;+-.0123456789&quot;))); &#x2F;&#x2F;d&#x3D;3.14</span><br></pre></td></tr></table></figure>
<p>如果string不能转换为一个数值，则抛出一个invalid_argument异常；数值无法用任何类型来表示则抛出out_of_range异常<br><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/15%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"></p>
<h3 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h3><p>标准库还定义了三个顺序容器适配器：stack、queue和priority_queue。本质上一个适配器是一种机制，能使某种事物的行为看起来像另外一种事物<br><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/16%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"><br>默认情况下，stack和queue是基于deque实现的，priority_queue是在vector之上实现的<br>定义一个适配器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;int&gt;deq;</span><br><span class="line">stack&lt;int&gt; stk(deq); &#x2F;&#x2F;从deq拷贝元素到stk</span><br></pre></td></tr></table></figure>
<p>我们可以再创建一个适配器时将一个命名的顺序容器作为第二个类型参数，来重载默认容器类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;int, vector&lt;string&gt;&gt;str_stk(sevc); &#x2F;&#x2F;str_stk在vector上实现，初始化时保存svec的拷贝</span><br></pre></td></tr></table></figure>
<p>因为所有适配器都要求容器具有添加、删除以及访问尾元素的能力，所以不能用array和forward_list来构造适配器<br>stack只要求push_back、pop_back和back操作–》使用除array和forward_list之外的任何容器类型来构造<br>queue要求back、push_back, front和push_front–》list或deque，不能用vector<br>priority_queue要求front, push_back, pop_back和随机访问能力–》vector或deque，不能用list</p>
<h3 id="栈适配器"><a href="#栈适配器" class="headerlink" title="栈适配器"></a>栈适配器</h3><p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/17%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;int&gt; intStack;</span><br><span class="line">for (size_t ix &#x3D; 0; ix &lt; 10; ++ix) </span><br><span class="line">	intStack.push(ix);</span><br><span class="line">while (!intStack.empty()) &#123;</span><br><span class="line">	int value &#x3D; intStack.top();</span><br><span class="line">	intStack.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="队列适配器"><a href="#队列适配器" class="headerlink" title="队列适配器"></a>队列适配器</h3><p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/18%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"><br><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/19%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/30/c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/" data-id="ckhua8rnr000jxsveefsv5ulf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-primer/" rel="tag">c++ primer</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-problem-library-哈希-02" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/12/problem-library-%E5%93%88%E5%B8%8C-02/" class="article-date">
  <time datetime="2020-08-12T03:31:29.000Z" itemprop="datePublished">2020-08-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/12/problem-library-%E5%93%88%E5%B8%8C-02/">problem library 哈希 02</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="#739.每日温度"></a>#739.每日温度</h2><p>请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p>
<p>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p>
<p>提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/daily-temperatures" target="_blank" rel="noopener">https://leetcode-cn.com/problems/daily-temperatures</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; T) &#123;</span><br><span class="line">		vector&lt;int&gt;res(T.size(), 0);</span><br><span class="line">		for (int i &#x3D; T.size() - 2; i &gt;&#x3D; 0; --i) &#123;</span><br><span class="line">			if (T[i] &lt; T[i + 1])res[i] &#x3D; 1;</span><br><span class="line">			else &#123;</span><br><span class="line">				int tmp &#x3D; i + 1 + res[i + 1];</span><br><span class="line">				if (res[i + 1] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">					res[i] &#x3D; 0;</span><br><span class="line">					continue;</span><br><span class="line">				&#125;</span><br><span class="line">				while (T[i] &gt;&#x3D; T[tmp] &amp;&amp; tmp &lt; T.size()) &#123;</span><br><span class="line">					if (res[tmp] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">					tmp +&#x3D; res[tmp];</span><br><span class="line">				&#125;</span><br><span class="line">				if (T[i] &lt; T[tmp])res[i] &#x3D; tmp - i;</span><br><span class="line">				else res[i] &#x3D; 0;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="347-前k个高频元素"><a href="#347-前k个高频元素" class="headerlink" title="#347.前k个高频元素"></a>#347.前k个高频元素</h2><p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p>
<p>示例 1:</p>
<p>输入: nums = [1,1,1,2,2,3], k = 2<br>输出: [1,2]<br>示例 2:</p>
<p>输入: nums = [1], k = 1<br>输出: [1]</p>
<p>提示：</p>
<p>你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。<br>你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。<br>题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。<br>你可以按任意顺序返回答案。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/top-k-frequent-elements" target="_blank" rel="noopener">https://leetcode-cn.com/problems/top-k-frequent-elements</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">		vector&lt;int&gt;res;</span><br><span class="line">		unordered_map&lt;int, int&gt;m;</span><br><span class="line">		for (auto i : nums)m[i]++;</span><br><span class="line">		vector&lt;pair&lt;int, int&gt;&gt;tmp;</span><br><span class="line">		for (auto it &#x3D; m.begin(); it !&#x3D; m.end(); ++it) &#123;</span><br><span class="line">			tmp.emplace_back(make_pair(it-&gt;second, it-&gt;first));</span><br><span class="line">		&#125;</span><br><span class="line">		sort(tmp.begin(), tmp.end(), compare);</span><br><span class="line">		int i &#x3D; tmp.size() - 1;</span><br><span class="line">		while (k &gt; 0) &#123;</span><br><span class="line">			res.emplace_back(tmp[i].second);</span><br><span class="line">			k--; i--;</span><br><span class="line">		&#125;</span><br><span class="line">		return res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	static bool compare(pair&lt;int, int&gt; i, pair&lt;int, int&gt; j) &#123;</span><br><span class="line">		return i.second &gt; j.second;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">		vector&lt;int&gt;res;</span><br><span class="line">		unordered_map&lt;int, int&gt;m;</span><br><span class="line">		for (auto i : nums)m[i]++;</span><br><span class="line">		vector&lt;pair&lt;int, int&gt;&gt;tmp(m.begin(), m.end());</span><br><span class="line">		sort(tmp.begin(), tmp.end(), compare);</span><br><span class="line">		for (int i &#x3D; 0; i &lt; k; ++i) &#123;</span><br><span class="line">			res.emplace_back(tmp[i].first);</span><br><span class="line">		&#125;</span><br><span class="line">		return res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="36-有效的数独"><a href="#36-有效的数独" class="headerlink" title="#36.有效的数独"></a>#36.有效的数独</h2><p>判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。</p>
<p>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">	[&quot;5&quot;, &quot;3&quot;, &quot;.&quot;, &quot;.&quot;, &quot;7&quot;, &quot;.&quot;, &quot;.&quot;, &quot;.&quot;, &quot;.&quot;],</span><br><span class="line">	[&quot;6&quot;, &quot;.&quot;, &quot;.&quot;, &quot;1&quot;, &quot;9&quot;, &quot;5&quot;, &quot;.&quot;, &quot;.&quot;, &quot;.&quot;],</span><br><span class="line">	[&quot;.&quot;, &quot;9&quot;, &quot;8&quot;, &quot;.&quot;, &quot;.&quot;, &quot;.&quot;, &quot;.&quot;, &quot;6&quot;, &quot;.&quot;],</span><br><span class="line">	[&quot;8&quot;, &quot;.&quot;, &quot;.&quot;, &quot;.&quot;, &quot;6&quot;, &quot;.&quot;, &quot;.&quot;, &quot;.&quot;, &quot;3&quot;],</span><br><span class="line">	[&quot;4&quot;, &quot;.&quot;, &quot;.&quot;, &quot;8&quot;, &quot;.&quot;, &quot;3&quot;, &quot;.&quot;, &quot;.&quot;, &quot;1&quot;],</span><br><span class="line">	[&quot;7&quot;, &quot;.&quot;, &quot;.&quot;, &quot;.&quot;, &quot;2&quot;, &quot;.&quot;, &quot;.&quot;, &quot;.&quot;, &quot;6&quot;],</span><br><span class="line">	[&quot;.&quot;, &quot;6&quot;, &quot;.&quot;, &quot;.&quot;, &quot;.&quot;, &quot;.&quot;, &quot;2&quot;, &quot;8&quot;, &quot;.&quot;],</span><br><span class="line">	[&quot;.&quot;, &quot;.&quot;, &quot;.&quot;, &quot;4&quot;, &quot;1&quot;, &quot;9&quot;, &quot;.&quot;, &quot;.&quot;, &quot;5&quot;],</span><br><span class="line">	[&quot;.&quot;, &quot;.&quot;, &quot;.&quot;, &quot;.&quot;, &quot;8&quot;, &quot;.&quot;, &quot;.&quot;, &quot;7&quot;, &quot;9&quot;]</span><br><span class="line">]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/valid-sudoku" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-sudoku</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;</span><br><span class="line">		int row[9][10] &#x3D; &#123; 0 &#125;, col[9][10] &#x3D; &#123; 0 &#125;, box[9][10] &#x3D; &#123; 0 &#125;;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; 9; ++i) &#123;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; 9; ++j) &#123;</span><br><span class="line">				if (board[i][j] &#x3D;&#x3D; &#39;.&#39;)continue;</span><br><span class="line">				int num &#x3D; board[i][j] - &#39;0&#39;;</span><br><span class="line">				if (row[i][num] + col[j][num] + box[j &#x2F; 3 + i &#x2F; 3 * 3][num] &gt; 0)return false;</span><br><span class="line">				++row[i][num]; ++col[j][num]; ++box[j &#x2F; 3 + i &#x2F; 3 * 3][num];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="560-和为k的子数组"><a href="#560-和为k的子数组" class="headerlink" title="#560.和为k的子数组"></a>#560.和为k的子数组</h2><p>给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。</p>
<p>示例 1 :</p>
<p>输入:nums = [1,1,1], k = 2<br>输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。<br>说明 :</p>
<p>数组的长度为 [1, 20,000]。<br>数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/subarray-sum-equals-k" target="_blank" rel="noopener">https://leetcode-cn.com/problems/subarray-sum-equals-k</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">		queue&lt;int&gt;tmp;</span><br><span class="line">		int sum &#x3D; 0, count &#x3D; 0;</span><br><span class="line">		for (auto i : nums) &#123;</span><br><span class="line">			tmp.push(i);</span><br><span class="line">			sum +&#x3D; i;</span><br><span class="line">			while (sum &gt; k) &#123;</span><br><span class="line">				sum -&#x3D; tmp.front();</span><br><span class="line">				tmp.pop();</span><br><span class="line">			&#125;</span><br><span class="line">			if (sum &#x3D;&#x3D; k &amp;&amp; !tmp.empty()) &#123;</span><br><span class="line">				sum -&#x3D; tmp.front();</span><br><span class="line">				tmp.pop();</span><br><span class="line">				++count;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return count;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="187-重复的DNA序列"><a href="#187-重复的DNA序列" class="headerlink" title="#187.重复的DNA序列"></a>#187.重复的DNA序列</h2><p>所有 DNA 都由一系列缩写为 A，C，G 和 T 的核苷酸组成，例如：“ACGAATTCCG”。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。</p>
<p>编写一个函数来查找目标子串，目标子串的长度为 10，且在 DNA 字符串 s 中出现次数超过一次。</p>
<p>示例：</p>
<p>输入：s = “AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT”<br>输出：[“AAAAACCCCC”, “CCCCCAAAAA”]</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/repeated-dna-sequences" target="_blank" rel="noopener">https://leetcode-cn.com/problems/repeated-dna-sequences</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	vector&lt;string&gt; findRepeatedDnaSequences(string s) &#123;</span><br><span class="line">		if (s.size() &lt; +10)return &#123;&#125;;</span><br><span class="line">		unordered_map&lt;string, int&gt;m;</span><br><span class="line">		vector&lt;string&gt;res;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; s.size() - 9; ++i) &#123;</span><br><span class="line">			string tmp(s.begin() + i, s.begin() + 10 + i);</span><br><span class="line">			if (m[tmp] &#x3D;&#x3D; 1)res.emplace_back(tmp);</span><br><span class="line">			++m[tmp];</span><br><span class="line">		&#125;</span><br><span class="line">		return res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="84-柱状图中最大矩形"><a href="#84-柱状图中最大矩形" class="headerlink" title="#84.柱状图中最大矩形"></a>#84.柱状图中最大矩形</h2><p>给定  <em>n</em>  个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<p><strong>示例:</strong></p>
<p><strong>输入:</strong> [2,1,5,6,2,3]<br><strong>输出:</strong> 10</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;</span><br><span class="line">        int sz &#x3D; heights.size(), res &#x3D; 0;</span><br><span class="line">        stack&lt;int&gt;tmp;</span><br><span class="line">        vector&lt;int&gt;left(sz), right(sz, sz);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; sz; ++i) &#123;</span><br><span class="line">            while (!tmp.empty() &amp;&amp; heights[i] &lt;&#x3D; heights[tmp.top()]) &#123;</span><br><span class="line">                right[tmp.top()] &#x3D; i;</span><br><span class="line">                tmp.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            left[i] &#x3D; tmp.empty() ? -1 : tmp.top();</span><br><span class="line">            tmp.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; sz; ++i) &#123;</span><br><span class="line">            res &#x3D; max(res, heights[i] * (right[i] - left[i] - 1));</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/12/problem-library-%E5%93%88%E5%B8%8C-02/" data-id="ckhua8roy0033xsve1il71bj8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/problem-library/" rel="tag">problem library</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-cocos2d-x-02-动作" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/10/cocos2d-x-02-%E5%8A%A8%E4%BD%9C/" class="article-date">
  <time datetime="2020-08-10T14:48:41.000Z" itemprop="datePublished">2020-08-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/10/cocos2d-x-02-%E5%8A%A8%E4%BD%9C/">cocos2d-x 02 动作</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">bool HelloWorld::init()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 1. super init first</span><br><span class="line">    if ( !Scene::init() )</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    auto visibleSize &#x3D; Director::getInstance()-&gt;getVisibleSize();</span><br><span class="line">    Vec2 origin &#x3D; Director::getInstance()-&gt;getVisibleOrigin();</span><br><span class="line"></span><br><span class="line">	LabelTTF* label &#x3D; LabelTTF::create(&quot;text text text&quot;, &quot;Courier&quot;, 30);</span><br><span class="line">	addChild(label);</span><br><span class="line">	label-&gt;setPosition(visibleSize.width &#x2F; 2, visibleSize.height &#x2F; 2);</span><br><span class="line"></span><br><span class="line">	auto listener &#x3D; EventListenerTouchOneByOne::create();</span><br><span class="line">	listener-&gt;onTouchBegan &#x3D; [label](Touch * t, Event * e) &#123;</span><br><span class="line">		if (label-&gt;getBoundingBox().containsPoint(t-&gt;getLocation())) &#123;</span><br><span class="line">			&#x2F;&#x2F;label-&gt;runAction(MoveTo::create(1, Point(100, 100)));</span><br><span class="line">			&#x2F;&#x2F;label-&gt;runAction(MoveBy::create(1, Point(100, 100))-&gt;reverse());</span><br><span class="line">			label-&gt;runAction(Sequence::create(</span><br><span class="line">				MoveBy::create(1, Point(50, 50)),</span><br><span class="line">				RotateBy::create(1, 360),</span><br><span class="line">				CallFunc::create([]() &#123;</span><br><span class="line">					MessageBox(&quot;Action Complete&quot;, &quot;complete&quot;);</span><br><span class="line">					&#125;), NULL));</span><br><span class="line">		&#125;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;;</span><br><span class="line">	Director::getInstance()-&gt;getEventDispatcher()-&gt;addEventListenerWithSceneGraphPriority(listener, label);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;label-&gt;runAction(Repeat::create(RotateBy::create(1, 180),3));</span><br><span class="line">	&#x2F;&#x2F;label-&gt;runAction(RepeatForever::create(RotateBy::create(1, 180)));</span><br><span class="line">	&#x2F;&#x2F;label-&gt;runAction(Spawn::create(MoveBy::create(1, Point(50, 50)), RotateBy::create(2, 360),NULL));</span><br><span class="line">	&#x2F;&#x2F;label-&gt;runAction(Sequence::create(MoveBy::create(1, Point(50, 50)), RotateBy::create(1, 360), NULL));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/10/cocos2d-x-02-%E5%8A%A8%E4%BD%9C/" data-id="ckhua8roa001fxsve9qkbhi9s" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cocos2d-x/" rel="tag">cocos2d-x</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/02-cpp-primer/" rel="tag">02 cpp primer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c-primer/" rel="tag">c++ primer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cocos2d-x/" rel="tag">cocos2d-x</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpp-notes/" rel="tag">cpp notes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/problem-library/" rel="tag">problem library</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reading-notes-DS/" rel="tag">reading notes DS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%82%93%E4%BF%8A%E8%BE%89/" rel="tag">数据结构 邓俊辉</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/02-cpp-primer/" style="font-size: 15px;">02 cpp primer</a> <a href="/tags/c-primer/" style="font-size: 17.5px;">c++ primer</a> <a href="/tags/cocos2d-x/" style="font-size: 12.5px;">cocos2d-x</a> <a href="/tags/cpp-notes/" style="font-size: 20px;">cpp notes</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/problem-library/" style="font-size: 15px;">problem library</a> <a href="/tags/reading-notes-DS/" style="font-size: 10px;">reading notes DS</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%82%93%E4%BF%8A%E8%BE%89/" style="font-size: 17.5px;">数据结构 邓俊辉</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/11/23/ncpp-09/">第9章 顺序容器</a>
          </li>
        
          <li>
            <a href="/2020/11/22/ncpp-08/">ncpp-08</a>
          </li>
        
          <li>
            <a href="/2020/11/20/ncpp-07/">第7章 类</a>
          </li>
        
          <li>
            <a href="/2020/11/19/ncpp-06/">第6章 函数</a>
          </li>
        
          <li>
            <a href="/2020/11/18/ncpp-05/">第5章 语句</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>
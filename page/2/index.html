<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-cocos2d-x-02-动作" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/10/cocos2d-x-02-%E5%8A%A8%E4%BD%9C/" class="article-date">
  <time datetime="2020-08-10T14:48:41.000Z" itemprop="datePublished">2020-08-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/10/cocos2d-x-02-%E5%8A%A8%E4%BD%9C/">cocos2d-x 02 动作</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">bool HelloWorld::init()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 1. super init first</span><br><span class="line">    if ( !Scene::init() )</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    auto visibleSize &#x3D; Director::getInstance()-&gt;getVisibleSize();</span><br><span class="line">    Vec2 origin &#x3D; Director::getInstance()-&gt;getVisibleOrigin();</span><br><span class="line"></span><br><span class="line">	LabelTTF* label &#x3D; LabelTTF::create(&quot;text text text&quot;, &quot;Courier&quot;, 30);</span><br><span class="line">	addChild(label);</span><br><span class="line">	label-&gt;setPosition(visibleSize.width &#x2F; 2, visibleSize.height &#x2F; 2);</span><br><span class="line"></span><br><span class="line">	auto listener &#x3D; EventListenerTouchOneByOne::create();</span><br><span class="line">	listener-&gt;onTouchBegan &#x3D; [label](Touch * t, Event * e) &#123;</span><br><span class="line">		if (label-&gt;getBoundingBox().containsPoint(t-&gt;getLocation())) &#123;</span><br><span class="line">			&#x2F;&#x2F;label-&gt;runAction(MoveTo::create(1, Point(100, 100)));</span><br><span class="line">			&#x2F;&#x2F;label-&gt;runAction(MoveBy::create(1, Point(100, 100))-&gt;reverse());</span><br><span class="line">			label-&gt;runAction(Sequence::create(</span><br><span class="line">				MoveBy::create(1, Point(50, 50)),</span><br><span class="line">				RotateBy::create(1, 360),</span><br><span class="line">				CallFunc::create([]() &#123;</span><br><span class="line">					MessageBox(&quot;Action Complete&quot;, &quot;complete&quot;);</span><br><span class="line">					&#125;), NULL));</span><br><span class="line">		&#125;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;;</span><br><span class="line">	Director::getInstance()-&gt;getEventDispatcher()-&gt;addEventListenerWithSceneGraphPriority(listener, label);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;label-&gt;runAction(Repeat::create(RotateBy::create(1, 180),3));</span><br><span class="line">	&#x2F;&#x2F;label-&gt;runAction(RepeatForever::create(RotateBy::create(1, 180)));</span><br><span class="line">	&#x2F;&#x2F;label-&gt;runAction(Spawn::create(MoveBy::create(1, Point(50, 50)), RotateBy::create(2, 360),NULL));</span><br><span class="line">	&#x2F;&#x2F;label-&gt;runAction(Sequence::create(MoveBy::create(1, Point(50, 50)), RotateBy::create(1, 360), NULL));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/10/cocos2d-x-02-%E5%8A%A8%E4%BD%9C/" data-id="ckhkofavw001g5kvebqilekza" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cocos2d-x/" rel="tag">cocos2d-x</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-cocos2d-x-01" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/10/cocos2d-x-01/" class="article-date">
  <time datetime="2020-08-10T14:47:11.000Z" itemprop="datePublished">2020-08-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/10/cocos2d-x-01/">cocos2d-x 01</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">bool HelloWorld::init()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 1. super init first</span><br><span class="line">    if ( !Scene::init() )</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;菜单</span><br><span class="line">	auto menu &#x3D; Menu::create(MenuItemImage::create(&quot;normal.png&quot;, &quot;selected.png&quot;, [](object * obj) &#123;</span><br><span class="line">		log(&quot;menu item touched&quot;);</span><br><span class="line">		&#125;), NULL);</span><br><span class="line">	addChild(menu);</span><br><span class="line">	&#x2F;&#x2F;场景切换</span><br><span class="line">	LabelTTF* label &#x3D; LabelTTF::create(&quot;show next scene&quot;, &quot;Courier&quot;, 30);</span><br><span class="line">	addChild(label);</span><br><span class="line">	label-&gt;setPosition(visibleSize.width &#x2F; 2, visibleSize.height &#x2F; 2);</span><br><span class="line">	auto listener &#x3D; EventListenerTouchOneByOne::create();</span><br><span class="line">	listener-&gt;onTouchBegan &#x3D; [label](Touch * t, Event * e) &#123;</span><br><span class="line">		if (label-&gt;getBoundingBox().containsPoint(t-&gt;getLocation())) &#123;</span><br><span class="line">			Director::getInstance()-&gt;replaceScene(Imagescene::createScene());</span><br><span class="line">		&#125;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;;</span><br><span class="line">	Director::getInstance()-&gt;getEventDispatcher()-&gt;addEventListenerWithSceneGraphPriority(listener, label);</span><br><span class="line">   </span><br><span class="line">	</span><br><span class="line">	return true; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="场景切换"><a href="#场景切换" class="headerlink" title="场景切换"></a>场景切换</h2><h3 id="ImageScene-cpp"><a href="#ImageScene-cpp" class="headerlink" title="ImageScene.cpp"></a>ImageScene.cpp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Imagescene.h&quot;</span><br><span class="line"></span><br><span class="line">Scene* Imagescene::createScene() &#123;</span><br><span class="line">	Scene* scene &#x3D; Scene::create();</span><br><span class="line">	Imagescene* layer &#x3D; Imagescene::create();</span><br><span class="line">	scene-&gt;addChild(layer);</span><br><span class="line">	return scene;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Imagescene::init() &#123;</span><br><span class="line">	auto visibleSize &#x3D; Director::getInstance()-&gt;getVisibleSize();</span><br><span class="line">	Sprite* s &#x3D; Sprite::create(&quot;HelloWorld.png&quot;);</span><br><span class="line">	s-&gt;setPosition(visibleSize.width &#x2F; 2, visibleSize.height &#x2F; 2);</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Imagescene-h"><a href="#Imagescene-h" class="headerlink" title="Imagescene.h"></a>Imagescene.h</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&quot;Imagescene.h&quot;</span><br><span class="line">#include&lt;cocos2d.h&gt;</span><br><span class="line">USING_NS_CC;</span><br><span class="line">class Imagescene:public Layer</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual bool init();</span><br><span class="line">	static Scene* createScene();</span><br><span class="line">	CREATE_FUNC(Imagescene);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/10/cocos2d-x-01/" data-id="ckhkofavs00185kve5f5m7qu8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cocos2d-x/" rel="tag">cocos2d-x</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-problem-library-哈希" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/09/problem-library-%E5%93%88%E5%B8%8C/" class="article-date">
  <time datetime="2020-08-09T12:09:23.000Z" itemprop="datePublished">2020-08-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/09/problem-library-%E5%93%88%E5%B8%8C/">problem library 哈希</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="#1.两数之和"></a>#1.两数之和</h2><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>
<p>示例:</p>
<p>给定 nums = [2, 7, 11, 15], target = 9</p>
<p>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/two-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        map&lt;int, int&gt;m;</span><br><span class="line">        vector&lt;int&gt;v;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; nums.size(); ++i)m.insert(map&lt;int, int&gt;::value_type(nums[i], i));</span><br><span class="line">        for (int i &#x3D; 0; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            if (m.count(target - nums[i]) &gt; 0 &amp;&amp; m[target - nums[i]] !&#x3D; i) &#123;</span><br><span class="line">                v.emplace_back(i);</span><br><span class="line">                v.emplace_back(m[target - nums[i]]);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="#136.只出现一次的数字"></a>#136.只出现一次的数字</h2><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p>说明：</p>
<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<p>示例 1:</p>
<p>输入: [2,2,1]<br>输出: 1<br>示例 2:</p>
<p>输入: [4,1,2,1,2]<br>输出: 4</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/single-number" target="_blank" rel="noopener">https://leetcode-cn.com/problems/single-number</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        map&lt;int, int&gt;m;</span><br><span class="line">        for (auto i : nums)m[i]++;</span><br><span class="line">        for (auto it &#x3D; m.begin(); it !&#x3D; m.end(); ++it) &#123;</span><br><span class="line">            if (it-&gt;second &#x3D;&#x3D; 1)return it-&gt;first;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int res &#x3D; 0;</span><br><span class="line">        for (auto i : nums)res ^&#x3D; i;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="#202.快乐数"></a>#202.快乐数</h2><p>编写一个算法来判断一个数 n 是不是快乐数。</p>
<p>「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。</p>
<p>如果 n 是快乐数就返回 True ；不是，则返回 False 。</p>
<p>示例：</p>
<p>输入：19<br>输出：true<br>解释：<br>12 + 92 = 82<br>82 + 22 = 68<br>62 + 82 = 100<br>12 + 02 + 02 = 1</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/happy-number" target="_blank" rel="noopener">https://leetcode-cn.com/problems/happy-number</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="哈希-1"><a href="#哈希-1" class="headerlink" title="哈希"></a>哈希</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int getN(int n) &#123;</span><br><span class="line">        int res &#x3D; 0;</span><br><span class="line">        while (n) &#123;</span><br><span class="line">            int a &#x3D; n % 10;</span><br><span class="line">            n &#x3D; n &#x2F; 10;</span><br><span class="line">            res +&#x3D; a * a;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    bool isHappy(int n) &#123;</span><br><span class="line">        unordered_map&lt;int, bool&gt;m;</span><br><span class="line">        while (n !&#x3D; 1) &#123;</span><br><span class="line">            n &#x3D; getN(n);</span><br><span class="line">            if (m[n] &#x3D;&#x3D; true)return false;</span><br><span class="line">            m[n] &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="快慢针"><a href="#快慢针" class="headerlink" title="快慢针"></a>快慢针</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int getN(int n) &#123;</span><br><span class="line">        int res &#x3D; 0;</span><br><span class="line">        while (n) &#123;</span><br><span class="line">            int a &#x3D; n % 10;</span><br><span class="line">            n &#x3D; n &#x2F; 10;</span><br><span class="line">            res +&#x3D; a * a;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    bool isHappy(int n) &#123;</span><br><span class="line">        int i &#x3D; n, j &#x3D; getN(n);</span><br><span class="line">        while (i !&#x3D; j) &#123;</span><br><span class="line">            i &#x3D; getN(i);</span><br><span class="line">            j &#x3D; getN(getN(j));</span><br><span class="line">        &#125;</span><br><span class="line">        return i &#x3D;&#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="219-存在重复的元素II"><a href="#219-存在重复的元素II" class="headerlink" title="#219.存在重复的元素II"></a>#219.存在重复的元素II</h2><p>给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的 绝对值 至多为 k。</p>
<p>示例 1:</p>
<p>输入: nums = [1,2,3,1], k = 3<br>输出: true<br>示例 2:</p>
<p>输入: nums = [1,0,1,1], k = 1<br>输出: true<br>示例 3:</p>
<p>输入: nums = [1,2,3,1,2,3], k = 2<br>输出: false</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/contains-duplicate-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/contains-duplicate-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        unordered_set&lt;int&gt;tmp;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            if (tmp.find(nums[i]) !&#x3D; tmp.end())return true;</span><br><span class="line">            tmp.emplace(nums[i]);</span><br><span class="line">            if (tmp.size() &gt; k)tmp.erase(nums[i - k]);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="217-存在重复元素"><a href="#217-存在重复元素" class="headerlink" title="#217.存在重复元素"></a>#217.存在重复元素</h2><p>给定一个整数数组，判断是否存在重复元素。</p>
<p>如果任意一值在数组中出现至少两次，函数返回  <code>true</code>  。如果数组中每个元素都不相同，则返回  <code>false</code>  。</p>
<p><strong>示例 1:</strong></p>
<p><strong>输入:</strong> [1,2,3,1]<br><strong>输出:</strong> true</p>
<p><strong>示例 2:</strong></p>
<p><strong>输入:</strong> [1,2,3,4]<br><strong>输出:</strong> false</p>
<p><strong>示例 3:</strong></p>
<p><strong>输入:</strong> [1,1,1,3,3,4,3,2,4,2]<br><strong>输出:</strong> true</p>
<h3 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        unordered_set&lt;int&gt;tmp;</span><br><span class="line">        for (auto i : nums) &#123;</span><br><span class="line">            if (tmp.find(i) !&#x3D; tmp.end())return true;</span><br><span class="line">            tmp.emplace(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        unordered_map&lt;int, int&gt;m;</span><br><span class="line">        for (auto i : nums) &#123;</span><br><span class="line">            m[i]++;</span><br><span class="line">            if (m[i] &gt; 1)return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="#349.两个数组的交集"></a>#349.两个数组的交集</h2><p>给定两个数组，编写一个函数来计算它们的交集。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong>nums1 = [1,2,2,1], nums2 = [2,2]<br><strong>输出：</strong>[2]</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>nums1 = [4,9,5], nums2 = [9,4,9,8,4]<br><strong>输出：</strong>[9,4]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">        unordered_set&lt;int&gt;res1, num11(nums1.begin(), nums1.end());</span><br><span class="line">        for (auto i : nums2) &#123;</span><br><span class="line">            if (num11.find(i) !&#x3D; num11.end())res1.emplace(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return vector&lt;int&gt;(res1.begin(), res1.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="#242.有效的字母异位词"></a>#242.有效的字母异位词</h2><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p>
<p>示例 1:</p>
<p>输入: s = “anagram”, t = “nagaram”<br>输出: true<br>示例 2:</p>
<p>输入: s = “rat”, t = “car”<br>输出: false<br>说明:<br>你可以假设字符串只包含小写字母。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/valid-anagram" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-anagram</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isAnagram(string s, string t) &#123;</span><br><span class="line">        if (s.size() !&#x3D; t.size())return false;</span><br><span class="line">        int words[26] &#x3D; &#123;&#125;;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            ++words[s[i] - &#39;a&#39;];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; t.size(); ++j) &#123;</span><br><span class="line">            if (--words[t[j] - &#39;a&#39;] &lt; 0)return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/09/problem-library-%E5%93%88%E5%B8%8C/" data-id="ckhkofawn002p5kvefy04c6yc" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/problem-library/" rel="tag">problem library</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-problem-library-链表" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/08/problem-library-%E9%93%BE%E8%A1%A8/" class="article-date">
  <time datetime="2020-08-08T15:13:57.000Z" itemprop="datePublished">2020-08-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/08/problem-library-%E9%93%BE%E8%A1%A8/">problem library 链表</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="#21.合并两个有序链表"></a>#21.合并两个有序链表</h2><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<p>示例：</p>
<p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-two-sorted-lists</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">        ListNode* prehead &#x3D; new ListNode(-1);</span><br><span class="line">        ListNode* pre &#x3D; prehead;</span><br><span class="line">        while (l1 !&#x3D; nullptr &amp;&amp; l2 !&#x3D; nullptr) &#123;</span><br><span class="line">            if (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                pre-&gt;next &#x3D; l1;</span><br><span class="line">                l1 &#x3D; l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                pre-&gt;next &#x3D; l2;</span><br><span class="line">                l2 &#x3D; l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre &#x3D; pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre-&gt;next &#x3D; l1 &#x3D;&#x3D; nullptr ? l2 : l1;</span><br><span class="line">        return prehead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="206-翻转链表"><a href="#206-翻转链表" class="headerlink" title="#206.翻转链表"></a>#206.翻转链表</h2><p>反转一个单链表。</p>
<p><strong>示例:</strong></p>
<p><strong>输入:</strong> 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br><strong>输出:</strong> 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p>
<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">        ListNode* pre &#x3D; nullptr;</span><br><span class="line">        ListNode* curr &#x3D; head;</span><br><span class="line">        while (curr !&#x3D; nullptr) &#123;</span><br><span class="line">            ListNode* tmp &#x3D; curr-&gt;next;</span><br><span class="line">            curr-&gt;next &#x3D; pre;</span><br><span class="line">            pre &#x3D; curr;</span><br><span class="line">            curr &#x3D; tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        return pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">        if (head &#x3D;&#x3D; nullptr || head-&gt;next &#x3D;&#x3D; nullptr)return head;</span><br><span class="line">        ListNode* res &#x3D; reverseList(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next &#x3D; head;</span><br><span class="line">        head-&gt;next &#x3D; nullptr;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="#141.环形链表"></a>#141.环形链表</h2><p>给定一个链表，判断链表中是否有环。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>
<p>示例 1：</p>
<p>输入：head = [3,2,0,-4], pos = 1<br>输出：true<br>解释：链表中有一个环，其尾部连接到第二个节点。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/linked-list-cycle" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-cycle</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool hasCycle(ListNode* head) &#123;</span><br><span class="line">        if (head &#x3D;&#x3D; nullptr || head-&gt;next &#x3D;&#x3D; nullptr)return false;</span><br><span class="line">        ListNode* slow &#x3D; head;</span><br><span class="line">        ListNode* fast &#x3D; head-&gt;next;</span><br><span class="line">        while (slow !&#x3D; fast) &#123;</span><br><span class="line">            if (fast &#x3D;&#x3D; nullptr || fast-&gt;next &#x3D;&#x3D; nullptr || fast-&gt;next-&gt;next &#x3D;&#x3D; nullptr)return false;</span><br><span class="line">            slow &#x3D; slow-&gt;next;</span><br><span class="line">            fast &#x3D; fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="#234.回文链表"></a>#234.回文链表</h2><p>请判断一个链表是否为回文链表。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: 1-&gt;2
输出: false</code></pre><p><strong>示例 2:</strong></p>
<pre><code>输入: 1-&gt;2-&gt;2-&gt;1
输出: true</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isPalindrome(ListNode* head) &#123;</span><br><span class="line">        if (head &#x3D;&#x3D; nullptr)return true;</span><br><span class="line">        ListNode* slow &#x3D; head;</span><br><span class="line">        ListNode* fast &#x3D; head-&gt;next;</span><br><span class="line">        while (fast !&#x3D; nullptr &amp;&amp; fast-&gt;next !&#x3D; nullptr) &#123;</span><br><span class="line">            slow &#x3D; slow-&gt;next;</span><br><span class="line">            fast &#x3D; fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* secondHalf &#x3D; nullptr;</span><br><span class="line">        ListNode* cur &#x3D; slow-&gt;next;</span><br><span class="line">        while (cur !&#x3D; nullptr) &#123;</span><br><span class="line">            ListNode* tmp &#x3D; cur-&gt;next;</span><br><span class="line">            cur-&gt;next &#x3D; secondHalf;</span><br><span class="line">            secondHalf &#x3D; cur;</span><br><span class="line">            cur &#x3D; tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        while (secondHalf !&#x3D; nullptr) &#123;</span><br><span class="line">            if (secondHalf-&gt;val !&#x3D; head-&gt;val)return false;</span><br><span class="line">            secondHalf &#x3D; secondHalf-&gt;next;</span><br><span class="line">            head &#x3D; head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="106-相交链表"><a href="#106-相交链表" class="headerlink" title="#106.相交链表"></a>#106.相交链表</h2><p>编写一个程序，找到两个单链表相交的起始节点。</p>
<p>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3<br>输出：Reference of the node with value = 8<br>输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists" target="_blank" rel="noopener">https://leetcode-cn.com/problems/intersection-of-two-linked-lists</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) &#123;</span><br><span class="line">        for (auto i &#x3D; headA; i !&#x3D; nullptr; i &#x3D; i-&gt;next) &#123;</span><br><span class="line">            for (auto j &#x3D; headB; j !&#x3D; nullptr; j &#x3D; j-&gt;next) &#123;</span><br><span class="line">                if (i &#x3D;&#x3D; j)return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) &#123;</span><br><span class="line">        ListNode* pA &#x3D; headA;</span><br><span class="line">        ListNode* pB &#x3D; headB;</span><br><span class="line">        while (pA !&#x3D; pB) &#123;</span><br><span class="line">            pA &#x3D; pA &#x3D;&#x3D; nullptr ? headB : pA-&gt;next;</span><br><span class="line">            pB &#x3D; pB &#x3D;&#x3D; nullptr ? headA : pB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return pA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="#203.移除链表元素"></a>#203.移除链表元素</h2><p>删除链表中等于给定值 <strong><em>val</em></strong> 的所有节点。</p>
<p><strong>示例:</strong></p>
<p><strong>输入:</strong> 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, <em><strong>val</strong></em> = 6<br><strong>输出:</strong> 1-&gt;2-&gt;3-&gt;4-&gt;5</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* removeElements(ListNode* head, int val) &#123;</span><br><span class="line">        ListNode* temp &#x3D; new ListNode(0);</span><br><span class="line">        temp-&gt;next &#x3D; head;</span><br><span class="line">        ListNode* prev &#x3D; temp, * cur &#x3D; head, * toDelete &#x3D; nullptr;</span><br><span class="line">        while (cur !&#x3D; nullptr) &#123;</span><br><span class="line">            if (cur-&gt;val &#x3D;&#x3D; val) &#123;</span><br><span class="line">                prev-&gt;next &#x3D; cur-&gt;next;</span><br><span class="line">                toDelete &#x3D; cur;</span><br><span class="line">            &#125;</span><br><span class="line">            else prev &#x3D; cur;</span><br><span class="line">            cur &#x3D; cur-&gt;next;</span><br><span class="line">            if (toDelete !&#x3D; nullptr) &#123;</span><br><span class="line">                delete toDelete;</span><br><span class="line">                toDelete &#x3D; nullptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* res &#x3D; temp-&gt;next;</span><br><span class="line">        delete temp;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="#2.两数相加"></a>#2.两数相加</h2><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p>示例：</p>
<p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/add-two-numbers" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-two-numbers</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">        int add &#x3D; 0;</span><br><span class="line">        ListNode* res &#x3D; new ListNode(0), * tmp &#x3D; res, * p1 &#x3D; l1, * p2 &#x3D; l2;</span><br><span class="line">        while (p1 !&#x3D; nullptr || p2 !&#x3D; nullptr) &#123;</span><br><span class="line">            int x &#x3D; p1 &#x3D;&#x3D; nullptr ? 0 : p1-&gt;val;</span><br><span class="line">            int y &#x3D; p2 &#x3D;&#x3D; nullptr ? 0 : p2-&gt;val;</span><br><span class="line">            int val &#x3D; x + y + add;</span><br><span class="line">            add &#x3D; val &#x2F; 10;</span><br><span class="line">            val %&#x3D; 10;</span><br><span class="line">            tmp-&gt;next &#x3D; new ListNode(val);</span><br><span class="line">            tmp &#x3D; tmp-&gt;next;</span><br><span class="line">            if (p1 !&#x3D; nullptr)p1 &#x3D; p1-&gt;next;</span><br><span class="line">            if (p2 !&#x3D; nullptr)p2 &#x3D; p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if (add !&#x3D; 0)tmp-&gt;next &#x3D; new ListNode(add);</span><br><span class="line">        return res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="#148.排序链表"></a>#148.排序链表</h2><p>在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。</p>
<p>示例 1:</p>
<p>输入: 4-&gt;2-&gt;1-&gt;3<br>输出: 1-&gt;2-&gt;3-&gt;4<br>示例 2:</p>
<p>输入: -1-&gt;5-&gt;3-&gt;4-&gt;0<br>输出: -1-&gt;0-&gt;3-&gt;4-&gt;5</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/sort-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sort-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* sortList(ListNode* head) &#123;</span><br><span class="line">        if (head &#x3D;&#x3D; nullptr || head-&gt;next &#x3D;&#x3D; nullptr)return head;</span><br><span class="line">        ListNode* slow &#x3D; head, * fast &#x3D; head-&gt;next;</span><br><span class="line">        while (fast !&#x3D; nullptr &amp;&amp; fast-&gt;next !&#x3D; nullptr) &#123;</span><br><span class="line">            fast &#x3D; fast-&gt;next-&gt;next;</span><br><span class="line">            slow &#x3D; slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* tmp &#x3D; slow-&gt;next;</span><br><span class="line">        slow-&gt;next &#x3D; nullptr;</span><br><span class="line">        ListNode* left &#x3D; sortList(head), * right &#x3D; sortList(tmp);</span><br><span class="line">        ListNode* res &#x3D; new ListNode(0), * h &#x3D; res;</span><br><span class="line">        while (left !&#x3D; nullptr &amp;&amp; right !&#x3D; nullptr) &#123;</span><br><span class="line">            if (left-&gt;val &lt; right-&gt;val) &#123;</span><br><span class="line">                h-&gt;next &#x3D; left;</span><br><span class="line">                left &#x3D; left-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                h-&gt;next &#x3D; right;</span><br><span class="line">                right &#x3D; right-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            h &#x3D; h-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        h-&gt;next &#x3D; left &#x3D;&#x3D; nullptr ? right : left;</span><br><span class="line">        return res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/08/problem-library-%E9%93%BE%E8%A1%A8/" data-id="ckhkofax0002x5kvebouy4z53" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/problem-library/" rel="tag">problem library</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-c-primer-04-表达式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/06/c-primer-04-%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="article-date">
  <time datetime="2020-08-06T15:09:11.000Z" itemprop="datePublished">2020-08-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/06/c-primer-04-%E8%A1%A8%E8%BE%BE%E5%BC%8F/">c++ primer 04 表达式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h1><p>表达式由一个或多个运算对象(operand)组成，对表达式求值将得到一个结果(result)。<br>右值(rvalue) :对象的值(内容)  左值(lvalue) : 对象的身份(在内存中的位置)<br>取余：(m / n)* n + m % n = m m % n符号和m相同 m % (-n) = m % n(-m) % n = -m % n<br>逻辑运算符与、或：当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值，短路求值(short_circuit evaluation)<br>if (i &lt; j &lt; k)k &gt; 1时为真(i &lt; j &amp;&amp; 1 &lt; k)<br>int k = 0; k = 3.14; (可以)k = { 3.14 }(不可以)k = { 3 }(可以)<br>多重赋值语句中的每一个对象，它的类型与右边对象相同或者可由右边对象的类型转换得到<br>int ival, <em>pval;ival=pval=0(错误，不能把指针的值赋值给int)<br>递增、递减运算符，后置版本储存了原值的副本，可能是一种浪费，尽量使用前置版本<br>*pbeg++:先进行递增，但返回初始值，所以解引用初始值，再将指针指向下一个<br>条件运算符 A?B:C?D:E–&gt;A?B:(C?D:E)<br>cou&lt;&lt;(A&gt;B)?C:D 输出0或者1   cout&lt;<A>B?C:D 错误，试图比较cout和B<br>位异或运算符(^)两个运算对象对应的位置有且只有一个为1,则结果中该位置为1，否则为0<br>运算对象分别为无符号和带符号类型：无符号不小于带符号-&gt;转换成无符号，反之转换成带符号<br>显示转换：<br>任何具有明确定义的类型转换，只要不包含底层constraint，都可以使用static_cast<br>double slope=static_cast<double>(i)/j<br>const_cast只能改变运算对象的底层const<br>const char</em> pc; char* p = const_cast&lt;char*&gt;(pc);<br>只有const_cast能改变表达式的常量属性<br>reinterpret_cast通常为运算对象的位模式提供较低层次上的重新解释</p>
<h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p>复合语句(compound statement)也被称作块(block)。一个块就是一个作用域，在块中引入的名字只能在块内部以及嵌套在块中的子块里访问</p>
<p>switch语句的case标签(case lable)必须是整型常量表达式<br>switch (ch) { case ‘a’:++acnt; case ‘e’:++ecnt; case ‘i’:++icnt; }ch==e的时候会执行++ecnt及之后的++icnt。需要break<br>若没有case匹配，执行default  标签后面必须跟上一条语句或者另一个标签<br>若某处一个带有初值的变量位于作用域之外，在另一处该变量位于作用域之内，则从前一处跳转到后一处的行为是非法行为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">	<span class="built_in">string</span> file_name; <span class="comment">//错误：控制流绕过一个隐式初始化的变量</span></span><br><span class="line">	<span class="keyword">int</span> jval = <span class="number">0</span>; <span class="comment">//错误：控制流绕过一个显式初始化的变量</span></span><br><span class="line">	<span class="keyword">int</span> jval; <span class="comment">//正确：jval没有初始化</span></span><br><span class="line"><span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">	jval = next_num; <span class="comment">//正确</span></span><br><span class="line">	<span class="keyword">if</span>(file_name.empty())<span class="comment">/**/</span></span><br></pre></td></tr></table></figure>
<p>使用while循环：不确定要迭代多少次、想在循环结束后访问循环控制变量</p>
<p>for语句头中init-statement只能有一条声明语句，因此所有变量的基础类型必须相同</p>
<p>范围for语句：若需要对序列中的元素执行写操作，循环变量必须声明成引用类型<br>不能通过范围for语句增加容器的元素</p>
<p>do while语句不允许在条件部分定义变量</p>
<p>continue：对于传统的for循环，继续执行for语句头的expression；对于范围for语句，用序列中的下一个元素初始化循环控制变量</p>
<p>go to语句(go lable;)goto语句和控制权转向的那条带标签的语句必须位于同一个函数之内</p>
<p>try语句块和异常处理</p>
<p>throw表达式(throw expression)异常检测部分使用throw表达式来表示它遇到了无法处理的问题。我们说throw引发(raise)了异常<br>throw表达式包含关键字throw和紧随其后的一个表达式，表达式的类型就是抛出的异常类型<br>throw runtime_error(“Data must refer to same ISBN”);</p>
<p>try语句块(try block)异常处理部分使用try语句块处理异常。以关键字try开始，并以一个或多个catch子句(catch clause)结束<br>catch子句包括：关键字catch、括号内一个(可能未命名的)对象的声明(异常声明,exception declaration)以及一个块。当选中了某个catch子句处理异常之后，执行与之对应的块。完成后跳转到try语句块最后一个catch子句之后的那条语句继续执行<br>没找到匹配的catch子句，程序转到名为terminate的标准函数库</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	program - staments</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (exception - declaration) &#123;</span><br><span class="line">	handler - staments</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; item1 &gt;&gt; item2) &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//执行添加两个Sales_item对象的代码，如果添加失败，代码抛出一个runtime_error异常</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (runtime_error) &#123;</span><br><span class="line">		<span class="comment">//提醒用户两个ISBN必须一致，询问是否重新输入</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; err.what() &lt;&lt; <span class="string">"\nTry Again?"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">char</span> c;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">cin</span> || c == <span class="string">'n'</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>调用函数时，传入的可以是能转换成的实参(int类型可以传入3.14)<br>形参列表可以为空()/(void)不能省略<br>函数的返回值类型不能是数组类型和函数类型，但可以是指向数组或函数的指针<br>把只存在于块执行期间的对象称为自动对象(automatic object)<br>局部静态对象(local static object)可将局部变量定义成static类型从而令局部变量的生命周期贯穿函数调用及之后的时间<br>内置类型的局部静态变量初始化为0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">size_t count_calls() &#123;</span><br><span class="line">	static size_t ctr &#x3D; 0;</span><br><span class="line">	return ++ctr;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	for (size_t i &#x3D; 0; i !&#x3D; 10; i++)</span><br><span class="line">		cout &lt;&lt; count_calls() &lt;&lt; endl;</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>指针形参：当执行指针拷贝操作时，拷贝的是指针的值。拷贝之后两个指针是不同的指针。因为指针使我们可以间接地访问它所指的对象，所以通过指针可以修改它所指对象的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void reset(int* p) &#123;</span><br><span class="line">	*p &#x3D; 0; &#x2F;&#x2F;改变指针p所指对象的值</span><br><span class="line">	p &#x3D; 0; &#x2F;&#x2F;只改变了p的局部拷贝，实参未被改变</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传引用参数可以避免拷贝<br>通常一个函数只能返回一个值，使用引用形参可返回额外信息<br>当用实参初始化形参时会忽略掉顶层const，当形参有顶层const时，传给它常量对象或非常量对象都是可以的<br>void fcn(const int i) {} 和 void fcn(int i) {} 不能同时存在，两个形参是相同的<br>尽量使用常量引用，非常量引用会限制函数所能结束的实参类型。不能把const对象、字面值或者需要类型转换的对象传递给普通的引用形参</p>
<p>不允许拷贝数组、使用数组时(通常)会将其转换成指针<br>void t01(const int* / const int[] / const int[10])<br>三个等价，每一个都有const int* 类型的形参<br>给函数传递一个数组时，实参自动地转换成指向数组首元素的指针，数组的大小对函数的调用没有影响<br>使用标记指定数组长度：要求数组本身包含一个结束标记(c风格字符串)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void print(const char* cp) &#123;</span><br><span class="line">	if (cp) &#x2F;&#x2F;若cp不是一个空指针</span><br><span class="line">		while (cp) &#x2F;&#x2F;只要指针所指的字符不是空字符</span><br><span class="line">			cout &lt;&lt; *cp++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用标准款规范：传递指向数组首元素和尾后元素的指针</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int j[2] &#x3D; &#123; 2,3 &#125;</span><br><span class="line">print(begin(j), end(j));</span><br><span class="line">void print(const int* beg, const int* end) &#123;</span><br><span class="line">	while (beg !&#x3D; end)cout &lt;&lt; *beg++ &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显式传递一个表示数组大小的形参：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int j[] &#x3D; &#123; 2,3 &#125;;</span><br><span class="line">print(j, end(j) - begin(j));</span><br><span class="line">void print(const int ia[], size_t size) &#123;</span><br><span class="line">	for (size_t i &#x3D; 0; i &lt; size; i++)cout &lt;&lt; ia[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(int&amp; arr[10])引用的数组 f(int(&amp;arr)[10])数组的引用</span><br><span class="line">int i &#x3D; 0, j[2] &#x3D; &#123; 2,3 &#125;, k[] &#x3D; &#123; 0,1,2,3,4,5,6,7,8,9 &#125;;</span><br><span class="line">print(&amp;i); &#x2F;&#x2F;错误：实参不是含有10个整数的数组</span><br><span class="line">print(j); &#x2F;&#x2F;错误</span><br><span class="line">print(k); &#x2F;&#x2F;正确</span><br></pre></td></tr></table></figure>
<p>含有可变形参的函数：无法提前预知应该想函数传递几个参数<br>所有的实参类型相同，可以传递initializer_list标准库类型；实参类型不同，可以编写可变参数模板</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">initializer_list&lt;T&gt;lst;</span><br><span class="line">initializer_list&lt;T&gt;lst&#123; a,b,c &#125;;</span><br><span class="line">lst2(lst);</span><br><span class="line">lst2 &#x3D; lst;</span><br><span class="line">lst.size(); lst.begin(); lst.end();</span><br><span class="line">void error_msg(initializer_list&lt;string&gt; il) &#123;</span><br><span class="line">	for (auto beg &#x3D; il.begin(); beg !&#x3D; il.end(); ++beg)</span><br><span class="line">		cout &lt;&lt; *beg &lt;&lt; &quot; &quot;;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">省略符形参：void foo(parm_list, ...) &#x2F; (...)</span><br></pre></td></tr></table></figure>
<p>没有返回值的return语句只能用在返回值类型是void的函数中，返回void的函数不要求非得有return语句，会隐式执行<br>不能返回局部变量的引用或指针。函数完成后会被释放掉</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const string &amp; manip() &#123;</span><br><span class="line">	string ret;</span><br><span class="line">	if (!ret.empty())return ret; &#x2F;&#x2F;错误：返回局部对象的引用</span><br><span class="line">	else return &quot;Empty&quot;; &#x2F;&#x2F;错误：&quot;Empty&quot;是一个局部临时变量</span><br><span class="line">&#125;</span><br><span class="line">主函数main允许没有return语句，编译器将隐式地插入一条返回0的return语句</span><br><span class="line">一个函数调用了它本身，称为递归函数(recursive function)</span><br><span class="line">int factorial(int val) &#123;</span><br><span class="line">	if (val &gt; 1)return factorial(val - 1) * val;</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回数组指针：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef int arr[10]; &#x2F;&#x2F;arr是一个类型别名，表示的类型是含有10个整数的数组</span><br><span class="line">using arr&#x3D;int[10]; &#x2F;&#x2F;arr的等价声明</span><br><span class="line">arr* func(int i) &#123;&#125; &#x2F;&#x2F;func发返回一个指向含有10个整数的数组指针</span><br><span class="line">Type(*function(parameter_list))[dimension]  int(*func(int i))[10];</span><br></pre></td></tr></table></figure>
<p>使用尾置返回类型：auto function(int i)-&gt;int(*)[10];<br>若知道函数返回的指针将指向哪个数组，可以使用decltype关键字声明返回类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int odd[] &#x3D; &#123; 1,3,5 &#125;, even[] &#x3D; &#123; 2,4,6 &#125;;</span><br><span class="line">decltype(odd)* arrPtr(int i) &#123; return (1 % 2) ? &amp;odd : &amp;even; &#125;</span><br></pre></td></tr></table></figure>
<p>arrPtr使用关键字decltype表示它的返回类型是个指针，且该指针所指的对象与odd的类型一致</p>
<p>顶层const不影响传入的对象：Record lookup(Phone) / (const Phone)和(Phone<em>) / (Phone * const)是重复声明<br>如果形参是某种类型的指针或引用，通过区分是否常量可以实现函数重载，此时const是底层的<br>Record lookup(Account&amp;) / (const Account&amp;)和(Account</em>) / (const Account*)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const_cast：</span><br><span class="line">const string &amp; shorterString(const string &amp; s1, const string &amp; s2) &#123;</span><br><span class="line">	return s1.size() &lt; s2.size() ? s1 : s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string&amp; shorterString(string s1, string s2) &#123;</span><br><span class="line">	auto&amp; r &#x3D; shorterString(const_cast&lt;const string&amp;&gt;s1 : const_cast&lt;const string&amp;&gt;s2;);</span><br><span class="line">	return const_cast&lt;string&amp;&gt;(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先将它的实参强制转换成对const的引用，然后调用了shorterString函数的const版本。const版本返回对const string的引用，这个引用绑定在某个初始的非常量实参上</p>
<p>重载与作用域</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">string read();</span><br><span class="line">void print(const string&amp;);</span><br><span class="line">void print(double);</span><br><span class="line">void fooBar(int ival) &#123;</span><br><span class="line">	bool read &#x3D; false; &#x2F;&#x2F;新作用域，隐藏了外层的read</span><br><span class="line">	string s &#x3D; read; &#x2F;&#x2F;错误：read是bool值，而非函数</span><br><span class="line">	void print(int); &#x2F;&#x2F;新作用域：隐藏了之前的print</span><br><span class="line">	print(&quot;Value&quot;); &#x2F;&#x2F;错误：print(const string&amp;)被隐藏掉了</span><br><span class="line">	print(ival); &#x2F;&#x2F;正确：当前print(int)可见</span><br><span class="line">	print(3.14); &#x2F;&#x2F;正确：调用print(int);print(double)被隐藏掉</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认实参<br>默认实参作为形参的初始值出现在形参列表中，可以为一个或多个形参定义默认值。一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">typedef string::size_type sz;</span><br><span class="line">string screen(sz ht &#x3D; 24, sz wid &#x3D; 80, char backgrnd &#x3D; &#39; &#39;);</span><br><span class="line">string window;</span><br><span class="line">window &#x3D; screen(); &#x2F;&#x2F;screen(24,80,&#39; &#39;)</span><br><span class="line">window &#x3D; screen(66); &#x2F;&#x2F;screen(66,80,&#39; &#39;)</span><br><span class="line">window &#x3D; screen(66, 256); &#x2F;&#x2F;screen(66,256,&#39; &#39;)</span><br><span class="line">window &#x3D; screen(66, 256, &#39;#&#39;); &#x2F;&#x2F;screen(66,256,&#39;#&#39;)</span><br><span class="line">window &#x3D; screen(, , &#39;?&#39;); &#x2F;&#x2F;错误：只能省略尾部实参</span><br><span class="line">window &#x3D; screen(&#39;?&#39;) &#x2F;&#x2F;screen(&#39;?&#39;,80,&#39; &#39;)</span><br><span class="line">在给定的作用域中一个形参只能被赋予一次默认实参</span><br><span class="line">string screen(sz, sz, char &#x3D; &#39; &#39;);</span><br><span class="line">string screen(sc, sc, char&#x3D;&#39;*&#39;); &#x2F;&#x2F;错误：重复声明</span><br><span class="line">string screen(sc &#x3D; 24, sc &#x3D; 80, char); &#x2F;&#x2F;正确：添加默认实参</span><br><span class="line">局部变量不能作为默认实参，能转换成形参所需的类型的表达式可以作为默认实参。</span><br><span class="line">sz wd &#x3D; 80; char def &#x3D; &#39; &#39;; sz ht();</span><br><span class="line">string screen(sz &#x3D; ht(), sz &#x3D; wd, char &#x3D; def);</span><br><span class="line">string window &#x3D; screen(); &#x2F;&#x2F;调用screen(ht(),80,&#39; &#39;)</span><br><span class="line">void f2() &#123;</span><br><span class="line">	def &#x3D; &#39;*&#39;; &#x2F;&#x2F;改变默认参数的值</span><br><span class="line">	sz wd &#x3D; 80; &#x2F;&#x2F;隐藏了外层定义的wd，但没有改变默认值</span><br><span class="line">	window &#x3D; screen(); &#x2F;&#x2F;调用screen(ht(),80,&#39;*&#39;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内联函数(inline)可以避免函数调用的开销<br>inline const string&amp; shorterString(const string&amp; s1, const string&amp; s2) {<br>    return s1.size() &lt;= s2.size() ? s1 : s2;<br>}<br>内联机制用于优化规模较小、流程直接、频繁调用的函数。很多编译器不支持内联递归函数</p>
<p>constexpr函数(constexpr function)是指能用于常量表达式的函数。函数的返回类型及所有形参的类型都得是字面值类型，且函数体中必须有且仅有一条return语句<br>constexpr int new_sz() { return 42 };<br>constexpr int foo = new_sz();<br>constexpr函数体内也可以包含其他语句，只要在运行时不执行任何操作。如空语句、类型别名以及using声明<br>允许constexpr函数返回值并非一个常量<br>对于某个给定的内联函数或者constexpr函数，它的多个定义必须完全一致。所以通常定义在头文件中</p>
<p>调试帮助<br>assert预处理宏(preprocessor marco)  assert(expr)若expr表达式为假，assert输出信息并终止程序执行；为真则什么也不做<br>NDEBUG预处理变量：如果定义了NDEBUG，则assert什么也不做。默认状态下没有定义NDEBUG，此时assert将执行运行时检查<br><strong>func</strong> 存放函数的名字 <strong>FILE</strong> 存放文件名的字符串字面值 <strong>LINE</strong> 存放当前行号的整型字面值<br><strong>TIME</strong> 存放文件编译时间的字符串字面值 <strong>DATE</strong> 存放文件编译日期的字符串字面值</p>
<p>函数匹配<br>void f(); void f(int); void f(int, int); void f(double, double = 3.14);<br>f(5.6); //调用f(double,double=3.14)<br>如果有且只有一个函数满足下列条件，则匹配成功：<br>该函数每个实参的匹配都不劣于其他可行函数需要的匹配<br>至少有一个实参的匹配优于其他可行函数提供的匹配<br>类型转换：<br>精确匹配：类型相同；实参从数组或函数类型转换成对应的指针类型；向实参添加顶层const或从实参删除顶层const<br>通过const转换实现的匹配<br>通过类型提升实现的匹配<br>通过算术类型转换实现的匹配<br>通过类类型转换实现的匹配</p>
<p>函数指针指向的是函数而非对象。函数的类型由它的返回类型和形参类型共同决定，与函数名无关<br>bool lengthCompare(const string&amp;, const string&amp;);<br>bool (<em>pf)(const string&amp;, const string&amp;); 未初始化。 pf指向一个函数，该函数的参数是两个const string的引用，返回值是bool类型<br>bool</em> pf(const string&amp;, const string&amp;); pf是一个返回值为bool指针的函数<br>把函数名作为一个值使用时，该函数自动地转换成指针<br>pf = lengthCompare或者pf = &amp;lengthCompare 两个等价，取地址符可选<br>可以直接使用指向函数的指针调用该函数，无需提前解引用指针<br>bool b1 = pf(“hello”, “goodbye”);<br>bool b2 = (*pf)(“hello”, “goodbye”);<br>bool b3 = lengthCompare(“hello”, “goodbye”); 三个等价<br>在指向不同类型的指针间不存在转换规则。但可以为函数指针赋一个nullptr或者值为0的整型常量表达式，表示该指针没有指向任何函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string::size_type sumLength(const string&amp;, const string&amp;);</span><br><span class="line">bool cstringCompare(const char*, const char*);</span><br><span class="line">pf &#x3D; 0; &#x2F;&#x2F;正确：pf不指向任何函数</span><br><span class="line">pf &#x3D; sumLength; &#x2F;&#x2F;错误：返回值类型不匹配</span><br><span class="line">pf &#x3D; cstringCompare; &#x2F;&#x2F;错误：形参类型不匹配</span><br><span class="line">pf &#x3D; lengthCompare; &#x2F;&#x2F;正确：函数和指针类型精确匹配</span><br></pre></td></tr></table></figure>
<p>重载函数时，上下文必须清晰地界定到底该选用哪个函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void ff &#x3D; (int*);</span><br><span class="line">void ff &#x3D; (unsigned int);</span><br><span class="line">void (*pf1)(unsigned int) &#x3D; ff; &#x2F;&#x2F;pf1指向ff(unsighed int)</span><br><span class="line">void (*pf2)(int) &#x3D; ff; &#x2F;&#x2F;错误：没有ff与该类型形参列表匹配</span><br><span class="line">double (*pf3)(int*) &#x3D; ff; &#x2F;&#x2F;错误：返回值不匹配</span><br></pre></td></tr></table></figure>
<p>函数指针形参</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void useBigger(const string&amp; s1, const string&amp; s2, bool pf(const string&amp;, const string&amp;));</span><br><span class="line">void useBigger(const string&amp; s1, const string&amp; s2, bool(*pf)(const string&amp;, const string&amp;)); 二者等价，显式地将形参定义成指向函数的指针</span><br><span class="line">可以把函数作为实参使用，自动转换成指针</span><br><span class="line">useBigger(s1, s2, lengthCompare);</span><br><span class="line">使用类型别名：</span><br><span class="line">typedef bool Func(const string&amp;, const string&amp;);</span><br><span class="line">typedef decltype(lengthCompare) Func2; 二者等价，Func和Func2是函数类型</span><br><span class="line">typedef bool (*FuncP)(const string&amp;, const string&amp;);</span><br><span class="line">typedef decltype(lengthCompare)* FuncP2; 二者等价，* FuncP和* FuncP2是指针类型</span><br><span class="line">void useBigger(const string&amp;, const string&amp;, Func);</span><br><span class="line">void useBigger(const strign&amp;, const string&amp;, *FuncP2); 二者等价，第一句中编译器自动将Func表示的函数类型转换成指针</span><br></pre></td></tr></table></figure>
<p>使用类型别名返回指向函数的指针</p>
<pre><code>using F=int(int*, int);  //F是函数类型，不是指针
using PF=int(*)(int*, int); //PF是指针类型
PF f1(int); //正确：PF是指向函数的指针，f1返回指向函数的指针
F f1(int); //错误：F是函数类型，f1不能返回一个函数
F* f1(int); //正确：显式地指定返回类型是指向函数的指针
int (*f1(int))(int*, int); //指针指向一个返回值是int类型的函数
auto fi(int)-&gt;int(*)(int*, int);

string::size_type sumLength(const string&amp;, const string&amp;);
decltype(sumLength)* getFcn(const string&amp;);
decltype作用于某个函数时，返回函数类型而非指针。因此显式地加上*表示需要返回指针而非函数本身
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/06/c-primer-04-%E8%A1%A8%E8%BE%BE%E5%BC%8F/" data-id="ckhkofavj000j5kve7e2l1fr8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-primer/" rel="tag">c++ primer</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-problem-library-树-02" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/28/problem-library-%E6%A0%91-02/" class="article-date">
  <time datetime="2020-07-28T15:15:05.000Z" itemprop="datePublished">2020-07-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/28/problem-library-%E6%A0%91-02/">problem library 树 02</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="#106.从中序与后序遍历序列构造二叉树"></a>#106.从中序与后序遍历序列构造二叉树</h2><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p>
<p>注意:<br>你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<p>中序遍历 inorder = [9,3,15,20,7]<br>后序遍历 postorder = [9,15,7,20,3]<br>返回如下的二叉树：</p>
<pre><code>  3
 / \
9  20
  /  \
 15   7</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal" target="_blank" rel="noopener">https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;postorder, <span class="keyword">int</span> i_begin, <span class="keyword">int</span> i_end, <span class="keyword">int</span> p_begin, <span class="keyword">int</span> p_end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i_begin &gt; i_end || p_begin &gt; p_end)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode* res = <span class="keyword">new</span> TreeNode(postorder[p_end]);</span><br><span class="line">        <span class="keyword">if</span> (p_begin == p_end)<span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (postorder[p_end] != inorder[index])index++;</span><br><span class="line">        res-&gt;left = helper(inorder, postorder, i_begin, index - <span class="number">1</span>, p_begin, p_begin + index - <span class="number">1</span> - i_begin);</span><br><span class="line">        res-&gt;right = helper(inorder, postorder, index + <span class="number">1</span>, i_end, p_end - <span class="number">1</span> - (i_end - (index + <span class="number">1</span>)), p_end - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(inorder, postorder, <span class="number">0</span>, inorder.<span class="built_in">size</span>() - <span class="number">1</span>, <span class="number">0</span>, postorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="95-不同的二叉搜索树II"><a href="#95-不同的二叉搜索树II" class="headerlink" title="#95.不同的二叉搜索树II"></a>#95.不同的二叉搜索树II</h2><p>给定一个整数 n，生成所有由 1 … n 为节点所组成的 二叉搜索树 。</p>
<p>示例：</p>
<p>输入：3<br>输出：<br>[<br>  [1,null,3,2],<br>  [3,2,null,1],<br>  [3,1,null,null,2],<br>  [2,1,3],<br>  [1,null,2,null,3]<br>]<br>解释：<br>以上的输出对应以下 5 种不同结构的二叉搜索树：</p>
<pre><code>1         3     3      2      1
 \       /     /      / \      \
  3     2     1      1   3      2
 /     /       \                 \
2     1         2                 3</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-binary-search-trees-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">getrees</span><span class="params">(<span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lo &gt; hi)<span class="keyword">return</span> &#123; <span class="literal">nullptr</span> &#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt;res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt;= hi; i++) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;TreeNode*&gt; leftTrees = getrees(lo, i - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">vector</span>&lt;TreeNode*&gt; rightTrees = getrees(i + <span class="number">1</span>, hi);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; l : leftTrees)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; r : rightTrees) &#123;</span><br><span class="line">                    TreeNode* root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    root-&gt;left = l;</span><br><span class="line">                    root-&gt;right = r;</span><br><span class="line">                    res.emplace_back(root);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)<span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">return</span> getrees(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/28/problem-library-%E6%A0%91-02/" data-id="ckhkofawm002n5kve6x04252z" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/problem-library/" rel="tag">problem library</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-DS邓俊辉-10" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/27/DS%E9%82%93%E4%BF%8A%E8%BE%89-10/" class="article-date">
  <time datetime="2020-07-27T14:34:35.000Z" itemprop="datePublished">2020-07-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/27/DS%E9%82%93%E4%BF%8A%E8%BE%89-10/">DS邓俊辉 10 优先级队列</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h1><p>call-by-priority</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">struct</span> <span class="title">PQ</span> &#123;</span> <span class="comment">//priority queue</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(T)</span> </span>= <span class="number">0</span>; <span class="comment">//按照优先级次序插入词条</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> T <span class="title">getMax</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">//取出优先级最高的词条</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> T <span class="title">delMax</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">//删除优先级最高的词条</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">完全二叉堆</span><br><span class="line">逻辑上等同于完全二叉树，物理上直接借助向量实现</span><br><span class="line">逻辑节点与物理元素，依层次遍历次序彼此对应</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Parent(i) ((i-1&gt;&gt;1))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LChild(i) (1+((i)&lt;&lt;1)) <span class="comment">//奇数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RChild(i) ((1+(i))&lt;&lt;1) <span class="comment">//偶数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">PQ_ComplHeap</span> :</span><span class="keyword">public</span> PQ&lt;T&gt;, <span class="keyword">public</span> Vector&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function">Rank <span class="title">percolateDown</span><span class="params">(Rank n, Rank i)</span></span>; <span class="comment">//下滤</span></span><br><span class="line">	<span class="function">Rank <span class="title">percolateUP</span><span class="params">(Rank i)</span></span>; <span class="comment">//上滤</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(Rank n)</span></span>; <span class="comment">//Floyd建堆算法</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	QP_ComplHeap(T* A,Rank n) <span class="comment">//批量构造</span></span><br><span class="line">	&#123;copuFrom(A, <span class="number">0</span>, n); heapify(n);	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(T)</span></span>; <span class="comment">//按照比较器确定的优先级次序，插入词条</span></span><br><span class="line">	<span class="function">T <span class="title">getMax</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> _elem[<span class="number">0</span>]; &#125; <span class="comment">//读取优先级最高的词条</span></span><br><span class="line">	<span class="function">T <span class="title">delMax</span><span class="params">()</span></span>; <span class="comment">//删除优先级最高的词条</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">堆序性：</span><br><span class="line">数值上，只要<span class="number">0</span> &lt; i，必满足H[i] &lt;= H[Parent(i)]，故H[<span class="number">0</span>]是全局最大元素</span><br><span class="line"></span><br><span class="line">插入与上滤</span><br><span class="line">为插入词条e，只需将e作为末元素接入向量  结构性自然保持，堆序性未必破坏</span><br><span class="line">若破坏只需和父节点交换，可能交换多次</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> PQ_ComplHeap&lt;T&gt;::insert(T e) <span class="comment">//插入</span></span><br><span class="line">	&#123;Vector&lt;T&gt;::insert(e); pervolateUp(_size - <span class="number">1</span>);&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">//对第i个词条实施上滤，i&lt;_size</span></span><br><span class="line">Rank PQ_ComplHeap&lt;T&gt;::percolateUp(Rank i) &#123;</span><br><span class="line">	<span class="keyword">while</span> (PerantValid(i)) &#123; <span class="comment">//只要i有父亲（尚未抵达堆顶），则</span></span><br><span class="line">		Rank j = Parent(i); <span class="comment">//将之记作j</span></span><br><span class="line">		<span class="keyword">if</span> (It(_elem[i], _elem[j]))<span class="keyword">break</span>; <span class="comment">//一旦父子不在逆序，上滤旋即完成</span></span><br><span class="line">		swap(_elem[i], _elem[j]); i = j; <span class="comment">//否则，交换父子位置，并上升一层</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">删除与下滤</span><br><span class="line">删除向量首元素，代之以末元素e，结构性保持，若堆序性破坏，与e孩子中大者换位</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; T PQ_ComplHeap&lt;T&gt;::delMax() &#123; <span class="comment">//删除</span></span><br><span class="line">	T maxElem = _elem[<span class="number">0</span>]; _elem[<span class="number">0</span>] = _elem[--_size]; <span class="comment">//摘除堆顶，代之以末次条</span></span><br><span class="line">	percolateDown(_size, <span class="number">0</span>); <span class="comment">//对新堆顶实施下滤</span></span><br><span class="line">	<span class="keyword">return</span> maxElem; <span class="comment">//返回此前备份的最大词条</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//对前n个词条中的第i个实施下滤，i&lt;n</span></span><br><span class="line">Rank PQ_ComplHeap&lt;T&gt;::percolateDown(Rank n, Rank i) &#123;</span><br><span class="line">	Rank j; <span class="comment">//i及其(至多两个)孩子中，堪为父者</span></span><br><span class="line">	<span class="keyword">while</span> (i != (j = ProperParent(_elem, n, i))) <span class="comment">//只要i非j，则</span></span><br><span class="line">	&#123;</span><br><span class="line">		swap(_elem[i], _elem[j]); i = j; <span class="comment">//换位，并继续考察i</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i; <span class="comment">//返回下滤抵达的位置（亦i亦j）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">批量建堆</span><br><span class="line">自上而下的上滤</span><br><span class="line">PQ_ComplHeap(T* A, Rank n) &#123; copyFrom(A, <span class="number">0</span>, n); heapify(n); &#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> PQ_ComplHeap&lt;T&gt;::heapify(Rank n) &#123; <span class="comment">//蛮力</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="comment">//按照层次遍历次序逐一</span></span><br><span class="line">		percolateUp(i); <span class="comment">//经上滤插入各节点</span></span><br><span class="line">&#125;O(nlogn)</span><br><span class="line">自下而上的下滤</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> PQ_ComplHeap&lt;T&gt;::heapify(Rank n) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = LastInternal(n); i &gt;= <span class="number">0</span>; i--) <span class="comment">//自下而上，一次</span></span><br><span class="line">		percolateDown(n, i); <span class="comment">//下滤各内部节点</span></span><br><span class="line">&#125; <span class="comment">//可以理解为子堆的逐层合并 O(n)</span></span><br><span class="line"></span><br><span class="line">堆排序</span><br><span class="line">在选择排序中，待排序部分u替换为H；</span><br><span class="line">初始化：heapify(),O(n)建堆</span><br><span class="line">迭代：delMax(),O(logn)取出堆顶并调整复原</span><br><span class="line">不变性：H&lt;=S</span><br><span class="line">有：m=H[<span class="number">0</span>],x=S[<span class="number">-1</span>]，所以swap(m,x)=H.insert(x)+S.insert(m)</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">//对向量区间[lo,hi)做就地堆排序</span></span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::heapSort(Rank lo, Rank hi) &#123;</span><br><span class="line">	PQ_ComplHeap&lt;T&gt; H(_elem + lo, hi - lo); <span class="comment">//待排序区间建堆，O(n)</span></span><br><span class="line">	<span class="keyword">while</span> (!H.empty()) <span class="comment">//反复地摘除最大元并归入已排序的后缀，直至堆空</span></span><br><span class="line">		_elem[--hi] = H.delMax(); <span class="comment">//等效于堆顶与末元素对换后下滤</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">堆合并</span><br><span class="line">H=merge(A,B):将堆A、B合二为一 <span class="comment">//设|A|=n&gt;=m=|B|</span></span><br><span class="line">方法一：A.insert(b.delMax()) O(m*<span class="built_in">log</span>(m+n))</span><br><span class="line">方法二：<span class="keyword">union</span>(A,B).heapify(m+n)  O(m+n)</span><br><span class="line"></span><br><span class="line">左式堆</span><br><span class="line">新条件：结点分布偏向于左侧，合并操作只涉及右侧，牺牲结构性，保留堆序性</span><br><span class="line">空节点路径长度：npl(<span class="literal">NULL</span>)=<span class="number">0</span>,npl(x)=<span class="number">1</span>+<span class="built_in">min</span>(npl(lc(x),npl(rc(x))</span><br><span class="line">npl(x)=x到外部结点的最近距离=以x为根的最大满子树的高度</span><br><span class="line">左倾：对任何内节点x，都有npl(lc(x))&gt;=npl(rc(x)),推论，对任何内节点x都有npl(x)=npl(rc(x))+<span class="number">1</span></span><br><span class="line">右侧链rChain(x):从节点x出发，一直沿着右分支前进</span><br><span class="line">rChain(root)的终点，必为全堆中最浅的外部节点  npl(r)==|rChain(r)|=d 存在一颗以r为根、高度为d的满子树</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  <span class="comment">//基于二叉树，以左式堆形式实现的优先级队列</span></span><br><span class="line">class PQ_ComplHeap :<span class="keyword">public</span> PQ&lt;T&gt;, <span class="keyword">public</span> BinTree&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">void</span> insert(T); <span class="comment">//（按比较器确定的优先级次序）插入元素</span></span><br><span class="line">	T getMax() &#123; <span class="keyword">return</span> _root-&gt;data; &#125; <span class="comment">//取出优先级最高的元素</span></span><br><span class="line">	T delMax(); <span class="comment">//删除优先级最高的元素</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">static</span> BinNodePosi(T) merge(BinNodePosi(T) a, BinNodePosi(T) b) &#123;</span><br><span class="line">	<span class="keyword">if</span> (!a)<span class="keyword">return</span> b; <span class="comment">//递归基</span></span><br><span class="line">	<span class="keyword">if</span> (!b)<span class="keyword">return</span> a; <span class="comment">//递归基</span></span><br><span class="line">	<span class="keyword">if</span> (lt(a-&gt;data, b-&gt;data))swap(b, a); <span class="comment">//一般情况：首先确保b不大</span></span><br><span class="line">	a-&gt;rc = merge(a-&gt;rc, b); <span class="comment">//将a的右子堆与b合并</span></span><br><span class="line">	a-&gt;rc-&gt;parent = a; <span class="comment">//并更新父子关系</span></span><br><span class="line">	<span class="keyword">if</span> (!a-&gt;lc || a-&gt;lc-&gt;npl &lt; a-&gt;rc-&gt;npl) <span class="comment">//若有必要</span></span><br><span class="line">		swap(a-&gt;lc, a-&gt;rc); <span class="comment">//交换a的左右子堆，以确保右子堆的npl不大</span></span><br><span class="line">	a-&gt;npl = a-&gt;rc ? a-&gt;rc-&gt;npl + <span class="number">1</span> : <span class="number">1</span>; <span class="comment">//更新a的npl</span></span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;O(logn)</span><br><span class="line"></span><br><span class="line">插入即是合并、删除亦是合并</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> PQ_LeftHeap&lt;T&gt;::insert(T e) &#123; <span class="comment">//O(logn)</span></span><br><span class="line">	BinNodePosi(T)v = <span class="keyword">new</span> BinNode&lt;T&gt;(e); <span class="comment">//为e创建一个二叉树节点</span></span><br><span class="line">	_root = merge(_root, v); <span class="comment">//通过合并完成新节点的插入</span></span><br><span class="line">	_root-&gt;parent = <span class="literal">NULL</span>; <span class="comment">//既然此时堆非空，还需相应设置父子链接</span></span><br><span class="line">	_size++; <span class="comment">//更新规模</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">//O(logn)</span></span><br><span class="line"><span class="keyword">void</span> PQ_LeftHeap&lt;T&gt;::delMax(T e) &#123;</span><br><span class="line">	BinNodePosi(T) lHeap = _root-&gt;lc; <span class="comment">//左子堆</span></span><br><span class="line">	BinNodePosi(T) rHeap = _root-&gt;rc; <span class="comment">//右子堆</span></span><br><span class="line">	T e = _root-&gt;data; <span class="comment">//备份堆顶处的最大元素</span></span><br><span class="line">	<span class="keyword">delete</span> _root; _size--; <span class="comment">//删除根节点</span></span><br><span class="line">	_root = merge(lHeap, rHeap); <span class="comment">//原左右子堆合并</span></span><br><span class="line">	<span class="keyword">if</span> (_root)_root-&gt;parent = <span class="literal">NULL</span>; <span class="comment">//更新父子链接</span></span><br><span class="line">	<span class="keyword">return</span> e; <span class="comment">//返回原根节点的数据项</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/27/DS%E9%82%93%E4%BF%8A%E8%BE%89-10/" data-id="ckhkofavf00085kve4rha9kda" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%82%93%E4%BF%8A%E8%BE%89/" rel="tag">数据结构 邓俊辉</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-problem-library-树" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/26/problem-library-%E6%A0%91/" class="article-date">
  <time datetime="2020-07-26T14:21:54.000Z" itemprop="datePublished">2020-07-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/26/problem-library-%E6%A0%91/">problem library 树 01</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="#104.二叉树的最大深度"></a>#104.二叉树的最大深度</h2><p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，</p>
<pre><code>    3
   / \
  9  20
 /     \
15      7</code></pre><p>返回它的最大深度 3 。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">max</span>(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="#226.翻转二叉树"></a>#226.翻转二叉树</h2><p>翻转一棵二叉树。</p>
<p>示例：</p>
<p>输入：</p>
<pre><code>     4
   /   \
  2     7
 / \   / \
1   3 6   9</code></pre><p>输出：</p>
<pre><code>     4
   /   \
  7     2
 / \   / \
9   6 3   1</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/invert-binary-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/invert-binary-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        TreeNode* tmp = root-&gt;left;</span><br><span class="line">        root-&gt;left = invertTree(root-&gt;right);</span><br><span class="line">        root-&gt;right = invertTree(tmp);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="#617.合并二叉树"></a>#617.合并二叉树</h2><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p>
<p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p>
<p>示例 1:</p>
<p>输入: </p>
<pre><code>    1                         2                             
   / \                       / \                            
  3   2                     1   3                        
 /                           \   \                      
5                             4   7                  </code></pre><p>输出:<br>合并后的树:</p>
<pre><code>    3
   / \
  4   5
 / \   \ 
5   4   7</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/merge-two-binary-trees" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-two-binary-trees</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">NULL</span>)<span class="keyword">return</span> t2;</span><br><span class="line">        <span class="keyword">if</span> (t2 == <span class="literal">NULL</span>)<span class="keyword">return</span> t1;</span><br><span class="line">        t1-&gt;val += t2-&gt;val;</span><br><span class="line">        t1-&gt;left = mergeTrees(t1-&gt;left, t2-&gt;left);</span><br><span class="line">        t1-&gt;right = mergeTrees(t1-&gt;right, t2-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="#108.将有序数组转换为二叉搜索树"></a>#108.将有序数组转换为二叉搜索树</h2><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1。</p>
<p><strong>示例:</strong></p>
<p>给定有序数组: [-10,-3,0,5,9],</p>
<p>一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：</p>
<pre><code>     0
    / \
  -3   9
  /   /
-10  5</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getRes(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">getRes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lo &gt; hi)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> mi = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        TreeNode* res = <span class="keyword">new</span> TreeNode(nums[mi]);</span><br><span class="line">        res-&gt;left = getRes(nums, lo, mi - <span class="number">1</span>);</span><br><span class="line">        res-&gt;right = getRes(nums, mi + <span class="number">1</span>, hi);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="#100.相同的树"></a>#100.相同的树</h2><p>给定两个二叉树，编写一个函数来检验它们是否相同。</p>
<p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
<p>示例 1:</p>
<pre><code>   1         1
  / \       / \
 2   3     2   3

[1,2,3],   [1,2,3]</code></pre><p>输出: true<br>示例 2:</p>
<pre><code>   1          1
  /           \
 2             2

[1,2],     [1,null,2]</code></pre><p>输出: false</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/same-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/same-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">NULL</span> &amp;&amp; q == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!p || !q)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> p-&gt;val == q-&gt;val &amp;&amp; isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="#101.对称二叉树"></a>#101.对称二叉树</h2><p>给定一个二叉树，检查它是否是镜像对称的。</p>
<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>
<pre><code>    1
   / \
  2   2
 / \ / \
3  4 4  3</code></pre><p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p>
<pre><code>  1
 / \
2   2
 \   \
 3    3</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/symmetric-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/symmetric-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">defsym</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root1 &amp;&amp; !root2)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!root1 || !root2)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> root1-&gt;val == root2-&gt;val &amp;&amp; defsym(root1-&gt;left, root2-&gt;right) &amp;&amp; defsym(root1-&gt;right, root2-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> defsym(root, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="#235.二叉搜索树的最近公共祖先"></a>#235.二叉搜索树的最近公共祖先</h2><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。<br>例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]<br>示例 1:</p>
<p>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8<br>输出: 6<br>解释: 节点 2 和节点 8 的最近公共祖先是 6。<br>示例 2:</p>
<p>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4<br>输出: 2<br>解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rv = root-&gt;val, pv = p-&gt;val, qv = q-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> ((pv &lt; rv &amp;&amp; rv &lt; qv) || (qv &lt; rv &amp;&amp; rv &lt; pv))<span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (pv &lt; rv &amp;&amp; qv &lt; rv)<span class="keyword">return</span> lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">        <span class="keyword">if</span> (rv &lt; pv &amp;&amp; rv &lt; qv)<span class="keyword">return</span> lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="938-二叉树搜索树的范围和"><a href="#938-二叉树搜索树的范围和" class="headerlink" title="#938.二叉树搜索树的范围和"></a>#938.二叉树搜索树的范围和</h2><p>给定二叉搜索树的根结点 root，返回 L 和 R（含）之间的所有结点的值的和。</p>
<p>二叉搜索树保证具有唯一的值。</p>
<p>示例 1：</p>
<p>输入：root = [10,5,15,3,7,null,18], L = 7, R = 15<br>输出：32<br>示例 2：</p>
<p>输入：root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10<br>输出：23</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/range-sum-of-bst" target="_blank" rel="noopener">https://leetcode-cn.com/problems/range-sum-of-bst</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rangeSumBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rv = root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (L &lt; rv &amp;&amp; R &lt; rv)<span class="keyword">return</span> rangeSumBST(root-&gt;left, L, R);</span><br><span class="line">        <span class="keyword">if</span> (rv &lt; L &amp;&amp; rv &lt; R)<span class="keyword">return</span> rangeSumBST(root-&gt;right, L, R);</span><br><span class="line">        <span class="keyword">if</span> (L &lt;= root-&gt;val &amp;&amp; root-&gt;val &lt;= R)<span class="keyword">return</span> (root-&gt;val + rangeSumBST(root-&gt;left, L, R) + rangeSumBST(root-&gt;right, L, R));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="#96.不同的二叉搜索树"></a>#96.不同的二叉搜索树</h2><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p>
<p>示例:</p>
<p>输入: 3<br>输出: 5<br>解释:<br>给定 n = 3, 一共有 5 种不同结构的二叉搜索树:</p>
<pre><code>1         3     3      2      1
 \       /     /      / \      \
  3     2     1      1   3      2
 /     /       \                 \
2     1         2                 3</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/unique-binary-search-trees" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-binary-search-trees</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;G(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        G[<span class="number">0</span>] = <span class="number">1</span>; G[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">                G[i] += (G[j - <span class="number">1</span>] * G[i - j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> G[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/26/problem-library-%E6%A0%91/" data-id="ckhkofawo002r5kve7nfgdasr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/problem-library/" rel="tag">problem library</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-problem-library-数组" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/26/problem-library-%E6%95%B0%E7%BB%84/" class="article-date">
  <time datetime="2020-07-26T13:41:44.000Z" itemprop="datePublished">2020-07-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/26/problem-library-%E6%95%B0%E7%BB%84/">problem library 数组</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="#53.最大子序和"></a>#53.最大子序和</h2><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例:</p>
<p>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/maximum-subarray" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-subarray</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> <span class="built_in">max</span> = INT_MIN;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; nums.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">				sum += nums[j];</span><br><span class="line">				<span class="keyword">if</span> (sum &gt; <span class="built_in">max</span>)<span class="built_in">max</span> = sum;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="121-买股票的最佳时机"><a href="#121-买股票的最佳时机" class="headerlink" title="#121.买股票的最佳时机"></a>#121.买股票的最佳时机</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">		int min &#x3D; INT_MAX, profit &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; prices.size(); i++)</span><br><span class="line">		&#123;</span><br><span class="line">			if (prices[i] &lt; min)min &#x3D; prices[i];</span><br><span class="line">			if (profit &lt; prices[i] - min)profit &#x3D; prices[i] - min;</span><br><span class="line">		&#125;</span><br><span class="line">		return profit;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="561-数组拆分"><a href="#561-数组拆分" class="headerlink" title="#561.数组拆分"></a>#561.数组拆分</h2><p>给定长度为 2n 的数组, 你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), …, (an, bn) ，使得从1 到 n 的 min(ai, bi) 总和最大。</p>
<p>示例 1:</p>
<p>输入: [1,4,3,2]</p>
<p>输出: 4<br>解释: n 等于 2, 最大总和为 4 = min(1, 2) + min(3, 4).</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/array-partition-i" target="_blank" rel="noopener">https://leetcode-cn.com/problems/array-partition-i</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">arrayPairSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i += <span class="number">2</span>)</span><br><span class="line">			sum += nums[i];</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="#169.多数元素"></a>#169.多数元素</h2><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<p>示例 1:</p>
<p>输入: [3,2,3]<br>输出: 3</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/majority-element" target="_blank" rel="noopener">https://leetcode-cn.com/problems/majority-element</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">		sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">		<span class="keyword">return</span> nums[nums.<span class="built_in">size</span>() / <span class="number">2</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="66-加一"><a href="#66-加一" class="headerlink" title="#66.加一"></a>#66.加一</h2><p>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。</p>
<p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p>
<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<p>示例 1:</p>
<p>输入: [1,2,3]<br>输出: [1,2,4]<br>解释: 输入数组表示数字 123。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/plus-one" target="_blank" rel="noopener">https://leetcode-cn.com/problems/plus-one</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">plusOne</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; digits)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = digits.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">			digits[i]++;</span><br><span class="line">			<span class="keyword">if</span> (digits[i] != <span class="number">10</span>)<span class="keyword">return</span> digits;</span><br><span class="line">			<span class="keyword">else</span> digits[i] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		digits.insert(digits.<span class="built_in">begin</span>(), <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span> digits;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="#88.合并两个有序数组"></a>#88.合并两个有序数组</h2><p>给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。</p>
<p>说明:</p>
<p>初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。<br>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</p>
<p>示例:</p>
<p>输入:<br>nums1 = [1,2,3,0,0,0], m = 3<br>nums2 = [2,5,6],       n = 3</p>
<p>输出: [1,2,2,3,5,6]</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/merge-sorted-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-sorted-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i = m + n - <span class="number">1</span>; m--; n--;</span><br><span class="line">		<span class="keyword">while</span> (n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">while</span> (m &gt;= <span class="number">0</span> &amp;&amp; nums1[m] &gt; nums2[n])swap(nums1[i--], nums1[m--]);</span><br><span class="line">			swap(nums1[i--], nums2[n--]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="283-移动零"><a href="#283-移动零" class="headerlink" title="#283.移动零"></a>#283.移动零</h2><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p>示例:</p>
<p>输入: [0,1,0,3,12]<br>输出: [1,3,12,0,0]<br>说明:</p>
<p>必须在原数组上操作，不能拷贝额外的数组。<br>尽量减少操作次数</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/move-zeroes" target="_blank" rel="noopener">https://leetcode-cn.com/problems/move-zeroes</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, count = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nums[i] != <span class="number">0</span>)swap(nums[count++], nums[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="122-买股票的最佳时机II"><a href="#122-买股票的最佳时机II" class="headerlink" title="#122.买股票的最佳时机II"></a>#122.买股票的最佳时机II</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例 1:</p>
<p>输入: [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>, <span class="built_in">min</span> = prices[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (prices[i] &lt; <span class="built_in">min</span>)<span class="built_in">min</span> = prices[i];</span><br><span class="line">			<span class="keyword">if</span> (prices[i + <span class="number">1</span>]&lt;prices[i] &amp;&amp; prices[i]&gt;<span class="built_in">min</span>) &#123; sum += prices[i] - <span class="built_in">min</span>; <span class="built_in">min</span> = prices[i]; &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (prices[prices.<span class="built_in">size</span>() - <span class="number">1</span>] &gt; <span class="built_in">min</span>)sum += (prices[prices.<span class="built_in">size</span>() - <span class="number">1</span>] - <span class="built_in">min</span>);</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="#26.  删除排序数组中的重复项"></a>#26.  删除排序数组中的重复项</h2><p>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
<p>示例 1:</p>
<p>给定数组 nums = [1,1,2], </p>
<p>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </p>
<p>你不需要考虑数组中超出新长度后面的元素。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (nums.empty())<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nums[i] != nums[count])swap(nums[i], nums[++count]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> count + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="11-盛水最多的容器"><a href="#11-盛水最多的容器" class="headerlink" title="#11.盛水最多的容器"></a>#11.盛水最多的容器</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> <span class="built_in">max</span> = INT_MIN;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="built_in">height</span>.<span class="built_in">size</span>() - <span class="number">1</span>; i &lt; j;) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">min</span>(<span class="built_in">height</span>[i], <span class="built_in">height</span>[j]) * (j - i) &gt; <span class="built_in">max</span>)<span class="built_in">max</span> = <span class="built_in">min</span>(<span class="built_in">height</span>[i], <span class="built_in">height</span>[j]) * (j - i);</span><br><span class="line">			(<span class="built_in">height</span>[i] &lt; <span class="built_in">height</span>[j]) ? i++ : j--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>#15.三数之和<br>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<p>示例：</p>
<p>给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p>
<p>满足要求的三元组集合为：<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/3sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/3sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">threeSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> j = i + <span class="number">1</span>, k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    j++; <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (k &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; nums[k] == nums[k + <span class="number">1</span>]) &#123;</span><br><span class="line">                    k--; <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] &gt; <span class="number">0</span>)k--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] &lt; <span class="number">0</span>)j++;</span><br><span class="line">                <span class="keyword">else</span> res.push_back(&#123; nums[i],nums[j++],nums[k--] &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="剑指offer11-旋转数组的最小数字"><a href="#剑指offer11-旋转数组的最小数字" class="headerlink" title="剑指offer11.旋转数组的最小数字"></a>剑指offer11.旋转数组的最小数字</h2><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  </p>
<p>示例 1：</p>
<p>输入：[3,4,5,1,2]<br>输出：1<br>示例 2：</p>
<p>输入：[2,2,2,0,1]<br>输出：0</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = numbers.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mi = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (numbers[mi] &lt; numbers[hi])hi = mi;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (numbers[hi] &lt; numbers[mi])lo = mi + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> hi -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[lo];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>#64.最小路径和<br>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>说明：每次只能向下或者向右移动一步。</p>
<p>示例:</p>
<p>输入:<br>[<br>  [1,3,1],<br>  [1,5,1],<br>  [4,2,1]<br>]<br>输出: 7<br>解释: 因为路径 1→3→1→1→1 的总和最小。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/minimum-path-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-path-sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid.<span class="built_in">size</span>() == <span class="number">0</span> || grid[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> row = grid.<span class="built_in">size</span>(), column = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">auto</span> dp = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(row, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(column));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; column; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; column; j++) &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[row - <span class="number">1</span>][column - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="1033-移动石子直到连续"><a href="#1033-移动石子直到连续" class="headerlink" title="#1033.移动石子直到连续"></a>#1033.移动石子直到连续</h2><p>三枚石子放置在数轴上，位置分别为 a，b，c。</p>
<p>每一回合，我们假设这三枚石子当前分别位于位置 x, y, z 且 x &lt; y &lt; z。从位置 x 或者是位置 z 拿起一枚石子，并将该石子移动到某一整数位置 k 处，其中 x &lt; k &lt; z 且 k != y。</p>
<p>当你无法进行任何移动时，即，这些石子的位置连续时，游戏结束。</p>
<p>要使游戏结束，你可以执行的最小和最大移动次数分别是多少？ 以长度为 2 的数组形式返回答案：answer = [minimum_moves, maximum_moves]</p>
<p>示例 1：</p>
<p>输入：a = 1, b = 2, c = 5<br>输出：[1, 2]<br>解释：将石子从 5 移动到 4 再移动到 3，或者我们可以直接将石子移动到 3。<br>示例 2：</p>
<p>输入：a = 4, b = 3, c = 2<br>输出：[0, 0]<br>解释：我们无法进行任何移动</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/moving-stones-until-consecutive" target="_blank" rel="noopener">https://leetcode-cn.com/problems/moving-stones-until-consecutive</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">numMovesStones</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v&#123; a,b,c &#125;;</span><br><span class="line">        sort(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> mMax = v[<span class="number">2</span>] - v[<span class="number">0</span>] - <span class="number">2</span>, <span class="built_in">min</span> = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> ((v[<span class="number">1</span>] - v[<span class="number">0</span>]) &lt;= <span class="number">2</span> || (v[<span class="number">2</span>] - v[<span class="number">1</span>]) &lt;= <span class="number">2</span>) <span class="built_in">min</span> = <span class="number">1</span>;;</span><br><span class="line">        <span class="keyword">if</span> ((v[<span class="number">1</span>] - v[<span class="number">0</span>]) == <span class="number">1</span> &amp;&amp; (v[<span class="number">2</span>] - v[<span class="number">1</span>]) == <span class="number">1</span>) <span class="built_in">min</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="built_in">min</span>,mMax &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="#238.除自身以外数组的乘积"></a>#238.除自身以外数组的乘积</h2><p>给你一个长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。</p>
<p>示例:</p>
<p>输入: [1,2,3,4]<br>输出: [24,12,8,6]</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/product-of-array-except-self" target="_blank" rel="noopener">https://leetcode-cn.com/problems/product-of-array-except-self</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v2;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v3;</span><br><span class="line">        <span class="keyword">int</span> n1 = <span class="number">1</span>, n2 = <span class="number">1</span>;</span><br><span class="line">        v1.push_back(<span class="number">1</span>);</span><br><span class="line">        v2.push_back(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            v1.push_back(n1 *= nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>(); j++)v2.push_back(n2 *= nums[nums.<span class="built_in">size</span>() - j - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; nums.<span class="built_in">size</span>(); k++) &#123;</span><br><span class="line">            v3.push_back(v1[k] * v2[nums.<span class="built_in">size</span>() - <span class="number">1</span> - k]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="#16.最接近的三数之和"></a>#16.最接近的三数之和</h2><p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p>
<p>示例：</p>
<p>输入：nums = [-1,2,1,-4], target = 1<br>输出：2<br>解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) </p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/3sum-closest" target="_blank" rel="noopener">https://leetcode-cn.com/problems/3sum-closest</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">min</span>=<span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>()<span class="number">-2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j=i+<span class="number">1</span>,k=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;k)&#123;</span><br><span class="line">                <span class="keyword">int</span> sum=nums[i]+nums[j]+nums[k];</span><br><span class="line">                <span class="keyword">if</span>(sum==target)<span class="keyword">return</span> target;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(sum-target)&lt;<span class="built_in">abs</span>(<span class="built_in">min</span>-target))&#123;</span><br><span class="line">                    <span class="built_in">min</span>=sum;&#125;</span><br><span class="line">                (sum&lt;target)?j++:k--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="5-6-合并区间"><a href="#5-6-合并区间" class="headerlink" title="#5 6.合并区间"></a>#5 6.合并区间</h2><p>给出一个区间的集合，请合并所有重叠的区间。</p>
<p>示例 1:</p>
<p>输入: [[1,3],[2,6],[8,10],[15,18]]<br>输出: [[1,6],[8,10],[15,18]]<br>解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/merge-intervals" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-intervals</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        sort(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.<span class="built_in">size</span>();) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> ir = intervals[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (j &lt; intervals.<span class="built_in">size</span>() &amp;&amp; intervals[j][<span class="number">0</span>] &lt;= ir) &#123;</span><br><span class="line">                ir = <span class="built_in">max</span>(ir, intervals[j][<span class="number">1</span>]);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(&#123; intervals[i][<span class="number">0</span>],ir &#125;);</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/26/problem-library-%E6%95%B0%E7%BB%84/" data-id="ckhkofawl002l5kveaf03cjfb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/problem-library/" rel="tag">problem library</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-DS邓俊辉09" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/26/DS%E9%82%93%E4%BF%8A%E8%BE%8909/" class="article-date">
  <time datetime="2020-07-26T13:32:35.000Z" itemprop="datePublished">2020-07-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/26/DS%E9%82%93%E4%BF%8A%E8%BE%8909/">DS邓俊辉09 散列</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h1><p>散列(Hashing)call-by-value<br>桶(bucket):直接存放活间接指向一个词条<br>桶数组(bucket array)/散列表(hash table)，容量为M N&lt;M&lt;&lt;R 空间O(N+M)=O(N)<br>定址/杂凑/散列：根据词条的key直接确定散列表入口<br>散列函数：hash():key-&gt;&amp;entry<br>装填因子(load factor)λ=N/M<br>散列函数(hash())：<br>确定(determinism)同一关键码总是被映射至同一地址；快速(efficiency)expected-O(1)；满射(surjection)：尽可能充分地覆盖整个散列空间<br>均匀(uniformity)：关键码映射到散列表各位置的概率尽量接近，避免聚集(clustering)现象<br>除余法：hash(key)=key%M  M为素数时，数据对散列表覆盖最充分，分布最均匀<br>最大公因子gc=(S,M)=G 当且仅当G=1时，可以遍布M，所以M应取素数<br>缺陷：不动点：无论表长M取值，总有hash(0)==0；零阶均匀：[0,R),平均分配至M个桶，但相邻关键码的散列地址也必相邻<br>MAD(multiply-add-divide):取M为素数，a &gt; 0,b &gt; 0,a % M!= 0,hash(key)=(a * key + b) % M<br>更多散列函数：数字分析(selecting digits)抽取key中某几位，构成地址；平方取中(mid-square)取key^2的中间若干位构成地址<br>折叠法(folding):将key分割成等宽的若干段，取其总和作为地址 位异或法<br>(伪)随机数法:rand(x+1)=[a<em>rand(x)]%M;  hash(key)=rand(key)=[rand[0]</em>a^key]%M 可移植性差<br>多项式法:hash(s =x0x1…xn-1) = x0<em>a^(n-1)+…+xn-2</em>a^1+xn-1</p>
<p>排解冲突：<br>多槽位(multiple slots)桶单元细分成若干槽位，存放冲突的词条。但预留过多空间会浪费，极端情况可能会不够<br>独立链(linked-list/separate chaining)每个桶存放一个指针，冲突的词条组织成列表<br>无需为每个桶预留多个槽位，任一多次的冲突都可解决，删除操作实现简单、统一<br>但是指针需要额外空间，节点需要动态申请；空间未必连续分布，系统缓存几乎失效<br>开放定址(open addressing)为每个桶都事先约定若干备用桶，他们构成一个查找链(probing sequence/chain)<br>查找时沿查找链，逐个转向下一桶单元，直到命中-&gt;成功,或者抵达一个空桶-&gt;失败<br>线性试探(linear probing)一旦冲突，则试探后一紧邻桶单元:[hash(key)+1]%M.[hash(key)+2]%M….直到命中成功或者抵达空桶失败<br>无需附加的(指针、链表或溢出区等)空间；查找链具有局部性，可充分利用系统缓存，有效减少I/O<br>但是操作时间&gt;O(1),冲突增多，以往的冲突会导致后续的冲突<br>懒惰删除(lazy removal)直接删除词条将导致查找链被切断，后续词条丢失，可以在删除的时候不删除而是加一标记，查找时越过，插入时加入<br>平方试探(quadratic probing)以平方数为距离，确定下一试探桶单元 [hash(key)+n^2]%M<br>数据聚集现象有所缓解，查找链上各桶间距线性递增，但涉及外存时I/O激增，且空桶一不定能被发现<br>M若为合数，n^2%M可能的取值必然少于[m/2]种，M若为合数，恰好[M/2]种，取遍前[M/2]个桶<br>所以若M是素数，且λ&lt;50%就一定能找到<br>双向平方试探：[hash(key) + n ^ 2] % M, [hash(key) - n ^ 2] % M<br>表长取素数M=4*k+3，必然可以保证查找链的前M项均互异<br>双平方定理(two-square theorem of fermat):任一素数p可表示为一对整数的平方和，当且仅当p%4=1</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/26/DS%E9%82%93%E4%BF%8A%E8%BE%8909/" data-id="ckhkofavh000d5kve9esq4tni" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%82%93%E4%BF%8A%E8%BE%89/" rel="tag">数据结构 邓俊辉</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/c-primer/" rel="tag">c++ primer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cocos2d-x/" rel="tag">cocos2d-x</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpp-notes/" rel="tag">cpp notes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/problem-library/" rel="tag">problem library</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reading-notes-DS/" rel="tag">reading notes DS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%82%93%E4%BF%8A%E8%BE%89/" rel="tag">数据结构 邓俊辉</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/c-primer/" style="font-size: 15px;">c++ primer</a> <a href="/tags/cocos2d-x/" style="font-size: 12.5px;">cocos2d-x</a> <a href="/tags/cpp-notes/" style="font-size: 20px;">cpp notes</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/problem-library/" style="font-size: 15px;">problem library</a> <a href="/tags/reading-notes-DS/" style="font-size: 10px;">reading notes DS</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%82%93%E4%BF%8A%E8%BE%89/" style="font-size: 17.5px;">数据结构 邓俊辉</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/10/27/mysql/">mysql</a>
          </li>
        
          <li>
            <a href="/2020/08/30/c-primer-16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/">c++ primer 16 模板与泛型编程</a>
          </li>
        
          <li>
            <a href="/2020/08/30/c-primer-15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">c++ primer 15 面向对象程序设计</a>
          </li>
        
          <li>
            <a href="/2020/08/30/c-primer-14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/">c++ primer 14 重载运算符与类型转换</a>
          </li>
        
          <li>
            <a href="/2020/08/30/c-primer-13-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/">c++ primer 13 拷贝控制</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>
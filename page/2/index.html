<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-c-primer-11-关联容器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/30/c-primer-11-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/" class="article-date">
  <time datetime="2020-08-30T02:40:52.000Z" itemprop="datePublished">2020-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/30/c-primer-11-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/">c++ primer 11 关联容器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="关联容器-associative-container"><a href="#关联容器-associative-container" class="headerlink" title="关联容器(associative_container)"></a>关联容器(associative_container)</h1><p>关联容器支持高效的关键字查找和访问<br>不同的关联容器体现在：set或map；是否允许重复关键字(multi)；是否按顺序保存(unordered)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;统计单词出现次数</span><br><span class="line">map&lt;string, size_t&gt;word_count;</span><br><span class="line">string word;</span><br><span class="line">while (cin &gt;&gt; word)++word_count[word];</span><br><span class="line">for (const auto&amp; w : word_count)cout &lt;&lt; w.first &lt;&lt; &quot; occurs &quot; &lt;&lt; w.second &lt;&lt; &quot; times &quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用set</span><br><span class="line">map&lt;string, size_t&gt;word_count;</span><br><span class="line">set&lt;string&gt;exclude &#x3D; &#123; &quot;a&quot;,&quot;an&quot;,&quot;the&quot; &#125;;</span><br><span class="line">string word;</span><br><span class="line">while (cin &gt;&gt; word) &#123;</span><br><span class="line">	if (exclude.find(word) &#x3D;&#x3D; exclude.end())word_count[word]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用关键字类型的比较函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bool compareIsbn(const Sales_data &amp; lhs, const Sales_data &amp; rhs) &#123; return lhs.isbn() &lt; rhs.isbn(); &#125;</span><br><span class="line">multiset&lt;Sales_data, decltype(compareIsbn)*&gt;bookstore(compareIsbn);</span><br></pre></td></tr></table></figure>
<p>为使用自定义操作，定义时我们必须提供关键字类型Sales_data，以及比较操作类型–一种函数指针类型，可以指向compareIsbn。<br>定义对象时，提供一个指向compareIsbn的指针</p>
<h3 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h3><p>———————————–380</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;string,int&gt;</span><br><span class="line">process(vector&lt;string&gt; &amp; v) &#123;</span><br><span class="line">	if (!v.empty())return &#123; v.back(),v.back().size() &#125;;</span><br><span class="line">	else return pair&lt;string, int&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!v.empty())return pair&lt;string, int&gt;(v.back(), v.back().size());</span><br><span class="line">if (!v.empty())return make_pair(v.back(), v.back().size());</span><br><span class="line"></span><br><span class="line">map&lt;string, int&gt;::value_type v1; &#x2F;&#x2F;v1是一个pair&lt;const string,int&gt;</span><br><span class="line">map&lt;string, int&gt;::key_type v2; &#x2F;&#x2F;v2是一个string</span><br><span class="line">map&lt;string, int&gt;::mapped_type v3; &#x2F;&#x2F;v3是一个int</span><br></pre></td></tr></table></figure>
<p>初始化map时，必须提供关键字类型和值类型。将其包围在花括号中{ key,value }</p>
<p>添加元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt;v &#x3D; &#123; 2,4,6,8,2,4,6,8 &#125;;</span><br><span class="line">set&lt;int&gt;s;</span><br><span class="line">s.insert(v.begin(), v.end()); &#x2F;&#x2F;有4个元素</span><br><span class="line">s.insert(&#123; 1,3,5,7,1,3,5,7 &#125;); &#x2F;&#x2F;有8个元素</span><br><span class="line"></span><br><span class="line">word_count.insert(&#123;word,1&#125;);</span><br><span class="line">word_count.insert(make_pair(word,1));</span><br><span class="line">word_count.insert(pair&lt;string,size_t&gt;(word,1));</span><br><span class="line">word_count.insert(map&lt;string,size_t&gt;::value_type(word,1));</span><br></pre></td></tr></table></figure>
<p>——————————————————————384</p>
<p>对于不包含重复关键字的容器，添加单一元素的insert和emplace返回一个pair，first是指向给定关键字元素的迭代器，second是bool类型，是否成功</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, size_t&gt;word_count; string word;</span><br><span class="line">while (cin &gt;&gt; word) &#123;</span><br><span class="line">	auto ret &#x3D; word_count.insert(&#123; word,1 &#125;);</span><br><span class="line">	if (!ret.second)++ret-&gt;first.second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除元素<br>——————————————————387</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map的下标操作</span><br><span class="line">word_count[&quot;anna&quot;] &#x3D; 1;</span><br></pre></td></tr></table></figure>
<p>在word_count搜索关键字为anna的元素，未找到；将新关键字 - 值对插入到word_count中，关键字是一个const string，保存anna。值进行初始化，0；<br>提取出新插入的元素，并将值1赋予它<br>只能对非const的map使用下标操作</p>
<p>c[k]：返回关键字为k的元素；如果k不在c中，添加一个关键字为k的元素，对其初始化<br>c.at(k)：访问关键字为k的元素，带参数检查；若k不在c中，抛出一个out_of_range异常</p>
<p>与vector和string不同，map下标运算符返回的类型(mapped_type)与解引用map迭代器得到的类型不同(value_type)</p>
<p>———————————————————————————— - 389</p>
<p>multimap或multiset中查找元素<br>有多个元素具有给定关键字，它们会相邻储存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">string search_item(&quot;Target&quot;);</span><br><span class="line">auto entries &#x3D; authors.count(search_item);</span><br><span class="line">auto iter &#x3D; authors.find(search_item);</span><br><span class="line">while (entries) &#123;</span><br><span class="line">	cout &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">	++iter;</span><br><span class="line">	--entries;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (auto beg &#x3D; authors.lower_bound(search_item), end &#x3D; authors.upper_bound(search_item); beg !&#x3D; end; ++beg) &#123;</span><br><span class="line">	cout &lt;&lt; beg-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (auto pos &#x3D; authors.equal_range(search_item); pos.first !&#x3D; pos.second; ++pos.first;)cout &lt;&lt; pos.first-&gt;second &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>无序容器(unordered associative container)<br>使用哈希函数(hash function)和关键字类型的 == 运算符来组织元素</p>
<p>——————————————– - 395</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">size_t hasher(const Sales_data&amp; sd) &#123; return hash&lt;string&gt;()(sd.isbn()); &#125;</span><br><span class="line">bool eqOp(const Sales_data&amp; lhs, const Sales_data&amp; rhs) &#123; return lhs.isbn() &#x3D;&#x3D; rhs.isbn(); &#125;</span><br><span class="line">using SD_multiset&#x3D;unordered_multiset&lt;Sales_data, decltype(hasher)*, decltype(eqOp)*&gt;;</span><br><span class="line">SD_multiset bookStore(42, hasher, eqOp);</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/30/c-primer-11-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/" data-id="ckhkopsd8000oesve8zig36pf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-primer/" rel="tag">c++ primer</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-c-primer-10-泛型算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/30/c-primer-10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/" class="article-date">
  <time datetime="2020-08-30T02:36:34.000Z" itemprop="datePublished">2020-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/30/c-primer-10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/">c++ primer 10 泛型算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="泛型算法"><a href="#泛型算法" class="headerlink" title="泛型算法"></a>泛型算法</h1><p>标准库定义了一组泛型算法来实现查找特定元素、替换或删除等操作<br>泛型：可以用于不同各类型的元素和多种容器类型<br>算法：实现了一些经典算法的公共接口，如排序和搜索等<br>大多数算法都定义在头文件algorithm中，在numeric中定义了一组数值泛型算法<br>迭代器领算法不依赖于容器，但算法依赖于元素类型的操作<br>泛型算法本身不会执行容器的操作，它们只会运行与迭代器之上，执行迭代器的操作–》算法永远不会改变底层容器的大小</p>
<p>除少数例外，标准库算法都对一个范围内的元素进行操作，“输入范围”。用要处理的第一个元素和尾元素之后位置的迭代器两个参数来表示此范围</p>
<p>只接受单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长</p>
<p>写容器元素的算法要注意确保序列原大小至少不小于要求算法写入的元素数目</p>
<p>插入迭代器(insert iterator)定义在头文件iterator中，back_inserter;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt;v;</span><br><span class="line">auto it &#x3D; back_inserter(v);</span><br><span class="line">*it &#x3D; 42; &#x2F;&#x2F;v中现在有一个元素，值为42</span><br><span class="line"></span><br><span class="line">fill_n(back_inserter(v), 10, 0); &#x2F;&#x2F;添加10个0到v</span><br></pre></td></tr></table></figure>
<p>拷贝算法是另一个向目的位置迭代器指向的输出序列中的元素写书数据的算法。接受三个迭代器，前两个表示范围，第三个表示目的序列的起始位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a1[] &#x3D; &#123; 0,1,2 &#125;;</span><br><span class="line">int a2[sizeof(a1) &#x2F; sizeof(*a1)];</span><br><span class="line">auto ret &#x3D; copy(begin(a1), end(a1), a2); &#x2F;&#x2F;把a1的内容拷贝给a2，ret指向拷贝到a2的尾元素之后的位置</span><br></pre></td></tr></table></figure>
<p>一些算法计算新元素的值，但不会将他们放置在输入序列的末尾，而是创建一个新序列保存这些结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">replace(ilst.bigin(), ilst.end(), 0, 42); &#x2F;&#x2F;将所有0替换为42</span><br><span class="line">replace(ilst.begin(), ilst.end(), back_inserter(ivec), 0, 42); &#x2F;&#x2F;ilst未改变，ivec包含ilst的一份拷贝，但其中的0替换为42</span><br></pre></td></tr></table></figure>
<h3 id="重排容器元素的算法"><a href="#重排容器元素的算法" class="headerlink" title="重排容器元素的算法"></a>重排容器元素的算法</h3><p>利用元素类型的&lt;运算符来实现排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void elimDups(vector&lt;string&gt;&amp; words) &#123;</span><br><span class="line">	sort(words.begin(), words.end());</span><br><span class="line">	auto end &#x3D; unique(words.begin(), words.end()); &#x2F;&#x2F;end指向最后一个不重复元素的下一个位置</span><br><span class="line">	erase(end, words.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>谓词是一个可调用的表达式，其返回结果是一个能用作条件的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bool isShorter(const string&amp; s1, const string&amp; s2) &#123; &#x2F;&#x2F;比较函数，按长度排序单词</span><br><span class="line">	return s1.size() &lt; s2.size();</span><br><span class="line">&#125;</span><br><span class="line">sort(words.begin(), words.end(), isShorter); &#x2F;&#x2F;由短至长排序单词</span><br><span class="line">stable_sort稳定排序算法，维持相等元素的原有顺序</span><br></pre></td></tr></table></figure>
<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>四种可调用的对象：函数、函数指针、重载了函数调用运算符的类、lambda表达式<br>一个lambda表达式表示一个可调用的代码单元。可理解为一个未命名的内联函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture list](parameter list)-&gt;return type&#123; function body &#125;</span><br></pre></td></tr></table></figure>
<p>capture list(捕获列表)是一个lambda所在函数中定义的局部变量的列表(通常为空)。lambda必须使用尾置返回来指定返回类型<br>可以忽略参数列表和返回值类型，但必须包含捕获列表和函数体</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto f &#x3D; [] &#123;return 42; &#125;</span><br></pre></td></tr></table></figure>
<p>调用方式与普通函数的调用方式相同，都是使用调用运算符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; f() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>在lambda中忽略括号和参数列表等价于指定一个空参数列表。忽略返回类型，lambda根据函数体中代码推断返回类型，返回类型可以是void<br>lambda不能有默认参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[](const string&amp; s1, const string&amp; s2) &#123;return s1.size() &lt; s2.size();&#125;</span><br></pre></td></tr></table></figure>
<p>空捕获列表表示此lambda不使用它所在函数中的任何局部变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stable_sort(words.begin(), words.end(), [](const string&amp; s1, const string&amp; s2) &#123;return s1.size() &lt; s2.size(); &#125;);</span><br></pre></td></tr></table></figure>
<p>lambda只能使用明确在捕获列表指出的局部变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto wc &#x3D; find_if(words.begin(), words.end(), [sz](const string &amp; s) &#123;return s.size() &gt;&#x3D; sz; &#125;); &#x2F;&#x2F;获取指向第一个长度不小于sz的元素的迭代器，如果不存在则返回words.end()的一个拷贝</span><br></pre></td></tr></table></figure>
<h3 id="for-each算法"><a href="#for-each算法" class="headerlink" title="for_each算法"></a>for_each算法</h3><p>打印words中长度大于等于sz的元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for_each(wc, words.end(), [](const string&amp; s) &#123;cout &lt;&lt; s &lt;&lt; &quot; &quot;; &#125;); cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h3 id="lambda捕获和返回"><a href="#lambda捕获和返回" class="headerlink" title="lambda捕获和返回"></a>lambda捕获和返回</h3><p>当定义一个lambda时，编译器生成一个与lambda对应的新的(未命名的)类类型。当向一个函数传递一个lambda时，同事定义了一个新类型和该类型的一个对象，传递的参数就是此编译器生成的类类型的未命名对象<br>默认情况下，从lambda生成的类都包含一个对应该lambda所捕获的变量的数据成员。<br>变量的捕获方式可以是值或引用<br>值捕获的前提是变量可以拷贝，在lambda创建时拷贝</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void func1() &#123;</span><br><span class="line">	size_t v1 &#x3D; 42; &#x2F;&#x2F;局部变量</span><br><span class="line">	auto f &#x3D; [v1] &#123;return v1; &#125;;</span><br><span class="line">	v1 &#x3D; 0; auto j &#x3D; f(); &#x2F;&#x2F;j为42，f保存了创建时的拷贝</span><br><span class="line">&#125;</span><br><span class="line">void func2() &#123;</span><br><span class="line">	size_t v1 &#x3D; 42;</span><br><span class="line">	auto f2 &#x3D; [&amp;v1] &#123;return v1; &#125;;</span><br><span class="line">	v1 &#x3D; 0; auto j &#x3D; f2(); &#x2F;&#x2F;j&#x3D;&#x3D;0,f2保存v1的引用而非拷贝</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当从函数返回lambda时，lambda不能包含引用捕获。</p>
<h3 id="隐式捕获"><a href="#隐式捕获" class="headerlink" title="隐式捕获"></a>隐式捕获</h3><p>[=]值捕获、[&amp;]引用捕获<br>混合捕获</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void biggies(vector&lt;string&gt;&amp; words, vector&lt;string&gt;::size_type sz, ostream&amp; os &#x3D; cout, char c &#x3D; &#39; &#39;) &#123;</span><br><span class="line">	for_each(words.begin(), words.end(), [&amp;, c](const string &amp; s) &#123;os &lt;&lt; s &lt;&lt; c; &#125;);</span><br><span class="line">	for_each(words.begin(), words.end(), [&#x3D;, &amp;os](const string &amp; s) &#123;os &lt;&lt; s &lt;&lt; c; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="10%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95_md_files/%E6%8D%95%E8%8E%B7.JPG?v=1&type=image" alt="输入图片描述"><br>可变lambda可省略参数列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void func3() &#123;</span><br><span class="line">	size_t v1 &#x3D; 42;</span><br><span class="line">	auto f &#x3D; [v1]()mutable &#123;return ++v1; &#125;;</span><br><span class="line">	v1 &#x3D; 0; auto j &#x3D; f(); &#x2F;&#x2F;j&#x3D;&#x3D;43</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个引用捕获的变量是否可以修改依赖于此引用是否指向非const类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void func4() &#123;</span><br><span class="line">	size_t v1 &#x3D; 42;</span><br><span class="line">	auto f2 &#x3D; [&amp;v1] &#123;return ++v1; &#125;;</span><br><span class="line">	v1 &#x3D; 0; auto j &#x3D; f(); &#x2F;&#x2F;j&#x3D;&#x3D;1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个lambda包含return之外的任何语句，则编译器假定此lambda返回void</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transform(vi.begin(), vi.end(), [](int i) &#123;if (i &lt; 0)return -i; else return i; &#125;); &#x2F;&#x2F;错误：不能推断lambda的返回类型</span><br><span class="line">transform(vi.begin(),vi.end(),[](int i)-&gt;int&#123;if (i &lt; 0)return -i; else return i; &#125;</span><br></pre></td></tr></table></figure>
<h3 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto newCallable &#x3D; bind(callable, arg_list);</span><br><span class="line">&#x2F;&#x2F;check6是一个可调用对象，接受一个string类型的参数</span><br><span class="line">auto check6 &#x3D; bind(check_size, _1, 6);</span><br></pre></td></tr></table></figure>
<p>_1为占位符，表示check6只接受单一参数。出现在arg_list的第一个位置，表示check6的此参数对应check_size的第一个参数。<br>此参数是一个const string&amp; ，因此，调用check6必须传给他一个string类型的参数，check6会将此参数传递给check_size</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string s &#x3D; &quot;hello&quot;;</span><br><span class="line">bool b1 &#x3D; check6(s); &#x2F;&#x2F;check6(s)会调用check_size(s,6)</span><br><span class="line">可以将lambda的find_if变为check_size版本</span><br><span class="line">auto wc &#x3D; find_if(words.begin(), words.end(), [](const string&amp; a));</span><br><span class="line">auto wc &#x3D; find_if(words.begin(), words.end(), bind(check_size, _1, sz));</span><br></pre></td></tr></table></figure>
<p>using std::placeholders::_1;<br>_1定义在命名空间placeholders中，它又定义在std中<br>另一种声明：using namespace namespace_name;<br>说明希望所有来自namespace_name的名字都可以直接使用<br>using namespace std::placeholders;</p>
<p>可以用bind绑定可调用对象中的参数或重新安排其顺序<br>auto g = bind(f, a, b, _2, c, _1);<br>生成一个新的可调用对象，有2个参数（_1, _2）。将它自己的参数作为第三个和第五个参数传递给f。调用g时，第一个参数传递给f作为最后一个参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;按单词长度由短至长排序</span><br><span class="line">sort(words.begin(), words.end(), isShorter); l</span><br><span class="line">&#x2F;&#x2F;由长至短</span><br><span class="line">sort(words.begin(), words.end(), bind(isShorter, _2, _1);</span><br><span class="line"></span><br><span class="line">bind拷贝其参数，对于不想拷贝的，使用ref函数</span><br><span class="line">for_each(words.begin(), words.end(), bind(print, ref(os), _1, &#39; &#39;));</span><br></pre></td></tr></table></figure>

<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h3 id="插入迭代器-insert-iterator"><a href="#插入迭代器-insert-iterator" class="headerlink" title="插入迭代器(insert iterator)"></a>插入迭代器(insert iterator)</h3><p>这些迭代器被绑定到一个容器上，可用来向容器插入元素<br>——————————————————–图358</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">back_inserter &#x2F; front_inserter &#x2F; inserter</span><br><span class="line"></span><br><span class="line">list&lt;int&gt;lst &#x3D; &#123; 1,2,3,4 &#125;, lst2, lst3;</span><br><span class="line">copy(lst.begin(), lst, end(), front_inserter(lst2)); &#x2F;&#x2F;4 3 2 1 </span><br><span class="line">copy(lst.begin(), lst.end(), inserter(lst3, lst3.begin())); &#x2F;&#x2F;1 2 3 4</span><br></pre></td></tr></table></figure>
<h3 id="流迭代器-stream-iterator"><a href="#流迭代器-stream-iterator" class="headerlink" title="流迭代器(stream iterator)"></a>流迭代器(stream iterator)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">istream_iterator&lt;int&gt;int_it(cin); &#x2F;&#x2F;从cin读取int</span><br><span class="line">istream_iterator&lt;int&gt;eof; &#x2F;&#x2F;istream尾后迭代器</span><br><span class="line">ifstream in(&quot;afile&quot;);</span><br><span class="line">istream_iterator&lt;string&gt;str_it(in); &#x2F;&#x2F;从&quot;afile&quot;读取字符串</span><br><span class="line"></span><br><span class="line">istream_iterator&lt;int&gt;in_iter(cin); &#x2F;&#x2F;从cin读取int</span><br><span class="line">istream_iterator&lt;int&gt;eof; &#x2F;&#x2F;istream尾后迭代器</span><br><span class="line">while (in_iter !&#x3D; eof)vec.push_back(*in_iter++); &#x2F;&#x2F;后置递增运算读取流，返回迭代器的旧值，解引用迭代器，获得从流读取的前一个值</span><br></pre></td></tr></table></figure>
<h3 id="反向迭代器-reverse-iterator"><a href="#反向迭代器-reverse-iterator" class="headerlink" title="反向迭代器(reverse iterator)"></a>反向迭代器(reverse iterator)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt;v &#x3D; &#123; 1,2,3,4,5 &#125;;</span><br><span class="line">for (auto r_iter &#x3D; v.crbegin(); r_iter !&#x3D; v.crend(); ++r_iter;) &#123;</span><br><span class="line">	cout &lt;&lt; *r_iter &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort(v.begin(), v.end()); &#x2F;&#x2F;正常排序v</span><br><span class="line">sort(v.rbegin(), v.rend()); &#x2F;&#x2F;逆序排序v</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;打印最后一个单词</span><br><span class="line">auto comma &#x3D; find(line.rbegin(), line.rend(), &#39;,&#39;);</span><br><span class="line">cout &lt;&lt; string(rcomma.base(), line.end()) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h2 id="泛型算法结构"><a href="#泛型算法结构" class="headerlink" title="泛型算法结构"></a>泛型算法结构</h2><p>输入、输出、前向、双向、随机访问，5种迭代器</p>
<p>返回void<br>图——————————————————–369</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/30/c-primer-10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/" data-id="ckhkopsd7000mesve90vh7utg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-c-primer-09-顺序容器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/30/c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/" class="article-date">
  <time datetime="2020-08-30T01:40:30.000Z" itemprop="datePublished">2020-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/30/c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/">c++ primer 09 顺序容器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="顺序容器-sequential-container"><a href="#顺序容器-sequential-container" class="headerlink" title="顺序容器(sequential container)"></a>顺序容器(sequential container)</h1><p>vector:可变大小数组。支持快速随机访问。在尾部之外位置插入删除元素可能很慢<br>deque:双端队列。支持快速随机访问。在头尾位置插入删除速度很快<br>list;双向列表。只支持双向顺序访问。在任何位置插入删除操作速度都很快<br>forward_list:单向列表。只支持单向顺序访问。在任何位置插入删除操作速度都很快<br>array:固定大小数组。支持快速随机访问。不能添加或删除元素<br>string:与vector相似，但专门用于保存字符。随机访问快。在尾部插入删除速度快</p>
<p>选择容器基本原则：<br>首选vector<br>有很多小元素，空间的额外开销很重要，不要用list或forward_list<br>在中间插入或删除，用list或forward_list<br>只在头尾插入或删除，用deque</p>
<h3 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h3><p><img src="./c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/%E6%8D%95%E8%8E%B7.png" alt="输入图片描述"></p>
<p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/%E6%8D%95%E8%8E%B71.PNG?v=1&type=image" alt="输入图片描述"></p>
<p>使用左闭合范围<br>如果begin与end相等，则范围为空；begin与end不等，则至少包含一个元素，且begin指向范围中的第一个元素；可以对begin递增若干次，使得begin==end</p>
<h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt;::iterator iter;    vector&lt;int&gt;::difference_type count;</span><br><span class="line"></span><br><span class="line">a.begin() &#x2F; rbegin() &#x2F; cbegin() &#x2F; crbegin()</span><br><span class="line">auto it &#x3D; a.begin(); &#x2F;&#x2F;仅当a是const时，it是const_iterator</span><br></pre></td></tr></table></figure>
<h3 id="容器定义和初始化"><a href="#容器定义和初始化" class="headerlink" title="容器定义和初始化"></a>容器定义和初始化</h3><p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/2%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"></p>
<p>创建一个容器为另一个的拷贝，两个容器的类型及元素类型必须匹配，传递迭代器参数拷贝范围时不要求，能转换即可;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt; authors &#x3D; &#123; &quot;ab&quot;,&quot;cd&quot;,&quot;ef&quot;&#125;;</span><br><span class="line">vector&lt;const char*&gt;articles &#x3D; &#123; &quot;a&quot;,&quot;an&quot;,&quot;the&quot; &#125;;</span><br><span class="line">list&lt;string&gt;list2(authors); &#x2F;&#x2F;正确：类型匹配</span><br><span class="line">deque&lt;string&gt;authList(authors); &#x2F;&#x2F;错误：容器类型不匹配</span><br><span class="line">vector&lt;string&gt;words(atricles); &#x2F;&#x2F;错误：容器类型必须匹配</span><br><span class="line">forward_list&lt;string&gt;words(articles.begin(), articles.end()); &#x2F;&#x2F;正确：可以将const char*转换为string</span><br></pre></td></tr></table></figure>
<p>如果元素类型是内置类型或者具有默认构造函数的类类型，可以值为构造函数提供一个容器大小参数；如果没有默认构造函数，还必须指定一个显式的元素初始值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">array&lt;string, 10&gt; &#x2F;&#x2F;类型为保存10个string的数组</span><br><span class="line">array&lt;int, 10&gt;::size_type i; &#x2F;&#x2F;正确  </span><br><span class="line">array&lt;int&gt;::size_type j; &#x2F;&#x2F;错误：array&lt;int&gt;不是一个类型</span><br><span class="line">array&lt;int,3&gt;ia1; &#x2F;&#x2F;10个默认初始化的int</span><br><span class="line">array&lt;int,3&gt;ia2 &#x3D; &#123; 0,1,2 &#125;; &#x2F;&#x2F;列表初始化</span><br><span class="line">array&lt;int, 3&gt;ia3 &#x3D; &#123; 1 &#125;; &#x2F;&#x2F;ia3[0]为1，其余元素为0</span><br><span class="line">不能对内置数组类型进行拷贝或对象赋值，但array可以</span><br><span class="line">array&lt;int, 3&gt;digs &#x3D; &#123; 1,2,3 &#125;;</span><br><span class="line">array&lt;int, 3&gt;copy &#x3D; digs;</span><br></pre></td></tr></table></figure>
<h3 id="赋值和swap"><a href="#赋值和swap" class="headerlink" title="赋值和swap"></a>赋值和swap</h3><p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/3%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c1 &#x3D; c2; &#x2F;&#x2F;将c1的内存替换为c2中元素的拷贝，c1大小变为c2的大小</span><br><span class="line">c1 &#x3D; &#123; a,b,c &#125;;</span><br><span class="line">array&lt;int, 3&gt;a1 &#x3D; &#123; 1,2,3 &#125;;</span><br><span class="line">array&lt;int, 3&gt;a2 &#x3D; &#123; 0 &#125;;</span><br><span class="line">a1 &#x3D; a2; &#x2F;&#x2F;替换a1中的元素</span><br><span class="line">a2 &#x3D; &#123; 0 &#125;; &#x2F;&#x2F;错误：不能讲一个花括号列表赋予数组</span><br></pre></td></tr></table></figure>
<p>赋值相关运算会导致指向左边容器内部的迭代器、引用和指针失效，而swap操作不会(array和string除外)</p>
<p>顺序容器(array除外)定义了一个assign成员，允许从一个不同但相容的类型赋值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt;names; vector&lt;const char*&gt;oldstyle;</span><br><span class="line">names &#x3D; oldstyle; &#x2F;&#x2F;错误：容器类型不匹配</span><br><span class="line">names.assign(oldstyle.begin(), oldstyle.end()); &#x2F;&#x2F;正确：可以将const char*转换成string</span><br><span class="line"></span><br><span class="line">list&lt;string&gt;slist1(1); &#x2F;&#x2F;1个元素，为空string</span><br><span class="line">slist1.assign(10, &quot;hi&quot;); &#x2F;&#x2F;10个元素，“hi”</span><br><span class="line">等价于slist1.clear(); slist1.insert(slist1.begin(), 10, &quot;hi&quot;);</span><br></pre></td></tr></table></figure>
<p>swap操作交换两个相同类型容器的内容。除array外，操作会很快，元素本身并未交换，只是交换了内部数据结构<br>除string外，指向容器的迭代器、引用和指针在swap后都不会失效</p>
<p>除forward_list外，都有size, empty, max_size(返回一个大于或等于该类型容器所能容纳的最大元素的值)。forward_list只有max_size和empty</p>
<p>每个容器类型都支持相等运算符(==/!=)；除无序关联容器外都支持关系运算符(&gt;/&gt;=/&lt;/&lt;=)。必须是相同类型容器，相同类型的元素<br>比较结果取决于第一个不相等的元素的比较结果</p>
<h3 id="向顺序容器中添加元素"><a href="#向顺序容器中添加元素" class="headerlink" title="向顺序容器中添加元素"></a>向顺序容器中添加元素</h3><p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/4%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"></p>
<p>插入容器后若容器没有扩容、该元素没有改变位置，不会使其失效<br>当我们用一个对象来初始化容器，或将一个对象插入到容器中时，实际上放入到容器中的是对象的一个拷贝，而不是对象本身</p>
<p>当调用push或insert成员函数时，我们将元素类型的对象传递给它们，这些对象被拷贝到容器中。<br>当我们调用emplace成员函数时，则是将参数传递给元素类型的构造函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c.emplace_back(&quot;99-9999&quot;,25,15.99); &#x2F;&#x2F;使用三个参数的Sales_data构造函数</span><br><span class="line">c.push_back((&quot;99-9999&quot;, 25, 15.99); &#x2F;&#x2F;错误：没有接受三个参数的push_back版本</span><br><span class="line">c.push_back(Sales_data((&quot;99-9999&quot;, 25, 15.99)); &#x2F;&#x2F;正确：创建一个临时的Sales_data对象传递给push_back</span><br></pre></td></tr></table></figure>
<p>调用emplace_back时会在容器管理的内存空间中直接创建对象；而调用push_back则会创建一个局部临时对象，并将其压入容器中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">emplace函数的参数根据元素类型而变化，参数必须与元素类型的构造函数相匹配</span><br><span class="line">c.emplace_back(); &#x2F;&#x2F;使用Sales_data的默认构造函数</span><br><span class="line">c.emplace(iter, &quot;99-9999&quot;); &#x2F;&#x2F;使用Sales_data(string)</span><br><span class="line">c.emplace_front(&quot;99-9999&quot;, 25, 15.99); &#x2F;&#x2F;使用Sales_data的接受一个ISBN、一个count和一个price的构造函数</span><br></pre></td></tr></table></figure>
<h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/5%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (!c.empty()) &#123;</span><br><span class="line">	auto val &#x3D; *c.begin(); val2 &#x3D; c.front();</span><br><span class="line">	auto last &#x3D; c.end();</span><br><span class="line">	auto val3 &#x3D; *(--c.end());</span><br><span class="line">	auto val4 &#x3D; c.back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在容器中访问元素的成员函数(fornt,back,下标和at)返回的都是引用，容器是一个const对象则返回值是const的引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (!c.empty()) &#123;</span><br><span class="line">	c.front() &#x3D; 42;</span><br><span class="line">	auto&amp; v &#x3D; c.back(); &#x2F;&#x2F;获得指向最后一个元素的引用</span><br><span class="line">	v &#x3D; 1024; &#x2F;&#x2F;改变c中元素</span><br><span class="line">	auto v2 &#x3D; c.back(); &#x2F;&#x2F;v2不是引用，是c.back()的一个拷贝</span><br><span class="line">	v2 &#x3D; 0; &#x2F;&#x2F;不改变c中元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>at成员函数类似下标运算符，但越界是会抛出一个out_of_range异常</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt;v;</span><br><span class="line">cout &lt;&lt; v[0]; &#x2F;&#x2F;运行时错误</span><br><span class="line">cout &lt;&lt; v.at(0); &#x2F;&#x2F;抛出一个out_of_range异常</span><br></pre></td></tr></table></figure>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/6%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"><br><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/7%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"></p>
<h3 id="改变容器大小"><a href="#改变容器大小" class="headerlink" title="改变容器大小"></a>改变容器大小</h3><p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/8%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"></p>
<h3 id="管理容量的成员函数"><a href="#管理容量的成员函数" class="headerlink" title="管理容量的成员函数"></a>管理容量的成员函数</h3><p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/9%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"><br>reserve分配的大小小于等于当前容量时，reserve什么也不错。resize成员函数值改变容器中元素的数目，而不是容量</p>
<h3 id="构造string的其他方法"><a href="#构造string的其他方法" class="headerlink" title="构造string的其他方法"></a>构造string的其他方法</h3><p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/10%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const char* cp &#x3D; &quot;hello world!!!&quot;;</span><br><span class="line">char noNull[] &#x3D; &#123; &#39;h&#39;,&#39;i&#39; &#125;;</span><br><span class="line">string s1(cp); &#x2F;&#x2F;拷贝cp重点字符直到遇到空字符；s1&#x3D;&#x3D;&quot;hello world!!!&quot;</span><br><span class="line">string s2(noNull, 2); &#x2F;&#x2F;从noNull拷贝两个字符 &quot;hi&quot;</span><br><span class="line">string s3(noNUll); &#x2F;&#x2F;未定义：noNull不是以空字符结束</span><br><span class="line">string s4(cp + 6, 5); &#x2F;&#x2F;从cp[6]开始拷贝5个字符 &quot;world&quot;</span><br><span class="line">string s5(s1, 6, 5); &#x2F;&#x2F;从s1[6]开始拷贝5个字符 &quot;world&quot;</span><br><span class="line">string s6(s1, 6); &#x2F;&#x2F;从s1[6]开始拷贝到末尾 &quot;world!!!&quot;</span><br><span class="line">string s7(s1, 6, 20); </span><br><span class="line">string s8(s1, 16); &#x2F;&#x2F;抛出out_of_range异常</span><br><span class="line">从const char* 创建string时，指针指向的数组必须以空字符结尾，或者再传递一个合适的计数值</span><br></pre></td></tr></table></figure>
<h3 id="substr操作"><a href="#substr操作" class="headerlink" title="substr操作"></a>substr操作</h3><p>s.substr(pos, n) 返回一个string，包含s中从pos开始的n个字符的拷贝。pos的默认值为0。n的默认值为s.size() - pos，即拷贝从pos开始的所有字符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">string s(&quot;hello world&quot;);</span><br><span class="line">string s2 &#x3D; s.substr(0, 5); &#x2F;&#x2F;hello</span><br><span class="line">string s3 &#x3D; s.substr(6); &#x2F;&#x2F;world</span><br><span class="line">string s4 &#x3D; s.substr(6, 11); &#x2F;&#x2F;world</span><br><span class="line">string s5 &#x3D; s.substr(12); &#x2F;&#x2F;out_of_range</span><br><span class="line"></span><br><span class="line">s.insert(s.size(), 5, &#39;!&#39;); &#x2F;&#x2F;在s末尾插入5个&#39;!&#39;</span><br><span class="line">s.erase(s.size() - 5, 5); &#x2F;&#x2F;从s删除最后5个字符</span><br><span class="line"></span><br><span class="line">const char* cp &#x3D; &quot;Stately, plump Buck&quot;;</span><br><span class="line">s.assign(cp, 7); &#x2F;&#x2F;s&#x3D;&#x3D;&quot;Stately&quot; 赋值从cp开始的7个字符</span><br><span class="line">s.insert(s.size(), cp + 7); &#x2F;&#x2F;s&#x3D;&#x3D;&quot;Stately, plump Buck&quot;  将cp+7开始的字符拷贝到s后面</span><br><span class="line"></span><br><span class="line">string s &#x3D; &quot;Some string&quot;, s2 &#x3D; &quot;some other string&quot;;</span><br><span class="line">s.insert(0, s2); &#x2F;&#x2F;在s的0位置前插入s2</span><br><span class="line">s.insert(0, s2, 0, s2.size()); &#x2F;&#x2F;在s的0位置前插入s2的从0开始s2.size()个字符</span><br></pre></td></tr></table></figure>
<p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/11%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"><br><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/image.png?v=1&type=image" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.replace(a, b, s2); &#x2F;&#x2F;从s的a位置开始删除b个字符，并在该位置插入s2</span><br></pre></td></tr></table></figure>
<h3 id="string搜索操作"><a href="#string搜索操作" class="headerlink" title="string搜索操作"></a>string搜索操作</h3><p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/12%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"><br><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/13%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"><br>每个搜索操作都返回一个string::size_type值，表示匹配发生位置的下标。搜索失败则返回名为string::nops的static成员。nops等于任何string最大的可能大小<br>返回值是unsigned类型，一般不用int或其他带符号类型来保存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string name(&quot;AnnaBelle&quot;); </span><br><span class="line">auto pos &#x3D; name.find(&quot;Anna&quot;); &#x2F;&#x2F;pos&#x3D;&#x3D;0</span><br><span class="line">auto pos1 &#x3D; name.find(&quot;anna&quot;); &#x2F;&#x2F;pos&#x3D;&#x3D;nops</span><br><span class="line"></span><br><span class="line">string numbers(&quot;0123456789&quot;), name(&quot;r2d2&quot;), dept(&quot;01714p3&quot;);</span><br><span class="line">auto pos &#x3D; name.find_first_of(numbers); &#x2F;&#x2F;pos&#x3D;&#x3D;1</span><br><span class="line">auto pos &#x3D; name.find_first_not_of(numbers); &#x2F;&#x2F;pos&#x3D;&#x3D;5</span><br></pre></td></tr></table></figure>
<h3 id="指定开始搜索的位置"><a href="#指定开始搜索的位置" class="headerlink" title="指定开始搜索的位置"></a>指定开始搜索的位置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string::size_type pos &#x3D; 0;</span><br><span class="line">while ((pos &#x3D; name.find_first_of(numbers, pos)) !&#x3D; string::nops) &#123;</span><br><span class="line">	cout &lt;&lt; &quot;found number at index: &quot; &lt;&lt; pos &lt;&lt; &quot; elem is &quot; &lt;&lt; name[pos] &lt;&lt; endl;</span><br><span class="line">	++pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="逆向搜索"><a href="#逆向搜索" class="headerlink" title="逆向搜索"></a>逆向搜索</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string river(&quot;Mississippi&quot;);</span><br><span class="line">auto first_pos&#x3D;river.find_first(&quot;is&quot;); &#x2F;&#x2F;返回1</span><br><span class="line">auto last_pos &#x3D; river.find_last(&quot;is&quot;); &#x2F;&#x2F;返回4</span><br></pre></td></tr></table></figure>
<h3 id="compare函数"><a href="#compare函数" class="headerlink" title="compare函数"></a>compare函数</h3><p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/14%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"><br>返回负数、0、正数</p>
<h3 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D; 42;</span><br><span class="line">string s &#x3D; to_string(i); &#x2F;&#x2F;将整数i转换为字符表示形式</span><br><span class="line">double d &#x3D; stod(s); &#x2F;&#x2F;将字符串s转换为浮点数</span><br></pre></td></tr></table></figure>
<p>要转换为数值的string中第一个非空白符必须是数值中可能出现的字符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s2 &#x3D; &quot;pi&#x3D;3.14&quot;;</span><br><span class="line">d &#x3D; stod(s2.substr(s2.find_first_of(&quot;+-.0123456789&quot;))); &#x2F;&#x2F;d&#x3D;3.14</span><br></pre></td></tr></table></figure>
<p>如果string不能转换为一个数值，则抛出一个invalid_argument异常；数值无法用任何类型来表示则抛出out_of_range异常<br><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/15%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"></p>
<h3 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h3><p>标准库还定义了三个顺序容器适配器：stack、queue和priority_queue。本质上一个适配器是一种机制，能使某种事物的行为看起来像另外一种事物<br><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/16%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"><br>默认情况下，stack和queue是基于deque实现的，priority_queue是在vector之上实现的<br>定义一个适配器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;int&gt;deq;</span><br><span class="line">stack&lt;int&gt; stk(deq); &#x2F;&#x2F;从deq拷贝元素到stk</span><br></pre></td></tr></table></figure>
<p>我们可以再创建一个适配器时将一个命名的顺序容器作为第二个类型参数，来重载默认容器类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;int, vector&lt;string&gt;&gt;str_stk(sevc); &#x2F;&#x2F;str_stk在vector上实现，初始化时保存svec的拷贝</span><br></pre></td></tr></table></figure>
<p>因为所有适配器都要求容器具有添加、删除以及访问尾元素的能力，所以不能用array和forward_list来构造适配器<br>stack只要求push_back、pop_back和back操作–》使用除array和forward_list之外的任何容器类型来构造<br>queue要求back、push_back, front和push_front–》list或deque，不能用vector<br>priority_queue要求front, push_back, pop_back和随机访问能力–》vector或deque，不能用list</p>
<h3 id="栈适配器"><a href="#栈适配器" class="headerlink" title="栈适配器"></a>栈适配器</h3><p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/17%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;int&gt; intStack;</span><br><span class="line">for (size_t ix &#x3D; 0; ix &lt; 10; ++ix) </span><br><span class="line">	intStack.push(ix);</span><br><span class="line">while (!intStack.empty()) &#123;</span><br><span class="line">	int value &#x3D; intStack.top();</span><br><span class="line">	intStack.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="队列适配器"><a href="#队列适配器" class="headerlink" title="队列适配器"></a>队列适配器</h3><p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/18%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"><br><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/19%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/30/c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/" data-id="ckhkopsd6000jesvecp814132" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-primer/" rel="tag">c++ primer</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-problem-library-哈希-02" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/12/problem-library-%E5%93%88%E5%B8%8C-02/" class="article-date">
  <time datetime="2020-08-12T03:31:29.000Z" itemprop="datePublished">2020-08-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/12/problem-library-%E5%93%88%E5%B8%8C-02/">problem library 哈希 02</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="#739.每日温度"></a>#739.每日温度</h2><p>请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p>
<p>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p>
<p>提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/daily-temperatures" target="_blank" rel="noopener">https://leetcode-cn.com/problems/daily-temperatures</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; T) &#123;</span><br><span class="line">		vector&lt;int&gt;res(T.size(), 0);</span><br><span class="line">		for (int i &#x3D; T.size() - 2; i &gt;&#x3D; 0; --i) &#123;</span><br><span class="line">			if (T[i] &lt; T[i + 1])res[i] &#x3D; 1;</span><br><span class="line">			else &#123;</span><br><span class="line">				int tmp &#x3D; i + 1 + res[i + 1];</span><br><span class="line">				if (res[i + 1] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">					res[i] &#x3D; 0;</span><br><span class="line">					continue;</span><br><span class="line">				&#125;</span><br><span class="line">				while (T[i] &gt;&#x3D; T[tmp] &amp;&amp; tmp &lt; T.size()) &#123;</span><br><span class="line">					if (res[tmp] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">					tmp +&#x3D; res[tmp];</span><br><span class="line">				&#125;</span><br><span class="line">				if (T[i] &lt; T[tmp])res[i] &#x3D; tmp - i;</span><br><span class="line">				else res[i] &#x3D; 0;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="347-前k个高频元素"><a href="#347-前k个高频元素" class="headerlink" title="#347.前k个高频元素"></a>#347.前k个高频元素</h2><p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p>
<p>示例 1:</p>
<p>输入: nums = [1,1,1,2,2,3], k = 2<br>输出: [1,2]<br>示例 2:</p>
<p>输入: nums = [1], k = 1<br>输出: [1]</p>
<p>提示：</p>
<p>你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。<br>你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。<br>题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。<br>你可以按任意顺序返回答案。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/top-k-frequent-elements" target="_blank" rel="noopener">https://leetcode-cn.com/problems/top-k-frequent-elements</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">		vector&lt;int&gt;res;</span><br><span class="line">		unordered_map&lt;int, int&gt;m;</span><br><span class="line">		for (auto i : nums)m[i]++;</span><br><span class="line">		vector&lt;pair&lt;int, int&gt;&gt;tmp;</span><br><span class="line">		for (auto it &#x3D; m.begin(); it !&#x3D; m.end(); ++it) &#123;</span><br><span class="line">			tmp.emplace_back(make_pair(it-&gt;second, it-&gt;first));</span><br><span class="line">		&#125;</span><br><span class="line">		sort(tmp.begin(), tmp.end(), compare);</span><br><span class="line">		int i &#x3D; tmp.size() - 1;</span><br><span class="line">		while (k &gt; 0) &#123;</span><br><span class="line">			res.emplace_back(tmp[i].second);</span><br><span class="line">			k--; i--;</span><br><span class="line">		&#125;</span><br><span class="line">		return res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	static bool compare(pair&lt;int, int&gt; i, pair&lt;int, int&gt; j) &#123;</span><br><span class="line">		return i.second &gt; j.second;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">		vector&lt;int&gt;res;</span><br><span class="line">		unordered_map&lt;int, int&gt;m;</span><br><span class="line">		for (auto i : nums)m[i]++;</span><br><span class="line">		vector&lt;pair&lt;int, int&gt;&gt;tmp(m.begin(), m.end());</span><br><span class="line">		sort(tmp.begin(), tmp.end(), compare);</span><br><span class="line">		for (int i &#x3D; 0; i &lt; k; ++i) &#123;</span><br><span class="line">			res.emplace_back(tmp[i].first);</span><br><span class="line">		&#125;</span><br><span class="line">		return res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="36-有效的数独"><a href="#36-有效的数独" class="headerlink" title="#36.有效的数独"></a>#36.有效的数独</h2><p>判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。</p>
<p>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">	[&quot;5&quot;, &quot;3&quot;, &quot;.&quot;, &quot;.&quot;, &quot;7&quot;, &quot;.&quot;, &quot;.&quot;, &quot;.&quot;, &quot;.&quot;],</span><br><span class="line">	[&quot;6&quot;, &quot;.&quot;, &quot;.&quot;, &quot;1&quot;, &quot;9&quot;, &quot;5&quot;, &quot;.&quot;, &quot;.&quot;, &quot;.&quot;],</span><br><span class="line">	[&quot;.&quot;, &quot;9&quot;, &quot;8&quot;, &quot;.&quot;, &quot;.&quot;, &quot;.&quot;, &quot;.&quot;, &quot;6&quot;, &quot;.&quot;],</span><br><span class="line">	[&quot;8&quot;, &quot;.&quot;, &quot;.&quot;, &quot;.&quot;, &quot;6&quot;, &quot;.&quot;, &quot;.&quot;, &quot;.&quot;, &quot;3&quot;],</span><br><span class="line">	[&quot;4&quot;, &quot;.&quot;, &quot;.&quot;, &quot;8&quot;, &quot;.&quot;, &quot;3&quot;, &quot;.&quot;, &quot;.&quot;, &quot;1&quot;],</span><br><span class="line">	[&quot;7&quot;, &quot;.&quot;, &quot;.&quot;, &quot;.&quot;, &quot;2&quot;, &quot;.&quot;, &quot;.&quot;, &quot;.&quot;, &quot;6&quot;],</span><br><span class="line">	[&quot;.&quot;, &quot;6&quot;, &quot;.&quot;, &quot;.&quot;, &quot;.&quot;, &quot;.&quot;, &quot;2&quot;, &quot;8&quot;, &quot;.&quot;],</span><br><span class="line">	[&quot;.&quot;, &quot;.&quot;, &quot;.&quot;, &quot;4&quot;, &quot;1&quot;, &quot;9&quot;, &quot;.&quot;, &quot;.&quot;, &quot;5&quot;],</span><br><span class="line">	[&quot;.&quot;, &quot;.&quot;, &quot;.&quot;, &quot;.&quot;, &quot;8&quot;, &quot;.&quot;, &quot;.&quot;, &quot;7&quot;, &quot;9&quot;]</span><br><span class="line">]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/valid-sudoku" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-sudoku</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;</span><br><span class="line">		int row[9][10] &#x3D; &#123; 0 &#125;, col[9][10] &#x3D; &#123; 0 &#125;, box[9][10] &#x3D; &#123; 0 &#125;;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; 9; ++i) &#123;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; 9; ++j) &#123;</span><br><span class="line">				if (board[i][j] &#x3D;&#x3D; &#39;.&#39;)continue;</span><br><span class="line">				int num &#x3D; board[i][j] - &#39;0&#39;;</span><br><span class="line">				if (row[i][num] + col[j][num] + box[j &#x2F; 3 + i &#x2F; 3 * 3][num] &gt; 0)return false;</span><br><span class="line">				++row[i][num]; ++col[j][num]; ++box[j &#x2F; 3 + i &#x2F; 3 * 3][num];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="560-和为k的子数组"><a href="#560-和为k的子数组" class="headerlink" title="#560.和为k的子数组"></a>#560.和为k的子数组</h2><p>给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。</p>
<p>示例 1 :</p>
<p>输入:nums = [1,1,1], k = 2<br>输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。<br>说明 :</p>
<p>数组的长度为 [1, 20,000]。<br>数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/subarray-sum-equals-k" target="_blank" rel="noopener">https://leetcode-cn.com/problems/subarray-sum-equals-k</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">		queue&lt;int&gt;tmp;</span><br><span class="line">		int sum &#x3D; 0, count &#x3D; 0;</span><br><span class="line">		for (auto i : nums) &#123;</span><br><span class="line">			tmp.push(i);</span><br><span class="line">			sum +&#x3D; i;</span><br><span class="line">			while (sum &gt; k) &#123;</span><br><span class="line">				sum -&#x3D; tmp.front();</span><br><span class="line">				tmp.pop();</span><br><span class="line">			&#125;</span><br><span class="line">			if (sum &#x3D;&#x3D; k &amp;&amp; !tmp.empty()) &#123;</span><br><span class="line">				sum -&#x3D; tmp.front();</span><br><span class="line">				tmp.pop();</span><br><span class="line">				++count;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return count;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="187-重复的DNA序列"><a href="#187-重复的DNA序列" class="headerlink" title="#187.重复的DNA序列"></a>#187.重复的DNA序列</h2><p>所有 DNA 都由一系列缩写为 A，C，G 和 T 的核苷酸组成，例如：“ACGAATTCCG”。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。</p>
<p>编写一个函数来查找目标子串，目标子串的长度为 10，且在 DNA 字符串 s 中出现次数超过一次。</p>
<p>示例：</p>
<p>输入：s = “AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT”<br>输出：[“AAAAACCCCC”, “CCCCCAAAAA”]</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/repeated-dna-sequences" target="_blank" rel="noopener">https://leetcode-cn.com/problems/repeated-dna-sequences</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	vector&lt;string&gt; findRepeatedDnaSequences(string s) &#123;</span><br><span class="line">		if (s.size() &lt; +10)return &#123;&#125;;</span><br><span class="line">		unordered_map&lt;string, int&gt;m;</span><br><span class="line">		vector&lt;string&gt;res;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; s.size() - 9; ++i) &#123;</span><br><span class="line">			string tmp(s.begin() + i, s.begin() + 10 + i);</span><br><span class="line">			if (m[tmp] &#x3D;&#x3D; 1)res.emplace_back(tmp);</span><br><span class="line">			++m[tmp];</span><br><span class="line">		&#125;</span><br><span class="line">		return res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="84-柱状图中最大矩形"><a href="#84-柱状图中最大矩形" class="headerlink" title="#84.柱状图中最大矩形"></a>#84.柱状图中最大矩形</h2><p>给定  <em>n</em>  个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<p><strong>示例:</strong></p>
<p><strong>输入:</strong> [2,1,5,6,2,3]<br><strong>输出:</strong> 10</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;</span><br><span class="line">        int sz &#x3D; heights.size(), res &#x3D; 0;</span><br><span class="line">        stack&lt;int&gt;tmp;</span><br><span class="line">        vector&lt;int&gt;left(sz), right(sz, sz);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; sz; ++i) &#123;</span><br><span class="line">            while (!tmp.empty() &amp;&amp; heights[i] &lt;&#x3D; heights[tmp.top()]) &#123;</span><br><span class="line">                right[tmp.top()] &#x3D; i;</span><br><span class="line">                tmp.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            left[i] &#x3D; tmp.empty() ? -1 : tmp.top();</span><br><span class="line">            tmp.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; sz; ++i) &#123;</span><br><span class="line">            res &#x3D; max(res, heights[i] * (right[i] - left[i] - 1));</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/12/problem-library-%E5%93%88%E5%B8%8C-02/" data-id="ckhkopsdw002nesvebz9n0dhz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/problem-library/" rel="tag">problem library</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-cocos2d-x-02-动作" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/10/cocos2d-x-02-%E5%8A%A8%E4%BD%9C/" class="article-date">
  <time datetime="2020-08-10T14:48:41.000Z" itemprop="datePublished">2020-08-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/10/cocos2d-x-02-%E5%8A%A8%E4%BD%9C/">cocos2d-x 02 动作</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">bool HelloWorld::init()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 1. super init first</span><br><span class="line">    if ( !Scene::init() )</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    auto visibleSize &#x3D; Director::getInstance()-&gt;getVisibleSize();</span><br><span class="line">    Vec2 origin &#x3D; Director::getInstance()-&gt;getVisibleOrigin();</span><br><span class="line"></span><br><span class="line">	LabelTTF* label &#x3D; LabelTTF::create(&quot;text text text&quot;, &quot;Courier&quot;, 30);</span><br><span class="line">	addChild(label);</span><br><span class="line">	label-&gt;setPosition(visibleSize.width &#x2F; 2, visibleSize.height &#x2F; 2);</span><br><span class="line"></span><br><span class="line">	auto listener &#x3D; EventListenerTouchOneByOne::create();</span><br><span class="line">	listener-&gt;onTouchBegan &#x3D; [label](Touch * t, Event * e) &#123;</span><br><span class="line">		if (label-&gt;getBoundingBox().containsPoint(t-&gt;getLocation())) &#123;</span><br><span class="line">			&#x2F;&#x2F;label-&gt;runAction(MoveTo::create(1, Point(100, 100)));</span><br><span class="line">			&#x2F;&#x2F;label-&gt;runAction(MoveBy::create(1, Point(100, 100))-&gt;reverse());</span><br><span class="line">			label-&gt;runAction(Sequence::create(</span><br><span class="line">				MoveBy::create(1, Point(50, 50)),</span><br><span class="line">				RotateBy::create(1, 360),</span><br><span class="line">				CallFunc::create([]() &#123;</span><br><span class="line">					MessageBox(&quot;Action Complete&quot;, &quot;complete&quot;);</span><br><span class="line">					&#125;), NULL));</span><br><span class="line">		&#125;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;;</span><br><span class="line">	Director::getInstance()-&gt;getEventDispatcher()-&gt;addEventListenerWithSceneGraphPriority(listener, label);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;label-&gt;runAction(Repeat::create(RotateBy::create(1, 180),3));</span><br><span class="line">	&#x2F;&#x2F;label-&gt;runAction(RepeatForever::create(RotateBy::create(1, 180)));</span><br><span class="line">	&#x2F;&#x2F;label-&gt;runAction(Spawn::create(MoveBy::create(1, Point(50, 50)), RotateBy::create(2, 360),NULL));</span><br><span class="line">	&#x2F;&#x2F;label-&gt;runAction(Sequence::create(MoveBy::create(1, Point(50, 50)), RotateBy::create(1, 360), NULL));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/10/cocos2d-x-02-%E5%8A%A8%E4%BD%9C/" data-id="ckhkopsde001besve9hfo1eqq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cocos2d-x/" rel="tag">cocos2d-x</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-cocos2d-x-01" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/10/cocos2d-x-01/" class="article-date">
  <time datetime="2020-08-10T14:47:11.000Z" itemprop="datePublished">2020-08-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/10/cocos2d-x-01/">cocos2d-x 01</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">bool HelloWorld::init()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 1. super init first</span><br><span class="line">    if ( !Scene::init() )</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;菜单</span><br><span class="line">	auto menu &#x3D; Menu::create(MenuItemImage::create(&quot;normal.png&quot;, &quot;selected.png&quot;, [](object * obj) &#123;</span><br><span class="line">		log(&quot;menu item touched&quot;);</span><br><span class="line">		&#125;), NULL);</span><br><span class="line">	addChild(menu);</span><br><span class="line">	&#x2F;&#x2F;场景切换</span><br><span class="line">	LabelTTF* label &#x3D; LabelTTF::create(&quot;show next scene&quot;, &quot;Courier&quot;, 30);</span><br><span class="line">	addChild(label);</span><br><span class="line">	label-&gt;setPosition(visibleSize.width &#x2F; 2, visibleSize.height &#x2F; 2);</span><br><span class="line">	auto listener &#x3D; EventListenerTouchOneByOne::create();</span><br><span class="line">	listener-&gt;onTouchBegan &#x3D; [label](Touch * t, Event * e) &#123;</span><br><span class="line">		if (label-&gt;getBoundingBox().containsPoint(t-&gt;getLocation())) &#123;</span><br><span class="line">			Director::getInstance()-&gt;replaceScene(Imagescene::createScene());</span><br><span class="line">		&#125;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;;</span><br><span class="line">	Director::getInstance()-&gt;getEventDispatcher()-&gt;addEventListenerWithSceneGraphPriority(listener, label);</span><br><span class="line">   </span><br><span class="line">	</span><br><span class="line">	return true; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="场景切换"><a href="#场景切换" class="headerlink" title="场景切换"></a>场景切换</h2><h3 id="ImageScene-cpp"><a href="#ImageScene-cpp" class="headerlink" title="ImageScene.cpp"></a>ImageScene.cpp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Imagescene.h&quot;</span><br><span class="line"></span><br><span class="line">Scene* Imagescene::createScene() &#123;</span><br><span class="line">	Scene* scene &#x3D; Scene::create();</span><br><span class="line">	Imagescene* layer &#x3D; Imagescene::create();</span><br><span class="line">	scene-&gt;addChild(layer);</span><br><span class="line">	return scene;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Imagescene::init() &#123;</span><br><span class="line">	auto visibleSize &#x3D; Director::getInstance()-&gt;getVisibleSize();</span><br><span class="line">	Sprite* s &#x3D; Sprite::create(&quot;HelloWorld.png&quot;);</span><br><span class="line">	s-&gt;setPosition(visibleSize.width &#x2F; 2, visibleSize.height &#x2F; 2);</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Imagescene-h"><a href="#Imagescene-h" class="headerlink" title="Imagescene.h"></a>Imagescene.h</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&quot;Imagescene.h&quot;</span><br><span class="line">#include&lt;cocos2d.h&gt;</span><br><span class="line">USING_NS_CC;</span><br><span class="line">class Imagescene:public Layer</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual bool init();</span><br><span class="line">	static Scene* createScene();</span><br><span class="line">	CREATE_FUNC(Imagescene);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/10/cocos2d-x-01/" data-id="ckhkopsdd0018esve1vvlgabt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cocos2d-x/" rel="tag">cocos2d-x</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-problem-library-哈希" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/09/problem-library-%E5%93%88%E5%B8%8C/" class="article-date">
  <time datetime="2020-08-09T12:09:23.000Z" itemprop="datePublished">2020-08-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/09/problem-library-%E5%93%88%E5%B8%8C/">problem library 哈希</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="#1.两数之和"></a>#1.两数之和</h2><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>
<p>示例:</p>
<p>给定 nums = [2, 7, 11, 15], target = 9</p>
<p>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/two-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        map&lt;int, int&gt;m;</span><br><span class="line">        vector&lt;int&gt;v;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; nums.size(); ++i)m.insert(map&lt;int, int&gt;::value_type(nums[i], i));</span><br><span class="line">        for (int i &#x3D; 0; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            if (m.count(target - nums[i]) &gt; 0 &amp;&amp; m[target - nums[i]] !&#x3D; i) &#123;</span><br><span class="line">                v.emplace_back(i);</span><br><span class="line">                v.emplace_back(m[target - nums[i]]);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="#136.只出现一次的数字"></a>#136.只出现一次的数字</h2><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p>说明：</p>
<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<p>示例 1:</p>
<p>输入: [2,2,1]<br>输出: 1<br>示例 2:</p>
<p>输入: [4,1,2,1,2]<br>输出: 4</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/single-number" target="_blank" rel="noopener">https://leetcode-cn.com/problems/single-number</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        map&lt;int, int&gt;m;</span><br><span class="line">        for (auto i : nums)m[i]++;</span><br><span class="line">        for (auto it &#x3D; m.begin(); it !&#x3D; m.end(); ++it) &#123;</span><br><span class="line">            if (it-&gt;second &#x3D;&#x3D; 1)return it-&gt;first;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int res &#x3D; 0;</span><br><span class="line">        for (auto i : nums)res ^&#x3D; i;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="#202.快乐数"></a>#202.快乐数</h2><p>编写一个算法来判断一个数 n 是不是快乐数。</p>
<p>「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。</p>
<p>如果 n 是快乐数就返回 True ；不是，则返回 False 。</p>
<p>示例：</p>
<p>输入：19<br>输出：true<br>解释：<br>12 + 92 = 82<br>82 + 22 = 68<br>62 + 82 = 100<br>12 + 02 + 02 = 1</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/happy-number" target="_blank" rel="noopener">https://leetcode-cn.com/problems/happy-number</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="哈希-1"><a href="#哈希-1" class="headerlink" title="哈希"></a>哈希</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int getN(int n) &#123;</span><br><span class="line">        int res &#x3D; 0;</span><br><span class="line">        while (n) &#123;</span><br><span class="line">            int a &#x3D; n % 10;</span><br><span class="line">            n &#x3D; n &#x2F; 10;</span><br><span class="line">            res +&#x3D; a * a;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    bool isHappy(int n) &#123;</span><br><span class="line">        unordered_map&lt;int, bool&gt;m;</span><br><span class="line">        while (n !&#x3D; 1) &#123;</span><br><span class="line">            n &#x3D; getN(n);</span><br><span class="line">            if (m[n] &#x3D;&#x3D; true)return false;</span><br><span class="line">            m[n] &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="快慢针"><a href="#快慢针" class="headerlink" title="快慢针"></a>快慢针</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int getN(int n) &#123;</span><br><span class="line">        int res &#x3D; 0;</span><br><span class="line">        while (n) &#123;</span><br><span class="line">            int a &#x3D; n % 10;</span><br><span class="line">            n &#x3D; n &#x2F; 10;</span><br><span class="line">            res +&#x3D; a * a;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    bool isHappy(int n) &#123;</span><br><span class="line">        int i &#x3D; n, j &#x3D; getN(n);</span><br><span class="line">        while (i !&#x3D; j) &#123;</span><br><span class="line">            i &#x3D; getN(i);</span><br><span class="line">            j &#x3D; getN(getN(j));</span><br><span class="line">        &#125;</span><br><span class="line">        return i &#x3D;&#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="219-存在重复的元素II"><a href="#219-存在重复的元素II" class="headerlink" title="#219.存在重复的元素II"></a>#219.存在重复的元素II</h2><p>给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的 绝对值 至多为 k。</p>
<p>示例 1:</p>
<p>输入: nums = [1,2,3,1], k = 3<br>输出: true<br>示例 2:</p>
<p>输入: nums = [1,0,1,1], k = 1<br>输出: true<br>示例 3:</p>
<p>输入: nums = [1,2,3,1,2,3], k = 2<br>输出: false</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/contains-duplicate-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/contains-duplicate-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        unordered_set&lt;int&gt;tmp;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            if (tmp.find(nums[i]) !&#x3D; tmp.end())return true;</span><br><span class="line">            tmp.emplace(nums[i]);</span><br><span class="line">            if (tmp.size() &gt; k)tmp.erase(nums[i - k]);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="217-存在重复元素"><a href="#217-存在重复元素" class="headerlink" title="#217.存在重复元素"></a>#217.存在重复元素</h2><p>给定一个整数数组，判断是否存在重复元素。</p>
<p>如果任意一值在数组中出现至少两次，函数返回  <code>true</code>  。如果数组中每个元素都不相同，则返回  <code>false</code>  。</p>
<p><strong>示例 1:</strong></p>
<p><strong>输入:</strong> [1,2,3,1]<br><strong>输出:</strong> true</p>
<p><strong>示例 2:</strong></p>
<p><strong>输入:</strong> [1,2,3,4]<br><strong>输出:</strong> false</p>
<p><strong>示例 3:</strong></p>
<p><strong>输入:</strong> [1,1,1,3,3,4,3,2,4,2]<br><strong>输出:</strong> true</p>
<h3 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        unordered_set&lt;int&gt;tmp;</span><br><span class="line">        for (auto i : nums) &#123;</span><br><span class="line">            if (tmp.find(i) !&#x3D; tmp.end())return true;</span><br><span class="line">            tmp.emplace(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        unordered_map&lt;int, int&gt;m;</span><br><span class="line">        for (auto i : nums) &#123;</span><br><span class="line">            m[i]++;</span><br><span class="line">            if (m[i] &gt; 1)return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="#349.两个数组的交集"></a>#349.两个数组的交集</h2><p>给定两个数组，编写一个函数来计算它们的交集。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong>nums1 = [1,2,2,1], nums2 = [2,2]<br><strong>输出：</strong>[2]</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>nums1 = [4,9,5], nums2 = [9,4,9,8,4]<br><strong>输出：</strong>[9,4]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">        unordered_set&lt;int&gt;res1, num11(nums1.begin(), nums1.end());</span><br><span class="line">        for (auto i : nums2) &#123;</span><br><span class="line">            if (num11.find(i) !&#x3D; num11.end())res1.emplace(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return vector&lt;int&gt;(res1.begin(), res1.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="#242.有效的字母异位词"></a>#242.有效的字母异位词</h2><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p>
<p>示例 1:</p>
<p>输入: s = “anagram”, t = “nagaram”<br>输出: true<br>示例 2:</p>
<p>输入: s = “rat”, t = “car”<br>输出: false<br>说明:<br>你可以假设字符串只包含小写字母。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/valid-anagram" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-anagram</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isAnagram(string s, string t) &#123;</span><br><span class="line">        if (s.size() !&#x3D; t.size())return false;</span><br><span class="line">        int words[26] &#x3D; &#123;&#125;;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            ++words[s[i] - &#39;a&#39;];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; t.size(); ++j) &#123;</span><br><span class="line">            if (--words[t[j] - &#39;a&#39;] &lt; 0)return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/09/problem-library-%E5%93%88%E5%B8%8C/" data-id="ckhkopsdu002kesvehn1ff3t0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/problem-library/" rel="tag">problem library</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-problem-library-链表" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/08/problem-library-%E9%93%BE%E8%A1%A8/" class="article-date">
  <time datetime="2020-08-08T15:13:57.000Z" itemprop="datePublished">2020-08-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/08/problem-library-%E9%93%BE%E8%A1%A8/">problem library 链表</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="#21.合并两个有序链表"></a>#21.合并两个有序链表</h2><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<p>示例：</p>
<p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-two-sorted-lists</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">        ListNode* prehead &#x3D; new ListNode(-1);</span><br><span class="line">        ListNode* pre &#x3D; prehead;</span><br><span class="line">        while (l1 !&#x3D; nullptr &amp;&amp; l2 !&#x3D; nullptr) &#123;</span><br><span class="line">            if (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                pre-&gt;next &#x3D; l1;</span><br><span class="line">                l1 &#x3D; l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                pre-&gt;next &#x3D; l2;</span><br><span class="line">                l2 &#x3D; l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre &#x3D; pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre-&gt;next &#x3D; l1 &#x3D;&#x3D; nullptr ? l2 : l1;</span><br><span class="line">        return prehead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="206-翻转链表"><a href="#206-翻转链表" class="headerlink" title="#206.翻转链表"></a>#206.翻转链表</h2><p>反转一个单链表。</p>
<p><strong>示例:</strong></p>
<p><strong>输入:</strong> 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br><strong>输出:</strong> 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p>
<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">        ListNode* pre &#x3D; nullptr;</span><br><span class="line">        ListNode* curr &#x3D; head;</span><br><span class="line">        while (curr !&#x3D; nullptr) &#123;</span><br><span class="line">            ListNode* tmp &#x3D; curr-&gt;next;</span><br><span class="line">            curr-&gt;next &#x3D; pre;</span><br><span class="line">            pre &#x3D; curr;</span><br><span class="line">            curr &#x3D; tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        return pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">        if (head &#x3D;&#x3D; nullptr || head-&gt;next &#x3D;&#x3D; nullptr)return head;</span><br><span class="line">        ListNode* res &#x3D; reverseList(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next &#x3D; head;</span><br><span class="line">        head-&gt;next &#x3D; nullptr;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="#141.环形链表"></a>#141.环形链表</h2><p>给定一个链表，判断链表中是否有环。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>
<p>示例 1：</p>
<p>输入：head = [3,2,0,-4], pos = 1<br>输出：true<br>解释：链表中有一个环，其尾部连接到第二个节点。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/linked-list-cycle" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-cycle</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool hasCycle(ListNode* head) &#123;</span><br><span class="line">        if (head &#x3D;&#x3D; nullptr || head-&gt;next &#x3D;&#x3D; nullptr)return false;</span><br><span class="line">        ListNode* slow &#x3D; head;</span><br><span class="line">        ListNode* fast &#x3D; head-&gt;next;</span><br><span class="line">        while (slow !&#x3D; fast) &#123;</span><br><span class="line">            if (fast &#x3D;&#x3D; nullptr || fast-&gt;next &#x3D;&#x3D; nullptr || fast-&gt;next-&gt;next &#x3D;&#x3D; nullptr)return false;</span><br><span class="line">            slow &#x3D; slow-&gt;next;</span><br><span class="line">            fast &#x3D; fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="#234.回文链表"></a>#234.回文链表</h2><p>请判断一个链表是否为回文链表。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: 1-&gt;2
输出: false</code></pre><p><strong>示例 2:</strong></p>
<pre><code>输入: 1-&gt;2-&gt;2-&gt;1
输出: true</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isPalindrome(ListNode* head) &#123;</span><br><span class="line">        if (head &#x3D;&#x3D; nullptr)return true;</span><br><span class="line">        ListNode* slow &#x3D; head;</span><br><span class="line">        ListNode* fast &#x3D; head-&gt;next;</span><br><span class="line">        while (fast !&#x3D; nullptr &amp;&amp; fast-&gt;next !&#x3D; nullptr) &#123;</span><br><span class="line">            slow &#x3D; slow-&gt;next;</span><br><span class="line">            fast &#x3D; fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* secondHalf &#x3D; nullptr;</span><br><span class="line">        ListNode* cur &#x3D; slow-&gt;next;</span><br><span class="line">        while (cur !&#x3D; nullptr) &#123;</span><br><span class="line">            ListNode* tmp &#x3D; cur-&gt;next;</span><br><span class="line">            cur-&gt;next &#x3D; secondHalf;</span><br><span class="line">            secondHalf &#x3D; cur;</span><br><span class="line">            cur &#x3D; tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        while (secondHalf !&#x3D; nullptr) &#123;</span><br><span class="line">            if (secondHalf-&gt;val !&#x3D; head-&gt;val)return false;</span><br><span class="line">            secondHalf &#x3D; secondHalf-&gt;next;</span><br><span class="line">            head &#x3D; head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="106-相交链表"><a href="#106-相交链表" class="headerlink" title="#106.相交链表"></a>#106.相交链表</h2><p>编写一个程序，找到两个单链表相交的起始节点。</p>
<p>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3<br>输出：Reference of the node with value = 8<br>输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists" target="_blank" rel="noopener">https://leetcode-cn.com/problems/intersection-of-two-linked-lists</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) &#123;</span><br><span class="line">        for (auto i &#x3D; headA; i !&#x3D; nullptr; i &#x3D; i-&gt;next) &#123;</span><br><span class="line">            for (auto j &#x3D; headB; j !&#x3D; nullptr; j &#x3D; j-&gt;next) &#123;</span><br><span class="line">                if (i &#x3D;&#x3D; j)return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) &#123;</span><br><span class="line">        ListNode* pA &#x3D; headA;</span><br><span class="line">        ListNode* pB &#x3D; headB;</span><br><span class="line">        while (pA !&#x3D; pB) &#123;</span><br><span class="line">            pA &#x3D; pA &#x3D;&#x3D; nullptr ? headB : pA-&gt;next;</span><br><span class="line">            pB &#x3D; pB &#x3D;&#x3D; nullptr ? headA : pB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return pA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="#203.移除链表元素"></a>#203.移除链表元素</h2><p>删除链表中等于给定值 <strong><em>val</em></strong> 的所有节点。</p>
<p><strong>示例:</strong></p>
<p><strong>输入:</strong> 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, <em><strong>val</strong></em> = 6<br><strong>输出:</strong> 1-&gt;2-&gt;3-&gt;4-&gt;5</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* removeElements(ListNode* head, int val) &#123;</span><br><span class="line">        ListNode* temp &#x3D; new ListNode(0);</span><br><span class="line">        temp-&gt;next &#x3D; head;</span><br><span class="line">        ListNode* prev &#x3D; temp, * cur &#x3D; head, * toDelete &#x3D; nullptr;</span><br><span class="line">        while (cur !&#x3D; nullptr) &#123;</span><br><span class="line">            if (cur-&gt;val &#x3D;&#x3D; val) &#123;</span><br><span class="line">                prev-&gt;next &#x3D; cur-&gt;next;</span><br><span class="line">                toDelete &#x3D; cur;</span><br><span class="line">            &#125;</span><br><span class="line">            else prev &#x3D; cur;</span><br><span class="line">            cur &#x3D; cur-&gt;next;</span><br><span class="line">            if (toDelete !&#x3D; nullptr) &#123;</span><br><span class="line">                delete toDelete;</span><br><span class="line">                toDelete &#x3D; nullptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* res &#x3D; temp-&gt;next;</span><br><span class="line">        delete temp;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="#2.两数相加"></a>#2.两数相加</h2><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p>示例：</p>
<p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/add-two-numbers" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-two-numbers</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">        int add &#x3D; 0;</span><br><span class="line">        ListNode* res &#x3D; new ListNode(0), * tmp &#x3D; res, * p1 &#x3D; l1, * p2 &#x3D; l2;</span><br><span class="line">        while (p1 !&#x3D; nullptr || p2 !&#x3D; nullptr) &#123;</span><br><span class="line">            int x &#x3D; p1 &#x3D;&#x3D; nullptr ? 0 : p1-&gt;val;</span><br><span class="line">            int y &#x3D; p2 &#x3D;&#x3D; nullptr ? 0 : p2-&gt;val;</span><br><span class="line">            int val &#x3D; x + y + add;</span><br><span class="line">            add &#x3D; val &#x2F; 10;</span><br><span class="line">            val %&#x3D; 10;</span><br><span class="line">            tmp-&gt;next &#x3D; new ListNode(val);</span><br><span class="line">            tmp &#x3D; tmp-&gt;next;</span><br><span class="line">            if (p1 !&#x3D; nullptr)p1 &#x3D; p1-&gt;next;</span><br><span class="line">            if (p2 !&#x3D; nullptr)p2 &#x3D; p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if (add !&#x3D; 0)tmp-&gt;next &#x3D; new ListNode(add);</span><br><span class="line">        return res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="#148.排序链表"></a>#148.排序链表</h2><p>在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。</p>
<p>示例 1:</p>
<p>输入: 4-&gt;2-&gt;1-&gt;3<br>输出: 1-&gt;2-&gt;3-&gt;4<br>示例 2:</p>
<p>输入: -1-&gt;5-&gt;3-&gt;4-&gt;0<br>输出: -1-&gt;0-&gt;3-&gt;4-&gt;5</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/sort-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sort-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* sortList(ListNode* head) &#123;</span><br><span class="line">        if (head &#x3D;&#x3D; nullptr || head-&gt;next &#x3D;&#x3D; nullptr)return head;</span><br><span class="line">        ListNode* slow &#x3D; head, * fast &#x3D; head-&gt;next;</span><br><span class="line">        while (fast !&#x3D; nullptr &amp;&amp; fast-&gt;next !&#x3D; nullptr) &#123;</span><br><span class="line">            fast &#x3D; fast-&gt;next-&gt;next;</span><br><span class="line">            slow &#x3D; slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* tmp &#x3D; slow-&gt;next;</span><br><span class="line">        slow-&gt;next &#x3D; nullptr;</span><br><span class="line">        ListNode* left &#x3D; sortList(head), * right &#x3D; sortList(tmp);</span><br><span class="line">        ListNode* res &#x3D; new ListNode(0), * h &#x3D; res;</span><br><span class="line">        while (left !&#x3D; nullptr &amp;&amp; right !&#x3D; nullptr) &#123;</span><br><span class="line">            if (left-&gt;val &lt; right-&gt;val) &#123;</span><br><span class="line">                h-&gt;next &#x3D; left;</span><br><span class="line">                left &#x3D; left-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                h-&gt;next &#x3D; right;</span><br><span class="line">                right &#x3D; right-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            h &#x3D; h-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        h-&gt;next &#x3D; left &#x3D;&#x3D; nullptr ? right : left;</span><br><span class="line">        return res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/08/problem-library-%E9%93%BE%E8%A1%A8/" data-id="ckhkopse1002wesvefcvs2k2x" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/problem-library/" rel="tag">problem library</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-c-primer-04-表达式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/06/c-primer-04-%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="article-date">
  <time datetime="2020-08-06T15:09:11.000Z" itemprop="datePublished">2020-08-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/06/c-primer-04-%E8%A1%A8%E8%BE%BE%E5%BC%8F/">c++ primer 04 表达式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h1><p>表达式由一个或多个运算对象(operand)组成，对表达式求值将得到一个结果(result)。<br>右值(rvalue) :对象的值(内容)  左值(lvalue) : 对象的身份(在内存中的位置)<br>取余：(m / n)* n + m % n = m m % n符号和m相同 m % (-n) = m % n(-m) % n = -m % n<br>逻辑运算符与、或：当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值，短路求值(short_circuit evaluation)<br>if (i &lt; j &lt; k)k &gt; 1时为真(i &lt; j &amp;&amp; 1 &lt; k)<br>int k = 0; k = 3.14; (可以)k = { 3.14 }(不可以)k = { 3 }(可以)<br>多重赋值语句中的每一个对象，它的类型与右边对象相同或者可由右边对象的类型转换得到<br>int ival, <em>pval;ival=pval=0(错误，不能把指针的值赋值给int)<br>递增、递减运算符，后置版本储存了原值的副本，可能是一种浪费，尽量使用前置版本<br>*pbeg++:先进行递增，但返回初始值，所以解引用初始值，再将指针指向下一个<br>条件运算符 A?B:C?D:E–&gt;A?B:(C?D:E)<br>cou&lt;&lt;(A&gt;B)?C:D 输出0或者1   cout&lt;<A>B?C:D 错误，试图比较cout和B<br>位异或运算符(^)两个运算对象对应的位置有且只有一个为1,则结果中该位置为1，否则为0<br>运算对象分别为无符号和带符号类型：无符号不小于带符号-&gt;转换成无符号，反之转换成带符号<br>显示转换：<br>任何具有明确定义的类型转换，只要不包含底层constraint，都可以使用static_cast<br>double slope=static_cast<double>(i)/j<br>const_cast只能改变运算对象的底层const<br>const char</em> pc; char* p = const_cast&lt;char*&gt;(pc);<br>只有const_cast能改变表达式的常量属性<br>reinterpret_cast通常为运算对象的位模式提供较低层次上的重新解释</p>
<h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p>复合语句(compound statement)也被称作块(block)。一个块就是一个作用域，在块中引入的名字只能在块内部以及嵌套在块中的子块里访问</p>
<p>switch语句的case标签(case lable)必须是整型常量表达式<br>switch (ch) { case ‘a’:++acnt; case ‘e’:++ecnt; case ‘i’:++icnt; }ch==e的时候会执行++ecnt及之后的++icnt。需要break<br>若没有case匹配，执行default  标签后面必须跟上一条语句或者另一个标签<br>若某处一个带有初值的变量位于作用域之外，在另一处该变量位于作用域之内，则从前一处跳转到后一处的行为是非法行为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">	<span class="built_in">string</span> file_name; <span class="comment">//错误：控制流绕过一个隐式初始化的变量</span></span><br><span class="line">	<span class="keyword">int</span> jval = <span class="number">0</span>; <span class="comment">//错误：控制流绕过一个显式初始化的变量</span></span><br><span class="line">	<span class="keyword">int</span> jval; <span class="comment">//正确：jval没有初始化</span></span><br><span class="line"><span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">	jval = next_num; <span class="comment">//正确</span></span><br><span class="line">	<span class="keyword">if</span>(file_name.empty())<span class="comment">/**/</span></span><br></pre></td></tr></table></figure>
<p>使用while循环：不确定要迭代多少次、想在循环结束后访问循环控制变量</p>
<p>for语句头中init-statement只能有一条声明语句，因此所有变量的基础类型必须相同</p>
<p>范围for语句：若需要对序列中的元素执行写操作，循环变量必须声明成引用类型<br>不能通过范围for语句增加容器的元素</p>
<p>do while语句不允许在条件部分定义变量</p>
<p>continue：对于传统的for循环，继续执行for语句头的expression；对于范围for语句，用序列中的下一个元素初始化循环控制变量</p>
<p>go to语句(go lable;)goto语句和控制权转向的那条带标签的语句必须位于同一个函数之内</p>
<p>try语句块和异常处理</p>
<p>throw表达式(throw expression)异常检测部分使用throw表达式来表示它遇到了无法处理的问题。我们说throw引发(raise)了异常<br>throw表达式包含关键字throw和紧随其后的一个表达式，表达式的类型就是抛出的异常类型<br>throw runtime_error(“Data must refer to same ISBN”);</p>
<p>try语句块(try block)异常处理部分使用try语句块处理异常。以关键字try开始，并以一个或多个catch子句(catch clause)结束<br>catch子句包括：关键字catch、括号内一个(可能未命名的)对象的声明(异常声明,exception declaration)以及一个块。当选中了某个catch子句处理异常之后，执行与之对应的块。完成后跳转到try语句块最后一个catch子句之后的那条语句继续执行<br>没找到匹配的catch子句，程序转到名为terminate的标准函数库</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	program - staments</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (exception - declaration) &#123;</span><br><span class="line">	handler - staments</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; item1 &gt;&gt; item2) &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//执行添加两个Sales_item对象的代码，如果添加失败，代码抛出一个runtime_error异常</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (runtime_error) &#123;</span><br><span class="line">		<span class="comment">//提醒用户两个ISBN必须一致，询问是否重新输入</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; err.what() &lt;&lt; <span class="string">"\nTry Again?"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">char</span> c;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">cin</span> || c == <span class="string">'n'</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>调用函数时，传入的可以是能转换成的实参(int类型可以传入3.14)<br>形参列表可以为空()/(void)不能省略<br>函数的返回值类型不能是数组类型和函数类型，但可以是指向数组或函数的指针<br>把只存在于块执行期间的对象称为自动对象(automatic object)<br>局部静态对象(local static object)可将局部变量定义成static类型从而令局部变量的生命周期贯穿函数调用及之后的时间<br>内置类型的局部静态变量初始化为0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">size_t count_calls() &#123;</span><br><span class="line">	static size_t ctr &#x3D; 0;</span><br><span class="line">	return ++ctr;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	for (size_t i &#x3D; 0; i !&#x3D; 10; i++)</span><br><span class="line">		cout &lt;&lt; count_calls() &lt;&lt; endl;</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>指针形参：当执行指针拷贝操作时，拷贝的是指针的值。拷贝之后两个指针是不同的指针。因为指针使我们可以间接地访问它所指的对象，所以通过指针可以修改它所指对象的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void reset(int* p) &#123;</span><br><span class="line">	*p &#x3D; 0; &#x2F;&#x2F;改变指针p所指对象的值</span><br><span class="line">	p &#x3D; 0; &#x2F;&#x2F;只改变了p的局部拷贝，实参未被改变</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传引用参数可以避免拷贝<br>通常一个函数只能返回一个值，使用引用形参可返回额外信息<br>当用实参初始化形参时会忽略掉顶层const，当形参有顶层const时，传给它常量对象或非常量对象都是可以的<br>void fcn(const int i) {} 和 void fcn(int i) {} 不能同时存在，两个形参是相同的<br>尽量使用常量引用，非常量引用会限制函数所能结束的实参类型。不能把const对象、字面值或者需要类型转换的对象传递给普通的引用形参</p>
<p>不允许拷贝数组、使用数组时(通常)会将其转换成指针<br>void t01(const int* / const int[] / const int[10])<br>三个等价，每一个都有const int* 类型的形参<br>给函数传递一个数组时，实参自动地转换成指向数组首元素的指针，数组的大小对函数的调用没有影响<br>使用标记指定数组长度：要求数组本身包含一个结束标记(c风格字符串)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void print(const char* cp) &#123;</span><br><span class="line">	if (cp) &#x2F;&#x2F;若cp不是一个空指针</span><br><span class="line">		while (cp) &#x2F;&#x2F;只要指针所指的字符不是空字符</span><br><span class="line">			cout &lt;&lt; *cp++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用标准款规范：传递指向数组首元素和尾后元素的指针</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int j[2] &#x3D; &#123; 2,3 &#125;</span><br><span class="line">print(begin(j), end(j));</span><br><span class="line">void print(const int* beg, const int* end) &#123;</span><br><span class="line">	while (beg !&#x3D; end)cout &lt;&lt; *beg++ &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显式传递一个表示数组大小的形参：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int j[] &#x3D; &#123; 2,3 &#125;;</span><br><span class="line">print(j, end(j) - begin(j));</span><br><span class="line">void print(const int ia[], size_t size) &#123;</span><br><span class="line">	for (size_t i &#x3D; 0; i &lt; size; i++)cout &lt;&lt; ia[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(int&amp; arr[10])引用的数组 f(int(&amp;arr)[10])数组的引用</span><br><span class="line">int i &#x3D; 0, j[2] &#x3D; &#123; 2,3 &#125;, k[] &#x3D; &#123; 0,1,2,3,4,5,6,7,8,9 &#125;;</span><br><span class="line">print(&amp;i); &#x2F;&#x2F;错误：实参不是含有10个整数的数组</span><br><span class="line">print(j); &#x2F;&#x2F;错误</span><br><span class="line">print(k); &#x2F;&#x2F;正确</span><br></pre></td></tr></table></figure>
<p>含有可变形参的函数：无法提前预知应该想函数传递几个参数<br>所有的实参类型相同，可以传递initializer_list标准库类型；实参类型不同，可以编写可变参数模板</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">initializer_list&lt;T&gt;lst;</span><br><span class="line">initializer_list&lt;T&gt;lst&#123; a,b,c &#125;;</span><br><span class="line">lst2(lst);</span><br><span class="line">lst2 &#x3D; lst;</span><br><span class="line">lst.size(); lst.begin(); lst.end();</span><br><span class="line">void error_msg(initializer_list&lt;string&gt; il) &#123;</span><br><span class="line">	for (auto beg &#x3D; il.begin(); beg !&#x3D; il.end(); ++beg)</span><br><span class="line">		cout &lt;&lt; *beg &lt;&lt; &quot; &quot;;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">省略符形参：void foo(parm_list, ...) &#x2F; (...)</span><br></pre></td></tr></table></figure>
<p>没有返回值的return语句只能用在返回值类型是void的函数中，返回void的函数不要求非得有return语句，会隐式执行<br>不能返回局部变量的引用或指针。函数完成后会被释放掉</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const string &amp; manip() &#123;</span><br><span class="line">	string ret;</span><br><span class="line">	if (!ret.empty())return ret; &#x2F;&#x2F;错误：返回局部对象的引用</span><br><span class="line">	else return &quot;Empty&quot;; &#x2F;&#x2F;错误：&quot;Empty&quot;是一个局部临时变量</span><br><span class="line">&#125;</span><br><span class="line">主函数main允许没有return语句，编译器将隐式地插入一条返回0的return语句</span><br><span class="line">一个函数调用了它本身，称为递归函数(recursive function)</span><br><span class="line">int factorial(int val) &#123;</span><br><span class="line">	if (val &gt; 1)return factorial(val - 1) * val;</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回数组指针：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef int arr[10]; &#x2F;&#x2F;arr是一个类型别名，表示的类型是含有10个整数的数组</span><br><span class="line">using arr&#x3D;int[10]; &#x2F;&#x2F;arr的等价声明</span><br><span class="line">arr* func(int i) &#123;&#125; &#x2F;&#x2F;func发返回一个指向含有10个整数的数组指针</span><br><span class="line">Type(*function(parameter_list))[dimension]  int(*func(int i))[10];</span><br></pre></td></tr></table></figure>
<p>使用尾置返回类型：auto function(int i)-&gt;int(*)[10];<br>若知道函数返回的指针将指向哪个数组，可以使用decltype关键字声明返回类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int odd[] &#x3D; &#123; 1,3,5 &#125;, even[] &#x3D; &#123; 2,4,6 &#125;;</span><br><span class="line">decltype(odd)* arrPtr(int i) &#123; return (1 % 2) ? &amp;odd : &amp;even; &#125;</span><br></pre></td></tr></table></figure>
<p>arrPtr使用关键字decltype表示它的返回类型是个指针，且该指针所指的对象与odd的类型一致</p>
<p>顶层const不影响传入的对象：Record lookup(Phone) / (const Phone)和(Phone<em>) / (Phone * const)是重复声明<br>如果形参是某种类型的指针或引用，通过区分是否常量可以实现函数重载，此时const是底层的<br>Record lookup(Account&amp;) / (const Account&amp;)和(Account</em>) / (const Account*)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const_cast：</span><br><span class="line">const string &amp; shorterString(const string &amp; s1, const string &amp; s2) &#123;</span><br><span class="line">	return s1.size() &lt; s2.size() ? s1 : s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string&amp; shorterString(string s1, string s2) &#123;</span><br><span class="line">	auto&amp; r &#x3D; shorterString(const_cast&lt;const string&amp;&gt;s1 : const_cast&lt;const string&amp;&gt;s2;);</span><br><span class="line">	return const_cast&lt;string&amp;&gt;(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先将它的实参强制转换成对const的引用，然后调用了shorterString函数的const版本。const版本返回对const string的引用，这个引用绑定在某个初始的非常量实参上</p>
<p>重载与作用域</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">string read();</span><br><span class="line">void print(const string&amp;);</span><br><span class="line">void print(double);</span><br><span class="line">void fooBar(int ival) &#123;</span><br><span class="line">	bool read &#x3D; false; &#x2F;&#x2F;新作用域，隐藏了外层的read</span><br><span class="line">	string s &#x3D; read; &#x2F;&#x2F;错误：read是bool值，而非函数</span><br><span class="line">	void print(int); &#x2F;&#x2F;新作用域：隐藏了之前的print</span><br><span class="line">	print(&quot;Value&quot;); &#x2F;&#x2F;错误：print(const string&amp;)被隐藏掉了</span><br><span class="line">	print(ival); &#x2F;&#x2F;正确：当前print(int)可见</span><br><span class="line">	print(3.14); &#x2F;&#x2F;正确：调用print(int);print(double)被隐藏掉</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认实参<br>默认实参作为形参的初始值出现在形参列表中，可以为一个或多个形参定义默认值。一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">typedef string::size_type sz;</span><br><span class="line">string screen(sz ht &#x3D; 24, sz wid &#x3D; 80, char backgrnd &#x3D; &#39; &#39;);</span><br><span class="line">string window;</span><br><span class="line">window &#x3D; screen(); &#x2F;&#x2F;screen(24,80,&#39; &#39;)</span><br><span class="line">window &#x3D; screen(66); &#x2F;&#x2F;screen(66,80,&#39; &#39;)</span><br><span class="line">window &#x3D; screen(66, 256); &#x2F;&#x2F;screen(66,256,&#39; &#39;)</span><br><span class="line">window &#x3D; screen(66, 256, &#39;#&#39;); &#x2F;&#x2F;screen(66,256,&#39;#&#39;)</span><br><span class="line">window &#x3D; screen(, , &#39;?&#39;); &#x2F;&#x2F;错误：只能省略尾部实参</span><br><span class="line">window &#x3D; screen(&#39;?&#39;) &#x2F;&#x2F;screen(&#39;?&#39;,80,&#39; &#39;)</span><br><span class="line">在给定的作用域中一个形参只能被赋予一次默认实参</span><br><span class="line">string screen(sz, sz, char &#x3D; &#39; &#39;);</span><br><span class="line">string screen(sc, sc, char&#x3D;&#39;*&#39;); &#x2F;&#x2F;错误：重复声明</span><br><span class="line">string screen(sc &#x3D; 24, sc &#x3D; 80, char); &#x2F;&#x2F;正确：添加默认实参</span><br><span class="line">局部变量不能作为默认实参，能转换成形参所需的类型的表达式可以作为默认实参。</span><br><span class="line">sz wd &#x3D; 80; char def &#x3D; &#39; &#39;; sz ht();</span><br><span class="line">string screen(sz &#x3D; ht(), sz &#x3D; wd, char &#x3D; def);</span><br><span class="line">string window &#x3D; screen(); &#x2F;&#x2F;调用screen(ht(),80,&#39; &#39;)</span><br><span class="line">void f2() &#123;</span><br><span class="line">	def &#x3D; &#39;*&#39;; &#x2F;&#x2F;改变默认参数的值</span><br><span class="line">	sz wd &#x3D; 80; &#x2F;&#x2F;隐藏了外层定义的wd，但没有改变默认值</span><br><span class="line">	window &#x3D; screen(); &#x2F;&#x2F;调用screen(ht(),80,&#39;*&#39;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内联函数(inline)可以避免函数调用的开销<br>inline const string&amp; shorterString(const string&amp; s1, const string&amp; s2) {<br>    return s1.size() &lt;= s2.size() ? s1 : s2;<br>}<br>内联机制用于优化规模较小、流程直接、频繁调用的函数。很多编译器不支持内联递归函数</p>
<p>constexpr函数(constexpr function)是指能用于常量表达式的函数。函数的返回类型及所有形参的类型都得是字面值类型，且函数体中必须有且仅有一条return语句<br>constexpr int new_sz() { return 42 };<br>constexpr int foo = new_sz();<br>constexpr函数体内也可以包含其他语句，只要在运行时不执行任何操作。如空语句、类型别名以及using声明<br>允许constexpr函数返回值并非一个常量<br>对于某个给定的内联函数或者constexpr函数，它的多个定义必须完全一致。所以通常定义在头文件中</p>
<p>调试帮助<br>assert预处理宏(preprocessor marco)  assert(expr)若expr表达式为假，assert输出信息并终止程序执行；为真则什么也不做<br>NDEBUG预处理变量：如果定义了NDEBUG，则assert什么也不做。默认状态下没有定义NDEBUG，此时assert将执行运行时检查<br><strong>func</strong> 存放函数的名字 <strong>FILE</strong> 存放文件名的字符串字面值 <strong>LINE</strong> 存放当前行号的整型字面值<br><strong>TIME</strong> 存放文件编译时间的字符串字面值 <strong>DATE</strong> 存放文件编译日期的字符串字面值</p>
<p>函数匹配<br>void f(); void f(int); void f(int, int); void f(double, double = 3.14);<br>f(5.6); //调用f(double,double=3.14)<br>如果有且只有一个函数满足下列条件，则匹配成功：<br>该函数每个实参的匹配都不劣于其他可行函数需要的匹配<br>至少有一个实参的匹配优于其他可行函数提供的匹配<br>类型转换：<br>精确匹配：类型相同；实参从数组或函数类型转换成对应的指针类型；向实参添加顶层const或从实参删除顶层const<br>通过const转换实现的匹配<br>通过类型提升实现的匹配<br>通过算术类型转换实现的匹配<br>通过类类型转换实现的匹配</p>
<p>函数指针指向的是函数而非对象。函数的类型由它的返回类型和形参类型共同决定，与函数名无关<br>bool lengthCompare(const string&amp;, const string&amp;);<br>bool (<em>pf)(const string&amp;, const string&amp;); 未初始化。 pf指向一个函数，该函数的参数是两个const string的引用，返回值是bool类型<br>bool</em> pf(const string&amp;, const string&amp;); pf是一个返回值为bool指针的函数<br>把函数名作为一个值使用时，该函数自动地转换成指针<br>pf = lengthCompare或者pf = &amp;lengthCompare 两个等价，取地址符可选<br>可以直接使用指向函数的指针调用该函数，无需提前解引用指针<br>bool b1 = pf(“hello”, “goodbye”);<br>bool b2 = (*pf)(“hello”, “goodbye”);<br>bool b3 = lengthCompare(“hello”, “goodbye”); 三个等价<br>在指向不同类型的指针间不存在转换规则。但可以为函数指针赋一个nullptr或者值为0的整型常量表达式，表示该指针没有指向任何函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string::size_type sumLength(const string&amp;, const string&amp;);</span><br><span class="line">bool cstringCompare(const char*, const char*);</span><br><span class="line">pf &#x3D; 0; &#x2F;&#x2F;正确：pf不指向任何函数</span><br><span class="line">pf &#x3D; sumLength; &#x2F;&#x2F;错误：返回值类型不匹配</span><br><span class="line">pf &#x3D; cstringCompare; &#x2F;&#x2F;错误：形参类型不匹配</span><br><span class="line">pf &#x3D; lengthCompare; &#x2F;&#x2F;正确：函数和指针类型精确匹配</span><br></pre></td></tr></table></figure>
<p>重载函数时，上下文必须清晰地界定到底该选用哪个函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void ff &#x3D; (int*);</span><br><span class="line">void ff &#x3D; (unsigned int);</span><br><span class="line">void (*pf1)(unsigned int) &#x3D; ff; &#x2F;&#x2F;pf1指向ff(unsighed int)</span><br><span class="line">void (*pf2)(int) &#x3D; ff; &#x2F;&#x2F;错误：没有ff与该类型形参列表匹配</span><br><span class="line">double (*pf3)(int*) &#x3D; ff; &#x2F;&#x2F;错误：返回值不匹配</span><br></pre></td></tr></table></figure>
<p>函数指针形参</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void useBigger(const string&amp; s1, const string&amp; s2, bool pf(const string&amp;, const string&amp;));</span><br><span class="line">void useBigger(const string&amp; s1, const string&amp; s2, bool(*pf)(const string&amp;, const string&amp;)); 二者等价，显式地将形参定义成指向函数的指针</span><br><span class="line">可以把函数作为实参使用，自动转换成指针</span><br><span class="line">useBigger(s1, s2, lengthCompare);</span><br><span class="line">使用类型别名：</span><br><span class="line">typedef bool Func(const string&amp;, const string&amp;);</span><br><span class="line">typedef decltype(lengthCompare) Func2; 二者等价，Func和Func2是函数类型</span><br><span class="line">typedef bool (*FuncP)(const string&amp;, const string&amp;);</span><br><span class="line">typedef decltype(lengthCompare)* FuncP2; 二者等价，* FuncP和* FuncP2是指针类型</span><br><span class="line">void useBigger(const string&amp;, const string&amp;, Func);</span><br><span class="line">void useBigger(const strign&amp;, const string&amp;, *FuncP2); 二者等价，第一句中编译器自动将Func表示的函数类型转换成指针</span><br></pre></td></tr></table></figure>
<p>使用类型别名返回指向函数的指针</p>
<pre><code>using F=int(int*, int);  //F是函数类型，不是指针
using PF=int(*)(int*, int); //PF是指针类型
PF f1(int); //正确：PF是指向函数的指针，f1返回指向函数的指针
F f1(int); //错误：F是函数类型，f1不能返回一个函数
F* f1(int); //正确：显式地指定返回类型是指向函数的指针
int (*f1(int))(int*, int); //指针指向一个返回值是int类型的函数
auto fi(int)-&gt;int(*)(int*, int);

string::size_type sumLength(const string&amp;, const string&amp;);
decltype(sumLength)* getFcn(const string&amp;);
decltype作用于某个函数时，返回函数类型而非指针。因此显式地加上*表示需要返回指针而非函数本身
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/06/c-primer-04-%E8%A1%A8%E8%BE%BE%E5%BC%8F/" data-id="ckhkopsd6000hesvectt1b2ph" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-primer/" rel="tag">c++ primer</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-problem-library-树-02" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/28/problem-library-%E6%A0%91-02/" class="article-date">
  <time datetime="2020-07-28T15:15:05.000Z" itemprop="datePublished">2020-07-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/28/problem-library-%E6%A0%91-02/">problem library 树 02</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="#106.从中序与后序遍历序列构造二叉树"></a>#106.从中序与后序遍历序列构造二叉树</h2><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p>
<p>注意:<br>你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<p>中序遍历 inorder = [9,3,15,20,7]<br>后序遍历 postorder = [9,15,7,20,3]<br>返回如下的二叉树：</p>
<pre><code>  3
 / \
9  20
  /  \
 15   7</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal" target="_blank" rel="noopener">https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;postorder, <span class="keyword">int</span> i_begin, <span class="keyword">int</span> i_end, <span class="keyword">int</span> p_begin, <span class="keyword">int</span> p_end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i_begin &gt; i_end || p_begin &gt; p_end)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode* res = <span class="keyword">new</span> TreeNode(postorder[p_end]);</span><br><span class="line">        <span class="keyword">if</span> (p_begin == p_end)<span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (postorder[p_end] != inorder[index])index++;</span><br><span class="line">        res-&gt;left = helper(inorder, postorder, i_begin, index - <span class="number">1</span>, p_begin, p_begin + index - <span class="number">1</span> - i_begin);</span><br><span class="line">        res-&gt;right = helper(inorder, postorder, index + <span class="number">1</span>, i_end, p_end - <span class="number">1</span> - (i_end - (index + <span class="number">1</span>)), p_end - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(inorder, postorder, <span class="number">0</span>, inorder.<span class="built_in">size</span>() - <span class="number">1</span>, <span class="number">0</span>, postorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="95-不同的二叉搜索树II"><a href="#95-不同的二叉搜索树II" class="headerlink" title="#95.不同的二叉搜索树II"></a>#95.不同的二叉搜索树II</h2><p>给定一个整数 n，生成所有由 1 … n 为节点所组成的 二叉搜索树 。</p>
<p>示例：</p>
<p>输入：3<br>输出：<br>[<br>  [1,null,3,2],<br>  [3,2,null,1],<br>  [3,1,null,null,2],<br>  [2,1,3],<br>  [1,null,2,null,3]<br>]<br>解释：<br>以上的输出对应以下 5 种不同结构的二叉搜索树：</p>
<pre><code>1         3     3      2      1
 \       /     /      / \      \
  3     2     1      1   3      2
 /     /       \                 \
2     1         2                 3</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-binary-search-trees-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">getrees</span><span class="params">(<span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lo &gt; hi)<span class="keyword">return</span> &#123; <span class="literal">nullptr</span> &#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt;res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt;= hi; i++) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;TreeNode*&gt; leftTrees = getrees(lo, i - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">vector</span>&lt;TreeNode*&gt; rightTrees = getrees(i + <span class="number">1</span>, hi);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; l : leftTrees)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; r : rightTrees) &#123;</span><br><span class="line">                    TreeNode* root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    root-&gt;left = l;</span><br><span class="line">                    root-&gt;right = r;</span><br><span class="line">                    res.emplace_back(root);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)<span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">return</span> getrees(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/28/problem-library-%E6%A0%91-02/" data-id="ckhkopsdy002pesveg5h6bgqo" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/problem-library/" rel="tag">problem library</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/02-cpp-primer/" rel="tag">02 cpp primer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c-primer/" rel="tag">c++ primer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cocos2d-x/" rel="tag">cocos2d-x</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpp-notes/" rel="tag">cpp notes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/problem-library/" rel="tag">problem library</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reading-notes-DS/" rel="tag">reading notes DS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%82%93%E4%BF%8A%E8%BE%89/" rel="tag">数据结构 邓俊辉</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/02-cpp-primer/" style="font-size: 14px;">02 cpp primer</a> <a href="/tags/c-primer/" style="font-size: 16px;">c++ primer</a> <a href="/tags/cocos2d-x/" style="font-size: 12px;">cocos2d-x</a> <a href="/tags/cpp-notes/" style="font-size: 20px;">cpp notes</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/problem-library/" style="font-size: 16px;">problem library</a> <a href="/tags/reading-notes-DS/" style="font-size: 10px;">reading notes DS</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%82%93%E4%BF%8A%E8%BE%89/" style="font-size: 18px;">数据结构 邓俊辉</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/11/17/ncpp-04/">第4章 表达式</a>
          </li>
        
          <li>
            <a href="/2020/11/16/%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/">操作方法</a>
          </li>
        
          <li>
            <a href="/2020/11/16/ncpp-03/">第3章 字符串、向量和数组</a>
          </li>
        
          <li>
            <a href="/2020/11/16/ncpp-02/">第2章 变量和基本类型</a>
          </li>
        
          <li>
            <a href="/2020/10/27/mysql/">mysql</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>
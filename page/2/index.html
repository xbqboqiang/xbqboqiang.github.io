<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-c-primer-09-顺序容器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/30/c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/" class="article-date">
  <time datetime="2020-08-30T01:40:30.000Z" itemprop="datePublished">2020-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/30/c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/">c++ primer 09 顺序容器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="顺序容器-sequential-container"><a href="#顺序容器-sequential-container" class="headerlink" title="顺序容器(sequential container)"></a>顺序容器(sequential container)</h1><p>vector:可变大小数组。支持快速随机访问。在尾部之外位置插入删除元素可能很慢<br>deque:双端队列。支持快速随机访问。在头尾位置插入删除速度很快<br>list;双向列表。只支持双向顺序访问。在任何位置插入删除操作速度都很快<br>forward_list:单向列表。只支持单向顺序访问。在任何位置插入删除操作速度都很快<br>array:固定大小数组。支持快速随机访问。不能添加或删除元素<br>string:与vector相似，但专门用于保存字符。随机访问快。在尾部插入删除速度快</p>
<p>选择容器基本原则：<br>首选vector<br>有很多小元素，空间的额外开销很重要，不要用list或forward_list<br>在中间插入或删除，用list或forward_list<br>只在头尾插入或删除，用deque</p>
<h3 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h3><p><img src="./c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/%E6%8D%95%E8%8E%B7.png" alt="输入图片描述"></p>
<p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/%E6%8D%95%E8%8E%B71.PNG?v=1&type=image" alt="输入图片描述"></p>
<p>使用左闭合范围<br>如果begin与end相等，则范围为空；begin与end不等，则至少包含一个元素，且begin指向范围中的第一个元素；可以对begin递增若干次，使得begin==end</p>
<h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt;::iterator iter;    vector&lt;int&gt;::difference_type count;</span><br><span class="line"></span><br><span class="line">a.begin() &#x2F; rbegin() &#x2F; cbegin() &#x2F; crbegin()</span><br><span class="line">auto it &#x3D; a.begin(); &#x2F;&#x2F;仅当a是const时，it是const_iterator</span><br></pre></td></tr></table></figure>
<h3 id="容器定义和初始化"><a href="#容器定义和初始化" class="headerlink" title="容器定义和初始化"></a>容器定义和初始化</h3><p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/2%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"></p>
<p>创建一个容器为另一个的拷贝，两个容器的类型及元素类型必须匹配，传递迭代器参数拷贝范围时不要求，能转换即可;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt; authors &#x3D; &#123; &quot;ab&quot;,&quot;cd&quot;,&quot;ef&quot;&#125;;</span><br><span class="line">vector&lt;const char*&gt;articles &#x3D; &#123; &quot;a&quot;,&quot;an&quot;,&quot;the&quot; &#125;;</span><br><span class="line">list&lt;string&gt;list2(authors); &#x2F;&#x2F;正确：类型匹配</span><br><span class="line">deque&lt;string&gt;authList(authors); &#x2F;&#x2F;错误：容器类型不匹配</span><br><span class="line">vector&lt;string&gt;words(atricles); &#x2F;&#x2F;错误：容器类型必须匹配</span><br><span class="line">forward_list&lt;string&gt;words(articles.begin(), articles.end()); &#x2F;&#x2F;正确：可以将const char*转换为string</span><br></pre></td></tr></table></figure>
<p>如果元素类型是内置类型或者具有默认构造函数的类类型，可以值为构造函数提供一个容器大小参数；如果没有默认构造函数，还必须指定一个显式的元素初始值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">array&lt;string, 10&gt; &#x2F;&#x2F;类型为保存10个string的数组</span><br><span class="line">array&lt;int, 10&gt;::size_type i; &#x2F;&#x2F;正确  </span><br><span class="line">array&lt;int&gt;::size_type j; &#x2F;&#x2F;错误：array&lt;int&gt;不是一个类型</span><br><span class="line">array&lt;int,3&gt;ia1; &#x2F;&#x2F;10个默认初始化的int</span><br><span class="line">array&lt;int,3&gt;ia2 &#x3D; &#123; 0,1,2 &#125;; &#x2F;&#x2F;列表初始化</span><br><span class="line">array&lt;int, 3&gt;ia3 &#x3D; &#123; 1 &#125;; &#x2F;&#x2F;ia3[0]为1，其余元素为0</span><br><span class="line">不能对内置数组类型进行拷贝或对象赋值，但array可以</span><br><span class="line">array&lt;int, 3&gt;digs &#x3D; &#123; 1,2,3 &#125;;</span><br><span class="line">array&lt;int, 3&gt;copy &#x3D; digs;</span><br></pre></td></tr></table></figure>
<h3 id="赋值和swap"><a href="#赋值和swap" class="headerlink" title="赋值和swap"></a>赋值和swap</h3><p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/3%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c1 &#x3D; c2; &#x2F;&#x2F;将c1的内存替换为c2中元素的拷贝，c1大小变为c2的大小</span><br><span class="line">c1 &#x3D; &#123; a,b,c &#125;;</span><br><span class="line">array&lt;int, 3&gt;a1 &#x3D; &#123; 1,2,3 &#125;;</span><br><span class="line">array&lt;int, 3&gt;a2 &#x3D; &#123; 0 &#125;;</span><br><span class="line">a1 &#x3D; a2; &#x2F;&#x2F;替换a1中的元素</span><br><span class="line">a2 &#x3D; &#123; 0 &#125;; &#x2F;&#x2F;错误：不能讲一个花括号列表赋予数组</span><br></pre></td></tr></table></figure>
<p>赋值相关运算会导致指向左边容器内部的迭代器、引用和指针失效，而swap操作不会(array和string除外)</p>
<p>顺序容器(array除外)定义了一个assign成员，允许从一个不同但相容的类型赋值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt;names; vector&lt;const char*&gt;oldstyle;</span><br><span class="line">names &#x3D; oldstyle; &#x2F;&#x2F;错误：容器类型不匹配</span><br><span class="line">names.assign(oldstyle.begin(), oldstyle.end()); &#x2F;&#x2F;正确：可以将const char*转换成string</span><br><span class="line"></span><br><span class="line">list&lt;string&gt;slist1(1); &#x2F;&#x2F;1个元素，为空string</span><br><span class="line">slist1.assign(10, &quot;hi&quot;); &#x2F;&#x2F;10个元素，“hi”</span><br><span class="line">等价于slist1.clear(); slist1.insert(slist1.begin(), 10, &quot;hi&quot;);</span><br></pre></td></tr></table></figure>
<p>swap操作交换两个相同类型容器的内容。除array外，操作会很快，元素本身并未交换，只是交换了内部数据结构<br>除string外，指向容器的迭代器、引用和指针在swap后都不会失效</p>
<p>除forward_list外，都有size, empty, max_size(返回一个大于或等于该类型容器所能容纳的最大元素的值)。forward_list只有max_size和empty</p>
<p>每个容器类型都支持相等运算符(==/!=)；除无序关联容器外都支持关系运算符(&gt;/&gt;=/&lt;/&lt;=)。必须是相同类型容器，相同类型的元素<br>比较结果取决于第一个不相等的元素的比较结果</p>
<h3 id="向顺序容器中添加元素"><a href="#向顺序容器中添加元素" class="headerlink" title="向顺序容器中添加元素"></a>向顺序容器中添加元素</h3><p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/4%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"></p>
<p>插入容器后若容器没有扩容、该元素没有改变位置，不会使其失效<br>当我们用一个对象来初始化容器，或将一个对象插入到容器中时，实际上放入到容器中的是对象的一个拷贝，而不是对象本身</p>
<p>当调用push或insert成员函数时，我们将元素类型的对象传递给它们，这些对象被拷贝到容器中。<br>当我们调用emplace成员函数时，则是将参数传递给元素类型的构造函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c.emplace_back(&quot;99-9999&quot;,25,15.99); &#x2F;&#x2F;使用三个参数的Sales_data构造函数</span><br><span class="line">c.push_back((&quot;99-9999&quot;, 25, 15.99); &#x2F;&#x2F;错误：没有接受三个参数的push_back版本</span><br><span class="line">c.push_back(Sales_data((&quot;99-9999&quot;, 25, 15.99)); &#x2F;&#x2F;正确：创建一个临时的Sales_data对象传递给push_back</span><br></pre></td></tr></table></figure>
<p>调用emplace_back时会在容器管理的内存空间中直接创建对象；而调用push_back则会创建一个局部临时对象，并将其压入容器中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">emplace函数的参数根据元素类型而变化，参数必须与元素类型的构造函数相匹配</span><br><span class="line">c.emplace_back(); &#x2F;&#x2F;使用Sales_data的默认构造函数</span><br><span class="line">c.emplace(iter, &quot;99-9999&quot;); &#x2F;&#x2F;使用Sales_data(string)</span><br><span class="line">c.emplace_front(&quot;99-9999&quot;, 25, 15.99); &#x2F;&#x2F;使用Sales_data的接受一个ISBN、一个count和一个price的构造函数</span><br></pre></td></tr></table></figure>
<h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/5%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (!c.empty()) &#123;</span><br><span class="line">	auto val &#x3D; *c.begin(); val2 &#x3D; c.front();</span><br><span class="line">	auto last &#x3D; c.end();</span><br><span class="line">	auto val3 &#x3D; *(--c.end());</span><br><span class="line">	auto val4 &#x3D; c.back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在容器中访问元素的成员函数(fornt,back,下标和at)返回的都是引用，容器是一个const对象则返回值是const的引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (!c.empty()) &#123;</span><br><span class="line">	c.front() &#x3D; 42;</span><br><span class="line">	auto&amp; v &#x3D; c.back(); &#x2F;&#x2F;获得指向最后一个元素的引用</span><br><span class="line">	v &#x3D; 1024; &#x2F;&#x2F;改变c中元素</span><br><span class="line">	auto v2 &#x3D; c.back(); &#x2F;&#x2F;v2不是引用，是c.back()的一个拷贝</span><br><span class="line">	v2 &#x3D; 0; &#x2F;&#x2F;不改变c中元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>at成员函数类似下标运算符，但越界是会抛出一个out_of_range异常</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt;v;</span><br><span class="line">cout &lt;&lt; v[0]; &#x2F;&#x2F;运行时错误</span><br><span class="line">cout &lt;&lt; v.at(0); &#x2F;&#x2F;抛出一个out_of_range异常</span><br></pre></td></tr></table></figure>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/6%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"><br><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/7%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"></p>
<h3 id="改变容器大小"><a href="#改变容器大小" class="headerlink" title="改变容器大小"></a>改变容器大小</h3><p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/8%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"></p>
<h3 id="管理容量的成员函数"><a href="#管理容量的成员函数" class="headerlink" title="管理容量的成员函数"></a>管理容量的成员函数</h3><p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/9%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"><br>reserve分配的大小小于等于当前容量时，reserve什么也不错。resize成员函数值改变容器中元素的数目，而不是容量</p>
<h3 id="构造string的其他方法"><a href="#构造string的其他方法" class="headerlink" title="构造string的其他方法"></a>构造string的其他方法</h3><p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/10%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const char* cp &#x3D; &quot;hello world!!!&quot;;</span><br><span class="line">char noNull[] &#x3D; &#123; &#39;h&#39;,&#39;i&#39; &#125;;</span><br><span class="line">string s1(cp); &#x2F;&#x2F;拷贝cp重点字符直到遇到空字符；s1&#x3D;&#x3D;&quot;hello world!!!&quot;</span><br><span class="line">string s2(noNull, 2); &#x2F;&#x2F;从noNull拷贝两个字符 &quot;hi&quot;</span><br><span class="line">string s3(noNUll); &#x2F;&#x2F;未定义：noNull不是以空字符结束</span><br><span class="line">string s4(cp + 6, 5); &#x2F;&#x2F;从cp[6]开始拷贝5个字符 &quot;world&quot;</span><br><span class="line">string s5(s1, 6, 5); &#x2F;&#x2F;从s1[6]开始拷贝5个字符 &quot;world&quot;</span><br><span class="line">string s6(s1, 6); &#x2F;&#x2F;从s1[6]开始拷贝到末尾 &quot;world!!!&quot;</span><br><span class="line">string s7(s1, 6, 20); </span><br><span class="line">string s8(s1, 16); &#x2F;&#x2F;抛出out_of_range异常</span><br><span class="line">从const char* 创建string时，指针指向的数组必须以空字符结尾，或者再传递一个合适的计数值</span><br></pre></td></tr></table></figure>
<h3 id="substr操作"><a href="#substr操作" class="headerlink" title="substr操作"></a>substr操作</h3><p>s.substr(pos, n) 返回一个string，包含s中从pos开始的n个字符的拷贝。pos的默认值为0。n的默认值为s.size() - pos，即拷贝从pos开始的所有字符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">string s(&quot;hello world&quot;);</span><br><span class="line">string s2 &#x3D; s.substr(0, 5); &#x2F;&#x2F;hello</span><br><span class="line">string s3 &#x3D; s.substr(6); &#x2F;&#x2F;world</span><br><span class="line">string s4 &#x3D; s.substr(6, 11); &#x2F;&#x2F;world</span><br><span class="line">string s5 &#x3D; s.substr(12); &#x2F;&#x2F;out_of_range</span><br><span class="line"></span><br><span class="line">s.insert(s.size(), 5, &#39;!&#39;); &#x2F;&#x2F;在s末尾插入5个&#39;!&#39;</span><br><span class="line">s.erase(s.size() - 5, 5); &#x2F;&#x2F;从s删除最后5个字符</span><br><span class="line"></span><br><span class="line">const char* cp &#x3D; &quot;Stately, plump Buck&quot;;</span><br><span class="line">s.assign(cp, 7); &#x2F;&#x2F;s&#x3D;&#x3D;&quot;Stately&quot; 赋值从cp开始的7个字符</span><br><span class="line">s.insert(s.size(), cp + 7); &#x2F;&#x2F;s&#x3D;&#x3D;&quot;Stately, plump Buck&quot;  将cp+7开始的字符拷贝到s后面</span><br><span class="line"></span><br><span class="line">string s &#x3D; &quot;Some string&quot;, s2 &#x3D; &quot;some other string&quot;;</span><br><span class="line">s.insert(0, s2); &#x2F;&#x2F;在s的0位置前插入s2</span><br><span class="line">s.insert(0, s2, 0, s2.size()); &#x2F;&#x2F;在s的0位置前插入s2的从0开始s2.size()个字符</span><br></pre></td></tr></table></figure>
<p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/11%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"><br><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/image.png?v=1&type=image" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.replace(a, b, s2); &#x2F;&#x2F;从s的a位置开始删除b个字符，并在该位置插入s2</span><br></pre></td></tr></table></figure>
<h3 id="string搜索操作"><a href="#string搜索操作" class="headerlink" title="string搜索操作"></a>string搜索操作</h3><p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/12%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"><br><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/13%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"><br>每个搜索操作都返回一个string::size_type值，表示匹配发生位置的下标。搜索失败则返回名为string::nops的static成员。nops等于任何string最大的可能大小<br>返回值是unsigned类型，一般不用int或其他带符号类型来保存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string name(&quot;AnnaBelle&quot;); </span><br><span class="line">auto pos &#x3D; name.find(&quot;Anna&quot;); &#x2F;&#x2F;pos&#x3D;&#x3D;0</span><br><span class="line">auto pos1 &#x3D; name.find(&quot;anna&quot;); &#x2F;&#x2F;pos&#x3D;&#x3D;nops</span><br><span class="line"></span><br><span class="line">string numbers(&quot;0123456789&quot;), name(&quot;r2d2&quot;), dept(&quot;01714p3&quot;);</span><br><span class="line">auto pos &#x3D; name.find_first_of(numbers); &#x2F;&#x2F;pos&#x3D;&#x3D;1</span><br><span class="line">auto pos &#x3D; name.find_first_not_of(numbers); &#x2F;&#x2F;pos&#x3D;&#x3D;5</span><br></pre></td></tr></table></figure>
<h3 id="指定开始搜索的位置"><a href="#指定开始搜索的位置" class="headerlink" title="指定开始搜索的位置"></a>指定开始搜索的位置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string::size_type pos &#x3D; 0;</span><br><span class="line">while ((pos &#x3D; name.find_first_of(numbers, pos)) !&#x3D; string::nops) &#123;</span><br><span class="line">	cout &lt;&lt; &quot;found number at index: &quot; &lt;&lt; pos &lt;&lt; &quot; elem is &quot; &lt;&lt; name[pos] &lt;&lt; endl;</span><br><span class="line">	++pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="逆向搜索"><a href="#逆向搜索" class="headerlink" title="逆向搜索"></a>逆向搜索</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string river(&quot;Mississippi&quot;);</span><br><span class="line">auto first_pos&#x3D;river.find_first(&quot;is&quot;); &#x2F;&#x2F;返回1</span><br><span class="line">auto last_pos &#x3D; river.find_last(&quot;is&quot;); &#x2F;&#x2F;返回4</span><br></pre></td></tr></table></figure>
<h3 id="compare函数"><a href="#compare函数" class="headerlink" title="compare函数"></a>compare函数</h3><p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/14%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"><br>返回负数、0、正数</p>
<h3 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D; 42;</span><br><span class="line">string s &#x3D; to_string(i); &#x2F;&#x2F;将整数i转换为字符表示形式</span><br><span class="line">double d &#x3D; stod(s); &#x2F;&#x2F;将字符串s转换为浮点数</span><br></pre></td></tr></table></figure>
<p>要转换为数值的string中第一个非空白符必须是数值中可能出现的字符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s2 &#x3D; &quot;pi&#x3D;3.14&quot;;</span><br><span class="line">d &#x3D; stod(s2.substr(s2.find_first_of(&quot;+-.0123456789&quot;))); &#x2F;&#x2F;d&#x3D;3.14</span><br></pre></td></tr></table></figure>
<p>如果string不能转换为一个数值，则抛出一个invalid_argument异常；数值无法用任何类型来表示则抛出out_of_range异常<br><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/15%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"></p>
<h3 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h3><p>标准库还定义了三个顺序容器适配器：stack、queue和priority_queue。本质上一个适配器是一种机制，能使某种事物的行为看起来像另外一种事物<br><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/16%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"><br>默认情况下，stack和queue是基于deque实现的，priority_queue是在vector之上实现的<br>定义一个适配器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;int&gt;deq;</span><br><span class="line">stack&lt;int&gt; stk(deq); &#x2F;&#x2F;从deq拷贝元素到stk</span><br></pre></td></tr></table></figure>
<p>我们可以再创建一个适配器时将一个命名的顺序容器作为第二个类型参数，来重载默认容器类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;int, vector&lt;string&gt;&gt;str_stk(sevc); &#x2F;&#x2F;str_stk在vector上实现，初始化时保存svec的拷贝</span><br></pre></td></tr></table></figure>
<p>因为所有适配器都要求容器具有添加、删除以及访问尾元素的能力，所以不能用array和forward_list来构造适配器<br>stack只要求push_back、pop_back和back操作–》使用除array和forward_list之外的任何容器类型来构造<br>queue要求back、push_back, front和push_front–》list或deque，不能用vector<br>priority_queue要求front, push_back, pop_back和随机访问能力–》vector或deque，不能用list</p>
<h3 id="栈适配器"><a href="#栈适配器" class="headerlink" title="栈适配器"></a>栈适配器</h3><p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/17%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;int&gt; intStack;</span><br><span class="line">for (size_t ix &#x3D; 0; ix &lt; 10; ++ix) </span><br><span class="line">	intStack.push(ix);</span><br><span class="line">while (!intStack.empty()) &#123;</span><br><span class="line">	int value &#x3D; intStack.top();</span><br><span class="line">	intStack.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="队列适配器"><a href="#队列适配器" class="headerlink" title="队列适配器"></a>队列适配器</h3><p><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/18%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"><br><img src="c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8_md_files/19%E6%8D%95%E8%8E%B7.PNG?v=1&type=image" alt="输入图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/30/c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/" data-id="ckhkopsd6000jesvecp814132" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-primer/" rel="tag">c++ primer</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-problem-library-哈希-02" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/12/problem-library-%E5%93%88%E5%B8%8C-02/" class="article-date">
  <time datetime="2020-08-12T03:31:29.000Z" itemprop="datePublished">2020-08-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/12/problem-library-%E5%93%88%E5%B8%8C-02/">problem library 哈希 02</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="#739.每日温度"></a>#739.每日温度</h2><p>请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p>
<p>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p>
<p>提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/daily-temperatures" target="_blank" rel="noopener">https://leetcode-cn.com/problems/daily-temperatures</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; T) &#123;</span><br><span class="line">		vector&lt;int&gt;res(T.size(), 0);</span><br><span class="line">		for (int i &#x3D; T.size() - 2; i &gt;&#x3D; 0; --i) &#123;</span><br><span class="line">			if (T[i] &lt; T[i + 1])res[i] &#x3D; 1;</span><br><span class="line">			else &#123;</span><br><span class="line">				int tmp &#x3D; i + 1 + res[i + 1];</span><br><span class="line">				if (res[i + 1] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">					res[i] &#x3D; 0;</span><br><span class="line">					continue;</span><br><span class="line">				&#125;</span><br><span class="line">				while (T[i] &gt;&#x3D; T[tmp] &amp;&amp; tmp &lt; T.size()) &#123;</span><br><span class="line">					if (res[tmp] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">					tmp +&#x3D; res[tmp];</span><br><span class="line">				&#125;</span><br><span class="line">				if (T[i] &lt; T[tmp])res[i] &#x3D; tmp - i;</span><br><span class="line">				else res[i] &#x3D; 0;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="347-前k个高频元素"><a href="#347-前k个高频元素" class="headerlink" title="#347.前k个高频元素"></a>#347.前k个高频元素</h2><p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p>
<p>示例 1:</p>
<p>输入: nums = [1,1,1,2,2,3], k = 2<br>输出: [1,2]<br>示例 2:</p>
<p>输入: nums = [1], k = 1<br>输出: [1]</p>
<p>提示：</p>
<p>你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。<br>你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。<br>题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。<br>你可以按任意顺序返回答案。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/top-k-frequent-elements" target="_blank" rel="noopener">https://leetcode-cn.com/problems/top-k-frequent-elements</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">		vector&lt;int&gt;res;</span><br><span class="line">		unordered_map&lt;int, int&gt;m;</span><br><span class="line">		for (auto i : nums)m[i]++;</span><br><span class="line">		vector&lt;pair&lt;int, int&gt;&gt;tmp;</span><br><span class="line">		for (auto it &#x3D; m.begin(); it !&#x3D; m.end(); ++it) &#123;</span><br><span class="line">			tmp.emplace_back(make_pair(it-&gt;second, it-&gt;first));</span><br><span class="line">		&#125;</span><br><span class="line">		sort(tmp.begin(), tmp.end(), compare);</span><br><span class="line">		int i &#x3D; tmp.size() - 1;</span><br><span class="line">		while (k &gt; 0) &#123;</span><br><span class="line">			res.emplace_back(tmp[i].second);</span><br><span class="line">			k--; i--;</span><br><span class="line">		&#125;</span><br><span class="line">		return res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	static bool compare(pair&lt;int, int&gt; i, pair&lt;int, int&gt; j) &#123;</span><br><span class="line">		return i.second &gt; j.second;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">		vector&lt;int&gt;res;</span><br><span class="line">		unordered_map&lt;int, int&gt;m;</span><br><span class="line">		for (auto i : nums)m[i]++;</span><br><span class="line">		vector&lt;pair&lt;int, int&gt;&gt;tmp(m.begin(), m.end());</span><br><span class="line">		sort(tmp.begin(), tmp.end(), compare);</span><br><span class="line">		for (int i &#x3D; 0; i &lt; k; ++i) &#123;</span><br><span class="line">			res.emplace_back(tmp[i].first);</span><br><span class="line">		&#125;</span><br><span class="line">		return res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="36-有效的数独"><a href="#36-有效的数独" class="headerlink" title="#36.有效的数独"></a>#36.有效的数独</h2><p>判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。</p>
<p>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">	[&quot;5&quot;, &quot;3&quot;, &quot;.&quot;, &quot;.&quot;, &quot;7&quot;, &quot;.&quot;, &quot;.&quot;, &quot;.&quot;, &quot;.&quot;],</span><br><span class="line">	[&quot;6&quot;, &quot;.&quot;, &quot;.&quot;, &quot;1&quot;, &quot;9&quot;, &quot;5&quot;, &quot;.&quot;, &quot;.&quot;, &quot;.&quot;],</span><br><span class="line">	[&quot;.&quot;, &quot;9&quot;, &quot;8&quot;, &quot;.&quot;, &quot;.&quot;, &quot;.&quot;, &quot;.&quot;, &quot;6&quot;, &quot;.&quot;],</span><br><span class="line">	[&quot;8&quot;, &quot;.&quot;, &quot;.&quot;, &quot;.&quot;, &quot;6&quot;, &quot;.&quot;, &quot;.&quot;, &quot;.&quot;, &quot;3&quot;],</span><br><span class="line">	[&quot;4&quot;, &quot;.&quot;, &quot;.&quot;, &quot;8&quot;, &quot;.&quot;, &quot;3&quot;, &quot;.&quot;, &quot;.&quot;, &quot;1&quot;],</span><br><span class="line">	[&quot;7&quot;, &quot;.&quot;, &quot;.&quot;, &quot;.&quot;, &quot;2&quot;, &quot;.&quot;, &quot;.&quot;, &quot;.&quot;, &quot;6&quot;],</span><br><span class="line">	[&quot;.&quot;, &quot;6&quot;, &quot;.&quot;, &quot;.&quot;, &quot;.&quot;, &quot;.&quot;, &quot;2&quot;, &quot;8&quot;, &quot;.&quot;],</span><br><span class="line">	[&quot;.&quot;, &quot;.&quot;, &quot;.&quot;, &quot;4&quot;, &quot;1&quot;, &quot;9&quot;, &quot;.&quot;, &quot;.&quot;, &quot;5&quot;],</span><br><span class="line">	[&quot;.&quot;, &quot;.&quot;, &quot;.&quot;, &quot;.&quot;, &quot;8&quot;, &quot;.&quot;, &quot;.&quot;, &quot;7&quot;, &quot;9&quot;]</span><br><span class="line">]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/valid-sudoku" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-sudoku</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;</span><br><span class="line">		int row[9][10] &#x3D; &#123; 0 &#125;, col[9][10] &#x3D; &#123; 0 &#125;, box[9][10] &#x3D; &#123; 0 &#125;;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; 9; ++i) &#123;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; 9; ++j) &#123;</span><br><span class="line">				if (board[i][j] &#x3D;&#x3D; &#39;.&#39;)continue;</span><br><span class="line">				int num &#x3D; board[i][j] - &#39;0&#39;;</span><br><span class="line">				if (row[i][num] + col[j][num] + box[j &#x2F; 3 + i &#x2F; 3 * 3][num] &gt; 0)return false;</span><br><span class="line">				++row[i][num]; ++col[j][num]; ++box[j &#x2F; 3 + i &#x2F; 3 * 3][num];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="560-和为k的子数组"><a href="#560-和为k的子数组" class="headerlink" title="#560.和为k的子数组"></a>#560.和为k的子数组</h2><p>给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。</p>
<p>示例 1 :</p>
<p>输入:nums = [1,1,1], k = 2<br>输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。<br>说明 :</p>
<p>数组的长度为 [1, 20,000]。<br>数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/subarray-sum-equals-k" target="_blank" rel="noopener">https://leetcode-cn.com/problems/subarray-sum-equals-k</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">		queue&lt;int&gt;tmp;</span><br><span class="line">		int sum &#x3D; 0, count &#x3D; 0;</span><br><span class="line">		for (auto i : nums) &#123;</span><br><span class="line">			tmp.push(i);</span><br><span class="line">			sum +&#x3D; i;</span><br><span class="line">			while (sum &gt; k) &#123;</span><br><span class="line">				sum -&#x3D; tmp.front();</span><br><span class="line">				tmp.pop();</span><br><span class="line">			&#125;</span><br><span class="line">			if (sum &#x3D;&#x3D; k &amp;&amp; !tmp.empty()) &#123;</span><br><span class="line">				sum -&#x3D; tmp.front();</span><br><span class="line">				tmp.pop();</span><br><span class="line">				++count;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return count;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="187-重复的DNA序列"><a href="#187-重复的DNA序列" class="headerlink" title="#187.重复的DNA序列"></a>#187.重复的DNA序列</h2><p>所有 DNA 都由一系列缩写为 A，C，G 和 T 的核苷酸组成，例如：“ACGAATTCCG”。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。</p>
<p>编写一个函数来查找目标子串，目标子串的长度为 10，且在 DNA 字符串 s 中出现次数超过一次。</p>
<p>示例：</p>
<p>输入：s = “AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT”<br>输出：[“AAAAACCCCC”, “CCCCCAAAAA”]</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/repeated-dna-sequences" target="_blank" rel="noopener">https://leetcode-cn.com/problems/repeated-dna-sequences</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	vector&lt;string&gt; findRepeatedDnaSequences(string s) &#123;</span><br><span class="line">		if (s.size() &lt; +10)return &#123;&#125;;</span><br><span class="line">		unordered_map&lt;string, int&gt;m;</span><br><span class="line">		vector&lt;string&gt;res;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; s.size() - 9; ++i) &#123;</span><br><span class="line">			string tmp(s.begin() + i, s.begin() + 10 + i);</span><br><span class="line">			if (m[tmp] &#x3D;&#x3D; 1)res.emplace_back(tmp);</span><br><span class="line">			++m[tmp];</span><br><span class="line">		&#125;</span><br><span class="line">		return res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="84-柱状图中最大矩形"><a href="#84-柱状图中最大矩形" class="headerlink" title="#84.柱状图中最大矩形"></a>#84.柱状图中最大矩形</h2><p>给定  <em>n</em>  个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<p><strong>示例:</strong></p>
<p><strong>输入:</strong> [2,1,5,6,2,3]<br><strong>输出:</strong> 10</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;</span><br><span class="line">        int sz &#x3D; heights.size(), res &#x3D; 0;</span><br><span class="line">        stack&lt;int&gt;tmp;</span><br><span class="line">        vector&lt;int&gt;left(sz), right(sz, sz);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; sz; ++i) &#123;</span><br><span class="line">            while (!tmp.empty() &amp;&amp; heights[i] &lt;&#x3D; heights[tmp.top()]) &#123;</span><br><span class="line">                right[tmp.top()] &#x3D; i;</span><br><span class="line">                tmp.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            left[i] &#x3D; tmp.empty() ? -1 : tmp.top();</span><br><span class="line">            tmp.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; sz; ++i) &#123;</span><br><span class="line">            res &#x3D; max(res, heights[i] * (right[i] - left[i] - 1));</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/12/problem-library-%E5%93%88%E5%B8%8C-02/" data-id="ckhkopsdw002nesvebz9n0dhz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/problem-library/" rel="tag">problem library</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-cocos2d-x-02-动作" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/10/cocos2d-x-02-%E5%8A%A8%E4%BD%9C/" class="article-date">
  <time datetime="2020-08-10T14:48:41.000Z" itemprop="datePublished">2020-08-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/10/cocos2d-x-02-%E5%8A%A8%E4%BD%9C/">cocos2d-x 02 动作</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">bool HelloWorld::init()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 1. super init first</span><br><span class="line">    if ( !Scene::init() )</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    auto visibleSize &#x3D; Director::getInstance()-&gt;getVisibleSize();</span><br><span class="line">    Vec2 origin &#x3D; Director::getInstance()-&gt;getVisibleOrigin();</span><br><span class="line"></span><br><span class="line">	LabelTTF* label &#x3D; LabelTTF::create(&quot;text text text&quot;, &quot;Courier&quot;, 30);</span><br><span class="line">	addChild(label);</span><br><span class="line">	label-&gt;setPosition(visibleSize.width &#x2F; 2, visibleSize.height &#x2F; 2);</span><br><span class="line"></span><br><span class="line">	auto listener &#x3D; EventListenerTouchOneByOne::create();</span><br><span class="line">	listener-&gt;onTouchBegan &#x3D; [label](Touch * t, Event * e) &#123;</span><br><span class="line">		if (label-&gt;getBoundingBox().containsPoint(t-&gt;getLocation())) &#123;</span><br><span class="line">			&#x2F;&#x2F;label-&gt;runAction(MoveTo::create(1, Point(100, 100)));</span><br><span class="line">			&#x2F;&#x2F;label-&gt;runAction(MoveBy::create(1, Point(100, 100))-&gt;reverse());</span><br><span class="line">			label-&gt;runAction(Sequence::create(</span><br><span class="line">				MoveBy::create(1, Point(50, 50)),</span><br><span class="line">				RotateBy::create(1, 360),</span><br><span class="line">				CallFunc::create([]() &#123;</span><br><span class="line">					MessageBox(&quot;Action Complete&quot;, &quot;complete&quot;);</span><br><span class="line">					&#125;), NULL));</span><br><span class="line">		&#125;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;;</span><br><span class="line">	Director::getInstance()-&gt;getEventDispatcher()-&gt;addEventListenerWithSceneGraphPriority(listener, label);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;label-&gt;runAction(Repeat::create(RotateBy::create(1, 180),3));</span><br><span class="line">	&#x2F;&#x2F;label-&gt;runAction(RepeatForever::create(RotateBy::create(1, 180)));</span><br><span class="line">	&#x2F;&#x2F;label-&gt;runAction(Spawn::create(MoveBy::create(1, Point(50, 50)), RotateBy::create(2, 360),NULL));</span><br><span class="line">	&#x2F;&#x2F;label-&gt;runAction(Sequence::create(MoveBy::create(1, Point(50, 50)), RotateBy::create(1, 360), NULL));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/10/cocos2d-x-02-%E5%8A%A8%E4%BD%9C/" data-id="ckhkopsde001besve9hfo1eqq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cocos2d-x/" rel="tag">cocos2d-x</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-cocos2d-x-01" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/10/cocos2d-x-01/" class="article-date">
  <time datetime="2020-08-10T14:47:11.000Z" itemprop="datePublished">2020-08-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/10/cocos2d-x-01/">cocos2d-x 01</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">bool HelloWorld::init()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 1. super init first</span><br><span class="line">    if ( !Scene::init() )</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;菜单</span><br><span class="line">	auto menu &#x3D; Menu::create(MenuItemImage::create(&quot;normal.png&quot;, &quot;selected.png&quot;, [](object * obj) &#123;</span><br><span class="line">		log(&quot;menu item touched&quot;);</span><br><span class="line">		&#125;), NULL);</span><br><span class="line">	addChild(menu);</span><br><span class="line">	&#x2F;&#x2F;场景切换</span><br><span class="line">	LabelTTF* label &#x3D; LabelTTF::create(&quot;show next scene&quot;, &quot;Courier&quot;, 30);</span><br><span class="line">	addChild(label);</span><br><span class="line">	label-&gt;setPosition(visibleSize.width &#x2F; 2, visibleSize.height &#x2F; 2);</span><br><span class="line">	auto listener &#x3D; EventListenerTouchOneByOne::create();</span><br><span class="line">	listener-&gt;onTouchBegan &#x3D; [label](Touch * t, Event * e) &#123;</span><br><span class="line">		if (label-&gt;getBoundingBox().containsPoint(t-&gt;getLocation())) &#123;</span><br><span class="line">			Director::getInstance()-&gt;replaceScene(Imagescene::createScene());</span><br><span class="line">		&#125;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;;</span><br><span class="line">	Director::getInstance()-&gt;getEventDispatcher()-&gt;addEventListenerWithSceneGraphPriority(listener, label);</span><br><span class="line">   </span><br><span class="line">	</span><br><span class="line">	return true; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="场景切换"><a href="#场景切换" class="headerlink" title="场景切换"></a>场景切换</h2><h3 id="ImageScene-cpp"><a href="#ImageScene-cpp" class="headerlink" title="ImageScene.cpp"></a>ImageScene.cpp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Imagescene.h&quot;</span><br><span class="line"></span><br><span class="line">Scene* Imagescene::createScene() &#123;</span><br><span class="line">	Scene* scene &#x3D; Scene::create();</span><br><span class="line">	Imagescene* layer &#x3D; Imagescene::create();</span><br><span class="line">	scene-&gt;addChild(layer);</span><br><span class="line">	return scene;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Imagescene::init() &#123;</span><br><span class="line">	auto visibleSize &#x3D; Director::getInstance()-&gt;getVisibleSize();</span><br><span class="line">	Sprite* s &#x3D; Sprite::create(&quot;HelloWorld.png&quot;);</span><br><span class="line">	s-&gt;setPosition(visibleSize.width &#x2F; 2, visibleSize.height &#x2F; 2);</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Imagescene-h"><a href="#Imagescene-h" class="headerlink" title="Imagescene.h"></a>Imagescene.h</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&quot;Imagescene.h&quot;</span><br><span class="line">#include&lt;cocos2d.h&gt;</span><br><span class="line">USING_NS_CC;</span><br><span class="line">class Imagescene:public Layer</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual bool init();</span><br><span class="line">	static Scene* createScene();</span><br><span class="line">	CREATE_FUNC(Imagescene);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/10/cocos2d-x-01/" data-id="ckhkopsdd0018esve1vvlgabt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cocos2d-x/" rel="tag">cocos2d-x</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-problem-library-哈希" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/09/problem-library-%E5%93%88%E5%B8%8C/" class="article-date">
  <time datetime="2020-08-09T12:09:23.000Z" itemprop="datePublished">2020-08-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/09/problem-library-%E5%93%88%E5%B8%8C/">problem library 哈希</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="#1.两数之和"></a>#1.两数之和</h2><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>
<p>示例:</p>
<p>给定 nums = [2, 7, 11, 15], target = 9</p>
<p>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/two-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        map&lt;int, int&gt;m;</span><br><span class="line">        vector&lt;int&gt;v;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; nums.size(); ++i)m.insert(map&lt;int, int&gt;::value_type(nums[i], i));</span><br><span class="line">        for (int i &#x3D; 0; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            if (m.count(target - nums[i]) &gt; 0 &amp;&amp; m[target - nums[i]] !&#x3D; i) &#123;</span><br><span class="line">                v.emplace_back(i);</span><br><span class="line">                v.emplace_back(m[target - nums[i]]);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="#136.只出现一次的数字"></a>#136.只出现一次的数字</h2><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p>说明：</p>
<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<p>示例 1:</p>
<p>输入: [2,2,1]<br>输出: 1<br>示例 2:</p>
<p>输入: [4,1,2,1,2]<br>输出: 4</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/single-number" target="_blank" rel="noopener">https://leetcode-cn.com/problems/single-number</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        map&lt;int, int&gt;m;</span><br><span class="line">        for (auto i : nums)m[i]++;</span><br><span class="line">        for (auto it &#x3D; m.begin(); it !&#x3D; m.end(); ++it) &#123;</span><br><span class="line">            if (it-&gt;second &#x3D;&#x3D; 1)return it-&gt;first;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int res &#x3D; 0;</span><br><span class="line">        for (auto i : nums)res ^&#x3D; i;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="#202.快乐数"></a>#202.快乐数</h2><p>编写一个算法来判断一个数 n 是不是快乐数。</p>
<p>「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。</p>
<p>如果 n 是快乐数就返回 True ；不是，则返回 False 。</p>
<p>示例：</p>
<p>输入：19<br>输出：true<br>解释：<br>12 + 92 = 82<br>82 + 22 = 68<br>62 + 82 = 100<br>12 + 02 + 02 = 1</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/happy-number" target="_blank" rel="noopener">https://leetcode-cn.com/problems/happy-number</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="哈希-1"><a href="#哈希-1" class="headerlink" title="哈希"></a>哈希</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int getN(int n) &#123;</span><br><span class="line">        int res &#x3D; 0;</span><br><span class="line">        while (n) &#123;</span><br><span class="line">            int a &#x3D; n % 10;</span><br><span class="line">            n &#x3D; n &#x2F; 10;</span><br><span class="line">            res +&#x3D; a * a;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    bool isHappy(int n) &#123;</span><br><span class="line">        unordered_map&lt;int, bool&gt;m;</span><br><span class="line">        while (n !&#x3D; 1) &#123;</span><br><span class="line">            n &#x3D; getN(n);</span><br><span class="line">            if (m[n] &#x3D;&#x3D; true)return false;</span><br><span class="line">            m[n] &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="快慢针"><a href="#快慢针" class="headerlink" title="快慢针"></a>快慢针</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int getN(int n) &#123;</span><br><span class="line">        int res &#x3D; 0;</span><br><span class="line">        while (n) &#123;</span><br><span class="line">            int a &#x3D; n % 10;</span><br><span class="line">            n &#x3D; n &#x2F; 10;</span><br><span class="line">            res +&#x3D; a * a;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    bool isHappy(int n) &#123;</span><br><span class="line">        int i &#x3D; n, j &#x3D; getN(n);</span><br><span class="line">        while (i !&#x3D; j) &#123;</span><br><span class="line">            i &#x3D; getN(i);</span><br><span class="line">            j &#x3D; getN(getN(j));</span><br><span class="line">        &#125;</span><br><span class="line">        return i &#x3D;&#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="219-存在重复的元素II"><a href="#219-存在重复的元素II" class="headerlink" title="#219.存在重复的元素II"></a>#219.存在重复的元素II</h2><p>给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的 绝对值 至多为 k。</p>
<p>示例 1:</p>
<p>输入: nums = [1,2,3,1], k = 3<br>输出: true<br>示例 2:</p>
<p>输入: nums = [1,0,1,1], k = 1<br>输出: true<br>示例 3:</p>
<p>输入: nums = [1,2,3,1,2,3], k = 2<br>输出: false</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/contains-duplicate-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/contains-duplicate-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        unordered_set&lt;int&gt;tmp;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            if (tmp.find(nums[i]) !&#x3D; tmp.end())return true;</span><br><span class="line">            tmp.emplace(nums[i]);</span><br><span class="line">            if (tmp.size() &gt; k)tmp.erase(nums[i - k]);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="217-存在重复元素"><a href="#217-存在重复元素" class="headerlink" title="#217.存在重复元素"></a>#217.存在重复元素</h2><p>给定一个整数数组，判断是否存在重复元素。</p>
<p>如果任意一值在数组中出现至少两次，函数返回  <code>true</code>  。如果数组中每个元素都不相同，则返回  <code>false</code>  。</p>
<p><strong>示例 1:</strong></p>
<p><strong>输入:</strong> [1,2,3,1]<br><strong>输出:</strong> true</p>
<p><strong>示例 2:</strong></p>
<p><strong>输入:</strong> [1,2,3,4]<br><strong>输出:</strong> false</p>
<p><strong>示例 3:</strong></p>
<p><strong>输入:</strong> [1,1,1,3,3,4,3,2,4,2]<br><strong>输出:</strong> true</p>
<h3 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        unordered_set&lt;int&gt;tmp;</span><br><span class="line">        for (auto i : nums) &#123;</span><br><span class="line">            if (tmp.find(i) !&#x3D; tmp.end())return true;</span><br><span class="line">            tmp.emplace(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        unordered_map&lt;int, int&gt;m;</span><br><span class="line">        for (auto i : nums) &#123;</span><br><span class="line">            m[i]++;</span><br><span class="line">            if (m[i] &gt; 1)return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="#349.两个数组的交集"></a>#349.两个数组的交集</h2><p>给定两个数组，编写一个函数来计算它们的交集。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong>nums1 = [1,2,2,1], nums2 = [2,2]<br><strong>输出：</strong>[2]</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>nums1 = [4,9,5], nums2 = [9,4,9,8,4]<br><strong>输出：</strong>[9,4]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">        unordered_set&lt;int&gt;res1, num11(nums1.begin(), nums1.end());</span><br><span class="line">        for (auto i : nums2) &#123;</span><br><span class="line">            if (num11.find(i) !&#x3D; num11.end())res1.emplace(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return vector&lt;int&gt;(res1.begin(), res1.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="#242.有效的字母异位词"></a>#242.有效的字母异位词</h2><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p>
<p>示例 1:</p>
<p>输入: s = “anagram”, t = “nagaram”<br>输出: true<br>示例 2:</p>
<p>输入: s = “rat”, t = “car”<br>输出: false<br>说明:<br>你可以假设字符串只包含小写字母。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/valid-anagram" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-anagram</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isAnagram(string s, string t) &#123;</span><br><span class="line">        if (s.size() !&#x3D; t.size())return false;</span><br><span class="line">        int words[26] &#x3D; &#123;&#125;;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            ++words[s[i] - &#39;a&#39;];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; t.size(); ++j) &#123;</span><br><span class="line">            if (--words[t[j] - &#39;a&#39;] &lt; 0)return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/09/problem-library-%E5%93%88%E5%B8%8C/" data-id="ckhkopsdu002kesvehn1ff3t0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/problem-library/" rel="tag">problem library</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-problem-library-链表" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/08/problem-library-%E9%93%BE%E8%A1%A8/" class="article-date">
  <time datetime="2020-08-08T15:13:57.000Z" itemprop="datePublished">2020-08-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/08/problem-library-%E9%93%BE%E8%A1%A8/">problem library 链表</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="#21.合并两个有序链表"></a>#21.合并两个有序链表</h2><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<p>示例：</p>
<p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-two-sorted-lists</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">        ListNode* prehead &#x3D; new ListNode(-1);</span><br><span class="line">        ListNode* pre &#x3D; prehead;</span><br><span class="line">        while (l1 !&#x3D; nullptr &amp;&amp; l2 !&#x3D; nullptr) &#123;</span><br><span class="line">            if (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                pre-&gt;next &#x3D; l1;</span><br><span class="line">                l1 &#x3D; l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                pre-&gt;next &#x3D; l2;</span><br><span class="line">                l2 &#x3D; l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre &#x3D; pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre-&gt;next &#x3D; l1 &#x3D;&#x3D; nullptr ? l2 : l1;</span><br><span class="line">        return prehead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="206-翻转链表"><a href="#206-翻转链表" class="headerlink" title="#206.翻转链表"></a>#206.翻转链表</h2><p>反转一个单链表。</p>
<p><strong>示例:</strong></p>
<p><strong>输入:</strong> 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br><strong>输出:</strong> 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p>
<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">        ListNode* pre &#x3D; nullptr;</span><br><span class="line">        ListNode* curr &#x3D; head;</span><br><span class="line">        while (curr !&#x3D; nullptr) &#123;</span><br><span class="line">            ListNode* tmp &#x3D; curr-&gt;next;</span><br><span class="line">            curr-&gt;next &#x3D; pre;</span><br><span class="line">            pre &#x3D; curr;</span><br><span class="line">            curr &#x3D; tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        return pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">        if (head &#x3D;&#x3D; nullptr || head-&gt;next &#x3D;&#x3D; nullptr)return head;</span><br><span class="line">        ListNode* res &#x3D; reverseList(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next &#x3D; head;</span><br><span class="line">        head-&gt;next &#x3D; nullptr;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="#141.环形链表"></a>#141.环形链表</h2><p>给定一个链表，判断链表中是否有环。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>
<p>示例 1：</p>
<p>输入：head = [3,2,0,-4], pos = 1<br>输出：true<br>解释：链表中有一个环，其尾部连接到第二个节点。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/linked-list-cycle" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-cycle</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool hasCycle(ListNode* head) &#123;</span><br><span class="line">        if (head &#x3D;&#x3D; nullptr || head-&gt;next &#x3D;&#x3D; nullptr)return false;</span><br><span class="line">        ListNode* slow &#x3D; head;</span><br><span class="line">        ListNode* fast &#x3D; head-&gt;next;</span><br><span class="line">        while (slow !&#x3D; fast) &#123;</span><br><span class="line">            if (fast &#x3D;&#x3D; nullptr || fast-&gt;next &#x3D;&#x3D; nullptr || fast-&gt;next-&gt;next &#x3D;&#x3D; nullptr)return false;</span><br><span class="line">            slow &#x3D; slow-&gt;next;</span><br><span class="line">            fast &#x3D; fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="#234.回文链表"></a>#234.回文链表</h2><p>请判断一个链表是否为回文链表。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: 1-&gt;2
输出: false</code></pre><p><strong>示例 2:</strong></p>
<pre><code>输入: 1-&gt;2-&gt;2-&gt;1
输出: true</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isPalindrome(ListNode* head) &#123;</span><br><span class="line">        if (head &#x3D;&#x3D; nullptr)return true;</span><br><span class="line">        ListNode* slow &#x3D; head;</span><br><span class="line">        ListNode* fast &#x3D; head-&gt;next;</span><br><span class="line">        while (fast !&#x3D; nullptr &amp;&amp; fast-&gt;next !&#x3D; nullptr) &#123;</span><br><span class="line">            slow &#x3D; slow-&gt;next;</span><br><span class="line">            fast &#x3D; fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* secondHalf &#x3D; nullptr;</span><br><span class="line">        ListNode* cur &#x3D; slow-&gt;next;</span><br><span class="line">        while (cur !&#x3D; nullptr) &#123;</span><br><span class="line">            ListNode* tmp &#x3D; cur-&gt;next;</span><br><span class="line">            cur-&gt;next &#x3D; secondHalf;</span><br><span class="line">            secondHalf &#x3D; cur;</span><br><span class="line">            cur &#x3D; tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        while (secondHalf !&#x3D; nullptr) &#123;</span><br><span class="line">            if (secondHalf-&gt;val !&#x3D; head-&gt;val)return false;</span><br><span class="line">            secondHalf &#x3D; secondHalf-&gt;next;</span><br><span class="line">            head &#x3D; head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="106-相交链表"><a href="#106-相交链表" class="headerlink" title="#106.相交链表"></a>#106.相交链表</h2><p>编写一个程序，找到两个单链表相交的起始节点。</p>
<p>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3<br>输出：Reference of the node with value = 8<br>输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists" target="_blank" rel="noopener">https://leetcode-cn.com/problems/intersection-of-two-linked-lists</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) &#123;</span><br><span class="line">        for (auto i &#x3D; headA; i !&#x3D; nullptr; i &#x3D; i-&gt;next) &#123;</span><br><span class="line">            for (auto j &#x3D; headB; j !&#x3D; nullptr; j &#x3D; j-&gt;next) &#123;</span><br><span class="line">                if (i &#x3D;&#x3D; j)return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) &#123;</span><br><span class="line">        ListNode* pA &#x3D; headA;</span><br><span class="line">        ListNode* pB &#x3D; headB;</span><br><span class="line">        while (pA !&#x3D; pB) &#123;</span><br><span class="line">            pA &#x3D; pA &#x3D;&#x3D; nullptr ? headB : pA-&gt;next;</span><br><span class="line">            pB &#x3D; pB &#x3D;&#x3D; nullptr ? headA : pB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return pA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="#203.移除链表元素"></a>#203.移除链表元素</h2><p>删除链表中等于给定值 <strong><em>val</em></strong> 的所有节点。</p>
<p><strong>示例:</strong></p>
<p><strong>输入:</strong> 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, <em><strong>val</strong></em> = 6<br><strong>输出:</strong> 1-&gt;2-&gt;3-&gt;4-&gt;5</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* removeElements(ListNode* head, int val) &#123;</span><br><span class="line">        ListNode* temp &#x3D; new ListNode(0);</span><br><span class="line">        temp-&gt;next &#x3D; head;</span><br><span class="line">        ListNode* prev &#x3D; temp, * cur &#x3D; head, * toDelete &#x3D; nullptr;</span><br><span class="line">        while (cur !&#x3D; nullptr) &#123;</span><br><span class="line">            if (cur-&gt;val &#x3D;&#x3D; val) &#123;</span><br><span class="line">                prev-&gt;next &#x3D; cur-&gt;next;</span><br><span class="line">                toDelete &#x3D; cur;</span><br><span class="line">            &#125;</span><br><span class="line">            else prev &#x3D; cur;</span><br><span class="line">            cur &#x3D; cur-&gt;next;</span><br><span class="line">            if (toDelete !&#x3D; nullptr) &#123;</span><br><span class="line">                delete toDelete;</span><br><span class="line">                toDelete &#x3D; nullptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* res &#x3D; temp-&gt;next;</span><br><span class="line">        delete temp;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="#2.两数相加"></a>#2.两数相加</h2><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p>示例：</p>
<p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/add-two-numbers" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-two-numbers</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">        int add &#x3D; 0;</span><br><span class="line">        ListNode* res &#x3D; new ListNode(0), * tmp &#x3D; res, * p1 &#x3D; l1, * p2 &#x3D; l2;</span><br><span class="line">        while (p1 !&#x3D; nullptr || p2 !&#x3D; nullptr) &#123;</span><br><span class="line">            int x &#x3D; p1 &#x3D;&#x3D; nullptr ? 0 : p1-&gt;val;</span><br><span class="line">            int y &#x3D; p2 &#x3D;&#x3D; nullptr ? 0 : p2-&gt;val;</span><br><span class="line">            int val &#x3D; x + y + add;</span><br><span class="line">            add &#x3D; val &#x2F; 10;</span><br><span class="line">            val %&#x3D; 10;</span><br><span class="line">            tmp-&gt;next &#x3D; new ListNode(val);</span><br><span class="line">            tmp &#x3D; tmp-&gt;next;</span><br><span class="line">            if (p1 !&#x3D; nullptr)p1 &#x3D; p1-&gt;next;</span><br><span class="line">            if (p2 !&#x3D; nullptr)p2 &#x3D; p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if (add !&#x3D; 0)tmp-&gt;next &#x3D; new ListNode(add);</span><br><span class="line">        return res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="#148.排序链表"></a>#148.排序链表</h2><p>在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。</p>
<p>示例 1:</p>
<p>输入: 4-&gt;2-&gt;1-&gt;3<br>输出: 1-&gt;2-&gt;3-&gt;4<br>示例 2:</p>
<p>输入: -1-&gt;5-&gt;3-&gt;4-&gt;0<br>输出: -1-&gt;0-&gt;3-&gt;4-&gt;5</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/sort-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sort-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* sortList(ListNode* head) &#123;</span><br><span class="line">        if (head &#x3D;&#x3D; nullptr || head-&gt;next &#x3D;&#x3D; nullptr)return head;</span><br><span class="line">        ListNode* slow &#x3D; head, * fast &#x3D; head-&gt;next;</span><br><span class="line">        while (fast !&#x3D; nullptr &amp;&amp; fast-&gt;next !&#x3D; nullptr) &#123;</span><br><span class="line">            fast &#x3D; fast-&gt;next-&gt;next;</span><br><span class="line">            slow &#x3D; slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* tmp &#x3D; slow-&gt;next;</span><br><span class="line">        slow-&gt;next &#x3D; nullptr;</span><br><span class="line">        ListNode* left &#x3D; sortList(head), * right &#x3D; sortList(tmp);</span><br><span class="line">        ListNode* res &#x3D; new ListNode(0), * h &#x3D; res;</span><br><span class="line">        while (left !&#x3D; nullptr &amp;&amp; right !&#x3D; nullptr) &#123;</span><br><span class="line">            if (left-&gt;val &lt; right-&gt;val) &#123;</span><br><span class="line">                h-&gt;next &#x3D; left;</span><br><span class="line">                left &#x3D; left-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                h-&gt;next &#x3D; right;</span><br><span class="line">                right &#x3D; right-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            h &#x3D; h-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        h-&gt;next &#x3D; left &#x3D;&#x3D; nullptr ? right : left;</span><br><span class="line">        return res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/08/problem-library-%E9%93%BE%E8%A1%A8/" data-id="ckhkopse1002wesvefcvs2k2x" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/problem-library/" rel="tag">problem library</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-c-primer-04-表达式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/06/c-primer-04-%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="article-date">
  <time datetime="2020-08-06T15:09:11.000Z" itemprop="datePublished">2020-08-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/06/c-primer-04-%E8%A1%A8%E8%BE%BE%E5%BC%8F/">c++ primer 04 表达式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h1><p>表达式由一个或多个运算对象(operand)组成，对表达式求值将得到一个结果(result)。<br>右值(rvalue) :对象的值(内容)  左值(lvalue) : 对象的身份(在内存中的位置)<br>取余：(m / n)* n + m % n = m m % n符号和m相同 m % (-n) = m % n(-m) % n = -m % n<br>逻辑运算符与、或：当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值，短路求值(short_circuit evaluation)<br>if (i &lt; j &lt; k)k &gt; 1时为真(i &lt; j &amp;&amp; 1 &lt; k)<br>int k = 0; k = 3.14; (可以)k = { 3.14 }(不可以)k = { 3 }(可以)<br>多重赋值语句中的每一个对象，它的类型与右边对象相同或者可由右边对象的类型转换得到<br>int ival, <em>pval;ival=pval=0(错误，不能把指针的值赋值给int)<br>递增、递减运算符，后置版本储存了原值的副本，可能是一种浪费，尽量使用前置版本<br>*pbeg++:先进行递增，但返回初始值，所以解引用初始值，再将指针指向下一个<br>条件运算符 A?B:C?D:E–&gt;A?B:(C?D:E)<br>cou&lt;&lt;(A&gt;B)?C:D 输出0或者1   cout&lt;<A>B?C:D 错误，试图比较cout和B<br>位异或运算符(^)两个运算对象对应的位置有且只有一个为1,则结果中该位置为1，否则为0<br>运算对象分别为无符号和带符号类型：无符号不小于带符号-&gt;转换成无符号，反之转换成带符号<br>显示转换：<br>任何具有明确定义的类型转换，只要不包含底层constraint，都可以使用static_cast<br>double slope=static_cast<double>(i)/j<br>const_cast只能改变运算对象的底层const<br>const char</em> pc; char* p = const_cast&lt;char*&gt;(pc);<br>只有const_cast能改变表达式的常量属性<br>reinterpret_cast通常为运算对象的位模式提供较低层次上的重新解释</p>
<h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p>复合语句(compound statement)也被称作块(block)。一个块就是一个作用域，在块中引入的名字只能在块内部以及嵌套在块中的子块里访问</p>
<p>switch语句的case标签(case lable)必须是整型常量表达式<br>switch (ch) { case ‘a’:++acnt; case ‘e’:++ecnt; case ‘i’:++icnt; }ch==e的时候会执行++ecnt及之后的++icnt。需要break<br>若没有case匹配，执行default  标签后面必须跟上一条语句或者另一个标签<br>若某处一个带有初值的变量位于作用域之外，在另一处该变量位于作用域之内，则从前一处跳转到后一处的行为是非法行为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">	<span class="built_in">string</span> file_name; <span class="comment">//错误：控制流绕过一个隐式初始化的变量</span></span><br><span class="line">	<span class="keyword">int</span> jval = <span class="number">0</span>; <span class="comment">//错误：控制流绕过一个显式初始化的变量</span></span><br><span class="line">	<span class="keyword">int</span> jval; <span class="comment">//正确：jval没有初始化</span></span><br><span class="line"><span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">	jval = next_num; <span class="comment">//正确</span></span><br><span class="line">	<span class="keyword">if</span>(file_name.empty())<span class="comment">/**/</span></span><br></pre></td></tr></table></figure>
<p>使用while循环：不确定要迭代多少次、想在循环结束后访问循环控制变量</p>
<p>for语句头中init-statement只能有一条声明语句，因此所有变量的基础类型必须相同</p>
<p>范围for语句：若需要对序列中的元素执行写操作，循环变量必须声明成引用类型<br>不能通过范围for语句增加容器的元素</p>
<p>do while语句不允许在条件部分定义变量</p>
<p>continue：对于传统的for循环，继续执行for语句头的expression；对于范围for语句，用序列中的下一个元素初始化循环控制变量</p>
<p>go to语句(go lable;)goto语句和控制权转向的那条带标签的语句必须位于同一个函数之内</p>
<p>try语句块和异常处理</p>
<p>throw表达式(throw expression)异常检测部分使用throw表达式来表示它遇到了无法处理的问题。我们说throw引发(raise)了异常<br>throw表达式包含关键字throw和紧随其后的一个表达式，表达式的类型就是抛出的异常类型<br>throw runtime_error(“Data must refer to same ISBN”);</p>
<p>try语句块(try block)异常处理部分使用try语句块处理异常。以关键字try开始，并以一个或多个catch子句(catch clause)结束<br>catch子句包括：关键字catch、括号内一个(可能未命名的)对象的声明(异常声明,exception declaration)以及一个块。当选中了某个catch子句处理异常之后，执行与之对应的块。完成后跳转到try语句块最后一个catch子句之后的那条语句继续执行<br>没找到匹配的catch子句，程序转到名为terminate的标准函数库</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	program - staments</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (exception - declaration) &#123;</span><br><span class="line">	handler - staments</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; item1 &gt;&gt; item2) &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//执行添加两个Sales_item对象的代码，如果添加失败，代码抛出一个runtime_error异常</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (runtime_error) &#123;</span><br><span class="line">		<span class="comment">//提醒用户两个ISBN必须一致，询问是否重新输入</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; err.what() &lt;&lt; <span class="string">"\nTry Again?"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">char</span> c;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">cin</span> || c == <span class="string">'n'</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>调用函数时，传入的可以是能转换成的实参(int类型可以传入3.14)<br>形参列表可以为空()/(void)不能省略<br>函数的返回值类型不能是数组类型和函数类型，但可以是指向数组或函数的指针<br>把只存在于块执行期间的对象称为自动对象(automatic object)<br>局部静态对象(local static object)可将局部变量定义成static类型从而令局部变量的生命周期贯穿函数调用及之后的时间<br>内置类型的局部静态变量初始化为0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">size_t count_calls() &#123;</span><br><span class="line">	static size_t ctr &#x3D; 0;</span><br><span class="line">	return ++ctr;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	for (size_t i &#x3D; 0; i !&#x3D; 10; i++)</span><br><span class="line">		cout &lt;&lt; count_calls() &lt;&lt; endl;</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>指针形参：当执行指针拷贝操作时，拷贝的是指针的值。拷贝之后两个指针是不同的指针。因为指针使我们可以间接地访问它所指的对象，所以通过指针可以修改它所指对象的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void reset(int* p) &#123;</span><br><span class="line">	*p &#x3D; 0; &#x2F;&#x2F;改变指针p所指对象的值</span><br><span class="line">	p &#x3D; 0; &#x2F;&#x2F;只改变了p的局部拷贝，实参未被改变</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传引用参数可以避免拷贝<br>通常一个函数只能返回一个值，使用引用形参可返回额外信息<br>当用实参初始化形参时会忽略掉顶层const，当形参有顶层const时，传给它常量对象或非常量对象都是可以的<br>void fcn(const int i) {} 和 void fcn(int i) {} 不能同时存在，两个形参是相同的<br>尽量使用常量引用，非常量引用会限制函数所能结束的实参类型。不能把const对象、字面值或者需要类型转换的对象传递给普通的引用形参</p>
<p>不允许拷贝数组、使用数组时(通常)会将其转换成指针<br>void t01(const int* / const int[] / const int[10])<br>三个等价，每一个都有const int* 类型的形参<br>给函数传递一个数组时，实参自动地转换成指向数组首元素的指针，数组的大小对函数的调用没有影响<br>使用标记指定数组长度：要求数组本身包含一个结束标记(c风格字符串)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void print(const char* cp) &#123;</span><br><span class="line">	if (cp) &#x2F;&#x2F;若cp不是一个空指针</span><br><span class="line">		while (cp) &#x2F;&#x2F;只要指针所指的字符不是空字符</span><br><span class="line">			cout &lt;&lt; *cp++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用标准款规范：传递指向数组首元素和尾后元素的指针</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int j[2] &#x3D; &#123; 2,3 &#125;</span><br><span class="line">print(begin(j), end(j));</span><br><span class="line">void print(const int* beg, const int* end) &#123;</span><br><span class="line">	while (beg !&#x3D; end)cout &lt;&lt; *beg++ &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显式传递一个表示数组大小的形参：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int j[] &#x3D; &#123; 2,3 &#125;;</span><br><span class="line">print(j, end(j) - begin(j));</span><br><span class="line">void print(const int ia[], size_t size) &#123;</span><br><span class="line">	for (size_t i &#x3D; 0; i &lt; size; i++)cout &lt;&lt; ia[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(int&amp; arr[10])引用的数组 f(int(&amp;arr)[10])数组的引用</span><br><span class="line">int i &#x3D; 0, j[2] &#x3D; &#123; 2,3 &#125;, k[] &#x3D; &#123; 0,1,2,3,4,5,6,7,8,9 &#125;;</span><br><span class="line">print(&amp;i); &#x2F;&#x2F;错误：实参不是含有10个整数的数组</span><br><span class="line">print(j); &#x2F;&#x2F;错误</span><br><span class="line">print(k); &#x2F;&#x2F;正确</span><br></pre></td></tr></table></figure>
<p>含有可变形参的函数：无法提前预知应该想函数传递几个参数<br>所有的实参类型相同，可以传递initializer_list标准库类型；实参类型不同，可以编写可变参数模板</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">initializer_list&lt;T&gt;lst;</span><br><span class="line">initializer_list&lt;T&gt;lst&#123; a,b,c &#125;;</span><br><span class="line">lst2(lst);</span><br><span class="line">lst2 &#x3D; lst;</span><br><span class="line">lst.size(); lst.begin(); lst.end();</span><br><span class="line">void error_msg(initializer_list&lt;string&gt; il) &#123;</span><br><span class="line">	for (auto beg &#x3D; il.begin(); beg !&#x3D; il.end(); ++beg)</span><br><span class="line">		cout &lt;&lt; *beg &lt;&lt; &quot; &quot;;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">省略符形参：void foo(parm_list, ...) &#x2F; (...)</span><br></pre></td></tr></table></figure>
<p>没有返回值的return语句只能用在返回值类型是void的函数中，返回void的函数不要求非得有return语句，会隐式执行<br>不能返回局部变量的引用或指针。函数完成后会被释放掉</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const string &amp; manip() &#123;</span><br><span class="line">	string ret;</span><br><span class="line">	if (!ret.empty())return ret; &#x2F;&#x2F;错误：返回局部对象的引用</span><br><span class="line">	else return &quot;Empty&quot;; &#x2F;&#x2F;错误：&quot;Empty&quot;是一个局部临时变量</span><br><span class="line">&#125;</span><br><span class="line">主函数main允许没有return语句，编译器将隐式地插入一条返回0的return语句</span><br><span class="line">一个函数调用了它本身，称为递归函数(recursive function)</span><br><span class="line">int factorial(int val) &#123;</span><br><span class="line">	if (val &gt; 1)return factorial(val - 1) * val;</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回数组指针：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef int arr[10]; &#x2F;&#x2F;arr是一个类型别名，表示的类型是含有10个整数的数组</span><br><span class="line">using arr&#x3D;int[10]; &#x2F;&#x2F;arr的等价声明</span><br><span class="line">arr* func(int i) &#123;&#125; &#x2F;&#x2F;func发返回一个指向含有10个整数的数组指针</span><br><span class="line">Type(*function(parameter_list))[dimension]  int(*func(int i))[10];</span><br></pre></td></tr></table></figure>
<p>使用尾置返回类型：auto function(int i)-&gt;int(*)[10];<br>若知道函数返回的指针将指向哪个数组，可以使用decltype关键字声明返回类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int odd[] &#x3D; &#123; 1,3,5 &#125;, even[] &#x3D; &#123; 2,4,6 &#125;;</span><br><span class="line">decltype(odd)* arrPtr(int i) &#123; return (1 % 2) ? &amp;odd : &amp;even; &#125;</span><br></pre></td></tr></table></figure>
<p>arrPtr使用关键字decltype表示它的返回类型是个指针，且该指针所指的对象与odd的类型一致</p>
<p>顶层const不影响传入的对象：Record lookup(Phone) / (const Phone)和(Phone<em>) / (Phone * const)是重复声明<br>如果形参是某种类型的指针或引用，通过区分是否常量可以实现函数重载，此时const是底层的<br>Record lookup(Account&amp;) / (const Account&amp;)和(Account</em>) / (const Account*)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const_cast：</span><br><span class="line">const string &amp; shorterString(const string &amp; s1, const string &amp; s2) &#123;</span><br><span class="line">	return s1.size() &lt; s2.size() ? s1 : s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string&amp; shorterString(string s1, string s2) &#123;</span><br><span class="line">	auto&amp; r &#x3D; shorterString(const_cast&lt;const string&amp;&gt;s1 : const_cast&lt;const string&amp;&gt;s2;);</span><br><span class="line">	return const_cast&lt;string&amp;&gt;(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先将它的实参强制转换成对const的引用，然后调用了shorterString函数的const版本。const版本返回对const string的引用，这个引用绑定在某个初始的非常量实参上</p>
<p>重载与作用域</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">string read();</span><br><span class="line">void print(const string&amp;);</span><br><span class="line">void print(double);</span><br><span class="line">void fooBar(int ival) &#123;</span><br><span class="line">	bool read &#x3D; false; &#x2F;&#x2F;新作用域，隐藏了外层的read</span><br><span class="line">	string s &#x3D; read; &#x2F;&#x2F;错误：read是bool值，而非函数</span><br><span class="line">	void print(int); &#x2F;&#x2F;新作用域：隐藏了之前的print</span><br><span class="line">	print(&quot;Value&quot;); &#x2F;&#x2F;错误：print(const string&amp;)被隐藏掉了</span><br><span class="line">	print(ival); &#x2F;&#x2F;正确：当前print(int)可见</span><br><span class="line">	print(3.14); &#x2F;&#x2F;正确：调用print(int);print(double)被隐藏掉</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认实参<br>默认实参作为形参的初始值出现在形参列表中，可以为一个或多个形参定义默认值。一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">typedef string::size_type sz;</span><br><span class="line">string screen(sz ht &#x3D; 24, sz wid &#x3D; 80, char backgrnd &#x3D; &#39; &#39;);</span><br><span class="line">string window;</span><br><span class="line">window &#x3D; screen(); &#x2F;&#x2F;screen(24,80,&#39; &#39;)</span><br><span class="line">window &#x3D; screen(66); &#x2F;&#x2F;screen(66,80,&#39; &#39;)</span><br><span class="line">window &#x3D; screen(66, 256); &#x2F;&#x2F;screen(66,256,&#39; &#39;)</span><br><span class="line">window &#x3D; screen(66, 256, &#39;#&#39;); &#x2F;&#x2F;screen(66,256,&#39;#&#39;)</span><br><span class="line">window &#x3D; screen(, , &#39;?&#39;); &#x2F;&#x2F;错误：只能省略尾部实参</span><br><span class="line">window &#x3D; screen(&#39;?&#39;) &#x2F;&#x2F;screen(&#39;?&#39;,80,&#39; &#39;)</span><br><span class="line">在给定的作用域中一个形参只能被赋予一次默认实参</span><br><span class="line">string screen(sz, sz, char &#x3D; &#39; &#39;);</span><br><span class="line">string screen(sc, sc, char&#x3D;&#39;*&#39;); &#x2F;&#x2F;错误：重复声明</span><br><span class="line">string screen(sc &#x3D; 24, sc &#x3D; 80, char); &#x2F;&#x2F;正确：添加默认实参</span><br><span class="line">局部变量不能作为默认实参，能转换成形参所需的类型的表达式可以作为默认实参。</span><br><span class="line">sz wd &#x3D; 80; char def &#x3D; &#39; &#39;; sz ht();</span><br><span class="line">string screen(sz &#x3D; ht(), sz &#x3D; wd, char &#x3D; def);</span><br><span class="line">string window &#x3D; screen(); &#x2F;&#x2F;调用screen(ht(),80,&#39; &#39;)</span><br><span class="line">void f2() &#123;</span><br><span class="line">	def &#x3D; &#39;*&#39;; &#x2F;&#x2F;改变默认参数的值</span><br><span class="line">	sz wd &#x3D; 80; &#x2F;&#x2F;隐藏了外层定义的wd，但没有改变默认值</span><br><span class="line">	window &#x3D; screen(); &#x2F;&#x2F;调用screen(ht(),80,&#39;*&#39;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内联函数(inline)可以避免函数调用的开销<br>inline const string&amp; shorterString(const string&amp; s1, const string&amp; s2) {<br>    return s1.size() &lt;= s2.size() ? s1 : s2;<br>}<br>内联机制用于优化规模较小、流程直接、频繁调用的函数。很多编译器不支持内联递归函数</p>
<p>constexpr函数(constexpr function)是指能用于常量表达式的函数。函数的返回类型及所有形参的类型都得是字面值类型，且函数体中必须有且仅有一条return语句<br>constexpr int new_sz() { return 42 };<br>constexpr int foo = new_sz();<br>constexpr函数体内也可以包含其他语句，只要在运行时不执行任何操作。如空语句、类型别名以及using声明<br>允许constexpr函数返回值并非一个常量<br>对于某个给定的内联函数或者constexpr函数，它的多个定义必须完全一致。所以通常定义在头文件中</p>
<p>调试帮助<br>assert预处理宏(preprocessor marco)  assert(expr)若expr表达式为假，assert输出信息并终止程序执行；为真则什么也不做<br>NDEBUG预处理变量：如果定义了NDEBUG，则assert什么也不做。默认状态下没有定义NDEBUG，此时assert将执行运行时检查<br><strong>func</strong> 存放函数的名字 <strong>FILE</strong> 存放文件名的字符串字面值 <strong>LINE</strong> 存放当前行号的整型字面值<br><strong>TIME</strong> 存放文件编译时间的字符串字面值 <strong>DATE</strong> 存放文件编译日期的字符串字面值</p>
<p>函数匹配<br>void f(); void f(int); void f(int, int); void f(double, double = 3.14);<br>f(5.6); //调用f(double,double=3.14)<br>如果有且只有一个函数满足下列条件，则匹配成功：<br>该函数每个实参的匹配都不劣于其他可行函数需要的匹配<br>至少有一个实参的匹配优于其他可行函数提供的匹配<br>类型转换：<br>精确匹配：类型相同；实参从数组或函数类型转换成对应的指针类型；向实参添加顶层const或从实参删除顶层const<br>通过const转换实现的匹配<br>通过类型提升实现的匹配<br>通过算术类型转换实现的匹配<br>通过类类型转换实现的匹配</p>
<p>函数指针指向的是函数而非对象。函数的类型由它的返回类型和形参类型共同决定，与函数名无关<br>bool lengthCompare(const string&amp;, const string&amp;);<br>bool (<em>pf)(const string&amp;, const string&amp;); 未初始化。 pf指向一个函数，该函数的参数是两个const string的引用，返回值是bool类型<br>bool</em> pf(const string&amp;, const string&amp;); pf是一个返回值为bool指针的函数<br>把函数名作为一个值使用时，该函数自动地转换成指针<br>pf = lengthCompare或者pf = &amp;lengthCompare 两个等价，取地址符可选<br>可以直接使用指向函数的指针调用该函数，无需提前解引用指针<br>bool b1 = pf(“hello”, “goodbye”);<br>bool b2 = (*pf)(“hello”, “goodbye”);<br>bool b3 = lengthCompare(“hello”, “goodbye”); 三个等价<br>在指向不同类型的指针间不存在转换规则。但可以为函数指针赋一个nullptr或者值为0的整型常量表达式，表示该指针没有指向任何函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string::size_type sumLength(const string&amp;, const string&amp;);</span><br><span class="line">bool cstringCompare(const char*, const char*);</span><br><span class="line">pf &#x3D; 0; &#x2F;&#x2F;正确：pf不指向任何函数</span><br><span class="line">pf &#x3D; sumLength; &#x2F;&#x2F;错误：返回值类型不匹配</span><br><span class="line">pf &#x3D; cstringCompare; &#x2F;&#x2F;错误：形参类型不匹配</span><br><span class="line">pf &#x3D; lengthCompare; &#x2F;&#x2F;正确：函数和指针类型精确匹配</span><br></pre></td></tr></table></figure>
<p>重载函数时，上下文必须清晰地界定到底该选用哪个函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void ff &#x3D; (int*);</span><br><span class="line">void ff &#x3D; (unsigned int);</span><br><span class="line">void (*pf1)(unsigned int) &#x3D; ff; &#x2F;&#x2F;pf1指向ff(unsighed int)</span><br><span class="line">void (*pf2)(int) &#x3D; ff; &#x2F;&#x2F;错误：没有ff与该类型形参列表匹配</span><br><span class="line">double (*pf3)(int*) &#x3D; ff; &#x2F;&#x2F;错误：返回值不匹配</span><br></pre></td></tr></table></figure>
<p>函数指针形参</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void useBigger(const string&amp; s1, const string&amp; s2, bool pf(const string&amp;, const string&amp;));</span><br><span class="line">void useBigger(const string&amp; s1, const string&amp; s2, bool(*pf)(const string&amp;, const string&amp;)); 二者等价，显式地将形参定义成指向函数的指针</span><br><span class="line">可以把函数作为实参使用，自动转换成指针</span><br><span class="line">useBigger(s1, s2, lengthCompare);</span><br><span class="line">使用类型别名：</span><br><span class="line">typedef bool Func(const string&amp;, const string&amp;);</span><br><span class="line">typedef decltype(lengthCompare) Func2; 二者等价，Func和Func2是函数类型</span><br><span class="line">typedef bool (*FuncP)(const string&amp;, const string&amp;);</span><br><span class="line">typedef decltype(lengthCompare)* FuncP2; 二者等价，* FuncP和* FuncP2是指针类型</span><br><span class="line">void useBigger(const string&amp;, const string&amp;, Func);</span><br><span class="line">void useBigger(const strign&amp;, const string&amp;, *FuncP2); 二者等价，第一句中编译器自动将Func表示的函数类型转换成指针</span><br></pre></td></tr></table></figure>
<p>使用类型别名返回指向函数的指针</p>
<pre><code>using F=int(int*, int);  //F是函数类型，不是指针
using PF=int(*)(int*, int); //PF是指针类型
PF f1(int); //正确：PF是指向函数的指针，f1返回指向函数的指针
F f1(int); //错误：F是函数类型，f1不能返回一个函数
F* f1(int); //正确：显式地指定返回类型是指向函数的指针
int (*f1(int))(int*, int); //指针指向一个返回值是int类型的函数
auto fi(int)-&gt;int(*)(int*, int);

string::size_type sumLength(const string&amp;, const string&amp;);
decltype(sumLength)* getFcn(const string&amp;);
decltype作用于某个函数时，返回函数类型而非指针。因此显式地加上*表示需要返回指针而非函数本身
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/06/c-primer-04-%E8%A1%A8%E8%BE%BE%E5%BC%8F/" data-id="ckhkopsd6000hesvectt1b2ph" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-primer/" rel="tag">c++ primer</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-problem-library-树-02" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/28/problem-library-%E6%A0%91-02/" class="article-date">
  <time datetime="2020-07-28T15:15:05.000Z" itemprop="datePublished">2020-07-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/28/problem-library-%E6%A0%91-02/">problem library 树 02</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="#106.从中序与后序遍历序列构造二叉树"></a>#106.从中序与后序遍历序列构造二叉树</h2><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p>
<p>注意:<br>你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<p>中序遍历 inorder = [9,3,15,20,7]<br>后序遍历 postorder = [9,15,7,20,3]<br>返回如下的二叉树：</p>
<pre><code>  3
 / \
9  20
  /  \
 15   7</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal" target="_blank" rel="noopener">https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;postorder, <span class="keyword">int</span> i_begin, <span class="keyword">int</span> i_end, <span class="keyword">int</span> p_begin, <span class="keyword">int</span> p_end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i_begin &gt; i_end || p_begin &gt; p_end)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode* res = <span class="keyword">new</span> TreeNode(postorder[p_end]);</span><br><span class="line">        <span class="keyword">if</span> (p_begin == p_end)<span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (postorder[p_end] != inorder[index])index++;</span><br><span class="line">        res-&gt;left = helper(inorder, postorder, i_begin, index - <span class="number">1</span>, p_begin, p_begin + index - <span class="number">1</span> - i_begin);</span><br><span class="line">        res-&gt;right = helper(inorder, postorder, index + <span class="number">1</span>, i_end, p_end - <span class="number">1</span> - (i_end - (index + <span class="number">1</span>)), p_end - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(inorder, postorder, <span class="number">0</span>, inorder.<span class="built_in">size</span>() - <span class="number">1</span>, <span class="number">0</span>, postorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="95-不同的二叉搜索树II"><a href="#95-不同的二叉搜索树II" class="headerlink" title="#95.不同的二叉搜索树II"></a>#95.不同的二叉搜索树II</h2><p>给定一个整数 n，生成所有由 1 … n 为节点所组成的 二叉搜索树 。</p>
<p>示例：</p>
<p>输入：3<br>输出：<br>[<br>  [1,null,3,2],<br>  [3,2,null,1],<br>  [3,1,null,null,2],<br>  [2,1,3],<br>  [1,null,2,null,3]<br>]<br>解释：<br>以上的输出对应以下 5 种不同结构的二叉搜索树：</p>
<pre><code>1         3     3      2      1
 \       /     /      / \      \
  3     2     1      1   3      2
 /     /       \                 \
2     1         2                 3</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-binary-search-trees-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">getrees</span><span class="params">(<span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lo &gt; hi)<span class="keyword">return</span> &#123; <span class="literal">nullptr</span> &#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt;res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt;= hi; i++) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;TreeNode*&gt; leftTrees = getrees(lo, i - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">vector</span>&lt;TreeNode*&gt; rightTrees = getrees(i + <span class="number">1</span>, hi);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; l : leftTrees)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; r : rightTrees) &#123;</span><br><span class="line">                    TreeNode* root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    root-&gt;left = l;</span><br><span class="line">                    root-&gt;right = r;</span><br><span class="line">                    res.emplace_back(root);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)<span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">return</span> getrees(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/28/problem-library-%E6%A0%91-02/" data-id="ckhkopsdy002pesveg5h6bgqo" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/problem-library/" rel="tag">problem library</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-DS邓俊辉-10" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/27/DS%E9%82%93%E4%BF%8A%E8%BE%89-10/" class="article-date">
  <time datetime="2020-07-27T14:34:35.000Z" itemprop="datePublished">2020-07-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/27/DS%E9%82%93%E4%BF%8A%E8%BE%89-10/">DS邓俊辉 10 优先级队列</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h1><p>call-by-priority</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">struct</span> <span class="title">PQ</span> &#123;</span> <span class="comment">//priority queue</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(T)</span> </span>= <span class="number">0</span>; <span class="comment">//按照优先级次序插入词条</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> T <span class="title">getMax</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">//取出优先级最高的词条</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> T <span class="title">delMax</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">//删除优先级最高的词条</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">完全二叉堆</span><br><span class="line">逻辑上等同于完全二叉树，物理上直接借助向量实现</span><br><span class="line">逻辑节点与物理元素，依层次遍历次序彼此对应</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Parent(i) ((i-1&gt;&gt;1))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LChild(i) (1+((i)&lt;&lt;1)) <span class="comment">//奇数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RChild(i) ((1+(i))&lt;&lt;1) <span class="comment">//偶数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">PQ_ComplHeap</span> :</span><span class="keyword">public</span> PQ&lt;T&gt;, <span class="keyword">public</span> Vector&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function">Rank <span class="title">percolateDown</span><span class="params">(Rank n, Rank i)</span></span>; <span class="comment">//下滤</span></span><br><span class="line">	<span class="function">Rank <span class="title">percolateUP</span><span class="params">(Rank i)</span></span>; <span class="comment">//上滤</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(Rank n)</span></span>; <span class="comment">//Floyd建堆算法</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	QP_ComplHeap(T* A,Rank n) <span class="comment">//批量构造</span></span><br><span class="line">	&#123;copuFrom(A, <span class="number">0</span>, n); heapify(n);	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(T)</span></span>; <span class="comment">//按照比较器确定的优先级次序，插入词条</span></span><br><span class="line">	<span class="function">T <span class="title">getMax</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> _elem[<span class="number">0</span>]; &#125; <span class="comment">//读取优先级最高的词条</span></span><br><span class="line">	<span class="function">T <span class="title">delMax</span><span class="params">()</span></span>; <span class="comment">//删除优先级最高的词条</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">堆序性：</span><br><span class="line">数值上，只要<span class="number">0</span> &lt; i，必满足H[i] &lt;= H[Parent(i)]，故H[<span class="number">0</span>]是全局最大元素</span><br><span class="line"></span><br><span class="line">插入与上滤</span><br><span class="line">为插入词条e，只需将e作为末元素接入向量  结构性自然保持，堆序性未必破坏</span><br><span class="line">若破坏只需和父节点交换，可能交换多次</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> PQ_ComplHeap&lt;T&gt;::insert(T e) <span class="comment">//插入</span></span><br><span class="line">	&#123;Vector&lt;T&gt;::insert(e); pervolateUp(_size - <span class="number">1</span>);&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">//对第i个词条实施上滤，i&lt;_size</span></span><br><span class="line">Rank PQ_ComplHeap&lt;T&gt;::percolateUp(Rank i) &#123;</span><br><span class="line">	<span class="keyword">while</span> (PerantValid(i)) &#123; <span class="comment">//只要i有父亲（尚未抵达堆顶），则</span></span><br><span class="line">		Rank j = Parent(i); <span class="comment">//将之记作j</span></span><br><span class="line">		<span class="keyword">if</span> (It(_elem[i], _elem[j]))<span class="keyword">break</span>; <span class="comment">//一旦父子不在逆序，上滤旋即完成</span></span><br><span class="line">		swap(_elem[i], _elem[j]); i = j; <span class="comment">//否则，交换父子位置，并上升一层</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">删除与下滤</span><br><span class="line">删除向量首元素，代之以末元素e，结构性保持，若堆序性破坏，与e孩子中大者换位</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; T PQ_ComplHeap&lt;T&gt;::delMax() &#123; <span class="comment">//删除</span></span><br><span class="line">	T maxElem = _elem[<span class="number">0</span>]; _elem[<span class="number">0</span>] = _elem[--_size]; <span class="comment">//摘除堆顶，代之以末次条</span></span><br><span class="line">	percolateDown(_size, <span class="number">0</span>); <span class="comment">//对新堆顶实施下滤</span></span><br><span class="line">	<span class="keyword">return</span> maxElem; <span class="comment">//返回此前备份的最大词条</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//对前n个词条中的第i个实施下滤，i&lt;n</span></span><br><span class="line">Rank PQ_ComplHeap&lt;T&gt;::percolateDown(Rank n, Rank i) &#123;</span><br><span class="line">	Rank j; <span class="comment">//i及其(至多两个)孩子中，堪为父者</span></span><br><span class="line">	<span class="keyword">while</span> (i != (j = ProperParent(_elem, n, i))) <span class="comment">//只要i非j，则</span></span><br><span class="line">	&#123;</span><br><span class="line">		swap(_elem[i], _elem[j]); i = j; <span class="comment">//换位，并继续考察i</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i; <span class="comment">//返回下滤抵达的位置（亦i亦j）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">批量建堆</span><br><span class="line">自上而下的上滤</span><br><span class="line">PQ_ComplHeap(T* A, Rank n) &#123; copyFrom(A, <span class="number">0</span>, n); heapify(n); &#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> PQ_ComplHeap&lt;T&gt;::heapify(Rank n) &#123; <span class="comment">//蛮力</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="comment">//按照层次遍历次序逐一</span></span><br><span class="line">		percolateUp(i); <span class="comment">//经上滤插入各节点</span></span><br><span class="line">&#125;O(nlogn)</span><br><span class="line">自下而上的下滤</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> PQ_ComplHeap&lt;T&gt;::heapify(Rank n) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = LastInternal(n); i &gt;= <span class="number">0</span>; i--) <span class="comment">//自下而上，一次</span></span><br><span class="line">		percolateDown(n, i); <span class="comment">//下滤各内部节点</span></span><br><span class="line">&#125; <span class="comment">//可以理解为子堆的逐层合并 O(n)</span></span><br><span class="line"></span><br><span class="line">堆排序</span><br><span class="line">在选择排序中，待排序部分u替换为H；</span><br><span class="line">初始化：heapify(),O(n)建堆</span><br><span class="line">迭代：delMax(),O(logn)取出堆顶并调整复原</span><br><span class="line">不变性：H&lt;=S</span><br><span class="line">有：m=H[<span class="number">0</span>],x=S[<span class="number">-1</span>]，所以swap(m,x)=H.insert(x)+S.insert(m)</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">//对向量区间[lo,hi)做就地堆排序</span></span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::heapSort(Rank lo, Rank hi) &#123;</span><br><span class="line">	PQ_ComplHeap&lt;T&gt; H(_elem + lo, hi - lo); <span class="comment">//待排序区间建堆，O(n)</span></span><br><span class="line">	<span class="keyword">while</span> (!H.empty()) <span class="comment">//反复地摘除最大元并归入已排序的后缀，直至堆空</span></span><br><span class="line">		_elem[--hi] = H.delMax(); <span class="comment">//等效于堆顶与末元素对换后下滤</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">堆合并</span><br><span class="line">H=merge(A,B):将堆A、B合二为一 <span class="comment">//设|A|=n&gt;=m=|B|</span></span><br><span class="line">方法一：A.insert(b.delMax()) O(m*<span class="built_in">log</span>(m+n))</span><br><span class="line">方法二：<span class="keyword">union</span>(A,B).heapify(m+n)  O(m+n)</span><br><span class="line"></span><br><span class="line">左式堆</span><br><span class="line">新条件：结点分布偏向于左侧，合并操作只涉及右侧，牺牲结构性，保留堆序性</span><br><span class="line">空节点路径长度：npl(<span class="literal">NULL</span>)=<span class="number">0</span>,npl(x)=<span class="number">1</span>+<span class="built_in">min</span>(npl(lc(x),npl(rc(x))</span><br><span class="line">npl(x)=x到外部结点的最近距离=以x为根的最大满子树的高度</span><br><span class="line">左倾：对任何内节点x，都有npl(lc(x))&gt;=npl(rc(x)),推论，对任何内节点x都有npl(x)=npl(rc(x))+<span class="number">1</span></span><br><span class="line">右侧链rChain(x):从节点x出发，一直沿着右分支前进</span><br><span class="line">rChain(root)的终点，必为全堆中最浅的外部节点  npl(r)==|rChain(r)|=d 存在一颗以r为根、高度为d的满子树</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  <span class="comment">//基于二叉树，以左式堆形式实现的优先级队列</span></span><br><span class="line">class PQ_ComplHeap :<span class="keyword">public</span> PQ&lt;T&gt;, <span class="keyword">public</span> BinTree&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">void</span> insert(T); <span class="comment">//（按比较器确定的优先级次序）插入元素</span></span><br><span class="line">	T getMax() &#123; <span class="keyword">return</span> _root-&gt;data; &#125; <span class="comment">//取出优先级最高的元素</span></span><br><span class="line">	T delMax(); <span class="comment">//删除优先级最高的元素</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">static</span> BinNodePosi(T) merge(BinNodePosi(T) a, BinNodePosi(T) b) &#123;</span><br><span class="line">	<span class="keyword">if</span> (!a)<span class="keyword">return</span> b; <span class="comment">//递归基</span></span><br><span class="line">	<span class="keyword">if</span> (!b)<span class="keyword">return</span> a; <span class="comment">//递归基</span></span><br><span class="line">	<span class="keyword">if</span> (lt(a-&gt;data, b-&gt;data))swap(b, a); <span class="comment">//一般情况：首先确保b不大</span></span><br><span class="line">	a-&gt;rc = merge(a-&gt;rc, b); <span class="comment">//将a的右子堆与b合并</span></span><br><span class="line">	a-&gt;rc-&gt;parent = a; <span class="comment">//并更新父子关系</span></span><br><span class="line">	<span class="keyword">if</span> (!a-&gt;lc || a-&gt;lc-&gt;npl &lt; a-&gt;rc-&gt;npl) <span class="comment">//若有必要</span></span><br><span class="line">		swap(a-&gt;lc, a-&gt;rc); <span class="comment">//交换a的左右子堆，以确保右子堆的npl不大</span></span><br><span class="line">	a-&gt;npl = a-&gt;rc ? a-&gt;rc-&gt;npl + <span class="number">1</span> : <span class="number">1</span>; <span class="comment">//更新a的npl</span></span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;O(logn)</span><br><span class="line"></span><br><span class="line">插入即是合并、删除亦是合并</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> PQ_LeftHeap&lt;T&gt;::insert(T e) &#123; <span class="comment">//O(logn)</span></span><br><span class="line">	BinNodePosi(T)v = <span class="keyword">new</span> BinNode&lt;T&gt;(e); <span class="comment">//为e创建一个二叉树节点</span></span><br><span class="line">	_root = merge(_root, v); <span class="comment">//通过合并完成新节点的插入</span></span><br><span class="line">	_root-&gt;parent = <span class="literal">NULL</span>; <span class="comment">//既然此时堆非空，还需相应设置父子链接</span></span><br><span class="line">	_size++; <span class="comment">//更新规模</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">//O(logn)</span></span><br><span class="line"><span class="keyword">void</span> PQ_LeftHeap&lt;T&gt;::delMax(T e) &#123;</span><br><span class="line">	BinNodePosi(T) lHeap = _root-&gt;lc; <span class="comment">//左子堆</span></span><br><span class="line">	BinNodePosi(T) rHeap = _root-&gt;rc; <span class="comment">//右子堆</span></span><br><span class="line">	T e = _root-&gt;data; <span class="comment">//备份堆顶处的最大元素</span></span><br><span class="line">	<span class="keyword">delete</span> _root; _size--; <span class="comment">//删除根节点</span></span><br><span class="line">	_root = merge(lHeap, rHeap); <span class="comment">//原左右子堆合并</span></span><br><span class="line">	<span class="keyword">if</span> (_root)_root-&gt;parent = <span class="literal">NULL</span>; <span class="comment">//更新父子链接</span></span><br><span class="line">	<span class="keyword">return</span> e; <span class="comment">//返回原根节点的数据项</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/27/DS%E9%82%93%E4%BF%8A%E8%BE%89-10/" data-id="ckhkopsd30008esve4kgw7l0v" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%82%93%E4%BF%8A%E8%BE%89/" rel="tag">数据结构 邓俊辉</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-problem-library-树" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/26/problem-library-%E6%A0%91/" class="article-date">
  <time datetime="2020-07-26T14:21:54.000Z" itemprop="datePublished">2020-07-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/26/problem-library-%E6%A0%91/">problem library 树 01</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="#104.二叉树的最大深度"></a>#104.二叉树的最大深度</h2><p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，</p>
<pre><code>    3
   / \
  9  20
 /     \
15      7</code></pre><p>返回它的最大深度 3 。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">max</span>(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="#226.翻转二叉树"></a>#226.翻转二叉树</h2><p>翻转一棵二叉树。</p>
<p>示例：</p>
<p>输入：</p>
<pre><code>     4
   /   \
  2     7
 / \   / \
1   3 6   9</code></pre><p>输出：</p>
<pre><code>     4
   /   \
  7     2
 / \   / \
9   6 3   1</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/invert-binary-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/invert-binary-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        TreeNode* tmp = root-&gt;left;</span><br><span class="line">        root-&gt;left = invertTree(root-&gt;right);</span><br><span class="line">        root-&gt;right = invertTree(tmp);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="#617.合并二叉树"></a>#617.合并二叉树</h2><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p>
<p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p>
<p>示例 1:</p>
<p>输入: </p>
<pre><code>    1                         2                             
   / \                       / \                            
  3   2                     1   3                        
 /                           \   \                      
5                             4   7                  </code></pre><p>输出:<br>合并后的树:</p>
<pre><code>    3
   / \
  4   5
 / \   \ 
5   4   7</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/merge-two-binary-trees" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-two-binary-trees</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">NULL</span>)<span class="keyword">return</span> t2;</span><br><span class="line">        <span class="keyword">if</span> (t2 == <span class="literal">NULL</span>)<span class="keyword">return</span> t1;</span><br><span class="line">        t1-&gt;val += t2-&gt;val;</span><br><span class="line">        t1-&gt;left = mergeTrees(t1-&gt;left, t2-&gt;left);</span><br><span class="line">        t1-&gt;right = mergeTrees(t1-&gt;right, t2-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="#108.将有序数组转换为二叉搜索树"></a>#108.将有序数组转换为二叉搜索树</h2><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1。</p>
<p><strong>示例:</strong></p>
<p>给定有序数组: [-10,-3,0,5,9],</p>
<p>一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：</p>
<pre><code>     0
    / \
  -3   9
  /   /
-10  5</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getRes(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">getRes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lo &gt; hi)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> mi = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        TreeNode* res = <span class="keyword">new</span> TreeNode(nums[mi]);</span><br><span class="line">        res-&gt;left = getRes(nums, lo, mi - <span class="number">1</span>);</span><br><span class="line">        res-&gt;right = getRes(nums, mi + <span class="number">1</span>, hi);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="#100.相同的树"></a>#100.相同的树</h2><p>给定两个二叉树，编写一个函数来检验它们是否相同。</p>
<p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
<p>示例 1:</p>
<pre><code>   1         1
  / \       / \
 2   3     2   3

[1,2,3],   [1,2,3]</code></pre><p>输出: true<br>示例 2:</p>
<pre><code>   1          1
  /           \
 2             2

[1,2],     [1,null,2]</code></pre><p>输出: false</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/same-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/same-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">NULL</span> &amp;&amp; q == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!p || !q)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> p-&gt;val == q-&gt;val &amp;&amp; isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="#101.对称二叉树"></a>#101.对称二叉树</h2><p>给定一个二叉树，检查它是否是镜像对称的。</p>
<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>
<pre><code>    1
   / \
  2   2
 / \ / \
3  4 4  3</code></pre><p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p>
<pre><code>  1
 / \
2   2
 \   \
 3    3</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/symmetric-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/symmetric-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">defsym</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root1 &amp;&amp; !root2)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!root1 || !root2)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> root1-&gt;val == root2-&gt;val &amp;&amp; defsym(root1-&gt;left, root2-&gt;right) &amp;&amp; defsym(root1-&gt;right, root2-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> defsym(root, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="#235.二叉搜索树的最近公共祖先"></a>#235.二叉搜索树的最近公共祖先</h2><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。<br>例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]<br>示例 1:</p>
<p>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8<br>输出: 6<br>解释: 节点 2 和节点 8 的最近公共祖先是 6。<br>示例 2:</p>
<p>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4<br>输出: 2<br>解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rv = root-&gt;val, pv = p-&gt;val, qv = q-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> ((pv &lt; rv &amp;&amp; rv &lt; qv) || (qv &lt; rv &amp;&amp; rv &lt; pv))<span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (pv &lt; rv &amp;&amp; qv &lt; rv)<span class="keyword">return</span> lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">        <span class="keyword">if</span> (rv &lt; pv &amp;&amp; rv &lt; qv)<span class="keyword">return</span> lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="938-二叉树搜索树的范围和"><a href="#938-二叉树搜索树的范围和" class="headerlink" title="#938.二叉树搜索树的范围和"></a>#938.二叉树搜索树的范围和</h2><p>给定二叉搜索树的根结点 root，返回 L 和 R（含）之间的所有结点的值的和。</p>
<p>二叉搜索树保证具有唯一的值。</p>
<p>示例 1：</p>
<p>输入：root = [10,5,15,3,7,null,18], L = 7, R = 15<br>输出：32<br>示例 2：</p>
<p>输入：root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10<br>输出：23</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/range-sum-of-bst" target="_blank" rel="noopener">https://leetcode-cn.com/problems/range-sum-of-bst</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rangeSumBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rv = root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (L &lt; rv &amp;&amp; R &lt; rv)<span class="keyword">return</span> rangeSumBST(root-&gt;left, L, R);</span><br><span class="line">        <span class="keyword">if</span> (rv &lt; L &amp;&amp; rv &lt; R)<span class="keyword">return</span> rangeSumBST(root-&gt;right, L, R);</span><br><span class="line">        <span class="keyword">if</span> (L &lt;= root-&gt;val &amp;&amp; root-&gt;val &lt;= R)<span class="keyword">return</span> (root-&gt;val + rangeSumBST(root-&gt;left, L, R) + rangeSumBST(root-&gt;right, L, R));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="#96.不同的二叉搜索树"></a>#96.不同的二叉搜索树</h2><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p>
<p>示例:</p>
<p>输入: 3<br>输出: 5<br>解释:<br>给定 n = 3, 一共有 5 种不同结构的二叉搜索树:</p>
<pre><code>1         3     3      2      1
 \       /     /      / \      \
  3     2     1      1   3      2
 /     /       \                 \
2     1         2                 3</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/unique-binary-search-trees" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-binary-search-trees</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;G(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        G[<span class="number">0</span>] = <span class="number">1</span>; G[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">                G[i] += (G[j - <span class="number">1</span>] * G[i - j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> G[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/26/problem-library-%E6%A0%91/" data-id="ckhkopse0002uesveagzhbtu1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/problem-library/" rel="tag">problem library</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/02-cpp-primer/" rel="tag">02 cpp primer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c-primer/" rel="tag">c++ primer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cocos2d-x/" rel="tag">cocos2d-x</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpp-notes/" rel="tag">cpp notes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/problem-library/" rel="tag">problem library</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reading-notes-DS/" rel="tag">reading notes DS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%82%93%E4%BF%8A%E8%BE%89/" rel="tag">数据结构 邓俊辉</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/02-cpp-primer/" style="font-size: 12.5px;">02 cpp primer</a> <a href="/tags/c-primer/" style="font-size: 15px;">c++ primer</a> <a href="/tags/cocos2d-x/" style="font-size: 12.5px;">cocos2d-x</a> <a href="/tags/cpp-notes/" style="font-size: 20px;">cpp notes</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/problem-library/" style="font-size: 15px;">problem library</a> <a href="/tags/reading-notes-DS/" style="font-size: 10px;">reading notes DS</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%82%93%E4%BF%8A%E8%BE%89/" style="font-size: 17.5px;">数据结构 邓俊辉</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/11/16/ncpp-03/">第3章 字符串、向量和数组</a>
          </li>
        
          <li>
            <a href="/2020/11/16/ncpp-02/">第2章 变量和基本类型</a>
          </li>
        
          <li>
            <a href="/2020/10/27/mysql/">mysql</a>
          </li>
        
          <li>
            <a href="/2020/08/30/c-primer-16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/">c++ primer 16 模板与泛型编程</a>
          </li>
        
          <li>
            <a href="/2020/08/30/c-primer-15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">c++ primer 15 面向对象程序设计</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>
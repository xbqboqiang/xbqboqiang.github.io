<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>第7章 类 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="类的基本思想是数据抽象(data abstraction)和封装(encapsulation)。数据抽象是一种依赖于接口(interface)和实现(implementation)分离的编程(以及设计)技术。类的接口包括用户所能执行的操作；类的实现包括类的数据成员、负责接口实现的函数以及定义类所需的各种私有函数封装实现了类的接口和实现的分离。封装后隐藏了它的实现细节。用户只能使用接口而无法访问实现">
<meta property="og:type" content="article">
<meta property="og:title" content="第7章 类">
<meta property="og:url" content="http://yoursite.com/2020/11/20/ncpp-07/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="类的基本思想是数据抽象(data abstraction)和封装(encapsulation)。数据抽象是一种依赖于接口(interface)和实现(implementation)分离的编程(以及设计)技术。类的接口包括用户所能执行的操作；类的实现包括类的数据成员、负责接口实现的函数以及定义类所需的各种私有函数封装实现了类的接口和实现的分离。封装后隐藏了它的实现细节。用户只能使用接口而无法访问实现">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-11-20T12:40:31.000Z">
<meta property="article:modified_time" content="2020-11-22T11:43:53.589Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="02 cpp primer">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-ncpp-07" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/20/ncpp-07/" class="article-date">
  <time datetime="2020-11-20T12:40:31.000Z" itemprop="datePublished">2020-11-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      第7章 类
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>类的基本思想是数据抽象(data abstraction)和封装(encapsulation)。数据抽象是一种依赖于接口(interface)和实现(implementation)分离的编程(以及设计)技术。<br>类的接口包括用户所能执行的操作；类的实现包括类的数据成员、负责接口实现的函数以及定义类所需的各种私有函数<br>封装实现了类的接口和实现的分离。封装后隐藏了它的实现细节。用户只能使用接口而无法访问实现部分</p>
<h2 id="定义抽象数据类型"><a href="#定义抽象数据类型" class="headerlink" title="定义抽象数据类型"></a>定义抽象数据类型</h2><h3 id="设计Sales-data类"><a href="#设计Sales-data类" class="headerlink" title="设计Sales_data类"></a>设计Sales_data类</h3><p>Sales_data的接口应包含以下操作：<br>·一个isbn成员函数，用于返回对象的ISBN号<br>·一个combine成员函数，用于将一个Sales_data对象加到另一个对象上<br>·一个名为add的函数，执行两个Sales_data对象的加法<br>·一个read函数，将数据从istream读入到Sales_data对象中<br>·一个print函数，将Sales_data对象的值输出到ostream</p>
<h3 id="定义改进的Sales-data类"><a href="#定义改进的Sales-data类" class="headerlink" title="定义改进的Sales_data类"></a>定义改进的Sales_data类</h3><p>成员函数的声明必须在类的内部，定义则既可以在类的内部也可以在类的外部。作为接口组成部分的非成员函数，定义和声明都在类的外部</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> bookNo;&#125;</span><br><span class="line">    <span class="function">Sales_data&amp; <span class="title">combine</span><span class="params">(<span class="keyword">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bookNo;</span><br><span class="line">    <span class="keyword">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//非成员接口函数</span></span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="keyword">const</span> Sales_data&amp;, <span class="keyword">const</span> Sales_dasta&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::ostream&amp; <span class="title">print</span><span class="params">(<span class="built_in">std</span>::ostream&amp;, <span class="keyword">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::istream&amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream&amp;,<span class="keyword">const</span> Sales_data&amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<p>定义在类内部的函数是隐式的inline函数</p>
<h4 id="引入this"><a href="#引入this" class="headerlink" title="引入this"></a>引入this</h4><p>对于total.isbn()，如果isbn指向Sales_data的成员，则它隐式的调用该函数对象的成员。实际上隐式地返回total.bookNo<br>成员函数通过一个名为<strong>this</strong>的额外的隐式参数来访问调用它的那个对象。编译器负责把total的地址传递给isbn的隐式形参this</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等价的认为如下形式</span></span><br><span class="line">Sales_data::isbn(&amp;total)</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以把isbn定义成：</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>-&gt;bookNo;&#125;</span><br></pre></td></tr></table></figure>

<p>this是一个常量指针，不允许改变this中保存的地址</p>
<h4 id="引入const成员函数"><a href="#引入const成员函数" class="headerlink" title="引入const成员函数"></a>引入const成员函数</h4><p>isbn函数中的const的作用是修改隐式this指针的类型<br>默认情况下，this的类型是指向类类型非常量版本的常量指针，即Sales_data* const。意味着不能把this绑定到一个常量对象上<br>把this设置为指向常量的指针有助于提高函数的灵活性<br>紧跟在参数列表后面的const表示this是一个指向常量的指针。像这样使用const的成员函数被称作常量成员函数(const member function)<br>可以把isbn的函数体想象成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码，非法的</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Sales_data::isbn</span><span class="params">(<span class="keyword">const</span> Sales_data*<span class="keyword">const</span> <span class="keyword">this</span>)</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>-&gt;isbn;&#125;</span><br></pre></td></tr></table></figure>

<p>常量对象，以及常量对象的引用或指针都只能调用常量成员函数</p>
<p>编译器首先编译成员的声明，然后才轮到成员函数体。所以成员函数体可以随意使用类中其它成员而无需在意这些成员出现的次序</p>
<h4 id="在类的外部定义成员函数"><a href="#在类的外部定义成员函数" class="headerlink" title="在类的外部定义成员函数"></a>在类的外部定义成员函数</h4><p>在类的外部定义成员函数时，定义必须与声明匹配。返回类型、参数列表和函数名都得与类内的声明保持一致。如果成员被声明为常量成员函数，定义时也必须在参数列表后明确指定const属性。类外定义的成员的名字必须包含它所属的类名</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Sales_data::avg_price</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(units_sold)</span><br><span class="line">        <span class="keyword">return</span> revenue/units_sold;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="定义一个返回this对象的函数"><a href="#定义一个返回this对象的函数" class="headerlink" title="定义一个返回this对象的函数"></a>定义一个返回this对象的函数</h4><p>调用combine函数的对象代表的是赋值运算符左侧的运算对象，右侧运算对象通过显式的实参被传入函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Sales_data&amp; <span class="title">Sales_data::combine</span><span class="params">(<span class="keyword">const</span> Sales_data&amp; rhs)</span></span>&#123;</span><br><span class="line">    units_sold += rhs.units_sold;   <span class="comment">//把rhs的成员加到this对象的成员上</span></span><br><span class="line">    revenue += rhs.revenue;</span><br><span class="line">    <span class="keyword">return</span>* <span class="keyword">this</span>;       <span class="comment">//返回调用该函数的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如：total.combine(trans)，total的地址被绑定到隐式的this参数上，rhs绑定到trans上</p>
<h3 id="定义类相关的非成员函数"><a href="#定义类相关的非成员函数" class="headerlink" title="定义类相关的非成员函数"></a>定义类相关的非成员函数</h3><p>通常把函数的声明和定义分离开来。如果函数在概念上属于类，但不定义在类中，则它一般应与类声明在同一个头文件内。这种方式下，用户使用个借口的任何部分都只需要引入一个文件</p>
<h4 id="定义read和print函数"><a href="#定义read和print函数" class="headerlink" title="定义read和print函数"></a>定义read和print函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">read</span><span class="params">(istream&amp; is,Sales_data&amp; item)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> price = <span class="number">0</span>;</span><br><span class="line">    is &gt;&gt; item.bookNo &gt;&gt;item.units_sold &gt;&gt; price;</span><br><span class="line">    item.revenue = price * item.units_sold;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ostream&amp; <span class="title">print</span><span class="params">(ostream&amp; os,<span class="keyword">const</span> Sales_data&amp; item)</span></span>&#123;</span><br><span class="line">    os &lt;&lt; item.isbn() &lt;&lt; <span class="string">" "</span> &lt;&lt; item.units_sold &lt;&lt; <span class="string">" "</span></span><br><span class="line">       &lt;&lt; item.revenue &lt;&lt; <span class="string">" "</span> &lt;&lt; item.avg_prive();</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IO类不能被拷贝，所以只能通过引用来传递。而且读取和写入会改变流的内容，所以两个函数接受的都是普通引用，而非对常量引用<br>print函数不负责换行。执行输出任务的函数应该尽量减少对格式的控制，这样可以确保由用户代码来决定是否换行</p>
<h4 id="定义add函数"><a href="#定义add函数" class="headerlink" title="定义add函数"></a>定义add函数</h4><p>接受两个Sales_data对象作为参数，返回值是一个新的Sales_data</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="keyword">const</span> Sales_data&amp; lhs,cosnt Sales_data&amp; rhs)</span></span>&#123;</span><br><span class="line">    Sales_data sum =lhs;</span><br><span class="line">    sum.combine(rhs);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>类通过一个或几个特殊的成员函数控制其对象的初始化过程，这些函数叫做构造函数(constructor)。构造函数的任务是初始化类对象的数据成员<br>构造函数的名字和类名相同，没有返回类型。可能有多个<br>构造函数不能被声明成const的<br>当类创建一个const对象时，知道构造函数完成初始化过程，对象才能真正取得其“常量”属性。因此构造函数在const对象的构造过程中可以向其写值</p>
<h4 id="合成的默认构造函数"><a href="#合成的默认构造函数" class="headerlink" title="合成的默认构造函数"></a>合成的默认构造函数</h4><p>类通过默认构造函数(default constructor)来控制默认初始化过程。默认构造函数无须任何实参<br>如果类没有显示地定义构造函数，编译器就会隐式地定义一个默认构造函数<br>编译器创建的构造函数又被称为合成的默认构造函数(synthesized default constructor)<br>合成的默认构造函数按照如下规则初始化类的数据成员：<br>·如果存在类内的初始值，用它来初始化成员<br>·否则，默认初始化该成员</p>
<p>编译器只有在发现类不包含任务构造函数的情况下才会生成一个默认构造函数<br>如果类包含内置类型或者符合类型的成员，只有在这些成员全部被赋予了类内初始值时，才适合使用默认构造函数。这些类型被默认初始化时，其值是未定义的<br>有时候编译器不能为某些类合成默认的构造函数</p>
<h4 id="定义Sales-data的构造函数"><a href="#定义Sales-data的构造函数" class="headerlink" title="定义Sales_data的构造函数"></a>定义Sales_data的构造函数</h4><p>·一个istream&amp;，从中读取一条信息<br>·一个const string&amp;，表示ISBN编号；一个unsigned，表示售出图书数量；以及一个double，表示图书价格<br>·一个const string&amp;，表示ISBN编号；编译器将赋予其它成员默认值<br>·一个空参数列表(即默认构造函数)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span>&#123;</span></span><br><span class="line">    Sales_data() = <span class="keyword">default</span>;</span><br><span class="line">    Sales_data(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s) : bookNo(s)&#123;&#125;</span><br><span class="line">    Sales_data(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s,<span class="keyword">unsigned</span> n,<span class="keyword">double</span> p) :</span><br><span class="line">               bookNo(s), units_sold(n), revenue(p*n)&#123;&#125;</span><br><span class="line">    Sales_data(istream&amp;);</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> bookNo;&#125;</span><br><span class="line">    <span class="function">Sales_data&amp; <span class="title">combine</span><span class="params">(<span class="keyword">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">avg_pirve</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="built_in">string</span> bookNo;</span><br><span class="line">    <span class="keyword">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="default-的含义"><a href="#default-的含义" class="headerlink" title="=default 的含义"></a>=default 的含义</h4><p>如果我们需要默认的行为，可以通过在参数列表后面写上=<strong>default</strong>来要求编译器生成构造函数</p>
<h4 id="构造函数初始值列表"><a href="#构造函数初始值列表" class="headerlink" title="构造函数初始值列表"></a>构造函数初始值列表</h4><p>对于：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sales_data(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s) : bookNo(s)&#123;&#125;</span><br><span class="line">Sales_data(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s,<span class="keyword">unsigned</span> n,<span class="keyword">double</span> p) :</span><br><span class="line">           bookNo(s), units_sold(n), revenue(p*n)&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>新出现的部分称为构造函数初始值列表(constructor initialize list)，说明一个类的数据成员的初始值，在构造函数体执行之前首先用初始值列表的值初始化数据成员。未经初始值列表初始化的成员将被默认初始化<br>它负责为新创建对象的一个或几个数据成员赋初值。构造函数初始值是成员名字的一个列表，每个名字后面紧跟括号括起来的(或者在花括号内的)成员初始值。不同成员的初始化通过逗号分隔开来<br>当某个数据成员被构造函数初始值列表忽略时，它将以与合成默认构造函数相同的方式隐式初始化<br>只接受一个string参数的构造函数等价于</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sales_data(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s):bookNo(s),units_sold(<span class="number">0</span>),revenue(<span class="number">0</span>)&#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在类的外部定义构造函数"><a href="#在类的外部定义构造函数" class="headerlink" title="在类的外部定义构造函数"></a>在类的外部定义构造函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sales_data::Sales_data(istream&amp; is)&#123;</span><br><span class="line">    <span class="built_in">read</span>(is,*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义时必须指明是哪个类的成员</p>
<h3 id="拷贝、赋值和析构"><a href="#拷贝、赋值和析构" class="headerlink" title="拷贝、赋值和析构"></a>拷贝、赋值和析构</h3><p>一般来说，编译器生成的版本将对对象的每个成员执行拷贝、赋值和销毁操作</p>
<h2 id="访问控制与封装"><a href="#访问控制与封装" class="headerlink" title="访问控制与封装"></a>访问控制与封装</h2><p>使用访问说明符(access specifiers)加强类的封装性：<br>·定义在public说明符之后的成员在整个程序内可被访问，public成员定义类的接口<br>·定义在private说明符之后的成员可被类的成员函数访问，但是不能被使用该类的代码访问，private部分封装了(即隐藏了)类的实现细节</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:         <span class="comment">//添加了访问说明符</span></span><br><span class="line">    Sales_data() = <span class="keyword">default</span>;</span><br><span class="line">    Sales_data(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s) : bookNo(s)&#123;&#125;</span><br><span class="line">    Sales_data(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s,<span class="keyword">unsigned</span> n,<span class="keyword">double</span> p) :</span><br><span class="line">               bookNo(s), units_sold(n), revenue(p*n)&#123;&#125;</span><br><span class="line">    Sales_data(istream&amp;);</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> bookNo;&#125;</span><br><span class="line">    <span class="function">Sales_data&amp; <span class="title">combine</span><span class="params">(<span class="keyword">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:        <span class="comment">//添加了访问说明符</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">avg_pirve</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;<span class="keyword">return</span> units_sold?revenue/units_sold : <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="built_in">string</span> bookNo;</span><br><span class="line">    <span class="keyword">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在类中访问说明符可以出现多次，其有效范围知道出现下一个访问说明符或到达类的结尾为止</p>
<h4 id="使用class或struct关键字"><a href="#使用class或struct关键字" class="headerlink" title="使用class或struct关键字"></a>使用class或struct关键字</h4><p>struct关键字第一个访问说明符的成员是public的；class的是private的</p>
<h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>通过友元可以允许其他类或者函数访问它的非公有成员，友元的访问权限与成员函数一样</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span>&#123;</span></span><br><span class="line"><span class="comment">//为Sales_data的非成员函数做的友元声明</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> Sales_data <span class="title">add</span><span class="params">(<span class="keyword">const</span> Sales_data&amp;,cosnt Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> istream&amp; <span class="title">read</span><span class="params">(istream&amp;, Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> ostream&amp; <span class="title">print</span><span class="params">(ostream&amp;, <span class="keyword">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Sales_data() = <span class="keyword">default</span>;</span><br><span class="line">    Sales_data(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s) : bookNo(s)&#123;&#125;</span><br><span class="line">    Sales_data(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s,<span class="keyword">unsigned</span> n,<span class="keyword">double</span> p) :</span><br><span class="line">               bookNo(s), units_sold(n), revenue(p*n)&#123;&#125;</span><br><span class="line">    Sales_data(istream&amp;);</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> bookNo;&#125;</span><br><span class="line">    <span class="function">Sales_data&amp; <span class="title">combine</span><span class="params">(<span class="keyword">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">avg_pirve</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;<span class="keyword">return</span> units_sold?revenue/units_sold : <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="built_in">string</span> bookNo;</span><br><span class="line">    <span class="keyword">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Sales_data接口的非成员组成部分的声明</span></span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="keyword">const</span> Sales_data&amp;,cosnt Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function">istream&amp; <span class="title">read</span><span class="params">(istream&amp;, Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function">ostream&amp; <span class="title">print</span><span class="params">(ostream&amp;, <span class="keyword">const</span> Sales_data&amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<p>友元声明只能出现再类定义的内部，但是在类内出现的具体位置不限<br>一般来说最好在类定义开始或结束前的位置集中声明友元</p>
<p>封装的益处：<br>·确保用户代码不会无意间破坏封装对象的状态<br>·被封装的类的具体试下细节可以随时改变，而无需调整用户级别的代码</p>
<p>友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果希望类的用户能够调用某个友元函数，就必须在友元声明之外专门对函数进行一次声明<br>为了使友元对类的用户可见，通常把友元的声明与类本身放置在同一个头文件中(类的外部)</p>
<h2 id="类的其他特性"><a href="#类的其他特性" class="headerlink" title="类的其他特性"></a>类的其他特性</h2><h3 id="类成员再探"><a href="#类成员再探" class="headerlink" title="类成员再探"></a>类成员再探</h3><h4 id="定义一个类型成员"><a href="#定义一个类型成员" class="headerlink" title="定义一个类型成员"></a>定义一个类型成员</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">string</span>::size_type pos;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    pos <span class="built_in">cursor</span> = <span class="number">0</span>;</span><br><span class="line">    pos <span class="built_in">height</span> = <span class="number">0</span>, <span class="built_in">width</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> contents;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>用来定义类型的成员必须先定义后使用</p>
<h4 id="Screen类的成员函数"><a href="#Screen类的成员函数" class="headerlink" title="Screen类的成员函数"></a>Screen类的成员函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> sring::size_type pos;</span><br><span class="line">    Screen() = <span class="keyword">default</span>;</span><br><span class="line">    Screen(pos ht,pos wd, <span class="keyword">char</span> c):<span class="built_in">height</span>(ht),<span class="built_in">width</span>(wd),</span><br><span class="line">           contents(ht*wd,c)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span>    <span class="comment">//读取光标处字符</span></span></span><br><span class="line"><span class="function">        </span>&#123;<span class="keyword">return</span> contents[<span class="built_in">cursor</span>];&#125;  <span class="comment">//隐式内联</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">get</span><span class="params">(pos ht,pos wd)</span><span class="keyword">const</span></span>;    <span class="comment">//显式内联</span></span><br><span class="line">    <span class="function">Screen&amp; <span class="title">move</span><span class="params">(pos r,pos c)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    pos <span class="built_in">cursor</span> = <span class="number">0</span>;</span><br><span class="line">    pos <span class="built_in">height</span> = <span class="number">0</span>, <span class="built_in">width</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> contents;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="令成员作为内联函数"><a href="#令成员作为内联函数" class="headerlink" title="令成员作为内联函数"></a>令成员作为内联函数</h4><p>定义在类内部的成员函数是自动内联的。也能在类的外部用inline关键字修饰函数的定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> Screen&amp; <span class="title">Screen::move</span><span class="params">(pos r,pos c)</span></span>&#123;</span><br><span class="line">    pos row = r*<span class="built_in">width</span>;  <span class="comment">//计算行的位置</span></span><br><span class="line">    <span class="built_in">cursor</span> = row + c;   <span class="comment">//在行内将光标移到指定的列</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;       <span class="comment">//以左值返回对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">Screen::get</span><span class="params">(pos r,pos c)</span><span class="keyword">const</span></span>&#123; <span class="comment">//在类内声明为inline</span></span><br><span class="line">    pos row = r * <span class="built_in">width</span>;    <span class="comment">//计算行的位置</span></span><br><span class="line">    <span class="keyword">return</span> contents[row+c]; <span class="comment">//返回给定列的字符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="可变数据成员"><a href="#可变数据成员" class="headerlink" title="可变数据成员"></a>可变数据成员</h4><p>一个可变数据成员(mutable data member)永远不会是const，几十它是const对象的成员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">some_member</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">size_t</span> access_ctr;</span><br><span class="line">    <span class="comment">//即使在一个const对象内也能被修改</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Screen::some_member</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    ++access_ctr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类数据成员的初始值"><a href="#类数据成员的初始值" class="headerlink" title="类数据成员的初始值"></a>类数据成员的初始值</h4><p>默认情况下，希望Window_mgr类开始时总是拥有一个默认初始化的Screen。可以把这个默认值声明成一个类内初始值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window_mgr</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;Screen&gt; screens&#123;Screen(<span class="number">24</span>,<span class="number">80</span>,<span class="string">' '</span>)&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当提供一个类内初始值时，必须以等号=或者花括号表示</p>
<h3 id="返回-this的成员函数"><a href="#返回-this的成员函数" class="headerlink" title="返回*this的成员函数"></a>返回*this的成员函数</h3><p>函数负责光标所在位置的字符或者其他任一给定位置的字符或者其他任一给定位置的字符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Screen&amp; <span class="title">set</span><span class="params">(<span class="keyword">char</span>)</span></span>;</span><br><span class="line">    <span class="function">Screen&amp; <span class="title">set</span><span class="params">(pos,pos,<span class="keyword">char</span>)</span></span>;</span><br><span class="line">    <span class="comment">//其他和之前一致</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Screen&amp; <span class="title">Screen::set</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    contents[<span class="built_in">cursor</span>]=c; <span class="comment">//设置光标所在位置的新值</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;       <span class="comment">//将this对象作为左值返回</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Screen&amp; <span class="title">Screen::set</span><span class="params">(pos r,pos col,<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">    contents[r*<span class="built_in">width</span>+col]=ch;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>set成员的返回值是调用set的对象的引用。返回引用的函数是左值的，意味着返回的是对象本身而非对象的副本</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">myScreen.<span class="built_in">move</span>(<span class="number">4</span>,<span class="number">0</span>).<span class="built_in">set</span>(<span class="string">'#'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">myScreen.<span class="built_in">move</span>(<span class="number">4</span>,<span class="number">0</span>);</span><br><span class="line">myScreen.<span class="built_in">set</span>(<span class="string">'#'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果move和set返回Screen，而非Screen&amp;</span></span><br><span class="line">Screen temp=myScreen.<span class="built_in">move</span>(<span class="number">4</span>,<span class="number">0</span>);</span><br><span class="line">temp.<span class="built_in">set</span>(<span class="string">'#'</span>);</span><br></pre></td></tr></table></figure>

<p>如果定义的返回类型不是引用，则move的返回值将是*this的副本，因此调用set只能改变临时副本，而不能改变myScreen的值</p>
<p>一个const成员函数如果以引用的形式返回*this，那么它的返回类型将是常量引用</p>
<h4 id="基于const的重载"><a href="#基于const的重载" class="headerlink" title="基于const的重载"></a>基于const的重载</h4><p>因为非常量版本的函数对于常量函数是不可用的，所以只能在一个常量对象上调用const成员函数；另一方面，虽然非常量对象可以调用常量或非常量版本，但非常量版本是一个更好的匹配</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Screen&amp; <span class="title">display</span><span class="params">(ostream&amp;os)</span></span>&#123;</span><br><span class="line">        do_display(os);<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Screen&amp; <span class="title">display</span><span class="params">(ostream&amp;os)</span><span class="keyword">const</span></span>&#123;</span><br><span class="line">        do_display(os);<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//该函数负责显示Screen内容</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do_display</span><span class="params">(ostream&amp; os)</span><span class="keyword">const</span></span>&#123;os &lt;&lt; contents;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h3><p>即使两个类的成员列表完全一致，它们也是不同的类型。对于一个类来说，它的成员和任何其他类的成员都不一样</p>
<p>可以把类名作为类型的名字使用，从而直接执行类类型，也可以跟在class或struct后面</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sales_data item1;   <span class="comment">//默认初始化Sales_data类型的对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span> <span class="title">item1</span>;</span> <span class="comment">//等价声明</span></span><br></pre></td></tr></table></figure>

<h4 id="类的声明"><a href="#类的声明" class="headerlink" title="类的声明"></a>类的声明</h4><p>可以仅声明类而暂时不定义它</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>;</span>   <span class="comment">//Screen类的声明</span></span><br></pre></td></tr></table></figure>

<p>这种声明被称作向前声明(forward declaration)，向程序中引入了名字Screen并且指明是一种类类型。对类型Screen来说，在它声明之后定义之前是一个不完全类型(incomplete type)，已知是一个类型，但不清楚成员<br>不完全类型可以指定指向这种类型的指针或引用，也可以声明以这种类型作为参数或返回类型的函数<br>类必须首先被定义后才能创建它的对象<br>一旦一个类的名字出现过后，它就认为是被声明过了，所以允许包含指向它自身类型的引用或指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Link_screen</span>&#123;</span></span><br><span class="line">    Screen window;</span><br><span class="line">    Link_screen* next;</span><br><span class="line">    Link_screen* prev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="友元再探"><a href="#友元再探" class="headerlink" title="友元再探"></a>友元再探</h3><p>类可以把其它的类定义成友元，也可以把其它类的成员函数定义成友元。友元能定义在类的内部，这样的函数是隐式内联的</p>
<h4 id="类之间的友元关系"><a href="#类之间的友元关系" class="headerlink" title="类之间的友元关系"></a>类之间的友元关系</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>&#123;</span></span><br><span class="line">    <span class="comment">//Window_mgr的成员可以访问Screen类的私有部分</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Window_mgr</span>;</span></span><br><span class="line">    <span class="comment">//Screen类剩余部分</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>友元类的成员函数可以访问此类包括非公有成员在内的所有成员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window_mgr</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//窗口中每个屏幕编号</span></span><br><span class="line">    <span class="keyword">using</span> ScreenIndex=<span class="built_in">vector</span>&lt;Screen&gt;::size_type;</span><br><span class="line">    <span class="comment">//按照编号将屏幕重置为空白</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(ScreenIndex)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;Screen&gt; screens&#123;Scree(<span class="number">24</span>,<span class="number">80</span>,<span class="string">' '</span>)&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Window_mgr::clear</span><span class="params">(ScreenIndex i)</span></span>&#123;</span><br><span class="line">    <span class="comment">//s是一个Screen的引用，指向想清空的屏幕</span></span><br><span class="line">    Screen &amp;s = screens[i];</span><br><span class="line">    <span class="comment">//将选定的Screen重置为空白</span></span><br><span class="line">    s.contents = <span class="built_in">string</span>(s.<span class="built_in">height</span>*s.<span class="built_in">width</span>,<span class="string">' '</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>友元关系不存在传递性。即Window_mgr的友元不能具有访问Screen的特权</p>
<h4 id="令成员函数作为友元"><a href="#令成员函数作为友元" class="headerlink" title="令成员函数作为友元"></a>令成员函数作为友元</h4><p>当把一个成员函数声明成友元时，必须明确指出属于哪个类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>&#123;</span></span><br><span class="line">    <span class="comment">//clear必须在Screen类之前被声明</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">Window_mgr::clear</span><span class="params">(ScreenIndex)</span></span>;</span><br><span class="line">    <span class="comment">//剩余部分</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>想要令某个成员函数作为友元：<br>·首先定义WIndow_mgr类，其中声明clear函数，但不能定义它。在clear使用Screen的成员之前必须先声明Screen<br>·接下来定义Screen，包括对clear的友元声明<br>·最后定义clear，此时它才可以使用Screen的成员</p>
<h4 id="函数重载和友元"><a href="#函数重载和友元" class="headerlink" title="函数重载和友元"></a>函数重载和友元</h4><p>如果一个类想把一组重载函数声明成它的友元，需要对每一个分别声明</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> ostream&amp; <span class="title">storeOn</span><span class="params">(ostream&amp;, Screen&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> BitMap&amp; <span class="title">storeOn</span><span class="params">(BitMap&amp;, Screen&amp;)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>&#123;</span></span><br><span class="line">    <span class="comment">//storeOn的ostream版本能访问Screen的私有部分</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> ostream&amp; <span class="title">storeOn</span><span class="params">(ostream&amp;, Screen&amp;)</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="友元声明和作用域"><a href="#友元声明和作用域" class="headerlink" title="友元声明和作用域"></a>友元声明和作用域</h4><p>类和非成员函数的声明不是必须在它们的友元之前。当一个名字第一次出现在一个友元声明中时，隐式地假定该名字在当前作用域中是可见的。然而友元本身不一定真的声明在当前作用域中<br>即使在类的内部定义该函数，也必须在类的外部提供相应的声明从而使该函数可见</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    X() &#123; f(); &#125;    <span class="comment">//错误：f还没有被声明</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">X::g</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> f();&#125;  <span class="comment">//错误：f还没有被声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;                   <span class="comment">//声明定义在X中的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">X::h</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> f();&#125;  <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>

<h2 id="类的作用域"><a href="#类的作用域" class="headerlink" title="类的作用域"></a>类的作用域</h2><p>在类的作用域之外，普通的数据和函数成员只能由对象、引用或指针使用成员访问运算符来访问。对于类类型成员则使用作用域运算符访问</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Screen::pos ht=<span class="number">24</span>,wd=<span class="number">80</span>;    <span class="comment">//使用Screen定义的pos类型</span></span><br><span class="line"><span class="function">Scrren <span class="title">scr</span><span class="params">(ht,wd,<span class="string">' '</span>)</span></span>;</span><br><span class="line">Screen* p=&amp;scr;</span><br><span class="line"><span class="keyword">char</span> c=scr.<span class="built_in">get</span>();   <span class="comment">//访问scr对象的get成员</span></span><br><span class="line">c=p-&gt;<span class="built_in">get</span>();         <span class="comment">//访问p所指对象的get成员</span></span><br></pre></td></tr></table></figure>

<h4 id="作用域和定义在类外部的成员"><a href="#作用域和定义在类外部的成员" class="headerlink" title="作用域和定义在类外部的成员"></a>作用域和定义在类外部的成员</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window_mgr</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//向窗口添加一个Screen，返回它的编号</span></span><br><span class="line">    <span class="function">ScreenIndex <span class="title">addScreen</span><span class="params">(<span class="keyword">const</span> Screen&amp;)</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//首先处理返回类型，之后才能进入Window_mgr的作用域</span></span><br><span class="line">Window_mgr::ScreenIndex</span><br><span class="line">Window_mgr::addScreen(<span class="keyword">const</span> Screen&amp;s)&#123;</span><br><span class="line">    screens.push_back(s);</span><br><span class="line">    <span class="keyword">return</span> screens.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回类型出现在类名之前，所以事实上它是位于Window_mgr类的作用域之外的。所以需要明确指定哪个类定义了它</p>
<h3 id="名字查找与类的作用域"><a href="#名字查找与类的作用域" class="headerlink" title="名字查找与类的作用域"></a>名字查找与类的作用域</h3><p>编译器处理完类中的全部声明才会处理成员函数的定义</p>
<h4 id="用于类声明的名字查找"><a href="#用于类声明的名字查找" class="headerlink" title="用于类声明的名字查找"></a>用于类声明的名字查找</h4><p>声明中使用的名字，包括返回类型或者参数列表中使用的名字，都必须确保使用前可见。如果某个成员的声明使用了类中尚未出现的名字，则编译器会在定义该类的作用域中继续查找</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> Money;</span><br><span class="line"><span class="built_in">string</span> bal;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Money <span class="title">balance</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> bal;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Money bal;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于balance函数的声明，编译器只考虑Account中在使用Money钱出现的声明，没有找到匹配的成员，编译器接着到Account的外层作用域中去找。<br>该例子中编译器会找到typedef语句，该类型被用作balance的返回累心高一级数据成员bal的类型。函数体在整个类可见后才会被处理，所以return语句返回名为bal的成员，而非外层的string对象</p>
<h4 id="类型名要特殊处理"><a href="#类型名要特殊处理" class="headerlink" title="类型名要特殊处理"></a>类型名要特殊处理</h4><p>内层作用域可以重新定义外层作用域的名字，即使该名字已经在内层作用域使用过。然而在类中，如果成员使用了外层作用域中的某个名字，而该名字代表一种类型，则类不能在之后重新定义该名字</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> Money;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//使用外层作用域的Money</span></span><br><span class="line">    <span class="function">Money <span class="title">balance</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> bal;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//错误：不能重新定义Money</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">double</span> Money;</span><br><span class="line">    Money bal;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>即使Account中定义的Money类型与外层作用域一致，仍然是错误的</p>
<h4 id="成员定义中的普通快作用域的名字查找"><a href="#成员定义中的普通快作用域的名字查找" class="headerlink" title="成员定义中的普通快作用域的名字查找"></a>成员定义中的普通快作用域的名字查找</h4><p>成员函数中使用的名字按照以下方式解析：<br>·在成员函数内查找该名字的声明。只有在函数使用之前出现的声明才被考虑<br>·再类内继续查找，类的所有成员都可以被考虑<br>·如果类内也没有，在成员函数定义之前的作用域内继续查找</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//仅为说明，不提倡</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">string</span>::size_type pos;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dummy_fcn</span><span class="params">(pos <span class="built_in">height</span>)</span></span>&#123;</span><br><span class="line">        <span class="built_in">cursor</span> = <span class="built_in">width</span>*<span class="built_in">height</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    pos <span class="built_in">cursor</span>=<span class="number">0</span>;</span><br><span class="line">    pos <span class="built_in">height</span>=<span class="number">0</span>,<span class="built_in">width</span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于height，首先在函数作用域内查找表达式中用到的名字。函数的参数位于函数作用域内，因此dummy_fcn函数体内用到的名字height指的是参数声明<br>此例中height参数隐藏了同名的成员。如果想绕开上面的查找规则：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Screen::dummy_fcn</span><span class="params">(pos <span class="built_in">height</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cursor</span>=<span class="built_in">width</span>*<span class="keyword">this</span>-&gt;<span class="built_in">height</span>;  <span class="comment">//成员height</span></span><br><span class="line">    <span class="comment">//另一种方式</span></span><br><span class="line">    <span class="built_in">cursor</span>=<span class="built_in">width</span>*Screen::<span class="built_in">height</span>;<span class="comment">//成员height</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最好的方式是给参数起个其它名字</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Screen::dummy_fcn</span><span class="params">(pos ht)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cursor</span> = <span class="built_in">width</span> * <span class="built_in">height</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用外层作用域的height</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Screen::dummy_fcn</span><span class="params">(pos <span class="built_in">height</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cursor</span>=<span class="built_in">width</span> * ::<span class="built_in">height</span>;</span><br></pre></td></tr></table></figure>

<h2 id="构造函数再探"><a href="#构造函数再探" class="headerlink" title="构造函数再探"></a>构造函数再探</h2><h3 id="构造函数初始值列表-1"><a href="#构造函数初始值列表-1" class="headerlink" title="构造函数初始值列表"></a>构造函数初始值列表</h3><p>如果没有在构造函数的初始值列表中显式地初始化成员，则该成员在构造函数体之前执行默认初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Sales_data::Sales_data(<span class="keyword">const</span> <span class="built_in">string</span>&amp;s,</span><br><span class="line">                        <span class="keyword">unsigned</span> cnt,<span class="keyword">double</span> price)&#123;</span><br><span class="line">    bookNo = s;</span><br><span class="line">    units_sold = cnt;</span><br><span class="line">    revenue = cnt * price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段和使用初始化列表的效果是相同的：当构造函数完成后，数据成员的值相同。区别是初始化列表版本初始化了它的数据成员，这个版本是对数据成员执行了赋值操作</p>
<h4 id="构造函数的初始值有时必不可少"><a href="#构造函数的初始值有时必不可少" class="headerlink" title="构造函数的初始值有时必不可少"></a>构造函数的初始值有时必不可少</h4><p>如果成员是const或者是引用的话，必须将其初始化。当成员属于某种类类型且该类没有定义默认构造函数时，也必须将这个成员初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConstRef</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ConstRef(<span class="keyword">int</span> i);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> ci;</span><br><span class="line">    <span class="keyword">int</span> &amp;ri;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//和其它常量对象或引用一样，ci和ri都必须被初始化</span></span><br><span class="line"><span class="comment">//因此，将引发错误</span></span><br><span class="line">ConstRef::ConstRef(<span class="keyword">int</span> ii)&#123;</span><br><span class="line">    i = ii;     <span class="comment">//正确</span></span><br><span class="line">    ci = ii;    <span class="comment">//错误：不能给const赋值</span></span><br><span class="line">    ri = ii;    <span class="comment">//错误：ri没被初始化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正确的形式应该是</span></span><br><span class="line">ConstRef::ConstRef(<span class="keyword">int</span> ii):i(ii),ci(ii),ri(ii)&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>如果成员是const、引用，或属于某种未提供默认构造函数的类类型，必须通过构造函数初始值列表为这些成员提供初始值</p>
<h4 id="成员初始化的顺序"><a href="#成员初始化的顺序" class="headerlink" title="成员初始化的顺序"></a>成员初始化的顺序</h4><p>成员初始化顺序与它们在类定义的中出现的顺序一致。构造函数初始值列表中初始值的前后位置不会影响实际的初始化顺序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//未定义的：i在j前被初始化</span></span><br><span class="line">    X(<span class="keyword">int</span> val):j(val),i(j)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="默认实参和构造函数"><a href="#默认实参和构造函数" class="headerlink" title="默认实参和构造函数"></a>默认实参和构造函数</h4><p>一个使用默认实参的构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Sales_data(<span class="built_in">string</span> s=<span class="string">" "</span>):bookNo(s)&#123;&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h3><p>委托构造函数(delegating constructor)使用它所属的类的其他构造函数执行它自己的初始化过程，或者说它把它自己的一些(或全部)职责委托给了其他构造函数<br>一个委托构造函数也有一个成员初始值的列表和一个函数体。在委托构造函数内，成员初始值列表只有唯一一个入口，就是类名本身。类名后面紧跟圆括号括起来的参数列表，参数列表必须与类中另外一个构造函数匹配</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//非维多构造函数使用对应的实参初始化成员</span></span><br><span class="line">    Sales_data(<span class="built_in">string</span> s, <span class="keyword">unsigned</span> cnt,<span class="keyword">double</span> price):</span><br><span class="line">        bookNo(s),units_sold(cnt),revenue(cnt*price)&#123;&#125;</span><br><span class="line">    <span class="comment">//其余构造函数全部委托给另一个构造函数</span></span><br><span class="line">    Sales_data():Sales_data(<span class="string">" "</span>,<span class="number">0</span>,<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    Sales_data(<span class="built_in">string</span> s):Sales_data(s,<span class="number">0</span>,<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    Sales_data(istream&amp; is):Sales_data()&#123;<span class="built_in">read</span>(is,*<span class="keyword">this</span>);&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="默认构造函数的作用"><a href="#默认构造函数的作用" class="headerlink" title="默认构造函数的作用"></a>默认构造函数的作用</h3><p>当对象被默认初始化或值初始化时自动执行默认构造函数。默认初始化在以下情况发生：<br>·在块作用域内不适用任何初始值定义一个非静态变量或者数组时<br>·当一个类本身含有类类型的成员且使用合成的默认构造函数时<br>·当类类型的成员没有在构造函数初始值列表中显示地初始化时<br>值初始化在以下情况发生：<br>·在数组初始化的过程中如果提供的初始值数量少于数组的大小时<br>·当我们不使用初始值定义一个局部静态变量时<br>·当通过书写形如T()的表达式显示地请求值初始化时，其中T是类型名</p>
<p>类必须包含一个默认构造函数以便在上述情况下使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoDefault</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NoDefault(<span class="keyword">const</span> <span class="built_in">string</span>&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    NoDefault my_mem;</span><br><span class="line">&#125;;</span><br><span class="line">A a;    <span class="comment">//错误：不能为A合成构造函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>&#123;</span></span><br><span class="line">    B()&#123;&#125;   <span class="comment">//错误：b_member没有初始值</span></span><br><span class="line">    NoDefault b_member;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="使用默认构造函数"><a href="#使用默认构造函数" class="headerlink" title="使用默认构造函数"></a>使用默认构造函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Sales_data <span class="title">obj</span><span class="params">()</span></span>;   <span class="comment">//声明了一个函数而非对象</span></span><br><span class="line">Sales_data obj2;    <span class="comment">//obj2是一个对象而非函数</span></span><br></pre></td></tr></table></figure>

<p>如果想定义一个使用默认构造函数进行初始化的对象，需要去掉对象名后的空括号对</p>
<h3 id="隐式的类类型转换"><a href="#隐式的类类型转换" class="headerlink" title="隐式的类类型转换"></a>隐式的类类型转换</h3><p>如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制，把这种构造函数称作转换构造函数(converting constructor)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> null_book=<span class="string">"999-9"</span>;</span><br><span class="line"><span class="comment">//构造一个临时的Sales_data对象</span></span><br><span class="line"><span class="comment">//units_sold和revenue等于0，bookNo等于null_book</span></span><br><span class="line">item.combine(null_book);</span><br></pre></td></tr></table></figure>

<h4 id="只允许一步类类型转换"><a href="#只允许一步类类型转换" class="headerlink" title="只允许一步类类型转换"></a>只允许一步类类型转换</h4><p>编译器只会自动地执行一步类型转换。下面代码隐式地使用了两种转换规则，所以是错误的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//"999-9"-&gt;string-&gt;Sales_data</span></span><br><span class="line">item.combine(<span class="string">"999-9"</span>);</span><br><span class="line"></span><br><span class="line">item.combine(<span class="built_in">string</span>(<span class="string">"999-9"</span>));      <span class="comment">//正确</span></span><br><span class="line">item.combine(Sales_data(<span class="string">"999-9"</span>));  <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>

<h4 id="抑制构造函数的隐式转换"><a href="#抑制构造函数的隐式转换" class="headerlink" title="抑制构造函数的隐式转换"></a>抑制构造函数的隐式转换</h4><p>可以通过将构造函数声明为explicit加以阻止</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Sales_data()=<span class="keyword">default</span>;</span><br><span class="line">    Sales_data(<span class="keyword">const</span> <span class="built_in">string</span>&amp;s,<span class="keyword">unsigned</span> n,<span class="keyword">double</span> p):</span><br><span class="line">            bookNo(s),units_sold(n),revenue(p*n)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Sales_data</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)</span>:<span class="title">bookNo</span><span class="params">(s)</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Sales_data</span><span class="params">(istream&amp;)</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此时，没有任何构造函数能用于隐式地创建Sales_data对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">item.combine(null_book);</span><br><span class="line">item.combine(<span class="built_in">cin</span>);  <span class="comment">//错误：构造函数都是explicit的</span></span><br></pre></td></tr></table></figure>

<p>explicit只对一个实参的构造函数游戏。只能在类内声明构造函数时使用explicit，在类外定义时不应重复</p>
<h4 id="explicit构造函数只能用于直接初始化"><a href="#explicit构造函数只能用于直接初始化" class="headerlink" title="explicit构造函数只能用于直接初始化"></a>explicit构造函数只能用于直接初始化</h4><p>发生隐式转换的一种情况是执行拷贝形式的初始化(使用=)。此时只能使用直接初始化而不能使用explicit构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Sales_data <span class="title">item1</span><span class="params">(null_book)</span></span>;<span class="comment">//正确：直接初始化</span></span><br><span class="line"><span class="comment">//错误：不能将explicit构造函数用于拷贝形式的初始化过程</span></span><br><span class="line">Sales_data item2=null_book;</span><br></pre></td></tr></table></figure>

<h4 id="为转换显示地使用构造函数"><a href="#为转换显示地使用构造函数" class="headerlink" title="为转换显示地使用构造函数"></a>为转换显示地使用构造函数</h4><p>可以使用explicit构造函数显示地强制进行转换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">item.combine(Sales_data(null_book));</span><br><span class="line">item.combine(<span class="keyword">static_cast</span>&lt;Sales_data&gt;(<span class="built_in">cin</span>));</span><br></pre></td></tr></table></figure>

<h4 id="标准库中含有显示构造函数的类"><a href="#标准库中含有显示构造函数的类" class="headerlink" title="标准库中含有显示构造函数的类"></a>标准库中含有显示构造函数的类</h4><p>接受一个单参数的const char*的string构造函数，不是explicit的<br>接受一个容量参数的vector构造函数，是explicit的</p>
<h3 id="聚合类"><a href="#聚合类" class="headerlink" title="聚合类"></a>聚合类</h3><p>聚合类(aggregate class)使得用户可以直接访问其成员，并且具有特殊的初始化语法形式<br>当一个类满足如下条件时，说它是聚合的：<br>·所有成员都是public的<br>·没有定义任何构造函数<br>·没有类内初始值<br>·没有基类，没有virtual函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ival;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以通过一个花括号括起来的成员初始值列表来初始化</span></span><br><span class="line">Data val1=&#123;<span class="number">0</span>,<span class="string">"Anna"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序必须一致</span></span><br><span class="line">Data val2=&#123;<span class="string">"Anna"</span>, <span class="number">1024</span>&#125;;   <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<p>显示地初始化类的对象成员存在的缺点：<br>·要求类的所有成员都是public的<br>·将正确初始化每个对象的每个成员的重任交给了类的用户。初始化过程冗长且容易出错<br>·添加或删除一个成员后，所有的初始化语句都需要更新</p>
<h3 id="字面值常量类"><a href="#字面值常量类" class="headerlink" title="字面值常量类"></a>字面值常量类</h3><p>数据成员都是字面值类型的聚合类是字面值常量类。如果一个类不是聚合类，但符合以下要求，则也是字面值常量类：<br>·数据成员都必须是字面值类型<br>·类必须至少含有一个constexpr构造函数<br>·如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，则初始值必须使用成员自己的constexpr构造函数<br>·类必须使用析构函数的默认定义，该成员负责销毁类的对象</p>
<h4 id="constexpr构造函数"><a href="#constexpr构造函数" class="headerlink" title="constexpr构造函数"></a>constexpr构造函数</h4><p>尽管构造函数不能是const的，但字面值常量类的构造函数可以是constexpr函数。constexpr构造函数可以声明成=default形式，或者是删除函数的形式。constexpr构造函数体应该是空的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Debug</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">Debug</span><span class="params">(<span class="keyword">bool</span> b=<span class="literal">true</span>)</span>:</span></span><br><span class="line">        hw(b),io(b),other(b)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">Debug</span><span class="params">(<span class="keyword">bool</span> h,<span class="keyword">bool</span> i,<span class="keyword">bool</span> o)</span>:</span></span><br><span class="line">        hw(h),io(i),other(o)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="title">any</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> hw||io||other;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_io</span><span class="params">(<span class="keyword">bool</span> b)</span></span>&#123;io=b;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_hw</span><span class="params">(<span class="keyword">bool</span> b)</span></span>&#123;hw=b;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_other</span><span class="params">(<span class="keyword">bool</span> b)</span></span>&#123;other=b;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> hw;</span><br><span class="line">    <span class="keyword">bool</span> io;</span><br><span class="line">    <span class="keyword">bool</span> other;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>constexpr构造函数必须初始化所有数据成员，初始值或者使用constexpr构造函数，或者是一条常量表达式</p>
<h2 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h2><h4 id="声明静态成员"><a href="#声明静态成员" class="headerlink" title="声明静态成员"></a>声明静态成员</h4><p>通过在成员的声明之前加上static使得其与类关联在一起</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">calculate</span><span class="params">()</span></span>&#123;amount+=amount*interestRate;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">rate</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> interestRate;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rate</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> owner;</span><br><span class="line">    <span class="keyword">double</span> amount;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> interestRate;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">initRate</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>类的静态成员存在于任何对象之外，对象中不包含任何与静态成员有关的数据。interestRate对象被所有Account对象共享<br>静态成员函数也不与任何对象绑定在一起，它们不包含this指针，静态成员函数不能声明成const的</p>
<h4 id="使用类的静态成员"><a href="#使用类的静态成员" class="headerlink" title="使用类的静态成员"></a>使用类的静态成员</h4><p>使用作用域运算符直接访问静态成员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> r;</span><br><span class="line">r=Account::rate();</span><br></pre></td></tr></table></figure>

<p>也可以使用类的对象、引用或指针来访问静态成员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Account ac1;</span><br><span class="line">Account* ac2=&amp;ac1;</span><br><span class="line"><span class="comment">//等价形式</span></span><br><span class="line">r=ac1.rate();</span><br><span class="line">r=ac2-&gt;rate();</span><br></pre></td></tr></table></figure>

<p>成员函数不用通过作用域运算符就能直接访问静态成员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">calulate</span><span class="params">()</span></span>&#123;amount+=amount*interestRate;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> interestRate;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="定义静态成员"><a href="#定义静态成员" class="headerlink" title="定义静态成员"></a>定义静态成员</h4><p>可以在类的内外定义静态成员函数。在类外时，不能重复static关键字。该关键字只出现在类内的声明语句</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Account::rate</span><span class="params">(<span class="keyword">double</span> newRate)</span></span>&#123;</span><br><span class="line">    interestRate=newRate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态数据成员不属于类的任何一个对象，所有他们并不是在创建类的对象时被定义的。意味着它们不是由类的构造函数初始化的。必须在类的外部定义和初始化每个静态成员<br>类似于全局变量，静态数据成员定义在任何函数之外。一旦被定义，就将一直存在于程序的整个生命周期中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义并初始化一个静态成员</span></span><br><span class="line"><span class="keyword">double</span> Account::interestRate=initRate();</span><br></pre></td></tr></table></figure>

<h4 id="静态成员的类内初始化"><a href="#静态成员的类内初始化" class="headerlink" title="静态成员的类内初始化"></a>静态成员的类内初始化</h4><p>通常情况下，类的静态成员不应该在类内初始化。但可以为静态成员提供const整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的constexpr。初始值必须是常量表达式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">rate</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> interestRate;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rate</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> period = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">double</span> daily_tbl[period];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>即使一个静态常量数据成员在类内被初始化了，通常情况下也应该在类外定义一下该成员</p>
<h4 id="静态成员能用于某些场景，而普通成员不能"><a href="#静态成员能用于某些场景，而普通成员不能" class="headerlink" title="静态成员能用于某些场景，而普通成员不能"></a>静态成员能用于某些场景，而普通成员不能</h4><p>静态数据成员可以是不完全类型。静态数据成员的类型可以就是它所属的类型，而费静态数据成员则受到限制，只能声明成它所属类的指针或引用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Bar mem1;    <span class="comment">//正确：静态成员可以是不完全类型</span></span><br><span class="line">    Bar* mem2;  <span class="comment">//正确：指针成员可以是不完全类型</span></span><br><span class="line">    Bar mem3;   <span class="comment">//错误：数据成员必须是完全类型</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>

<p>静态成员可以作为默认实参</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//bkground表示一个在类中稍后定义的静态成员</span></span><br><span class="line">    <span class="function">Screen&amp; <span class="title">clear</span><span class="params">(<span class="keyword">char</span> = bkground)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> bkground;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>非静态成员不能作为默认实参，因为它的值本身属于对象的一部分，这么做的结果是无法真正提供一个对象以便从中获取成员的值，最终将引发错误</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/11/20/ncpp-07/" data-id="ckhua8row002yxsve6wyu2mjt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/02-cpp-primer/" rel="tag">02 cpp primer</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/11/22/ncpp-08/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          ncpp-08
        
      </div>
    </a>
  
  
    <a href="/2020/11/19/ncpp-06/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">第6章 函数</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/02-cpp-primer/" rel="tag">02 cpp primer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c-primer/" rel="tag">c++ primer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cocos2d-x/" rel="tag">cocos2d-x</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpp-notes/" rel="tag">cpp notes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/problem-library/" rel="tag">problem library</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reading-notes-DS/" rel="tag">reading notes DS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%82%93%E4%BF%8A%E8%BE%89/" rel="tag">数据结构 邓俊辉</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/02-cpp-primer/" style="font-size: 15px;">02 cpp primer</a> <a href="/tags/c-primer/" style="font-size: 17.5px;">c++ primer</a> <a href="/tags/cocos2d-x/" style="font-size: 12.5px;">cocos2d-x</a> <a href="/tags/cpp-notes/" style="font-size: 20px;">cpp notes</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/problem-library/" style="font-size: 15px;">problem library</a> <a href="/tags/reading-notes-DS/" style="font-size: 10px;">reading notes DS</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%82%93%E4%BF%8A%E8%BE%89/" style="font-size: 17.5px;">数据结构 邓俊辉</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/08/06/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B81/">c++ primer 04 表达式</a>
          </li>
        
          <li>
            <a href="/2020/11/23/ncpp-09/">第9章 顺序容器</a>
          </li>
        
          <li>
            <a href="/2020/11/22/ncpp-08/">ncpp-08</a>
          </li>
        
          <li>
            <a href="/2020/11/20/ncpp-07/">第7章 类</a>
          </li>
        
          <li>
            <a href="/2020/11/19/ncpp-06/">第6章 函数</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>
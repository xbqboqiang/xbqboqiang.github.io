<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>c++ primer 13 拷贝控制 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="拷贝控制拷贝控制操作(copy control)：拷贝构造函数(copy constructor)、拷贝赋值运算符(copy-assignment operator)、移动构造函数(move constructor)、移动赋值运算符(move-assignment operator)和析构函数是(destructor)拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么拷贝和移动赋值">
<meta property="og:type" content="article">
<meta property="og:title" content="c++ primer 13 拷贝控制">
<meta property="og:url" content="http://yoursite.com/2020/08/30/c-primer-13-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="拷贝控制拷贝控制操作(copy control)：拷贝构造函数(copy constructor)、拷贝赋值运算符(copy-assignment operator)、移动构造函数(move constructor)、移动赋值运算符(move-assignment operator)和析构函数是(destructor)拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么拷贝和移动赋值">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-08-30T02:46:44.000Z">
<meta property="article:modified_time" content="2020-08-30T02:51:04.892Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="c++ primer">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-c-primer-13-拷贝控制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/30/c-primer-13-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/" class="article-date">
  <time datetime="2020-08-30T02:46:44.000Z" itemprop="datePublished">2020-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      c++ primer 13 拷贝控制
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="拷贝控制"><a href="#拷贝控制" class="headerlink" title="拷贝控制"></a>拷贝控制</h1><p>拷贝控制操作(copy control)：拷贝构造函数(copy constructor)、拷贝赋值运算符(copy-assignment operator)、<br>移动构造函数(move constructor)、移动赋值运算符(move-assignment operator)和析构函数是(destructor)<br>拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么<br>拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么<br>析构函数定义了当此类型对象销毁时做什么<br>一个类没有定义所有这些拷贝控制成员，编译器会自动为它定义缺失的操作</p>
<p>拷贝构造函数<br>如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">public:</span><br><span class="line">	Foo();           &#x2F;&#x2F;默认构造函数</span><br><span class="line">	Foo(const Foo&amp;); &#x2F;&#x2F;拷贝构造函数</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>拷贝构造函数的第一个参数必须是一个引用类型</p>
<p>如果我们没有为类定义拷贝构造函数，编译器会为我们定义一个合成拷贝构造函数(synthesized copy constructor)<br>合成拷贝构造函数通过编译器从给定对象中一次将每个非static成员拷贝到正在创建的对象中<br>类类型的成员使用其拷贝构造函数来拷贝；内置类型的成员则直接拷贝</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Sales_data &#123;</span><br><span class="line">public:</span><br><span class="line">	Sales_data(const Sales_data&amp;); &#x2F;&#x2F;与合成的拷贝构造函数等价的拷贝构造函数的声明</span><br><span class="line">private:</span><br><span class="line">	string bookNo;</span><br><span class="line">	int units_sold &#x3D; 0;</span><br><span class="line">	double revenue &#x3D; 0.0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>与Sales_data的合成拷贝构造函数等价</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sales_data::Sales_data(const Sales_data&amp; orig);</span><br><span class="line">bookNo(orig.bookNo),          &#x2F;&#x2F;使用string的拷贝构造函数</span><br><span class="line">units_sold(orig.units_sold),  &#x2F;&#x2F;拷贝orig.units_sold</span><br><span class="line">revenue(orig.revenue)         &#x2F;&#x2F;拷贝orig.revenue</span><br><span class="line">&#123; &#125;							  &#x2F;&#x2F;空函数体</span><br></pre></td></tr></table></figure>
<p>拷贝初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string dots(10, &#39;.&#39;);        &#x2F;&#x2F;直接初始化</span><br><span class="line">string s(dots);				&#x2F;&#x2F;直接初始化</span><br><span class="line">string s2 &#x3D; dots;			&#x2F;&#x2F;拷贝初始化</span><br><span class="line">string null_book &#x3D; &quot;999-9&quot;; &#x2F;&#x2F;拷贝初始化</span><br><span class="line">string nines &#x3D; string(100, &#39;9&#39;); &#x2F;&#x2F;拷贝初始化</span><br></pre></td></tr></table></figure>
<p>直接初始化是要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数；拷贝初始化是要求编译器将右侧运算对象拷贝到种族创建的对象中，需要的话进行类型转换<br>拷贝初始化除了”=”定义变量时<br>·将一个对象作为实参传递给一个非引用类型的形参<br>·从一个返回类型为非引用类型的函数返回一个对象<br>·用花括号列表初始化一个数组中的元素或一个聚合类中的成员<br>初始化标准库容器或调用其insert或push成员时，容器会对其元素进行拷贝初始化；用emplace成员创建的元素都进行直接初始化<br>拷贝构造函数被用来初始化非引用类类型参数，如果拷贝构造函数其参数不是引用类型，则调用永远不会成功–为了调用拷贝构造函数，必须拷贝它的实参，但为了拷贝实参，又需要调用拷贝构造函数，无限循环</p>
<p>vector的接受单一大小参数的构造函数是explicit的，传递实参或从函数返回一个值时，不能隐式使用一个explicit构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt;v1(10); &#x2F;&#x2F;正确：直接初始化</span><br><span class="line">vector&lt;int&gt;v2 &#x3D; 10; &#x2F;&#x2F;错误：接受大小参数的构造函数是explicit的</span><br><span class="line">void f(vector&lt;int&gt;); &#x2F;&#x2F;f参数进行拷贝初始化</span><br><span class="line">f(10);               &#x2F;&#x2F;错误：不能用一个explicit的构造函数拷贝一个实参</span><br><span class="line">f(vector&lt;int&gt;(10)); &#x2F;&#x2F;正确：从一个int直接构造一个临时vector</span><br></pre></td></tr></table></figure>
<p>编译器可以绕过拷贝构造函数，但拷贝 / 移动构造函数必须是存在且可访问的(如，不能是private的)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string null_book &#x3D; (&quot;99999&quot;);</span><br><span class="line">string null_book(&quot;99999&quot;);</span><br></pre></td></tr></table></figure>
<p>拷贝赋值运算符<br>赋值运算符通常应该返回一个指向其左侧运算对象的引用<br>合成拷贝运算符通常会将右侧运算对象的每个非static成员赋予左侧运算对象的对应成员</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Sales_data&amp; Sales_data::operator&#x3D;(const Sales_data&amp; rhs) &#123;</span><br><span class="line">	bookNo &#x3D; rhs.bookNo;		&#x2F;&#x2F;调用string::operator&#x3D;</span><br><span class="line">	units_sold &#x3D; rhs.units_sold;&#x2F;&#x2F;使用内置的int赋值</span><br><span class="line">	revenue &#x3D; rhs.revenue;		&#x2F;&#x2F;使用内置的double赋值</span><br><span class="line">	return*this;				&#x2F;&#x2F;返回一个此对象的引用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>析构函数<br>析构函数释放对象使用的资源，并销毁对象的非static数据成员。没有返回值，也不接受参数。所以不能被重载，只会有唯一一个析构函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">public:</span><br><span class="line">	~Foo();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在析构函数中，首先执行函数体，然后销毁成员，按照初始化顺序的逆序销毁<br>隐式销毁一个内置指针类型的成员不会delete它所指的对象</p>
<p>调用析构函数<br>·变量在离开其作用域时被销毁<br>·当一个对象被销毁时，其成员被销毁<br>·容器被销毁时，其元素被销毁<br>·对于动态分配的对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	Sales_data * p &#x3D; new Sales_data;	&#x2F;&#x2F;p是内置指针</span><br><span class="line">	auto p2 &#x3D; make_shared&lt;Sales_data&gt;();&#x2F;&#x2F;p2是shared_ptr</span><br><span class="line">	Sales_data item(p*);				&#x2F;&#x2F;拷贝构造函数将*p拷贝到item中</span><br><span class="line">	vector&lt;Sales_data&gt;v;				&#x2F;&#x2F;局部对象</span><br><span class="line">	v.push_back(*p2);					&#x2F;&#x2F;拷贝p2指向的对象</span><br><span class="line">	delete p;							&#x2F;&#x2F;对p指向的对象执行析构函数</span><br><span class="line">&#125;&#x2F;&#x2F;退出局部作用域，对item,v,p2调用析构函数</span><br></pre></td></tr></table></figure>
<p>当一个类未定义自己的析构函数时，编译器会为它定义一个合成析构函数(synthesized destructor)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Sales_data &#123;</span><br><span class="line">public:</span><br><span class="line">	~Sales_data() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>等价于合成析构函数<br>析构函数自身并不直接销毁成员，是在析构函数体之后隐含的析构阶段中被销毁的<br>合成析构函数不会delete一个指针数据成员<br>一个类如果需要自定义析构函数，几乎可以肯定也需要自定义拷贝赋值运算符和拷贝构造函数（指针）<br>需要一个拷贝构造函数，几乎可以肯定也需要拷贝赋值运算符，反之亦然</p>
<p>可以通过将拷贝控制成员定义为=default来显式地要求编译器生成合成的版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Sales_data &#123;</span><br><span class="line">	Sales_data() &#x3D; default;</span><br><span class="line">	Sales_data(const Sales_data&amp;) &#x3D; default;</span><br><span class="line">	Sales_data&amp; operator&#x3D;(const Sales_data&amp;);</span><br><span class="line">	~Sales_data() &#x3D; default;</span><br><span class="line">&#125;;</span><br><span class="line">Sales_data&amp; Sales_data::operator&#x3D;(const Sales_data&amp;) &#x3D; default;</span><br></pre></td></tr></table></figure>
<p>类内用=default，歌城的函数将隐式地声明为内联的</p>
<p>阻止拷贝<br>可以通过将拷贝构造函数和拷贝赋值运算符定义为删除的函数(delete function)来阻止拷贝<br>删除的函数：虽然声明了它们，但不能以任何方式使用它们。在参数列表后加上=delete</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct NoCopy &#123;</span><br><span class="line">	NoCopy() &#x3D; default;		&#x2F;&#x2F;使用合成的默认构造函数</span><br><span class="line">	NoCopy(const NoCopy&amp;) &#x3D; delete; &#x2F;&#x2F;阻止拷贝</span><br><span class="line">	NoCopy&amp; operator&#x3D;(const NoCopy&amp;) &#x3D; delete;&#x2F;&#x2F;阻止赋值</span><br><span class="line">	~NoCopy() &#x3D; default; &#x2F;&#x2F;使用合成的析构函数</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>=delete必须出现在第一次声明的时候，可以对任何函数用</p>
<p>析构函数不能是删除的成员<br>对于删除了析构函数的类型，不能定义该类型的变量或成员，但可以动态分配这种类型的对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct NoDtor &#123;</span><br><span class="line">	NoDtor() &#x3D; default;</span><br><span class="line">	~NoDtor() &#x3D; delete;</span><br><span class="line">&#125;;</span><br><span class="line">NoDtor nd;			&#x2F;&#x2F;错误：NoDtor的析构函数是删除的</span><br><span class="line">NoDtor* p &#x3D; new Dtor(); &#x2F;&#x2F;正确</span><br><span class="line">delete p;			&#x2F;&#x2F;错误：NoDtor的析构函数是删除的</span><br></pre></td></tr></table></figure>
<p>对某些类，编译器将合成的成员定义为删除的函数：<br>·类的某个成员的析构函数是删除的或不可访问的(如private)，则类的合成析构函数被定义为删除的<br>·类的某个成员的拷贝构造函数或析构函数是删除的或不可访问的，则类的合成拷贝构造函数被定义为删除的；<br>·如果类的某个成员的拷贝赋值运算符是删除的或不可访问的，或是类有一个const的或引用成员，则类的合成拷贝赋值运算符被定义为删除的<br>·如果类的某个成员的析构函数是删除的或不可访问的，或是类有一个引用成员，它没有类内初始化器，或是类有一个const成员，它没有类内<br>初始化器且其类型未显示定义默认构造函数，则该类的默认构造函数被定义为删除的<br>本质上，规则：类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的<br>删除的或不可访问的析构函数-&gt;可能会创建出无法销毁的对象；<br>引用成员或const成员-&gt;编译器不会为其合成默认构造函数</p>
<p>行为像值的类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class HasPtr &#123;</span><br><span class="line">public:</span><br><span class="line">	HasPtr(const string&amp; s &#x3D; string()):ps(new string(s)),i(0)&#123;&#125;</span><br><span class="line">	HasPtr(const HasPtr&amp; p) :ps(new string(*p.ps)), i(p.i) &#123;&#125;</span><br><span class="line">	HasPtr&amp; operator&#x3D;(const HasPtr&amp;);</span><br><span class="line">	~HasPtr() &#123; delete ps; &#125;</span><br><span class="line">private:</span><br><span class="line">	string* ps;</span><br><span class="line">	int i;</span><br><span class="line">&#125;;</span><br><span class="line">HasPtr&amp; HasPtr::operator&#x3D;(const HasPtr&amp; rhs) &#123;</span><br><span class="line">	auto newp &#x3D; new string(*rhs.ps);</span><br><span class="line">	delete ps;</span><br><span class="line">	ps &#x3D; newp;</span><br><span class="line">	i &#x3D; rhs.i;</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>赋值运算符：<br>·将一个对象赋予它自身，赋值运算符必须能正确工作<br>·大多数赋值运算符组合了析构函数和拷贝构造函数<br>先将右侧运算对象拷贝到一个局部临时对象中，拷贝完成后，销毁左侧运算对象的现有成员就是安全的了。<br>否则，若rhs和本对象是同一个对象，delete ps会释放<em>this和rhs指向的string，接下来new表达式中试图拷贝</em>(rhs.ps)时就会访问一个指向无效内存的指针，是未定义的</p>
<p>行为像指针的类<br>设计引用计数<br>·除初始化对象外，每个构造函数(拷贝构造除外)还要创建一个引用计数。创建对象时将其初始化为1<br>·拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享的计数器<br>·析构函数递减计数器。变为0则释放状态<br>·拷贝赋值运算符递增右侧运算对象计数器，递减左侧。左侧变为0则销毁状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class HasPtr &#123;</span><br><span class="line">public:</span><br><span class="line">	HasPtr(const string&amp; s &#x3D; string()):ps(new string(s)),i(0),use(new size_t(1))&#123;&#125;</span><br><span class="line">	HasPtr(const HasPtr&amp; p) :ps(p.ps), i(p.i), use(p.use) &#123; ++*use; &#125;</span><br><span class="line">	HasPtr&amp; operator&#x3D;(const HasPtr&amp;);</span><br><span class="line">	~HasPtr();</span><br><span class="line">private:</span><br><span class="line">	string* ps;</span><br><span class="line">	int i;</span><br><span class="line">	size_t* use; &#x2F;&#x2F;用来记录有多少个共享ps的成员</span><br><span class="line">&#125;;</span><br><span class="line">HasPtr::~HasPtr() &#123;</span><br><span class="line">	if (--use &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		delete ps; &#x2F;&#x2F;释放string内存</span><br><span class="line">		delete use;&#x2F;&#x2F;释放计数器内存</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">HasPtr&amp; HasPtr::operator&#x3D;(const HasPtr&amp; rhs) &#123;</span><br><span class="line">	++* rhs.use;</span><br><span class="line">	if (-- * use &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		delete ps;</span><br><span class="line">		delete use;</span><br><span class="line">	&#125;</span><br><span class="line">	ps &#x3D; rhs.ps;</span><br><span class="line">	i &#x3D; rhs.i;</span><br><span class="line">	use &#x3D; rhs.use;</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>交换操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class HasPtr &#123;</span><br><span class="line">	friend void swap(HasPtr&amp;, HasPtr&amp;);</span><br><span class="line">&#125;;</span><br><span class="line">inline void swap(HasPtr&amp; lhs, HasPtr&amp; rhs) &#123;</span><br><span class="line">	using std::swap;</span><br><span class="line">	swap(lhs.ps, rhs.ps); &#x2F;&#x2F;交换指针，而不是string数据</span><br><span class="line">	swap(lhs.i, rhs.i);   &#x2F;&#x2F;交换int成员</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本例中数据成员是内置类型的，而内置类型是没有特定版本的swap，所以调用标准库std::swap。<br>如果一个类的成员有自己类型特定的swap，调用std::swap就是错误的</p>
<p>在赋值运算符中使用swap</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HasPtr&amp; HasPtr::operator&#x3D;(HasPtr rhs) &#123;</span><br><span class="line">	swap(*this, rhs); &#x2F;&#x2F;rhs现在指向本对象曾经使用的内存</span><br><span class="line">	return *this;	  &#x2F;&#x2F;rhs被销毁，从而delete了rhs中的指针</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>rhs是按值传递，意味着HasPtr的拷贝构造函数将右侧运算对象中的string拷贝到rhs。rhs是右侧运算对象的一个副本。<br>swap调用之后，*this中的指针成员将指向新分配的string–右侧运算对象中string的一个副本<br>赋值运算符结束时，rhs被销毁，HasPtr的析构函数将执行，释放掉左侧运算对象中原来的内存。是天然异常安全的</p>
<p>拷贝控制示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">class Message &#123;</span><br><span class="line">	friend class Folder;</span><br><span class="line">public:</span><br><span class="line">	explicit Message(const string&amp; str &#x3D; &quot;&quot;) :contents(str) &#123;&#125;</span><br><span class="line">	Message(const Message&amp;);</span><br><span class="line">	Message&amp; operator&#x3D;(const Message&amp;);</span><br><span class="line">	~Message();</span><br><span class="line">	&#x2F;&#x2F;从给定Folder中添加、删除本Message</span><br><span class="line">	void save(Folder&amp;);</span><br><span class="line">	void remove(Folder&amp;);</span><br><span class="line">private:</span><br><span class="line">	string contents;</span><br><span class="line">	set&lt;Folder*&gt;folders;</span><br><span class="line">	void add_to_Folders(const Message&amp;);</span><br><span class="line">	void remove_from_Folders();</span><br><span class="line">&#125;;</span><br><span class="line">void Message::save(Folder&amp; f) &#123;</span><br><span class="line">	folders.insert(&amp;f); &#x2F;&#x2F;将给定Folder添加到我们的Folder列表中</span><br><span class="line">	f.addMsg(this);		&#x2F;&#x2F;将本Message添加到f的Message集合中</span><br><span class="line">&#125;</span><br><span class="line">void Message::remove(Folder&amp; f) &#123;</span><br><span class="line">	folders.erase(&amp;f);</span><br><span class="line">	f.remMsg(this);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;将本Message添加到指向m的Folder中</span><br><span class="line">void Message::add_to_Folders(const Message&amp; m) &#123;</span><br><span class="line">	for (auto f : m.folders) &#x2F;&#x2F;对每个包含m的Folder</span><br><span class="line">		f-&gt;addMsg(this);	 &#x2F;&#x2F;向该Folder添加一个指向本Message的指针</span><br><span class="line">&#125;</span><br><span class="line">Message::Message(const Message&amp; m) :contents(m.contents), folders(m.folders) &#123;</span><br><span class="line">	add_to_Folders(m);  &#x2F;&#x2F;将本消息添加到指向m的Folder中</span><br><span class="line">&#125;</span><br><span class="line">void Message::remove_from_Folders() &#123;</span><br><span class="line">	for (auto f : folders) &#x2F;&#x2F;对folders中每个指针</span><br><span class="line">		f-&gt;remMsg(this);   &#x2F;&#x2F;从该Folder中删除本Message</span><br><span class="line">&#125;</span><br><span class="line">Message::~Message() &#123;</span><br><span class="line">	remove_from_Folders();</span><br><span class="line">&#125;</span><br><span class="line">Message&amp; Message::operator&#x3D;(const Message&amp; rhs) &#123;</span><br><span class="line">	remove_from_Folders();	&#x2F;&#x2F;更新已有Folder</span><br><span class="line">	contents &#x3D; rhs.contents;&#x2F;&#x2F;从rhs拷贝消息内容</span><br><span class="line">	folders &#x3D; rhs.folders;  &#x2F;&#x2F;从rhs拷贝Folder指针</span><br><span class="line">	add_to_Folders(rhs);	&#x2F;&#x2F;将本Message添加到那些Folder中</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br><span class="line">void swap(Message&amp; lhs, Message&amp; rhs) &#123;</span><br><span class="line">	using std::swap;</span><br><span class="line">	&#x2F;&#x2F;将每个消息的指针从它(原来)所在Folder中删除</span><br><span class="line">	for (auto f : lhs.folders)</span><br><span class="line">		f-&gt;remMsg(&amp;lhs);</span><br><span class="line">	for (auto f : rhs.folders)</span><br><span class="line">		f-&gt;remMsg(&amp;rhs);</span><br><span class="line">	&#x2F;&#x2F;交换contents和Folder指针set</span><br><span class="line">	swap(lhs.folders, rhs.folders);</span><br><span class="line">	swap(lhs.contents, rhs.contents);</span><br><span class="line">	&#x2F;&#x2F;将每个Message的指针添加到它的(新)Folder中</span><br><span class="line">	for (auto f : lhs.folders)</span><br><span class="line">		f-&gt;addMsg(&amp;lhs);</span><br><span class="line">	for (auto f : rhs.folders)</span><br><span class="line">		f-&gt;addMsg(&amp;rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>动态内存管理类<br>vector<string>的一个简化版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">class StrVec &#123;</span><br><span class="line">public:</span><br><span class="line">	StrVec() :elements(nullptr), first_free(nullptr), cap(nullptr) &#123;&#125;</span><br><span class="line">	StrVec(const StrVec&amp;);				&#x2F;&#x2F;拷贝构造函数</span><br><span class="line">	StrVec&amp; operator&#x3D;(const StrVec&amp;);	&#x2F;&#x2F;拷贝赋值操作符</span><br><span class="line">	~StrVec();</span><br><span class="line">	void push_back(const string&amp;);</span><br><span class="line">	size_t size() const &#123; return first_free - elements; &#125;</span><br><span class="line">	size_t capacity() const &#123; return cap - elements; &#125;</span><br><span class="line">	string* begin() const &#123; return elements; &#125;</span><br><span class="line">	string* end()const &#123; return first_free; &#125;</span><br><span class="line">private:</span><br><span class="line">	Static allocator&lt;string&gt;alloc;</span><br><span class="line">	void chk_n_alloc() &#123;	&#x2F;&#x2F;被添加元素的函数所使用</span><br><span class="line">		if (size() &#x3D;&#x3D; capacity())reallocate();</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;被拷贝构造函数、赋值运算符和析构函数所使用</span><br><span class="line">	pair&lt;string*, string*&gt; alloc_n_copy(const string*, const string*);</span><br><span class="line">	void free();			&#x2F;&#x2F;销毁元素并释放内存</span><br><span class="line">	void reallocate();		&#x2F;&#x2F;获得更多内存并拷贝已有元素</span><br><span class="line">	string* elements;		&#x2F;&#x2F;指向数组首元素的指针</span><br><span class="line">	string* first_free();	&#x2F;&#x2F;指向数组第一个空闲元素的指针</span><br><span class="line">	string* cap();			&#x2F;&#x2F;指向数组尾后位置的指针</span><br><span class="line">&#125;;</span><br><span class="line">void StrVec::push_back(const string&amp; s) &#123;</span><br><span class="line">	chk_n_alloc();</span><br><span class="line">	&#x2F;&#x2F;在first_free指向的元素中构造s的副本</span><br><span class="line">	alloc.construct(first_free++, s);</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;string*,string*&gt;</span><br><span class="line">StrVec::alloc_n_copy(const string* b, const string* e) &#123;</span><br><span class="line">	auto data &#x3D; alloc.allocate(e - b);</span><br><span class="line">	return &#123; data,uninitialized_copy(b,e,data) &#125;;</span><br><span class="line">&#125;</span><br><span class="line">void StrVec::free() &#123;</span><br><span class="line">	if (elements) &#123;</span><br><span class="line">		for (auto p &#x3D; first_free; p !&#x3D; elements;)</span><br><span class="line">			alloc.destory(--p);</span><br><span class="line">		alloc.deallocate(elements, cap - elements);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">StrVec::StrVec(const StrVec&amp; s) &#123;</span><br><span class="line">	auto newdata &#x3D; alloc_n_copy(s.begin(), s.end());</span><br><span class="line">	elements &#x3D; newdata.first;</span><br><span class="line">	first_free &#x3D; cap &#x3D; newdata.second;</span><br><span class="line">&#125;</span><br><span class="line">StrVec::~StrVec() &#123;</span><br><span class="line">	free();</span><br><span class="line">&#125;</span><br><span class="line">StrVec&amp; StrVec::operator&#x3D;(const StrVec&amp; rhs) &#123;</span><br><span class="line">	&#x2F;&#x2F;调用alloc_n_copy分配内存，大小与rhs中元素占用空间一样多</span><br><span class="line">	auto data &#x3D; alloc_n_copy(rhs.begin(), rhs.end());</span><br><span class="line">	free();</span><br><span class="line">	elements &#x3D; data.first;</span><br><span class="line">	first_free &#x3D; cap &#x3D; data.second;</span><br><span class="line">	return*this;</span><br><span class="line">&#125;</span><br><span class="line">void StrVec::reallocate() &#123;</span><br><span class="line">	auto newcapacity &#x3D; size() ? 2 * size() : 1;</span><br><span class="line">	auto newdata &#x3D; alloc.allocate(newcapacity); &#x2F;&#x2F;分配新内存</span><br><span class="line">	&#x2F;&#x2F;将数据从旧内存移到新内存</span><br><span class="line">	auto dest &#x3D; newdata; &#x2F;&#x2F;指向新数组中下一个空闲位置</span><br><span class="line">	auto elem &#x3D; elements;&#x2F;&#x2F;指向旧数组中下一个元素</span><br><span class="line">	for (size_t i &#x3D; 0; i !&#x3D; size(); ++i) &#123;</span><br><span class="line">		alloc.construct(dest++, move(*elem++));</span><br><span class="line">	&#125;</span><br><span class="line">	free();</span><br><span class="line">	elements &#x3D; newdata;</span><br><span class="line">	first_free &#x3D; dest;</span><br><span class="line">	cap &#x3D; elements + newcapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>移动构造函数move，避免了string的拷贝</p>
<p>标准库容器、string和shared_ptr类既支持移动也支持拷贝。IO类和unique_ptr可以移动但不能拷贝</p>
<p>右值引用(rvalue reference) &amp;&amp;<br>必须绑定到右值的引用，只能绑定到一个将要销毁的对象<br>一般而言，左值表达式是一个对象的身份，右值表达式表示的是对象的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D; 42;</span><br><span class="line">int&amp; r &#x3D; i;			&#x2F;&#x2F;正确：r引用i</span><br><span class="line">int&amp;&amp; rr &#x3D; i;		&#x2F;&#x2F;错误：不能将一个右值引用绑定到一个左值上</span><br><span class="line">int&amp; r2 &#x3D; i * 42;	&#x2F;&#x2F;错误：i*42是一个右值</span><br><span class="line">const int&amp; r3 &#x3D; i * 42; &#x2F;&#x2F;正确：可以将一个const引用绑定到一个右值上</span><br><span class="line">int&amp;&amp; rr2 &#x3D; i * 42;	&#x2F;&#x2F;正确：将rr2绑定到乘法结果上</span><br></pre></td></tr></table></figure>
<p>返回左值表达式：返回左值引用的函数、赋值、下标、解引用、前置递增 / 递减运算符<br>返回右值表达式：返回非引用类型的函数、算术、关系、位、后置递增 / 递减运算符<br>左值有持久的状态，右值是字面常量或者表达式求值过程中创建的临时对象<br>变量是左值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int&amp;&amp; rr &#x3D; 42;	&#x2F;&#x2F;正确：字面常量是右值</span><br><span class="line">int&amp;&amp; rr2 &#x3D; rr;	&#x2F;&#x2F;错误：表达式rr是左值</span><br></pre></td></tr></table></figure>
<p>可以显式地将一个左值转换为对应右值的引用类型。可以通过调用一个move来获得绑定到左值上的右值引用，move在头文件utility中<br>int&amp;&amp; rr3 = std::move(rr1);<br>move调用告诉编译器：希望像右值一样处理一个左值。除了对rr1赋值或销毁外不再使用它。</p>
<p>移动构造函数和移动赋值运算符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StrVec::StrVec(StrVec&amp;&amp; s)noexcept &#x2F;&#x2F;移动操作不应抛出任何异常</span><br><span class="line">	:elements(s.elements), first_free(s.first_free), cap(s.cap) &#123;</span><br><span class="line">	s.elements &#x3D; s.first_free &#x3D; s.cap &#x3D; nullptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>noexcept出现在参数列表和初始化列表开始的冒号之间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class StrVec &#123;</span><br><span class="line">public:</span><br><span class="line">	StrVec(StrVec&amp;&amp;)noexcept;</span><br><span class="line">&#125;;</span><br><span class="line">StrVec::StrVec(StrVec&amp;&amp; s)noexcept :&#x2F;*初始化器*&#x2F;&#123;&#x2F;*构造函数体*&#x2F;&#125;</span><br></pre></td></tr></table></figure>
<p>若移动了部分元素后抛出异常会产生问题。</p>
<p>移动赋值运算符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">StrVec&amp; StrVec::operator&#x3D;(StrVec&amp;&amp; rhs) noexcept &#123;</span><br><span class="line">	&#x2F;&#x2F;直接检测自赋值</span><br><span class="line">	if (this !&#x3D; rhs) &#123;</span><br><span class="line">		free();</span><br><span class="line">		elements &#x3D; rhs.elements;</span><br><span class="line">		first_free &#x3D; rhs.first_free;</span><br><span class="line">		cap &#x3D; rhs.cap;</span><br><span class="line">		rhs.elements &#x3D; rhs.first_free &#x3D; rhs.cap &#x3D; nullptr;</span><br><span class="line">	&#125;</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不能在使用右侧运算对象的资源之前就释放左侧运算对象的资源(可能是相同的资源)</p>
<p>合成的移动操作<br>如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符了。会通过正常的函数匹配，用对应的拷贝操作来代替移动操作<br>只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct X &#123;</span><br><span class="line">	int i;</span><br><span class="line">	string s;</span><br><span class="line">&#125;;</span><br><span class="line">struct hasX &#123;</span><br><span class="line">	X mem;</span><br><span class="line">&#125;;</span><br><span class="line">X x, x2 &#x3D; std::move(x);			&#x2F;&#x2F;使用合成的移动构造函数</span><br><span class="line">hasX hx, hx2 &#x3D; std::move(hx);	&#x2F;&#x2F;使用合成的移动构造函数</span><br></pre></td></tr></table></figure>
<p>移动操作永远不会隐式定义为删除的函数。但如果显式地要求编译器生成=default的移动操作，且编译器不能移动所有成员，则编译器会将移动操作定义为删除的函数。<br>将合成的移动操作定义为删除的函数：<br>·移动构造函数被定义为删除的函数：有类成员定义了自己的拷贝构造函数且未定义移动构造函数；有类成员未定义自己的拷贝构造函数且编译器不能为其合成移动构造函数。移动赋值运算符的情况类似<br>·如果有类成员的移动构造函数或移动赋值运算符呗定义为删除的或是不可访问的，则类的移动构造函数或移动赋值运算符被定义为删除的<br>·如果类的析构函数被定义为删除的或不可访问的，则类的移动构造函数被定义为删除的<br>·如果有类成员是const的或引用，则类的移动赋值运算符被定义为删除的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;假定Y是一个类，定义了自己的拷贝构造函数，但未定义自己的移动构造函数</span><br><span class="line">struct hasY &#123;</span><br><span class="line">	hasY() &#x3D; default;</span><br><span class="line">	hasY(hasY&amp;&amp;) &#x3D; default;</span><br><span class="line">	Y mem;	&#x2F;&#x2F;hansY将有一个删除的移动构造函数</span><br><span class="line">&#125;;</span><br><span class="line">hanY hy, hy2 &#x3D; std::move(hy);	&#x2F;&#x2F;错误：移动构造函数是删除的</span><br></pre></td></tr></table></figure>
<p>类hasY显式地要求一个移动构造函数，但编译器无法为其生成<br>如果一个类定义了一个移动构造函数和 / 或一个移动赋值运算符，则该类的合成拷贝构造函数和拷贝赋值运算符会被定义为删除的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StrVec v1, v2;</span><br><span class="line">v1 &#x3D; v2;					&#x2F;&#x2F;v2是左值；使用拷贝赋值</span><br><span class="line">StrVec getVec(istream&amp;);	&#x2F;&#x2F;getVec返回一个右值</span><br><span class="line">v2 &#x3D; getVec(cin);			&#x2F;&#x2F;getVec(cin)是一个右值；使用移动赋值</span><br></pre></td></tr></table></figure>
<p>表达式v2是一个左值，不能隐式地将一个右值引用绑定到一个左值，所以使用拷贝赋值运算符<br>第二个中表达式是一个右值，两个赋值运算符都是可行的。但调用拷贝赋值运算符需要进行一次到const的转换，而StrVec&amp;&amp;是精确匹配。所以第二个用移动赋值运算符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">public:</span><br><span class="line">	Foo() &#x3D; default;</span><br><span class="line">	Foo(const Foo&amp;); &#x2F;&#x2F;拷贝构造函数</span><br><span class="line">&#125;;</span><br><span class="line">Foo x;</span><br><span class="line">Foo y(x);				&#x2F;&#x2F;拷贝构造函数；x是一个左值</span><br><span class="line">Foo z(std::move(x));	&#x2F;&#x2F;拷贝构造函数；未定义移动构造函数</span><br></pre></td></tr></table></figure>
<p>定义了拷贝构造函数就不会生成合成移动构造函数</p>
<p>拷贝并交换赋值运算符和移动操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class HasPtr &#123;</span><br><span class="line">public:</span><br><span class="line">	&#x2F;&#x2F;添加的移动构造函数</span><br><span class="line">	HasPtr(HasPtr&amp;&amp; p)noexcept :ps(p.ps), i(p.i) &#123; p.ps &#x3D; 0; &#125;</span><br><span class="line">	&#x2F;&#x2F;赋值运算符既是移动赋值运算符也是拷贝赋值运算符</span><br><span class="line">	HasPtr&amp; operator&#x3D;(HasPtr rhs) &#123;</span><br><span class="line">		swap(*this, rhs);</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为类添加了一个移动构造函数，接管了给定实参的值。构造体将给定的HasPtr的指针置为0，从而确保销毁移后源对象是安全的<br>赋值运算符有一个非引用参数，意味着此参数要进行拷贝初始化。依赖于实参的类型，左值被拷贝，右值被移动。因此单一的赋值运算符实现了拷贝赋值运算符和移动赋值运算符两种功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hp &#x3D; hp2;			&#x2F;&#x2F;hp2是一个左值，hp2通过拷贝构造函数来拷贝</span><br><span class="line">hp &#x3D; std::move(hp2);&#x2F;&#x2F;移动构造函数移动hp2</span><br></pre></td></tr></table></figure>
<p>Message类的移动操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;从本Message移动Folder指针</span><br><span class="line">void Message::move_Folders(Message* m) &#123;</span><br><span class="line">	folders &#x3D; std::move(m-&gt;folders);&#x2F;&#x2F;使用set的移动赋值运算符</span><br><span class="line">	for (auto f : folders) &#123; &#x2F;&#x2F;对每个Folder</span><br><span class="line">		f-&gt;remMsg(m);	&#x2F;&#x2F;从Folder中删除旧Message</span><br><span class="line">		f-&gt;addMsg(this);&#x2F;&#x2F;将本Message添加到Folder中</span><br><span class="line">	&#125;</span><br><span class="line">	m-&gt;folders.clear(); &#x2F;&#x2F;确保销毁m是无害的</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过调用move，使用了set的移动赋值运算符移动folders集合，函数遍历所有Folder，从其中删除指向原Message的指针，并添加指向新Message的指针<br>向set中插入元素要求分配内存，可能会抛出bad_alloc异常。Message的移动构造函数和移动构造运算符可能会抛出异常，所以未标记为noexcept</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Message::Message(Message&amp;&amp; m) :contents(std::move(m.contents)) &#123;</span><br><span class="line">	move_Folders(&amp;m); &#x2F;&#x2F;移动folders并更新Folder指针</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Message的移动构造函数调用move来移动contents，并默认初始化自己的folders成员</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Message&amp; Message::operator&#x3D;(Message&amp;&amp; rhs) &#123;</span><br><span class="line">	if (this !&#x3D; &amp;rhs) &#123;		&#x2F;&#x2F;直接检查自赋值情况</span><br><span class="line">		remove_from_Folders();</span><br><span class="line">		contents &#x3D; std::move(rhs.contents); &#x2F;&#x2F;移动赋值运算符</span><br><span class="line">		move_Folders(&amp;rhs);	&#x2F;&#x2F;重置Folders指向本Message</span><br><span class="line">	&#125;</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>移动迭代器(move iterator)<br>移动迭代器的解引用生成一个右值引用<br>通过调用标准库的make_move_iterator函数将一个普通迭代器转换为一个移动迭代器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void StrVec::reallovate() &#123;</span><br><span class="line">	auto newcapacity &#x3D; size() ? 2 + size() : 1;</span><br><span class="line">	auto first &#x3D; alloc.allocate(newcapacity);</span><br><span class="line">	&#x2F;&#x2F;移动元素</span><br><span class="line">	auto last &#x3D; uninitialized_copy(make_move_iterator(begin()), make_move_iterator(end()), first);</span><br><span class="line">	free();</span><br><span class="line">	elements &#x3D; first;</span><br><span class="line">	first_free &#x3D; last;</span><br><span class="line">	cap &#x3D; elements + newcapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>unitialized_copy对输入序列中的每个元素调用construct来将元素“拷贝”到目的位置。此算法使用迭代器的解引用运算符从输入序列中提取元素，生成的是一个右值引用，意味着construct将使用移动构造函数来构造元素</p>
<p>由于一个移后源对象具有不确定的状态，对其调用std::move是危险的。当我们调用move时，必须确定移后源对象没有其他用户</p>
<p>右值引用和成员函数<br>允许移动的成员函数通常使用与拷贝 / 移动构造函数和赋值运算符相同的参数模式–一个版本接受一个指向const的左值引用，一个接受一个指向非const的右值引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void push_back(const X&amp;);	&#x2F;&#x2F;拷贝：绑定到任意类型的X</span><br><span class="line">void push_back(X&amp;&amp;);		&#x2F;&#x2F;移动：只能绑定到类型X的可修改的右值</span><br></pre></td></tr></table></figure>
<p>一般来说，不需要为函数操作定义接受一个const X&amp;&amp;或是X&amp;参数的版本。<br>当我们希望从实参“窃取”数据时，通常需要传递一个右值，不能是const的；从一个对象拷贝操作不应该改变该对象，因此通常不需要X&amp;版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class StrVec &#123;</span><br><span class="line">public:</span><br><span class="line">	void push_back(const string&amp;);</span><br><span class="line">	void push_back(strng&amp;&amp;);</span><br><span class="line">&#125;;</span><br><span class="line">void StrVec::push_back(const string&amp; s) &#123;</span><br><span class="line">	chk_n_alloc();	&#x2F;&#x2F;确保有空间容纳新元素</span><br><span class="line">	&#x2F;&#x2F;在first_free指向的元素中构造s的一个副本</span><br><span class="line">	alloc.construct(first_free++, s);</span><br><span class="line">&#125;</span><br><span class="line">void StrVec::push_back(string&amp;&amp; s) &#123;</span><br><span class="line">	chk_n_alloc();</span><br><span class="line">	alloc.construct(first_free++, std::move(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>construct函数使用其第二个和随后的实参类型确定使用哪个构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StrVec vec;</span><br><span class="line">string s &#x3D; &quot;some string or another&quot;;</span><br><span class="line">vec.push_back(s);		&#x2F;&#x2F;调用push_back(const string&amp;)</span><br><span class="line">vec.push_back(&quot;done&quot;);	&#x2F;&#x2F;调用push_back(string&amp;&amp;),右值，从&quot;done&quot;创建的临时string</span><br></pre></td></tr></table></figure>
<p>右值和左值成员函数<br>通过在参数列表后放置一个引用限定符(reference qualifier)来指出左值/右值属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">public:</span><br><span class="line">	Foo&amp; operator&#x3D;(const Foo&amp;)&amp;; &#x2F;&#x2F;只能向可修改的左值赋值</span><br><span class="line">&#125;;</span><br><span class="line">Foo&amp; Foo::operator&#x3D;(const Foo&amp; rhs)&amp; &#123;</span><br><span class="line">	&#x2F;&#x2F;执行所需操作</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引用限定符可以是&amp; 或&amp;&amp; ，指出this可以指向一个左值或右值。只能用于非static成员函数，且必须同时出现在函数的声明和定义中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Foo&amp; retFoo();	&#x2F;&#x2F;返回一个引用；retFoo调用是一个左值</span><br><span class="line">Foo retVal();	&#x2F;&#x2F;返回一直值；retVal调用是一个右值</span><br><span class="line">Foo i, j;		&#x2F;&#x2F;i和j是左值</span><br><span class="line">i &#x3D; j;			&#x2F;&#x2F;正确：i是左值</span><br><span class="line">retFoo() &#x3D; j;	&#x2F;&#x2F;正确：retFoo()返回一个左值</span><br><span class="line">retVal() &#x3D; j;	&#x2F;&#x2F;错误：retVal()返回一个右值</span><br><span class="line">i &#x3D; retVal();	&#x2F;&#x2F;正确：可以将一个右值作为赋值操作的右侧运算对象</span><br></pre></td></tr></table></figure>
<p>一个函数可以同时用const和引用限定。引用限定符必须跟随在const限定符之后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">public:</span><br><span class="line">	Foo someMen()&amp; const;	&#x2F;&#x2F;错误</span><br><span class="line">	Foo anotherMen()const&amp;;	&#x2F;&#x2F;正确</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>引用限定符也可以区分重载版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">public:</span><br><span class="line">	Foo sorted()&amp;&amp;;</span><br><span class="line">	Foo sorted()const&amp;;</span><br><span class="line">private:</span><br><span class="line">	vector&lt;int&gt;data;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;本对象为右值，可以原址排序</span><br><span class="line">Foo Foo::sorted()&amp;&amp; &#123;</span><br><span class="line">	sort(data.begin(), data.end());</span><br><span class="line">	return*this;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;本对象是const或是左值，不能进行原址排序</span><br><span class="line">Foo Foo::sorted()const&amp; &#123;</span><br><span class="line">	Foo ret(*this);							&#x2F;&#x2F;拷贝一个副本</span><br><span class="line">	sort(ret.data.begin(), ret.data.end());	&#x2F;&#x2F;排序副本</span><br><span class="line">	return ret;								&#x2F;&#x2F;返回副本</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对象是一个右值意味着没有其他用户，可以改变对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">retVal().sorted();	&#x2F;&#x2F;retVal是一个右值，调用Foo::sorted()&amp;&amp;</span><br><span class="line">retFoo().sorted();	&#x2F;&#x2F;retFoo是一个左值，调用Foo::sorted()const&amp;</span><br></pre></td></tr></table></figure>
<p>如果定义两个或以上具有相同名字和相同参数列表的成员函数，就必须对所有函数都加上引用限定符，或者所有都不加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">public:</span><br><span class="line">	Foo sorted()&amp;&amp;;</span><br><span class="line">	Foo sorted() const;	&#x2F;&#x2F;错误：必须加上引用限定符</span><br><span class="line">	&#x2F;&#x2F;Comp是函数类型的类型别名，此函数类型可以用来比较int值</span><br><span class="line">	using Comp &#x3D; bool(const int&amp;, const int&amp;);</span><br><span class="line">	Foo sorted(Comp*);		&#x2F;&#x2F;正确：不同的参数列表</span><br><span class="line">	Foo sorted(Comp*)const;	&#x2F;&#x2F;正确：两个都没哟引用限定符</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/30/c-primer-13-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/" data-id="ckhkopsd8000qesveh3xn7vam" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-primer/" rel="tag">c++ primer</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/08/30/c-primer-14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          c++ primer 14 重载运算符与类型转换
        
      </div>
    </a>
  
  
    <a href="/2020/08/30/c-primer-12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">c++ primer 12 动态内存</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/02-cpp-primer/" rel="tag">02 cpp primer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c-primer/" rel="tag">c++ primer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cocos2d-x/" rel="tag">cocos2d-x</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpp-notes/" rel="tag">cpp notes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/problem-library/" rel="tag">problem library</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reading-notes-DS/" rel="tag">reading notes DS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%82%93%E4%BF%8A%E8%BE%89/" rel="tag">数据结构 邓俊辉</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/02-cpp-primer/" style="font-size: 10px;">02 cpp primer</a> <a href="/tags/c-primer/" style="font-size: 15px;">c++ primer</a> <a href="/tags/cocos2d-x/" style="font-size: 12.5px;">cocos2d-x</a> <a href="/tags/cpp-notes/" style="font-size: 20px;">cpp notes</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/problem-library/" style="font-size: 15px;">problem library</a> <a href="/tags/reading-notes-DS/" style="font-size: 10px;">reading notes DS</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%82%93%E4%BF%8A%E8%BE%89/" style="font-size: 17.5px;">数据结构 邓俊辉</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/11/16/ncpp-02/">第2章 变量和基本类型</a>
          </li>
        
          <li>
            <a href="/2020/10/27/mysql/">mysql</a>
          </li>
        
          <li>
            <a href="/2020/08/30/c-primer-16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/">c++ primer 16 模板与泛型编程</a>
          </li>
        
          <li>
            <a href="/2020/08/30/c-primer-15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">c++ primer 15 面向对象程序设计</a>
          </li>
        
          <li>
            <a href="/2020/08/30/c-primer-14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/">c++ primer 14 重载运算符与类型转换</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>
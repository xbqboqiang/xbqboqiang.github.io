<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>c++ primer 16 模板与泛型编程 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="模板与泛型编程模板是泛型编程的基础。使用时提供足够的信息，将蓝图转换为特定的类或函数。转换发生在编译时 定义模板函数模板(function template)一个函数模板就是一个公式，可用来生成针对特定类型的函数版本 123456template&lt;typename T&gt;int compare(const T&amp; v1, const T&amp; v2) &amp;#123;	if (v1">
<meta property="og:type" content="article">
<meta property="og:title" content="c++ primer 16 模板与泛型编程">
<meta property="og:url" content="http://yoursite.com/2020/08/30/c-primer-16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="模板与泛型编程模板是泛型编程的基础。使用时提供足够的信息，将蓝图转换为特定的类或函数。转换发生在编译时 定义模板函数模板(function template)一个函数模板就是一个公式，可用来生成针对特定类型的函数版本 123456template&lt;typename T&gt;int compare(const T&amp; v1, const T&amp; v2) &amp;#123;	if (v1">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-08-30T03:01:44.000Z">
<meta property="article:modified_time" content="2020-08-30T03:07:54.602Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="c++ primer">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-c-primer-16-模板与泛型编程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/30/c-primer-16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/" class="article-date">
  <time datetime="2020-08-30T03:01:44.000Z" itemprop="datePublished">2020-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      c++ primer 16 模板与泛型编程
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="模板与泛型编程"><a href="#模板与泛型编程" class="headerlink" title="模板与泛型编程"></a>模板与泛型编程</h1><p>模板是泛型编程的基础。使用时提供足够的信息，将蓝图转换为特定的类或函数。转换发生在编译时</p>
<h2 id="定义模板"><a href="#定义模板" class="headerlink" title="定义模板"></a>定义模板</h2><h3 id="函数模板-function-template"><a href="#函数模板-function-template" class="headerlink" title="函数模板(function template)"></a>函数模板(function template)</h3><p>一个函数模板就是一个公式，可用来生成针对特定类型的函数版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">int compare(const T&amp; v1, const T&amp; v2) &#123;</span><br><span class="line">	if (v1 &lt; v2)return -1;</span><br><span class="line">	if (v2 &lt; v1)return 1;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以template开始，跟一个模板参数列表(template parameter list)，包括若干个逗号分隔的模板参数(template parameter)<br>使用模板时，指定模板实参，将其绑定到模板参数上</p>
<p>实例化函数模板<br>调用函数模板时，编译器用函数实参来推断模板实参<br>cout &lt;&lt; compare(1, 0) &lt;&lt; endl;<br>编译器用推断出的模板参数来实例化(instantiate)一个特点版本的函数</p>
<p>模板类型参数<br>可以将类型参数看做类型说明符，类型参数前必须使用关键字class或typename</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;正确：返回类型和参数类型相同</span><br><span class="line">template&lt;typename T&gt;T foo(T* p) &#123;</span><br><span class="line">	T tmp &#x3D; *p;	&#x2F;&#x2F;tmp的类型将是指针p指向的类型</span><br><span class="line">	return tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;错误：U之前必须加上class或typename</span><br><span class="line">template&lt;typename T, U&gt;T calc(const T&amp;, const T&amp;);</span><br><span class="line">在模板参数列表中这两个关键字的含义相同</span><br><span class="line">template&lt;typename T, class U&gt;calc(const T&amp;, const U&amp;);</span><br></pre></td></tr></table></figure>
<p>非类型模板参数(nontype parameter)<br>一个非类型模板参数表示一个值而非一个类型。通过一个特定的类型名关键字来指定非类型参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;模板参数表示数组的长度</span><br><span class="line">template&lt;unsigned N,unsigned M&gt;</span><br><span class="line">int compare(const char&amp; p1[n], const char&amp; p2[M]) &#123;</span><br><span class="line">	return strcmp(p1, p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用时：compare(“hi”, “hello”); 编译器会在字符串字面常量的末尾插入一个空字符作为终结符<br>int compare(const char(&amp;p1)[3], const char(&amp;p2)[6])<br>一个非类型参数可以是一个整型，或者一个指向对象或函数类型的指针或(左值)引用<br>绑定到非类型参数的实参必须是常量表达式；绑定到指针或引用的必须具有静态的生命周期，不能用普通(非静态)局部变量或动态对象作为指针或引用非类型模板参数的实参</p>
<p>模板函数可以声明为inline或constexpr的，说明符放在模板参数列表之后<br>template<typename T>inline T min(const T&amp;, const T&amp;);</p>
<p>模板中的函数参数是const的引用，保证了函数可以用于不能拷贝的类型(unique_ptr和IO类型等)</p>
<p>为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义，所以模板的头文件通常既包括声明也包括定义</p>
<p>模板直到实例化才会生成代码。编译器会在三个阶段报告错误：<br>·编译模板本身时。检查语法错误<br>·编译器遇到模板使用时。检查实参数目、类型等<br>·模板实例化时。大多数编译错误在实例化期间报告<br>if (v1 &lt; v2)return -1;<br>到实例化时才知道v1&lt;v2是否合法</p>
<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>编译器不能为类模板推断模板参数信息</p>
<p>定义类模板</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;class Blob &#123;</span><br><span class="line">public:</span><br><span class="line">	typedef T value_type;</span><br><span class="line">	typedef typename vector&lt;T&gt;::size_type size_type;</span><br><span class="line">	&#x2F;&#x2F;构造函数</span><br><span class="line">	Blob();</span><br><span class="line">	Blob(initializer_list&lt;T&gt; il);</span><br><span class="line">	&#x2F;&#x2F;Blob中元素数目</span><br><span class="line">	size_type size() const &#123; return data-&gt;size(); &#125;</span><br><span class="line">	bool empty() const &#123; return data-&gt;empty(); &#125;</span><br><span class="line">	&#x2F;&#x2F;删除和添加元素</span><br><span class="line">	void push_back(const T&amp; t) &#123; data-&gt;push_back(t); &#125;</span><br><span class="line">	&#x2F;&#x2F;移动版本</span><br><span class="line">	void push_back(T&amp;&amp; t) &#123; data-&gt;push_back(move(t)); &#125;</span><br><span class="line">	void pop_back();</span><br><span class="line">	&#x2F;&#x2F;元素访问</span><br><span class="line">	T&amp; back();</span><br><span class="line">	T&amp; operator[](size_type i);</span><br><span class="line">private:</span><br><span class="line">	shared_ptr&lt;vector&lt;T&gt;&gt;data;</span><br><span class="line">	&#x2F;&#x2F;若data[i]无效，抛出msg</span><br><span class="line">	void check(size_type i, const string&amp; msg)const;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>实例化类模板<br>提供显示模板实参(explicit template argument)列表，他们被绑定到模板参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Blob&lt;int&gt; ia;					&#x2F;&#x2F;空Blob&lt;int&gt;</span><br><span class="line">Blob&lt;int&gt; ia2 &#x3D; &#123; 0,1,2,3,4 &#125;;	&#x2F;&#x2F;有5个元素的Blob&lt;int&gt;</span><br></pre></td></tr></table></figure>
<p>编译器会实例出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">template&lt;&gt;class Blob&lt;int&gt; &#123;</span><br><span class="line">	typedef typename vector&lt;int&gt;::size_type size_type;</span><br><span class="line">	Blob();</span><br><span class="line">	Blob(initializer_list&lt;int&gt; il);</span><br><span class="line">	&#x2F;&#x2F;...</span><br><span class="line">	int&amp; operator[](size_type i);</span><br><span class="line">private:</span><br><span class="line">	shared_ptr&lt;vector&lt;int&gt;&gt; data;</span><br><span class="line">	void check(size_type i, const string&amp; msg)const;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一个类模板的每个实例都形成一个独立的类。Blob<int>与其他Bolb类没有关联</p>
<p>类模板的成员函数<br>定义在类模板内的成员喊被隐式声明为内联函数<br>定义在类模板之外的成员函数就必须以关键字template开始，后接类模板参数列表</p>
<p>check和元素访问成员</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void Blob&lt;T&gt;::check(size_type i, const string&amp; msg)const &#123;</span><br><span class="line">	if (i &gt;&#x3D; data-&gt;size())</span><br><span class="line">		throw out_of_range(msg);</span><br><span class="line">&#125;</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">T&amp; Blog&lt;T&gt;::back() &#123;</span><br><span class="line">	check(0, &quot;back on empty Blob&quot;);</span><br><span class="line">	return data-&gt;check();</span><br><span class="line">&#125;</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">T&amp; Blob&lt;T&gt;::operator[](size_type i) &#123;</span><br><span class="line">	check(i, &quot;subscript out of range&quot;);</span><br><span class="line">	return (*data)[i];</span><br><span class="line">&#125;</span><br><span class="line">返回一个引用，指向用来实例化BLob的类型</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void Blob&lt;T&gt;::pop_back() &#123;</span><br><span class="line">	check(0, &quot;pop_back on empty Blob&quot;);</span><br><span class="line">	data-&gt;pop_back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Blob构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">Blob&lt;T&gt;::Blob() :data(make_shared&lt;vector&lt;T&gt;&gt;()) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数分配一个空vector，并将指向vector的指针保存在data中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">Blob&lt;T&gt;::Blob(initializer_list&lt;T&gt; il) : data(make_shared&lt;vector&lt;T&gt;&gt;(il)) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>为了使用这个构造函数，必须传给它一个initializer_list</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Blob&lt;string&gt;articals &#x3D; &#123; &quot;a&quot;,&quot;an&quot;,&quot;the&quot; &#125;;</span><br></pre></td></tr></table></figure>
<p>列表中每个字符串字面常量隐式地转换为一个string</p>
<p>类模板成员函数的实例化<br>默认情况下，一个类模板的成员函数只有当程序用到它时才进行实例化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;实例化Blob&lt;int&gt;和接受initializer_list&lt;int&gt;的构造函数</span><br><span class="line">Blob&lt;int&gt;squares &#x3D; &#123; 0,1,2,3,4,5,6,7,8,9 &#125;;</span><br><span class="line">&#x2F;&#x2F;实例化Blob&lt;int&gt;::size()const</span><br><span class="line">for (size_t i &#x3D; 0; i !&#x3D; squares.size(); ++i)</span><br><span class="line">	squares[i] &#x3D; i * i;		&#x2F;&#x2F;实例化Blob&lt;int&gt;::operator[](size_t)</span><br></pre></td></tr></table></figure>
<p>这一特性使得即使某种类型不能完全符合模板操作的要求，扔能用该类型实例化类</p>
<p>在类代码内简化模板类名的使用<br>在类模板自己的作用域中，可以直接使用模板名而不提供实参</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;class BlobPtr &#123;</span><br><span class="line">public:</span><br><span class="line">	BlobPtr() :curr(0) &#123;&#125;</span><br><span class="line">	BlobPtr(Blob&lt;T&gt;&amp; a, size_t sz &#x3D; 0) :wptr(a.data), curr(sz) &#123;&#125;</span><br><span class="line">	T&amp; operator*()const &#123;</span><br><span class="line">		auto p &#x3D; check(curr, &quot;dereference past end&quot;);</span><br><span class="line">		return (*p)[curr];	&#x2F;&#x2F;(*p)为本对象指向的vector</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;递增和递减</span><br><span class="line">	BlobPtr&amp; operator++();	&#x2F;&#x2F;前置运算符</span><br><span class="line">	BlobPtr&amp; operator--();</span><br><span class="line">private:</span><br><span class="line">	&#x2F;&#x2F;若检查成功，返回一个指向vector的shared_ptr</span><br><span class="line">	shared_ptr&lt;vector&lt;T&gt;&gt;check(size_t, const string&amp;)const;</span><br><span class="line">	&#x2F;&#x2F;保存一个weak_ptr，表示底层vector可能被销毁</span><br><span class="line">	weak_ptr&lt;vector&lt;T&gt;&gt;wptr;</span><br><span class="line">	size_t curr;	&#x2F;&#x2F;数组中的当前位置</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在类模板外使用类模板名<br>在类模板外定义成员时，直到遇到类名才表示进入类的作用域</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;后置：递增&#x2F;递减对象但返回原值</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">BlobPtr&lt;T&gt; BlobPtr&lt;T&gt;::operator(int) &#123;</span><br><span class="line">	&#x2F;&#x2F;无需检查，调用前置时会检查</span><br><span class="line">	BlobPtr ret &#x3D; *this;</span><br><span class="line">	++* this;</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ret的定义与BlobPtr<int>ret = *this等价</p>
<p>类模板和友元<br>类包含友元声明是，类与友元各自是否是模板是无关的<br>类模板包含一个非模板友元，则友元被授权访问所有模板实例<br>友元自身是模板，类可以授权给所有友元模板实例，也可以授权给特定的</p>
<p>一对一友好关系<br>类模板与另一个(类或函数)模板间友好关系的最常见形式是建立对应实例及其友元间的友好关系</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;前置声明，在Blob中声明友元所需要的</span><br><span class="line">template&lt;typename T&gt;class BlobPtr;</span><br><span class="line">template&lt;typename T&gt;class Blob;	&#x2F;&#x2F;运算符&#x3D;&#x3D;中的参数所需要的</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">bool operator&#x3D;&#x3D;(const Blob&lt;T&gt;&amp;, const Blob&lt;T&gt;&amp;);</span><br><span class="line">template&lt;typename T&gt;class Blob &#123;</span><br><span class="line">	&#x2F;&#x2F;每个Blob实例将访问权限授予用相同类型实例化的BlobPtr和相等运算符</span><br><span class="line">	friend class BlobPtr&lt;T&gt;;</span><br><span class="line">	friend bool operator&#x3D;&#x3D;&lt;T&gt;(const Blob&lt;T&gt;&amp;, const Blob&lt;T&gt;&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>友元的声明用Blob的模板形参作为他们自己的模板实参。因此，友好关系被限定在用相同类型实例化的Blob与BlobPtr相等运算符之间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Blob&lt;char&gt;ca;	&#x2F;&#x2F;BlobPtr&lt;char&gt;和operator&#x3D;&#x3D;&lt;char&gt;都是本对象的友元</span><br><span class="line">Blob&lt;int&gt;ia;	&#x2F;&#x2F;BlobPtr&lt;int&gt;和operator&#x3D;&#x3D;&lt;int&gt;都是本对象的友元</span><br></pre></td></tr></table></figure>
<p>BlobPtr<char>的成员可以访问ca(或任何其他BlobPtr<char>对象)的非public部分，但ca对ia或Blob的任何其他实例都没有特殊访问权限</p>
<p>通用和特定的模板友好关系<br>一个类可以将另一个模板的每个实例都声明为自己的友元，或限定特定的实例为友元</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;class Pal;</span><br><span class="line">class C &#123;	&#x2F;&#x2F;C是一个普通非模板类</span><br><span class="line">	friend class Pal&lt;C&gt;;	&#x2F;&#x2F;用类C实例化的Pal是C的一个友元</span><br><span class="line">	&#x2F;&#x2F;Pal2的所实例都是C的友元</span><br><span class="line">	template&lt;typename T&gt;friend class Pal2;</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;typename T&gt; class C2 &#123;</span><br><span class="line">	&#x2F;&#x2F;C2的每个实例将相同实例化的Pal声明为友元</span><br><span class="line">	friend class Pal&lt;T&gt;;	&#x2F;&#x2F;Pal的模板声明必须在作用域之内</span><br><span class="line">	&#x2F;&#x2F;Pal2的所有实例都是iC2的每个实例的友元，不需要前置声明</span><br><span class="line">	template&lt;typename X&gt;friend class Pal2;</span><br><span class="line">	&#x2F;&#x2F;Pal3是一个非模板类，它是C2所有实例的友元</span><br><span class="line">	friend class Pal3;		&#x2F;&#x2F;不需要Pal3的前置声明</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为了让所有实例成为友元，友元声明中必须使用与类模板本身不同的模板参数</p>
<p>令模板自己的类型参数为友元</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;class Bar &#123;</span><br><span class="line">	friend Type;	&#x2F;&#x2F;将访问权限授予用来实例化Bar的类型</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于某个类型名Foo，Foo将成为Bar<Foo>的友元</p>
<p>模板类型别名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;using twin &#x3D; pair&lt;T, T&gt;;</span><br><span class="line">twin&lt;string&gt; authors;	&#x2F;&#x2F;authors是一个pair&lt;string,string&gt;</span><br><span class="line">也可以固定一个或多个模板参数</span><br><span class="line">template&lt;typename T&gt;using partNo &#x3D; pair&lt;T, unsigned&gt;;</span><br><span class="line">partNo&lt;string&gt;books;	&#x2F;&#x2F;books是一个pair&lt;string,unsigned&gt;</span><br><span class="line">partNo&lt;Vehicle&gt;cars;	&#x2F;&#x2F;cars是一个pair&lt;Vehicle,unsigned&gt;</span><br></pre></td></tr></table></figure>
<p>类模板的static成员</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;class Foo &#123;</span><br><span class="line">public:</span><br><span class="line">	static size_t count() &#123; return ctr; &#125;</span><br><span class="line">private:</span><br><span class="line">	static size_t ctr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对任意给定类型X，都有一个Foo<X>::ctr和一个Foo<X>::count成员<br>所有Foo<X>类型对象共享相同的ctr对象和count函数<br>将static数据成员也定义成模板</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt; size_t Foo&lt;T&gt;::ctr &#x3D; 0;	&#x2F;&#x2F;定义并初始化str</span><br></pre></td></tr></table></figure>
<p>一个static成员函数只有在使用时才会实例化</p>
<h3 id="模板参数"><a href="#模板参数" class="headerlink" title="模板参数"></a>模板参数</h3><p>一个模板参数名的可用范围是在其声明之后至模板声明或定义结束之前<br>模板参数会隐藏外层作用域中声明的相同名字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef double A;</span><br><span class="line">template&lt;typename A, typename B&gt;void f(A a, B b) &#123;</span><br><span class="line">	A tmp &#x3D; a;	&#x2F;&#x2F;tmp的类型为模板参数A的类型而非double</span><br><span class="line">	double B;	&#x2F;&#x2F;错误：重声明模板参数B</span><br><span class="line">&#125;</span><br><span class="line">template&lt;typename V,typename V&gt;&#x2F;&#x2F;错误：只能出现一次</span><br></pre></td></tr></table></figure>
<p>模板声明<br>模板声明必须包含模板参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;声明但不定义</span><br><span class="line">template&lt;typename T&gt;int compare(const T&amp;, const T&amp;);</span><br><span class="line">template&lt;typename T&gt;class Blob;</span><br><span class="line">声明中的模板参数的名字不必与定义中相同</span><br><span class="line">&#x2F;&#x2F;指向相同的函数模板</span><br><span class="line">template&lt;typename T&gt;T calc(const T&amp;, constT&amp;);</span><br><span class="line">template&lt;typename U&gt;U calc(const U&amp;, constU&amp;);</span><br></pre></td></tr></table></figure>
<p>使用类的类型成员<br>假定T是一个类型参数的名字，编译器遇到T::size_t*p时，需要知道是定义还是相乘<br>默认情况下，c++假定通过作用域运算符访问的名字不是类型。因此希望使用一个模板类型参数的类型成员，<br>必须显式地告诉编译器该名字是一个类型。 通过关键字typename</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">typename T::value_type top(const T&amp; c) &#123;</span><br><span class="line">	if (!c.empty())return c.back();</span><br><span class="line">	else return typename T::value_type();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认模板实参<br>compare有一个默认模板实参less<T>和一个默认函数实参F()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T,typename F&#x3D;less&lt;T&gt;&gt;</span><br><span class="line">int compare(const T&amp; v1, const T&amp; v2, F f &#x3D; F()) &#123;</span><br><span class="line">	if (f(v1, v2))return -1;</span><br><span class="line">	if (f(v2, v1))return 1;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认模板实参指出compare将使用标准库中的less函数对象类，它是使用与compare一样的类型参数实例化的<br>默认函数实参指出f将是类型F的一个默认初始化对象<br>调用compare时，可以提供自己的比较操作，但不是必须的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bool i &#x3D; compare(0, 42);</span><br><span class="line">&#x2F;&#x2F;结果依赖于item1和item2中的isbn</span><br><span class="line">Sales_data item1(cin), item2(cin);</span><br><span class="line">bool j &#x3D; compare(item1, item2, compareIsbn);</span><br></pre></td></tr></table></figure>
<p>对于一个模板参数，只有当它右侧的所有参数都有默认实参时，它才可以有默认实参</p>
<p>模板默认实参与类模板<br>一个类模板为其所有模板参数都提供了默认实参，而且我们希望使用这些默认实参，就必须在模板名之后跟一个空尖括号对</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T &#x3D; int&gt;class Numbers &#123;</span><br><span class="line">public:</span><br><span class="line">	Numbers(T v &#x3D; 0) :val(v) &#123;&#125;</span><br><span class="line">private:</span><br><span class="line">	T val;</span><br><span class="line">&#125;;</span><br><span class="line">Numbers&lt;long long&gt;lots_of_precision;</span><br><span class="line">Numbers&lt;&gt;avertage_precision;	&#x2F;&#x2F;空&lt;&gt;表示使用默认类型</span><br></pre></td></tr></table></figure>
<h3 id="成员模板-member-template"><a href="#成员模板-member-template" class="headerlink" title="成员模板(member template)"></a>成员模板(member template)</h3><p>一个类可以包含本身是模板的成员函数，被称为成员模板。成员模板不能是虚函数</p>
<p>普通类的成员模板</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class DebugDelete &#123;</span><br><span class="line">public:</span><br><span class="line">	DebugDelete(ostream&amp; s &#x3D; cerr) :os(s) &#123;&#125;</span><br><span class="line">	template&lt;typename T&gt;void operator()(T* p)const &#123;</span><br><span class="line">		os &lt;&lt; &quot;deleting unique_ptr&quot; &lt;&lt; endl;</span><br><span class="line">		delete p;</span><br><span class="line">	&#125;</span><br><span class="line">private:ostream&amp; os;</span><br><span class="line">&#125;;</span><br><span class="line">double* p &#x3D; new double;</span><br><span class="line">DebugDelete d;	&#x2F;&#x2F;可像delete表达式一样使用对象</span><br><span class="line">d(p);			&#x2F;&#x2F;调用DebugDelete::operator()(double*),释放p</span><br><span class="line">int* ip &#x3D; new int;</span><br><span class="line">&#x2F;&#x2F;在一个临时DebugDelete对象上调用operator()(int*)</span><br><span class="line">DebugDelete()(ip);</span><br><span class="line">调用一个DebugDelete对象会delete其指针，可以将其用作unique_ptr的删除器</span><br><span class="line">为了重载unique_ptr的删除器，在尖括号内给出</span><br><span class="line">&#x2F;&#x2F;销毁p指向的对象</span><br><span class="line">&#x2F;&#x2F;实例化DebugDelete::operator()&lt;int*&gt;(int*)</span><br><span class="line">unique_ptr&lt;int, DebugDelete&gt;p(new int, DebugDelete());</span><br><span class="line">&#x2F;&#x2F;销毁sp指向的对象</span><br><span class="line">&#x2F;&#x2F;实例化DebugDelete::operator()&lt;string&gt;(string*)</span><br><span class="line">unique_ptr&lt;string, DebugDelete&gt;sp(new string, DebugDelete());</span><br><span class="line">unique_ptr的析构函数会调用DebugDelete的调用运算符。unique_ptr的析构函数实例化时，DebugDelete的调用运算符会实例化</span><br><span class="line">void DebugDelete::operator()(int* p)const &#123; delete p; &#125;</span><br><span class="line">void DebugDelete::operator()(string* p)const &#123; delete p; &#125;</span><br></pre></td></tr></table></figure>
<p>类模板的成员模板<br>类和成员各有自己的、独立的模板参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;class Blob &#123;</span><br><span class="line">	template&lt;typename It&gt;Blob(It b, It e);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在类模板外定义时</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;	&#x2F;&#x2F;类的类型参数</span><br><span class="line">template&lt;typename It&gt;	&#x2F;&#x2F;构造函数的类型参数</span><br><span class="line">Blob&lt;T&gt;::Blob(It b, It e) :data(make_shared&lt;vector&lt;T&gt;&gt;(b, e)) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>实例化与成员模板<br>实例化一个类模板的成员模板，必须同时提供类和函数模板的实参</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int ia[] &#x3D; &#123; 1,2,3,4,5 &#125;;</span><br><span class="line">vector&lt;int&gt;vi &#x3D; &#123; 1,2,3,4,5 &#125;;</span><br><span class="line">list&lt;const char*&gt;w &#x3D; &#123; &quot;now&quot;,&quot;is&quot;,&quot;the&quot;,&quot;time&quot; &#125;;</span><br><span class="line">&#x2F;&#x2F;实例化Blob&lt;int&gt;类及接受两个int*参数的构造函数</span><br><span class="line">Blob&lt;int&gt;a1(begin(ia), end(ia));</span><br><span class="line">&#x2F;&#x2F;实例化Blob&lt;int&gt;类的接受两个vector&lt;long&gt;::iterator的构造参数</span><br><span class="line">Blob&lt;int&gt;a2(vi.begin(), vi.end());</span><br><span class="line">Blob&lt;string&gt;a3(w.begin(), w.end());</span><br><span class="line">a1实例化了Blob&lt;int&gt;::Blob(int*, int*);</span><br><span class="line">a2使用了已经实例化的Blob&lt;int&gt;类，并用vector&lt;short&gt;::iterator替换It来实例化构造函数</span><br><span class="line">a3的定义(显式地)实例化了一个string版本的Blob，并(隐式地)实例化了该类成员模板构造函数，其模板参数绑定到list&lt;const char*&gt;</span><br></pre></td></tr></table></figure>
<h3 id="控制实例化"><a href="#控制实例化" class="headerlink" title="控制实例化"></a>控制实例化</h3><p>模板被使用才会实例化，所以相同的实例可能出现在多个对象文件中<br>可以通过显式实例化(explicit instantiation)来避免这种开销</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extern template declaration;	&#x2F;&#x2F;实例化声明</span><br><span class="line">template declaratino;			&#x2F;&#x2F;实例化定义</span><br><span class="line">declaration中所有模板参数已被替换为模板实参</span><br><span class="line">extern template class Blob&lt;string&gt;;				&#x2F;&#x2F;声明</span><br><span class="line">template int compare(const int&amp;, const int&amp;);	&#x2F;&#x2F;定义</span><br></pre></td></tr></table></figure>
<p>编译器遇到extern时，不会在本文件中生成实例化代码。extern表示承诺在程序其他位置有该实例化的一个非extern声明<br>extern声明必须出现在任何使用此实例化版本的代码之前</p>
<p>实例化定义会实例化该模板的所有成员</p>
<h3 id="效率与灵活性"><a href="#效率与灵活性" class="headerlink" title="效率与灵活性"></a>效率与灵活性</h3><p>shared_ptr共享指针所有权；unique_ptr独占指针<br>重载shared_ptr删除器只需要创建或rest指针时传递给它一个可调用对象即可；<br>删除器的类型是unique_ptr对象的一部分，必须在定义unique_ptr时以显式模板实参形式提供删除器的类型</p>
<p>在运行时绑定删除器<br>shared_ptr删除器的类型知道运行时才会知道。假定shared_ptr将它管理的指针保存在成员p中，删除器是通过del成员来访问的<br>则析构函数必须包含：del ? del(p) : delete p; 调用del(p)需要一次运行时的跳转操作，转到del中保存的地址来执行对应代码</p>
<p>unique_ptr在编译时绑定删除器</p>
<h2 id="模板实参推断"><a href="#模板实参推断" class="headerlink" title="模板实参推断"></a>模板实参推断</h2><p>从函数实参来确定模板实参的过程被称为模板实参推断(template argument deduction)</p>
<h3 id="类型转换与模板类型参数"><a href="#类型转换与模板类型参数" class="headerlink" title="类型转换与模板类型参数"></a>类型转换与模板类型参数</h3><p>类型转换中，能在调用中应用于模板函数的：<br>·const转换：将一个非const对象的引用或指针传递给一个const的引用或指针形参<br>·数组或函数指针转换：如果函数形参不是引用类型，可以对数组或函数类型的实参应用正常的指针转换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;T fobj(T, T);	&#x2F;&#x2F;实参被拷贝</span><br><span class="line">template&lt;typename T&gt;T fref(const T&amp;, const T&amp;);	&#x2F;&#x2F;引用</span><br><span class="line">string s1(&quot;a value&quot;);</span><br><span class="line">const string s2(&quot;another value&quot;);</span><br><span class="line">fobj(s1, s2);	&#x2F;&#x2F;调用fobj(string,string) const被忽略</span><br><span class="line">fref(s1, s2);	&#x2F;&#x2F;调用fref(const string&amp;,const string&amp;) 将s1转换为const是允许的</span><br><span class="line">int a[10],b[42];</span><br><span class="line">fobj(a, b);	&#x2F;&#x2F;调用fobj(int*,int*)</span><br><span class="line">fref(a, b);	&#x2F;&#x2F;错误：数组类型不匹配</span><br></pre></td></tr></table></figure>
<p>如果形参是一个引用，则数组不会转换为指针</p>
<p>使用相同模板参数类型的函数形参</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">long lng;</span><br><span class="line">compare(lng, 1024);	&#x2F;&#x2F;错误：不能实例化compare(long,int)</span><br></pre></td></tr></table></figure>
<p>传递给compare的实参类型不同</p>
<p>正常类型转换应用于普通函数实参</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt; ostream&amp; print(ostream&amp; os, const T&amp; obj) &#123;</span><br><span class="line">	return os &lt;&lt; obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>os的类型是固定的，调用print时，传递给它的实参会进行正常的类型转换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(cout, 42);	&#x2F;&#x2F;实例化print(ostream&amp;,int)</span><br><span class="line">ofstream f(&quot;output&quot;);</span><br><span class="line">print(f, 10);		&#x2F;&#x2F;使用print(ostream&amp;,int) 将f转换为ostream&amp;</span><br></pre></td></tr></table></figure>
<p>第二个中，第一个参数的类型不依赖于模板参数，因此编译器会将f隐式转换为ostream&amp;</p>
<h3 id="函数模板显式实参"><a href="#函数模板显式实参" class="headerlink" title="函数模板显式实参"></a>函数模板显式实参</h3><p>指定显式模板实参(explicit template argument)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T1, typename T2, typename T3&gt;T1 sum(T2, T3);</span><br></pre></td></tr></table></figure>
<p>每次调用必须为T1提供一个显示模板实参</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto val3 &#x3D; sum&lt;long long&gt;(i, lng);	&#x2F;&#x2F;long long sum(int,long)</span><br></pre></td></tr></table></figure>
<p>显式模板实参按照由左至右的顺序与对应的模板参数匹配<br>只有尾部(最右)参数的显示模板实参才可以忽略</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T1,typename T2,typename T3&gt;</span><br><span class="line">T3 alternative_sum(T2, T1);</span><br></pre></td></tr></table></figure>
<p>用户必须制定所有三个模板参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;错误：不能推断前几个模板参数</span><br><span class="line">auto val3 &#x3D; alternative_sum&lt;long long&gt;(i, lng);</span><br><span class="line">&#x2F;&#x2F;正确：显式指定了所有三个参数</span><br><span class="line">auto val2 &#x3D; alternativa_sum&lt;long long, int, long&gt;(i, lng);</span><br></pre></td></tr></table></figure>
<p>正常类型转换应用于显式指定的实参</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">long lng;</span><br><span class="line">compare(lng, 1024);		&#x2F;&#x2F;错误：模板参数不匹配</span><br><span class="line">compare&lt;long&gt;(lng, 1024);	&#x2F;&#x2F;正确：实例化compare(long,long)</span><br><span class="line">compare&lt;int&gt;(lng, 1024);	&#x2F;&#x2F;正确：实例化compare(int,int)</span><br></pre></td></tr></table></figure>
<h3 id="尾置返回类型与类型转换"><a href="#尾置返回类型与类型转换" class="headerlink" title="尾置返回类型与类型转换"></a>尾置返回类型与类型转换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename It&gt; ? ? ? &amp;fcn(It beg, It end) &#123;</span><br><span class="line">	&#x2F;&#x2F;...</span><br><span class="line">	return *beg;	&#x2F;&#x2F;返回序列中一个元素的引用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并不知道返回结果的准确类型，但知道所需类型是所处理的序列的元素类型<br>使用尾置返回类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename It&gt;</span><br><span class="line">auto fcn(It beg, It end)-&gt;decltype(*beg) &#123;</span><br><span class="line">	&#x2F;&#x2F;...</span><br><span class="line">	return *beg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通知编译器fcn的返回类型与解引用beg参数的结果类型相同。解引用运算符返回一个左值，<br>因此通过decltype推断的类型为beg表示的元素的类型的引用</p>
<p>进行类型转换的标准库模板类<br>标准库的类型转换(type transformation)定义在头文件type_traits中<br>————————————————————————606</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename It&gt;</span><br><span class="line">auto fcn2(It beg, It end)-&gt;typename remove_reference&lt;decltype(*beg)&gt;::type &#123;</span><br><span class="line">	&#x2F;&#x2F;...</span><br><span class="line">	return *beg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回beg引用的元素的类型</p>
<h3 id="函数指针和实参推断"><a href="#函数指针和实参推断" class="headerlink" title="函数指针和实参推断"></a>函数指针和实参推断</h3><p>用函数模板初始化一个函数指针或为一个函数指针赋值时，编译器使用指针的类型来推断模板实参</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;int compare(const T&amp;, const T&amp;);</span><br><span class="line">int (*pf1)(const int&amp;, const int&amp;) &#x3D; compare;</span><br><span class="line">pf1指向实例int compare(const int&amp;, const int&amp;)</span><br><span class="line">pf1中的参数类型决定了T的模板参数类型</span><br><span class="line">&#x2F;&#x2F;func的重载版本，每个版本接受一个不同的函数指针类型</span><br><span class="line">void func(int(*)(const string&amp;, const string&amp;));</span><br><span class="line">void func(int(*)(const int&amp;, const int&amp;));</span><br><span class="line">func(compare)	&#x2F;&#x2F;错误</span><br><span class="line">通过func的参数类型无法确定模板实参的唯一类型</span><br><span class="line">&#x2F;&#x2F;正确：显式指出实例化哪个compare版本</span><br><span class="line">func(compare&lt;int&gt;);	&#x2F;&#x2F;传递compare(const int&amp;,const int&amp;)</span><br></pre></td></tr></table></figure>
<h3 id="模板实参推断和引用"><a href="#模板实参推断和引用" class="headerlink" title="模板实参推断和引用"></a>模板实参推断和引用</h3><p>template<typename T>void f(T&amp; p);<br>编译器会应用正常的引用绑定规则；const是底层的，不是顶层的</p>
<p>从左值引用函数参数推断类型<br>函数参数是模板类型参数的一个普通引用时(T&amp;)，只能传给它一个左值(变量或返回引用类型的表达式)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;void f1(T&amp;);	&#x2F;&#x2F;实参必须是一个左值</span><br><span class="line">f1(i);	&#x2F;&#x2F;i是一个int，模板参数类型T是int</span><br><span class="line">f1(ci);	&#x2F;&#x2F;ci是一个const int，T是const int</span><br><span class="line">f1(5);	&#x2F;&#x2F;错误：传递给一个&amp;参数的实参必须是左值</span><br></pre></td></tr></table></figure>
<p>如果函数参数类型是const T&amp; ，可以给它传递一个对象(const或非const)、一个临时对象或是字面常量值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;void f2(const T&amp;);	&#x2F;&#x2F;可以接受一个右值</span><br><span class="line">f2(i);	&#x2F;&#x2F;i是int，T是int</span><br><span class="line">f2(ci);	&#x2F;&#x2F;ci是const int，T是int</span><br><span class="line">f2(5);	&#x2F;&#x2F;T是int</span><br></pre></td></tr></table></figure>
<p>从右值引用函数参数推断参数类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;void f3(T&amp;&amp;);</span><br><span class="line">f3(42);	&#x2F;&#x2F;实参是一个int类型的右值，T是int</span><br></pre></td></tr></table></figure>
<p>引用折叠和右值引用<br>可以允许f3(i)，即将一个右值引用绑定到一个左值i上。只有2种情况<br>·将左值i传递给函数的右值引用参数，且此右值引用指向模板类型参数(T&amp;&amp;)时，编译器推断T的类型为int&amp; ，而非int<br>通常不能直接定义一个引用的引用，但通过类型别名或通过模板类型参数间接定义是可以的<br>·间接创建一个引用的引用，这些引用形成了折叠。除右值引用的右值引用外，引用会折叠成一个普通的左值引用<br>X&amp;&amp;, X&amp;&amp;&amp;, X&amp;&amp;&amp; 都折叠成X&amp; ；X&amp;&amp;&amp;&amp; 折叠成X&amp;&amp;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f3(i);	&#x2F;&#x2F;实参是一个左值，T是int&amp;</span><br><span class="line">f3(ci);	&#x2F;&#x2F;实参是一个左值，T是const int&amp;</span><br></pre></td></tr></table></figure>
<p>·如果一个函数参数是一个指向模板类型参数的右值引用(T&amp;&amp;)，则它可以被绑定到一个左值，且<br>·如果实参是一个左值，则推断出的模板实参类型是一个左值引用，且函数参数将被实例化为一个左值引用参数(T&amp;)</p>
<p>编写接受右值引用参数的模板函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;void f3(T&amp;&amp; val) &#123;</span><br><span class="line">	T t &#x3D; val;	&#x2F;&#x2F;拷贝还是绑定一个引用？</span><br><span class="line">	t &#x3D; fcn(t);	&#x2F;&#x2F;赋值是只改变t还是也改变val？</span><br><span class="line">	if(val&#x3D;&#x3D;t)&#123;&#x2F;*........*&#x2F; &#125;	&#x2F;&#x2F;若T是引用类型则一直为true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="理解std-move"><a href="#理解std-move" class="headerlink" title="理解std::move"></a>理解std::move</h3><p>定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">typename remove_reference&lt;T&gt;::type&amp;&amp; move(type&amp;&amp; t) &#123;</span><br><span class="line">	return static_cast&lt;typename remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br><span class="line">string s1(&quot;hi&quot;), s2;</span><br><span class="line">s2 &#x3D; move(string(&quot;bye&quot;));	&#x2F;&#x2F;正确：从一个右值移动数据</span><br><span class="line">s2 &#x3D; move(s1);				&#x2F;&#x2F;正确：但赋值后s1的值是不确定的</span><br></pre></td></tr></table></figure>
<p>第一个中传递给s2的实参是string构造函数的右值结果，因此在move(string(“bye”))中<br>T的类型为string；remove_reference用string实例化；remove_reference<string>的type成员是string<br>move的返回类型是string&amp;&amp; ；move的函数参数t类型为string&amp;&amp;<br>因此string&amp;&amp; move(string&amp;&amp; t)<br>函数体返回castic_cast&lt;string&amp;&amp;&gt;(t)，t的类型是string&amp;&amp; ，于是转换什么也不做<br>第二个中传递给move的实参是一个左值<br>推断出T类型是string&amp; ；remove_reference用string&amp; 实例化；<br>remove_reference&lt;string&amp;&gt;的type成员是string；move返回类型仍是string&amp;&amp; ；<br>move的函数参数t实例化为string&amp;&amp;&amp; ，折叠为string&amp;<br>因此string&amp;&amp; move(string&amp; t)<br>即将右值引用绑定到左值</p>
<p>从一个左值static_cast到一个右值引用是允许的<br>虽然不能隐式地将一个左值转换为右值引用，但可以用static_cast显式地将左值转换为右值引用</p>
<h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T,typename T1,typename T2&gt;</span><br><span class="line">void flip1(F f, T1 t1, T2 t2)&#123;</span><br><span class="line">	f(t2, t1);</span><br><span class="line">&#125;</span><br><span class="line">void f(int v1, int&amp; v2) &#123;</span><br><span class="line">	cout &lt;&lt; v1 &lt;&lt; &quot; &quot; &lt;&lt; ++v2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">f(42, i);			&#x2F;&#x2F;f改变了实参i</span><br><span class="line">flip1(f, j, 42);	&#x2F;&#x2F;通过flip1调用f不会改变j</span><br></pre></td></tr></table></figure>
<p>j被传递给flip1的参数t1，此参数是个普通的、非引用的类型int，而非int&amp; ，flip1实例化为<br>void flip1(void(*fcn)(int, int&amp;), int t1, int t2);<br>j的值被拷贝到t1中，f中的引用参数绑定到t1，而非j</p>
<p>定义能保持类型信息的函数参数<br>通过将函数参数定义为一直指向模板类型的右值引用，可以保持其实参类型信息；使用引用可以保持const属性<br>因为在引用类型中const是底层的，右值引用通过折叠可以保持实参的左右值属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename F,typename T1,typename T2&gt;</span><br><span class="line">void flip2(F f, T1&amp;&amp; t1, T2&amp;&amp; t2) &#123;</span><br><span class="line">	f(t2, t1);</span><br><span class="line">&#125;</span><br><span class="line">但不能用于接受右值引用参数的函数</span><br><span class="line">void g(int&amp;&amp; i, int&amp; j) &#123; cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl; &#125;</span><br><span class="line">通过flip2调用g，则t2将被传递给g的右值引用参数</span><br><span class="line">flip2(g, i, 42);	&#x2F;&#x2F;错误：不能从一个左值实例化int&amp;&amp;</span><br></pre></td></tr></table></figure>
<p>使用std::forward保持类型信息<br>forward定义在头文件utility中，必须通过显式模板实参来调用，返回该实参类型的右值引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename Type&gt;intermediary(Type&amp;&amp; arg) &#123;</span><br><span class="line">	finalFcn(forward&lt;Type&gt;(arg));</span><br><span class="line">&#125;</span><br><span class="line">当用于一个模板参数类型的右值引用函数参数(T&amp;&amp;)时，forward会保持实参类型的所有细节</span><br><span class="line">template&lt;typename F,typename T1,typename T2&gt;</span><br><span class="line">void flip(F f, T1 t1, T2 t2) &#123;</span><br><span class="line">	f(forward&lt;T2&gt;(t2), forward&lt;T1&gt;(t1));</span><br><span class="line">&#125;</span><br><span class="line">调用flip(g,i,42),i将以int&amp;类型传递给g，42将以int&amp;&amp;类型传递给g</span><br></pre></td></tr></table></figure>
<h2 id="重载与模板"><a href="#重载与模板" class="headerlink" title="重载与模板"></a>重载与模板</h2><p>函数模板可以被另一个模板或普通非模板函数重载<br>匹配规则：<br>·对于一个调用，其候选函数包括所有模板实参推断成功的函数模板实例<br>·候选的函数模板总是可行的，因为模板实参推断会排除任何不可行的模板<br>·可行函数(模板与非模板)按类型转换(如果需要)来排序<br>·如果恰有一个函数提供比其他任何函数都更好的匹配，则选择此函数。但是，<br>如果有多个函数提供同样好的匹配，则：<br>– 如果同样好的函数中只有一个是非模板函数，则选择此函数<br>– 如果没有非模板函数，而有多个模板，且其中一个模板比其他的更特例话，则选此<br>– 否则调用有歧义</p>
<p>编写重载模板</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;string debug_rep(const T&amp; t) &#123;</span><br><span class="line">	ostringstream ret;</span><br><span class="line">	ret &lt;&lt; t;	&#x2F;&#x2F;使用T的输出运算符打印t的一个表示形式</span><br><span class="line">	return ret.str();	&#x2F;&#x2F;返回ret绑定的string的一个副本</span><br><span class="line">&#125;</span><br><span class="line">此函数生成一个对象对应的string表示，该对象可以是任意具备输出运算符的类型</span><br><span class="line">打印指针的版本</span><br><span class="line">&#x2F;&#x2F;打印指针的值，后跟指针指向的对象</span><br><span class="line">template&lt;typename T&gt;string debug_rep(T* p) &#123;</span><br><span class="line">	ostringstream ret;</span><br><span class="line">	ret &lt;&lt; &quot;pointer: &quot; &lt;&lt; p;	&#x2F;&#x2F;打印指针本身的值</span><br><span class="line">	if (p)ret &lt;&lt; &quot; &quot; &lt;&lt; debug_rep(*p);&#x2F;&#x2F;打印p指向的值</span><br><span class="line">	else ret &lt;&lt; &quot; null pointer&quot;;	&#x2F;&#x2F;或指出p为空</span><br><span class="line">	return ret.str();		&#x2F;&#x2F;返回ret绑定的string的一个副本</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成一个string，包含指针本身的值和调用debug_rep获得的指针指向的值<br>不能打印字符指针，因为IO库为char* 定义了一个 &lt;&lt; 版本，假定指针表示一个空字符结尾的字符数组，<br>打印数组的内容而非地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s(&quot;hi&quot;);</span><br><span class="line">cout &lt;&lt; debug_rep(s) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>只有第一个版本的debug_rep是可行的。第二个要求一个指针参数，但传递了非指针对象。<br>编译器无法从一个非指针参数实例化一个期望指针类型参数的函数模板，实参推断失败</p>
<p>若cout &lt;&lt; debug_rep(&amp;s) &lt;&lt; endl; 则两个函数都生成可行的实例<br>·debug_rep(const string<em>&amp;), T被绑定到string</em><br>·debug_rep(string*), T被绑定到string<br>第二个是精确匹配，第一个需要普通指针到const指针的转换</p>
<p>多个可行模板<br>const string* sp = &s;<br>cout &lt;&lt; debug_rep(sp) &lt;&lt; endl;<br>两个都可行，都是精确匹配<br>·debug_rep(const string<em>&amp;),T被绑定到string</em><br>·debug_rep(const string<em>),T被绑定到string<br>第二个是更特例化的版本，被解析为debug_rep(T</em>)</p>
<p>模板重载和类型转换</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/30/c-primer-16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/" data-id="ckhua8ro40011xsve633c7fm2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-primer/" rel="tag">c++ primer</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/10/27/mysql/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          mysql
        
      </div>
    </a>
  
  
    <a href="/2020/08/30/c-primer-15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">c++ primer 15 面向对象程序设计</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/02-cpp-primer/" rel="tag">02 cpp primer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c-primer/" rel="tag">c++ primer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cocos2d-x/" rel="tag">cocos2d-x</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpp-notes/" rel="tag">cpp notes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/problem-library/" rel="tag">problem library</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reading-notes-DS/" rel="tag">reading notes DS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%82%93%E4%BF%8A%E8%BE%89/" rel="tag">数据结构 邓俊辉</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" rel="tag">深入理解计算机系统</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/02-cpp-primer/" style="font-size: 15px;">02 cpp primer</a> <a href="/tags/c-primer/" style="font-size: 15px;">c++ primer</a> <a href="/tags/cocos2d-x/" style="font-size: 12.5px;">cocos2d-x</a> <a href="/tags/cpp-notes/" style="font-size: 20px;">cpp notes</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/problem-library/" style="font-size: 15px;">problem library</a> <a href="/tags/reading-notes-DS/" style="font-size: 10px;">reading notes DS</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%82%93%E4%BF%8A%E8%BE%89/" style="font-size: 17.5px;">数据结构 邓俊辉</a> <a href="/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">深入理解计算机系统</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/08/06/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B81/">第一章 计算机系统漫游</a>
          </li>
        
          <li>
            <a href="/2020/11/23/ncpp-09/">第9章 顺序容器</a>
          </li>
        
          <li>
            <a href="/2020/11/22/ncpp-08/">ncpp-08</a>
          </li>
        
          <li>
            <a href="/2020/11/20/ncpp-07/">第7章 类</a>
          </li>
        
          <li>
            <a href="/2020/11/19/ncpp-06/">第6章 函数</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>
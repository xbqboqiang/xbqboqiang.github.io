<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>c++ primer 15 面向对象程序设计 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="面向对象程序设计OOP面向对象程序设计(object-oriented programming)的核心思想是数据抽象、继承和动态绑定数据抽象：将类的接口与实现分离继承：可以定义相似的类型并对其相似关系建模动态绑定：可以在一定程度上忽略相似类型的区别，以统一的方式使用它们的对象 继承层次关系的根部有一个基类(base class)，其他为派生类(derived class)。基类负责定义所有类共有的">
<meta property="og:type" content="article">
<meta property="og:title" content="c++ primer 15 面向对象程序设计">
<meta property="og:url" content="http://yoursite.com/2020/08/30/c-primer-15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="面向对象程序设计OOP面向对象程序设计(object-oriented programming)的核心思想是数据抽象、继承和动态绑定数据抽象：将类的接口与实现分离继承：可以定义相似的类型并对其相似关系建模动态绑定：可以在一定程度上忽略相似类型的区别，以统一的方式使用它们的对象 继承层次关系的根部有一个基类(base class)，其他为派生类(derived class)。基类负责定义所有类共有的">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-08-30T02:55:38.000Z">
<meta property="article:modified_time" content="2020-08-30T03:01:08.327Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="c++ primer">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-c-primer-15-面向对象程序设计" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/30/c-primer-15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" class="article-date">
  <time datetime="2020-08-30T02:55:38.000Z" itemprop="datePublished">2020-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      c++ primer 15 面向对象程序设计
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h1><h2 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h2><p>面向对象程序设计(object-oriented programming)的核心思想是数据抽象、继承和动态绑定<br>数据抽象：将类的接口与实现分离<br>继承：可以定义相似的类型并对其相似关系建模<br>动态绑定：可以在一定程度上忽略相似类型的区别，以统一的方式使用它们的对象</p>
<p>继承<br>层次关系的根部有一个基类(base class)，其他为派生类(derived class)。<br>基类负责定义所有类共有的成员，派生类定义各自特有的成员<br>对于某些函数，基类希望它的派生类个自定义合适自身的版本，则将其声明成虚函数(virtuan function)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Quote &#123;</span><br><span class="line">public:</span><br><span class="line">	string isbn() const;</span><br><span class="line">	virtual double net_price(size_t n)const;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>派生类必须通过类派生列表(class derivation list)明确指出是从哪基类继承而来的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Bulk_quote :public Quote &#123;</span><br><span class="line">public:</span><br><span class="line">	double net_price(size_t)const override;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>派生类必须在其内部对所有重新定义的虚函数进行声明</p>
<p>动态绑定<br>通过动态绑定可以用同一段代码分别处理Quote和Bulk_quote的对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">double print_total(ostream&amp; os, const Quote&amp; item, size_t n) &#123;</span><br><span class="line">	&#x2F;&#x2F;根据传入item形参的对象类型调用Quote::net_price或者Bulk_quote::net_price</span><br><span class="line">	double ret &#x3D; item.net_price(n);</span><br><span class="line">	os &lt;&lt; item.isbn() &lt;&lt; &quot; &quot; &lt;&lt; n &lt;&lt; &quot; &quot; &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据实际传入print_total的对象类型决定执行net_price的哪个版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print_total(cout, basic, 20);	&#x2F;&#x2F;调用Quote的net_price</span><br><span class="line">print_total(cout, bulk, 20);	&#x2F;&#x2F;调用Bulk_quote的net_price</span><br></pre></td></tr></table></figure>
<p>当我们使用基类的引用(或指针)调用一个虚函数时将发生动态绑定</p>
<h2 id="定义基类和派生类"><a href="#定义基类和派生类" class="headerlink" title="定义基类和派生类"></a>定义基类和派生类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Quote &#123;</span><br><span class="line">public:</span><br><span class="line">	Quote() &#x3D; default;</span><br><span class="line">	Quote(const string&amp; book, double sales_price) :bookNo(book), price(sales_price) &#123;&#125;</span><br><span class="line">	string isbn()const &#123; return bookNo; &#125;</span><br><span class="line">	&#x2F;&#x2F;返回给定数量书籍的总销售额  派生类负责改写并使用不同的折扣计算法</span><br><span class="line">	virtual double net_price(size_t n)const &#123; return n * price; &#125;</span><br><span class="line">	virtual ~Quote() &#x3D; default;	&#x2F;&#x2F;对析构函数进行动态绑定</span><br><span class="line">private:</span><br><span class="line">	string bookNo;	&#x2F;&#x2F;书籍的isbn编号</span><br><span class="line">protected:</span><br><span class="line">	double price &#x3D; 0.0;	&#x2F;&#x2F;代表普通状态下不打折的价格</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>成员函数与继承<br>基类将希望其派生类进行覆盖的函数定义为虚函数。当使用指针或引用调用虚函数时，该调用将被动态绑定。<br>根据所绑定对象的版本来调用对应执行的版本<br>构造函数之外的非静态函数都可以是虚函数。关键字virtual只能出现在类内部的声明语句之前不能用于外部定义</p>
<h3 id="定义派生类"><a href="#定义派生类" class="headerlink" title="定义派生类"></a>定义派生类</h3><p>派生类必须将其继承而来的成员函数中需要覆盖的那些重新声明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Bulk_quote :public Quote &#123;</span><br><span class="line">public;</span><br><span class="line">	Bulk_quote() &#x3D; default;</span><br><span class="line">	Bulk_quote(const string&amp;, double, size_t, double);</span><br><span class="line">	&#x2F;&#x2F;覆盖基类的函数版本以实现基于大量购买的折扣政策</span><br><span class="line">	double net_price(size_t)const override;</span><br><span class="line">private:</span><br><span class="line">	size_t min_qty &#x3D; 0;		&#x2F;&#x2F;使用折扣政策的最低购买量</span><br><span class="line">	double discount &#x3D; 0.0;	&#x2F;&#x2F;以小数表示折扣额</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他普通成员，派生类会直接继承其在基类中的版本</p>
<p>派生类对象及派生类向基类的类型转换<br>一个派生类的对象包含：含有派生类自己定义的(非静态)成员的子对象及与该派生类继承的基类对应的子对象<br>可以把派生类的对象当成基类对象来使用，也可以把基类的指针或引用绑定到派生类对象中的基类部分上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Quote item;			&#x2F;&#x2F;基类对象</span><br><span class="line">Bulk_quote bulk;	&#x2F;&#x2F;派生类对象</span><br><span class="line">Quote* p &#x3D; &amp;item;	&#x2F;&#x2F;p指向Quote对象</span><br><span class="line">p &#x3D; &amp;bulk;			&#x2F;&#x2F;p指向bulk的Quote部分</span><br><span class="line">Quote&amp; r &#x3D; bulk;	&#x2F;&#x2F;r绑定到bulk的Quote部分</span><br></pre></td></tr></table></figure>
<p>Bulk_quote的构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bulk_quote(const string&amp; book, double p, size_t qty, double disc) :Quote(book, p), min_qty(qty), discount(disc) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>该函数将它前两个参数传递给Quote的构造函数，由Quote的构造函数负责初始化Bulk_quote的基类部分<br>接下来由派生类直接定义其它的成员，最后运行Bulk_quote构造函数的函数体</p>
<p>派生类可以访问基类的公有成员和受保护成员</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">double Bulk_quote::net_price(size_t cnt)const &#123;</span><br><span class="line">	if (cnt &gt;&#x3D; min_qty)</span><br><span class="line">		return cnt * (1 - discount) * price;</span><br><span class="line">	else</span><br><span class="line">		return cnt * price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继承与静态成员<br>如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">public:</span><br><span class="line">	static void statmem();</span><br><span class="line">&#125;;</span><br><span class="line">class Derived :public Base &#123;</span><br><span class="line">	void f(const Derived&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>假设某静态成员是可以访问的，就既能通过基类使用它也能通过派生类使用它</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void Derived::f(const Derived&amp; derived_obj) &#123;</span><br><span class="line">	Base::statmem();		&#x2F;&#x2F;正确：Base定义了statmem</span><br><span class="line">	Derived::statmem();		&#x2F;&#x2F;正确：Derived继承了statmem</span><br><span class="line">	&#x2F;&#x2F;正确：派生类的对象能访问基类的静态成员</span><br><span class="line">	derived_obj.statmem();	&#x2F;&#x2F;通过Derived对象访问</span><br><span class="line">	statmem();				&#x2F;&#x2F;通过this对象访问</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>派生类声明中包含类名但不包含它的派生列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Bulk_quote :public Quote;	&#x2F;&#x2F;错误</span><br><span class="line">class Bulk_quote;				&#x2F;&#x2F;正确</span><br></pre></td></tr></table></figure>
<p>想将有个类用作基类，必须已经定义而非仅仅声明</p>
<p>防止基类发生<br>在类名后跟一个关键字final</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class NoDerived final &#123;&#125;;</span><br><span class="line">class Base &#123;&#125;;</span><br><span class="line">class Last final :Base &#123;&#125;;</span><br><span class="line">class Bad :NeDerived &#123;&#125;;	&#x2F;&#x2F;错误：NoDerived是final的</span><br><span class="line">class Bad2 :Last &#123;&#125;;		&#x2F;&#x2F;错误：Last是final的</span><br></pre></td></tr></table></figure>
<h3 id="类型转换与继承"><a href="#类型转换与继承" class="headerlink" title="类型转换与继承"></a>类型转换与继承</h3><p>可以将基类的指针或引用绑定到派生类对象上<br>当使用基类的引用或指针时，实际上我们并不清楚该引用或指针所绑定对象的真实类型<br>基类的指针或引用的静态类型可能与其动态类型不一致</p>
<p>不存在基类向派生类的隐式类型转换<br>一个基类的对象可能是派生类对象的一部分，也可能不是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Quote base;</span><br><span class="line">Bulk_quote* bulkP &#x3D; &amp;base;	&#x2F;&#x2F;错误</span><br><span class="line">Bulk_quote&amp; bulkR &#x3D; base;	&#x2F;&#x2F;错误</span><br></pre></td></tr></table></figure>
<p>如果上述是合法的，则可能用其访问base中不存在的成员<br>即使一个基类指针或引用绑定在派生类对象上，也不能执行从基类向派生类的转换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bulk_quote bulk;</span><br><span class="line">Quote* itemP &#x3D; &amp;bulk;		&#x2F;&#x2F;正确：动态类型是Bulk_quote</span><br><span class="line">Bulk_quote* bulkP &#x3D; itemP;	&#x2F;&#x2F;错误：不能将基类转换成派生类</span><br></pre></td></tr></table></figure>
<p>派生类向基类的自动类型转换至针对指针或引用类型有效<br>当用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，派生类部分将被忽略掉</p>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>使用基类的引用或指针调用一个虚成员函数时会执行动态绑定。虚函数都必须有定义</p>
<p>对虚函数的调用可能在运行时才被解析<br>被调用的函数是与绑定到指针或引用上的对象的动态类型匹配的那个</p>
<p>引用或指针的静态类型与动态类型不听这一事实是c++语言支持多态性的根本所在<br>使用基类的引用或指针调用基类中定义的一个函数时，并不知道该函数真正作用的对象是什么类型，可能是基类的对象也可能是派生类的对象<br>如果该函数是虚函数，知道运行时才会决定到底执行那个版本，判断的依据是引用或指针所绑定对象的真实类型<br>对非虚函数的调用在编译时进行绑定。通过对象进行的函数调用也在编译时绑定。对象的类型是确定不变的，不可能动态类型和静态类型不一致</p>
<p>当且仅当通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有这种情况下对象的动态类型才可能与静态类型不同</p>
<p>派生类中的虚函数<br>一旦某个函数被声明为虚函数，则在所有的派生类中都是虚函数<br>一个派生类的函数如果覆盖了某个继承来的虚函数，它的形参类型必须与被覆盖的基类函数完全一致<br>派生类中虚函数的返回类型也必须与基类函数匹配。有一例外：当类的虚函数返回类型是类本身的指针或引用时。不过要求派生类到基类的类型转换是可以访问的</p>
<p>可以使用override关键字来说明派生类中的虚函数<br>可以使程序员的意图更清晰，也可以让编译器为我们发现错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct B &#123;</span><br><span class="line">	virtual void f1(int)const;</span><br><span class="line">	virtual void f2();</span><br><span class="line">	void f3();</span><br><span class="line">&#125;;</span><br><span class="line">struct D1 :B &#123;</span><br><span class="line">	void f1(int)const override;	&#x2F;&#x2F;正确：f1与基类中f1匹配</span><br><span class="line">	void f2(int) override;		&#x2F;&#x2F;错误：B没有形如f2(int)的函数</span><br><span class="line">	void f3() override;			&#x2F;&#x2F;错误：f3不是虚函数</span><br><span class="line">	void f4() override;			&#x2F;&#x2F;错误：B没有f4</span><br><span class="line">&#125;;</span><br><span class="line">struct D2 :B &#123;</span><br><span class="line">	void f1(int)const final;	&#x2F;&#x2F;不允许后续的其他类覆盖f1(int)</span><br><span class="line">&#125;;</span><br><span class="line">struct D3 :D2 &#123;</span><br><span class="line">	void f2();			&#x2F;&#x2F;正确：覆盖从间接基类B继承而来的f2</span><br><span class="line">	void f1(int)const;	&#x2F;&#x2F;错误：D2已将f1(int)声明成final</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>虚函数与默认实参<br>如果某次函数调用使用了默认实参，则该实参值由本次调用的静态类型决定<br>如果通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即使实际中运行的是派生类中的版本也是如此<br>此时传入派生类函数的将是基类函数定义的默认实参，如果派生类函数依赖不同的实参，则结果将与我们的预期不符</p>
<p>回避虚函数的机制<br>希望对虚函数的调用不要进行动态绑定，强迫执行虚函数的某个特定版本，使用作用域运算符来实现<br>double undiscounted = baseP-&gt;Quote::net_price(42);<br>该调用将在编译时完成解析</p>
<h2 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h2><p>纯虚函数(pure virtual)，无须定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;用于保存折扣值和购买量的类，派生类使用这些数据可以实现不同的价格策略</span><br><span class="line">class Disc_quote :public Quote &#123;</span><br><span class="line">public:</span><br><span class="line">	Disc_quote() &#x3D; default;</span><br><span class="line">	Disc_quote(const string&amp; book, double price, size_t qty, double disc) :</span><br><span class="line">		Quote(book, price), quantity(qty), discount(disc) &#123;&#125;</span><br><span class="line">	double net_price(size_t)const &#x3D; 0;</span><br><span class="line">protected:</span><br><span class="line">	size_t quantity &#x3D; 0;	&#x2F;&#x2F;折扣适用的购买量</span><br><span class="line">	double discount &#x3D; 0.0;	&#x2F;&#x2F;表示折扣的小数值</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以为纯虚函数提供定义，不过函数体必须定义在类的外部</p>
<p>含有纯虚函数的类是抽象基类(abstract base class)<br>抽象基类负责定义接口，不能直接创建一个抽象基类的对象<br>派生类必须给出自己的net_price定义，否则他们仍是抽象基类</p>
<p>派生类构造函数只初始化它的直接基类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Bulk_quote :public Disc_quote &#123;</span><br><span class="line">public:</span><br><span class="line">	Bulk_quote() &#x3D; default;</span><br><span class="line">	Bulk_quote(const string&amp; book, double price, size_t qty, double disc) :</span><br><span class="line">		Disc_quote(book, price, qyt, disc) &#123;&#125;</span><br><span class="line">	&#x2F;&#x2F;覆盖基类中的函数版本以实现一种新的折扣策略</span><br><span class="line">	double net_price(size_t)const override;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>重构负责重新设计类的体系以便将操作和 / 或数据从一个类移动到另一个类中</p>
<h2 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h2><p>受保护的成员<br>一个类使用protected关键字来声明那些它希望与派生类分享但是不想被其它公共访问的成员<br>·受保护的成员对于类的用户来说是不可访问的<br>·受保护的成员也对于派生类的成员和友元来说是可访问的<br>·派生类的成员和或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问特权</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">protected:</span><br><span class="line">	int prot_mem;</span><br><span class="line">&#125;;</span><br><span class="line">class Sneaky :public Base &#123;</span><br><span class="line">	friend void clobber(Sneaky&amp;);	&#x2F;&#x2F;能访问Sneaky::prot_mem</span><br><span class="line">	friend void clobber(Base&amp;);		&#x2F;&#x2F;能访问Base::prot_mem</span><br><span class="line">	int j;							&#x2F;&#x2F;j默认是private</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;正确：clobber能访问Sneaky对象的private和protected成员</span><br><span class="line">void clobber(Sneaky&amp; s) &#123; s.j &#x3D; s.prot_mem &#x3D; 0; &#125;</span><br><span class="line">&#x2F;&#x2F;错误：clobber不能访问Base的protected成员</span><br><span class="line">void clovver(Base&amp; b) &#123; b.prot_mem &#x3D; 0; &#125;</span><br></pre></td></tr></table></figure>
<p>公有、私有和受保护继承</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">public:</span><br><span class="line">	void pub_mem();</span><br><span class="line">protected:</span><br><span class="line">	int prot_mem;</span><br><span class="line">private:</span><br><span class="line">	char priv_mem;</span><br><span class="line">&#125;;</span><br><span class="line">struct Pub_Derv :public Base &#123;</span><br><span class="line">	&#x2F;&#x2F;正确：派生类能访问protected成员</span><br><span class="line">	int f() &#123; return prot_mem; &#125;</span><br><span class="line">	&#x2F;&#x2F;错误：private成员对于派生类是不可访问的</span><br><span class="line">	char g() &#123; return priv_mem; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">struct Priv_Derv :private Base &#123;</span><br><span class="line">	&#x2F;&#x2F;private不影响派生类的访问权限</span><br><span class="line">	int f1() &#123; return prot_mem; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>派生类访问说明符对于派生类的成员(及友元)能否访问其直接基类的成员没什么影响，对于基类成员的访问权限只与基类中的访问说明符有关<br>派生访问说明符的目的是控制派生类用户(包括派生类的派生类)对于基类成员的访问权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Pub_Derv d1;	&#x2F;&#x2F;继承自Base的成员是public的</span><br><span class="line">Priv_Derv d2;	&#x2F;&#x2F;继承自Base的成员是private的</span><br><span class="line">d1.pub_mem();	&#x2F;&#x2F;正确：pub_mem在派生类中是public的</span><br><span class="line">d2.pub_mem();	&#x2F;&#x2F;错误：pub_mem在派生类中是private的</span><br></pre></td></tr></table></figure>
<p>派生访问说明符还可以控制继承自派生类的新类的访问权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct Derived_from_Public :public Pub_Derv &#123;</span><br><span class="line">	&#x2F;&#x2F;正确：Base::prot_mem在Pub_Derv中仍然是protected的</span><br><span class="line">	int use_base() &#123; return prot_mem; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">struct Derived_from_Prevate :public Priv_Derv &#123;</span><br><span class="line">	&#x2F;&#x2F;错误：Base::prot_mem在PrivDerv中是private的</span><br><span class="line">	int use_base() &#123; return prot_mem; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>派生类向基类转换的可访问性<br>·只有当D公有地继承B时，用户代码才能使用派生类向基类的转换<br>·无论什么方式继承，D的成员函数和友元都能使用派生类向基类的转换<br>·如果继承方式是公有或者受保护的，则D的派生类的成员和友元可以使用D向B的类型转换</p>
<p>友元与继承<br>友元关系不能继承。基类的友元访问派生类成员时不具有特殊性，派生类的友元也不能随意访问基类的成员</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">	friend class Pal;</span><br><span class="line">&#125;;</span><br><span class="line">class Pal &#123;</span><br><span class="line">public:</span><br><span class="line">	int f(Base b) &#123; return b.prot_mem; &#125;	&#x2F;&#x2F;正确：pal是Base的友元</span><br><span class="line">	int f2(Sneaky s) &#123; return s.j; &#125;		&#x2F;&#x2F;错误：Pal不是Sneaky的友元</span><br><span class="line">	&#x2F;&#x2F;对基类的访问权限由基类本身控制，即使对于派生类的基类部分也是如此</span><br><span class="line">	int f3(Sneaky s) &#123; return s.prot_mem; &#125;	&#x2F;&#x2F;正确：Pal是Base的友元</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当一个类将另一个类声明为友元时，这种友元关系只能对做出声明的类有效。对于原来那个类来说，其友元的基类或者派生类不具有特殊的访问能力</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class D2 :public Pal &#123;</span><br><span class="line">public:</span><br><span class="line">	int mem(Base b) &#123; return b.prot_mem; &#125;	&#x2F;&#x2F;错误：友元关系不能继承</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>改变个别成员的可访问性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">public:</span><br><span class="line">	size_t size()const &#123; return n; &#125;</span><br><span class="line">protected:</span><br><span class="line">	size_t n;</span><br><span class="line">&#125;;</span><br><span class="line">class Derived :private Base &#123;</span><br><span class="line">public:</span><br><span class="line">	using Base::size;</span><br><span class="line">protected:</span><br><span class="line">	using Base::n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>默认情况下，class关键字定义的派生类是私有继承；struct是公有继承<br>class和struct唯一的差别就是默认成员访问说明符和默认派生访问说明符</p>
<h2 id="继承中的作用域"><a href="#继承中的作用域" class="headerlink" title="继承中的作用域"></a>继承中的作用域</h2><p>派生类的做哟用于嵌套在其基类的作用域之内。如果一个名字在派生类的作用域内无法解析，则编译器将继续在外层的基类作用域中寻找该名字的定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bulk_quote bulk;</span><br><span class="line">cout &lt;&lt; bulk.isbn();</span><br><span class="line">isbn()先在Bulk_quote中查找，再在Disc_quote中找，最后在Quote中找</span><br></pre></td></tr></table></figure>
<p>一个对象、引用或指针的静态类型决定了该对象的哪些成员是可见的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Disc_quote :public Quote &#123;</span><br><span class="line">public:</span><br><span class="line">	pair&lt;size_t, double&gt;discount_policy()const &#123; return &#123; quantity,discount &#125;; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>只能通过Disc_quote及其派生类的对象、引用或指针使用discount_policy</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Bulk_quote bulk;</span><br><span class="line">Bulk_quote* bulkP &#x3D; &amp;bulk;	&#x2F;&#x2F;静态类型与动态类型一直</span><br><span class="line">Quote* itemP &#x3D; &amp;bulk;		&#x2F;&#x2F;静态类型与动态类型不一致</span><br><span class="line">bulkP-&gt;discount_policy();	&#x2F;&#x2F;正确：bulkP的类型是Bulk_quote*</span><br><span class="line">itemP-&gt;discount_policy();	&#x2F;&#x2F;错误：itemP的类型是Quote*</span><br></pre></td></tr></table></figure>
<p>名字冲突与继承</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct Base &#123;</span><br><span class="line">	Base() :mem(0) &#123;&#125;</span><br><span class="line">protected:</span><br><span class="line">	int mem;</span><br><span class="line">&#125;;</span><br><span class="line">struct Derived :Base &#123;</span><br><span class="line">	Derived(int i) :mem(i) &#123;&#125;		&#x2F;&#x2F;用i初始化Derived::mem， Base::mem进行默认初始化</span><br><span class="line">	int get_mem() &#123; return mem; &#125;	&#x2F;&#x2F;返回Derived::mem</span><br><span class="line">protected:</span><br><span class="line">	int mem;						&#x2F;&#x2F;隐藏基类中的mem</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过作用域运算符来使用隐藏的成员</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct Derived :Base &#123;</span><br><span class="line">	int get_base_mem() &#123; return Base::mem; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>函数调用的解析过程，调用p-&gt;mem()：<br>·先确定p的静态类型<br>·在p的静态类型对象的类中查找mem。找不到则在其基类中继续。扔找不到则编译器报错<br>·一旦找到mem则进行常规的类型检查，确认对于当前找到的mem，本次调用是否合法<br>·假设调用合法，编译器根据是否是虚函数而产生不同代码：<br>–是虚函数且通过引用或指针进行的调用，则编译器产生的代码将在运行时确定运行该虚函数的哪个版本，依据是对象动态类型<br>–反之则产生一个常规函数调用</p>
<p>如果派生类的成员与基类的某个成员同名，则派生类在其作用域内隐藏掉该基类成员，即使形参列表不一致</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct Base &#123;</span><br><span class="line">	int memfcn();</span><br><span class="line">&#125;;</span><br><span class="line">struct Derived :Base &#123;</span><br><span class="line">	int memfcn(int);</span><br><span class="line">&#125;;</span><br><span class="line">Derived d; Base b;</span><br><span class="line">b.memfcn();			&#x2F;&#x2F;调用Base::memfcn</span><br><span class="line">d.memfcn(10);		&#x2F;&#x2F;调用Derived::memfcn</span><br><span class="line">d.memfcn();			&#x2F;&#x2F;错误：参数列表为空的memfcn被隐藏了</span><br><span class="line">d.Base::memfcn();	&#x2F;&#x2F;正确：调用Base::memfcn</span><br></pre></td></tr></table></figure>
<p>虚函数与作用域<br>如果基类与派生类的虚函数接受的实参不同，则无法通过基类的引用或指针调用派生类的虚函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">public:</span><br><span class="line">	virtual int fcn();</span><br><span class="line">&#125;;</span><br><span class="line">class D1 :public Base &#123;</span><br><span class="line">public:</span><br><span class="line">	&#x2F;&#x2F;隐藏基类的fcn，这个fcn不是虚函数</span><br><span class="line">	int fcn(int);		&#x2F;&#x2F;形参列表与Base中的不一致</span><br><span class="line">	virtual void f2();	&#x2F;&#x2F;是一个新的虚函数，Base中不存在</span><br><span class="line">&#125;;</span><br><span class="line">class D2 :public D1 &#123;</span><br><span class="line">public:</span><br><span class="line">	int fcn(int);	&#x2F;&#x2F;一个非虚函数，隐藏了D1::fcn(int)</span><br><span class="line">	int fcn();		&#x2F;&#x2F;覆盖了Base中的虚函数fcn</span><br><span class="line">	void f2();		&#x2F;&#x2F;覆盖了D1中的虚函数f2</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过基类调用隐藏的虚函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Base bobj; D1 d1obj; D2 d2obj;</span><br><span class="line">Base* bp1 &#x3D; &amp;bobj, * bp2 &#x3D; &amp;d1obj, * bp3 &#x3D; &amp;d2obj;</span><br><span class="line">bp1-&gt;fcn();	&#x2F;&#x2F;虚调用，将在运行时调用Base::fcn</span><br><span class="line">bp2-&gt;fcn(); &#x2F;&#x2F;虚调用，将在运行时调用Base::fcn</span><br><span class="line">bp3-&gt;fcn();	&#x2F;&#x2F;&#x2F;虚调用，将在运行时调用D2::fcn</span><br><span class="line"></span><br><span class="line">D1* d1p &#x3D; &amp;d1obj; D2* d2p &#x3D; &amp;d2obj;</span><br><span class="line">bp2-&gt;f2();	&#x2F;&#x2F;错误：Base没有名为f2的成员</span><br><span class="line">d1p-&gt;f2(); &#x2F;&#x2F;虚调用，将在运行时调用D1::f2()</span><br><span class="line">d2p-&gt;f2(); &#x2F;&#x2F;虚调用，将在运行时调用D2::f2()</span><br><span class="line"></span><br><span class="line">Base* p1 &#x3D; &amp;d2obj; D1* p2 &#x3D; &amp;d2obj; D2* p3 &#x3D; &amp;d2obj;</span><br><span class="line">p1-&gt;fcn(42);	&#x2F;&#x2F;错误：Base中没有fcn(int)</span><br><span class="line">p2-&gt;fcn(42);	&#x2F;&#x2F;正确：调用D1:fcn(int)</span><br><span class="line">p3-&gt;fcn(42);	&#x2F;&#x2F;正确：调用D2:fcn(int)</span><br></pre></td></tr></table></figure>
<h2 id="构造函数与拷贝控制"><a href="#构造函数与拷贝控制" class="headerlink" title="构造函数与拷贝控制"></a>构造函数与拷贝控制</h2><h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p>通常基类应该定义一个虚析构函数，这样就能动态分配继承体系中的对象了<br>如果delete一个Quote* 类型的指针，该指针实际指向了一个Bulk_quote类型的对象。编译器就必须要清楚它应该执行Bulk_quote的析构函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Quote &#123;</span><br><span class="line">public:</span><br><span class="line">	virtual ~Quote() &#x3D; default;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>析构函数的虚属性会被继承</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Quote* itemP &#x3D; new Quote;	&#x2F;&#x2F;静态类型与动态类型一致</span><br><span class="line">delete itemP;				&#x2F;&#x2F;调用Quote的析构函数</span><br><span class="line">itemp &#x3D; new Bulk_quote;		&#x2F;&#x2F;静态类型与动态类型不一致</span><br><span class="line">delete itemP;				&#x2F;&#x2F;调用Bulk_quote的析构函数</span><br></pre></td></tr></table></figure>
<p>如果基类的析构函数不是虚函数，则delete一个指向派生类对象的指针将产生未定义的行为</p>
<p>如果一个类定义了析构函数，则编译器不会为这个类合成移动操作，因此移动基类对象时，实际使用的是合成和拷贝的操作</p>
<h3 id="合成拷贝控制与继承"><a href="#合成拷贝控制与继承" class="headerlink" title="合成拷贝控制与继承"></a>合成拷贝控制与继承</h3><p>基类或派生类的合成拷贝控制成员的行为：对类本身的成员依次进行初始化、赋值或销毁的操作，还负责使用直接基类中对应的操作对一个对象的直接基类部分进行初始化、赋值或销毁的操作<br>·合成的Bulk_quote默认构造函数运行Disc_quote的默认构造函数，后又运行Quote的默认构造函数<br>·Quote的默认构造函数将bookNo成员默认初始化为空字符串，同时使用类内初始值将price初始化为0<br>·Quote的构造函数完成后，继续执行Disc_quote的构造函数，使用类内初始值初始化qty和discount<br>·继续执行Bulk_quote的构造函数，但它什么也不做</p>
<p>派生类中删除的拷贝控制与基类的关系<br>·如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的函数或不可访问，则派生类中对象的成员将是被删除的，<br>原因是编译器不能使用基类成员来执行派生类对象基类部分的构造赋值或销毁操作<br>·如果在基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认和拷贝构造函数将是被删除的，因为编译器无法销毁派生类对象的基类部分<br>·编译器将不会合成一个删除掉的操作。当使用 = default请求一个移动操作时，如果基类中的对应操作是删除的或不可访问的，<br>那么派生类中该函数将是被删除的，因为派生类对象的基类部分不可移动。同样，基类的析构函数是删除的或不可访问的，<br>则派生类的移动构造函数也是被删除的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class B &#123;</span><br><span class="line">public:</span><br><span class="line">	B();</span><br><span class="line">	B(const&amp;) &#x3D; delete;</span><br><span class="line">&#125;;</span><br><span class="line">class D :public B &#123;</span><br><span class="line">	&#x2F;&#x2F;没有声明任何构造函数</span><br><span class="line">&#125;;</span><br><span class="line">D d;			&#x2F;&#x2F;正确：D的合成默认构造函数使用B的默认构造函数</span><br><span class="line">D d2(d);		&#x2F;&#x2F;错误：D的合成拷贝构造函数是被删除的</span><br><span class="line">D d3(move(d));	&#x2F;&#x2F;错误：隐式地使用D的被删除的拷贝构造函数</span><br></pre></td></tr></table></figure>
<p>因为定义了拷贝构造函数，所以编译器不会为B合成一个移动构造函数，因此既不能拷贝也不能移动B的对象</p>
<p>移动操作与继承<br>大多数基类会定义一个虚析构函数，因此在默认情况下基类通常不含有合成的移动操作，而且派生类中也没有<br>所以需要执行移动时应首先在基类中进行定义，一旦定义了自己的移动操作，又必须显式地定义拷贝操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Quote &#123;</span><br><span class="line">public:</span><br><span class="line">	Quote(); &#x3D; default;</span><br><span class="line">	Quote(const Quote&amp;) &#x3D; default;</span><br><span class="line">	Quote(Quote&amp;&amp;) &#x3D; default;</span><br><span class="line">	Quote&amp; operator&#x3D;(const Quote&amp;) &#x3D; default;</span><br><span class="line">	Quote&amp; operator(Quote&amp;&amp;) &#x3D; default;</span><br><span class="line">	virtual ~Quote() &#x3D; default;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="派生类的拷贝控制成员"><a href="#派生类的拷贝控制成员" class="headerlink" title="派生类的拷贝控制成员"></a>派生类的拷贝控制成员</h3><p>派生类的拷贝和移动构造函数在拷贝和移动自有成员的同时，也要拷贝和移动基类部分的成员<br>析构函数只负责销毁派生类自己分配的资源</p>
<p>定义派生类的拷贝或移动构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;&#x2F;* *&#x2F; &#125;;</span><br><span class="line">class D :public Base &#123;</span><br><span class="line">public:</span><br><span class="line">	&#x2F;&#x2F;默认情况下，基类的默认构造函数初始化对象的基类部分</span><br><span class="line">	&#x2F;&#x2F;想要使用拷贝或移动构造函数，必须在构造函数初始值列表中显式地调用该构造函数</span><br><span class="line">	D(const D&amp; d) :Base(d)&#x2F;*D成员的初始值*&#x2F; &#123;&#125;</span><br><span class="line">	D(D&amp;&amp; d) :Base(move(d))&#x2F;*D成员的初始值*&#x2F; &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>派生类赋值运算符<br>派生类的赋值运算符也必须显式地为其基类部分赋值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Base::operator&#x3D;(const Base&amp;)不会被自动调用</span><br><span class="line">D&amp; D::operator&#x3D;(const D&amp; rhs) &#123;</span><br><span class="line">	Base::operator(rhs);&#x2F;&#x2F;为基类部分赋值</span><br><span class="line">	return*this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先显式调用基类赋值运算符，令其为派生类对象的基类部分赋值。</p>
<p>派生类析构函数<br>派生类析构函数只负责销毁由派生类自己分配的资源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class D :public Base &#123;</span><br><span class="line">	public;</span><br><span class="line">	&#x2F;&#x2F;Base::~Base被自动调用执行</span><br><span class="line">	~D() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对象销毁的顺序与创建的相反：派生类析构函数首先执行，然后是基类的析构函数</p>
<h3 id="继承的构造函数"><a href="#继承的构造函数" class="headerlink" title="继承的构造函数"></a>继承的构造函数</h3><p>通过注明了基类名的using声明语句来为派生类继承基类构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Bulk_quote :public Disc_quote &#123;</span><br><span class="line">	public;</span><br><span class="line">	using Disc_quote::Disc_quote;	&#x2F;&#x2F;继承Disc_quote的构造函数</span><br><span class="line">	double net_price(size_t)const;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>编译器生成的构造函数形如：<br>derived(parms) :base(args) {}<br>Bulk_quote类中继承的构造函数等价于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bulk_quote(const string&amp; book, double price, size_t qty, double disc) : Disc_quote(book, price, qty, disc) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>如果派生类含有自己的数据成员，则这些成员将被默认初始化</p>
<p>继承的构造函数的特点<br>一个构造函数的using声明不会改变该构造函数的访问级别。基类的私有构造函数在派生类中还是一个私有构造函数<br>一个using声明语句不能指定explicit或constexpr<br>当一个基类构造函数含有默认实参时，这些实参不会被继承。相反，派生类将会获得多个继承的构造函数，每个构造函数分别省略掉一个含有默认实参的形参<br>派生类可以继承一部分构造函数，而为其它的构造函数定义自己的版本。如果派生类定义的构造函数与基类的有相同的参数列表，则该构造函数不会被继承<br>默认、拷贝和移动构造函数不会被继承。继承的构造函数不会被作为用户定义的构造函数来使用，如果一个类只含有继承的构造函数，它也将拥有合成的默认构造函数</p>
<h2 id="容器与继承"><a href="#容器与继承" class="headerlink" title="容器与继承"></a>容器与继承</h2><p>当使用容器存放继承体系中的对象时，必须采用简洁储存的方式。不允许在容器中保存不同类型的元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;Quote&gt;basket;</span><br><span class="line">basket.push_back(Quote(&quot;999-99&quot;, 50);</span><br><span class="line">&#x2F;&#x2F;正确：但只能把对象的Quote部分拷贝给basket</span><br><span class="line">basket.push_balk(Bulk_quote(&quot;999-9999&quot;, 50, 10, .25));</span><br><span class="line">&#x2F;&#x2F;调用Quote定义的版本，打印750</span><br><span class="line">cout &lt;&lt; basket.back().net_price(15) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>在容器中放置(智能)指针而非对象<br>当我们希望在容器中存放具有继承关系的对象时，实际上存放的通常是基类的指针。这些指针所指的对象的动态类型可能是基类或者派生类类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;shared_ptr&lt;Quote&gt;&gt;basket;</span><br><span class="line">basket.push_back(make_shared&lt;Quote&gt;(&quot;999-99&quot;, 50);</span><br><span class="line">basket.push_back(make_shared&lt;Bulk_quote&gt;(&quot;999-9999&quot;, 50, 10, .25));</span><br><span class="line">cout &lt;&lt; basket.back()-&gt;net_price(15) &lt;&lt; endl;	&#x2F;&#x2F;打印562.5，即15*50*.75</span><br></pre></td></tr></table></figure>
<p>实际调用的net_price版本依赖于指针所指对象的动态类型<br>在第二个push_back中，我们可以把一个派生类的智能指针转换成基类的智能指针<br>make_shared<Bulk_quote>返回一个shared_ptr<Bulk_quote>对象。调用push_back时该对象被转换成shared_ptr<Quote></p>
<h3 id="编写Basket类"><a href="#编写Basket类" class="headerlink" title="编写Basket类"></a>编写Basket类</h3><p>对于c++面向对象编程来说，一个悖论是无法直接使用对象进行面向对象编程。必须使用指针和引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Basket &#123;</span><br><span class="line">public:</span><br><span class="line">	&#x2F;&#x2F;Basket使用合成的默认构造函数和拷贝控制成员</span><br><span class="line">	void add_item(const shared_ptr&lt;Quote&gt;&amp; sale) &#123; items.insert(sale); &#125;</span><br><span class="line">	double total_receipt(ostream&amp;)const;</span><br><span class="line">private:</span><br><span class="line">	static bool compare(const shared_ptr&lt;Quote&gt;&amp; lhs, const shared_ptr&lt;Quote&gt;&amp; rhs) &#123;</span><br><span class="line">		return lhs-&gt;isbn() &lt; rhs-&gt;isbn();</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;multiset保存多个报价，按照compare成员排序</span><br><span class="line">	multiset&lt;shared_ptr&lt;Quote&gt;, decltype(compare)*&gt;items&#123; compare &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>定义了一个指向Quote的shared_ptr的multiset。这个multiset将使用一个与compare成员类型相同的函数来对其中的元素进行排序。<br>multiset成员的名字是items，初始化items并令其使用我们的compare函数</p>
<p>定义Basket的成员<br>total_receipt成员负责量购物篮的内容逐项打印成清单，然后返回购物篮中所有物品的总价格</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">double Basket::total_receipt(ostream&amp; os)const &#123;</span><br><span class="line">	double sum &#x3D; 0.0;</span><br><span class="line">	&#x2F;&#x2F;iter指向ISBN相同的一批元素的第一个</span><br><span class="line">	&#x2F;&#x2F;uooer_bound返回一个迭代器，指向这批元素的尾后位置</span><br><span class="line">	for (auto iter &#x3D; items.cbegin(); iter !&#x3D; items.cend(); iter &#x3D; items.upper_bound(*iter)) &#123;</span><br><span class="line">		&#x2F;&#x2F;在当前的Basket中至少有一个该关键字的元素，打印该书籍对应的项目</span><br><span class="line">		sum +&#x3D; print_total(os, **iter, items.count(*iter));</span><br><span class="line">	&#125;</span><br><span class="line">	os &lt;&lt; &quot;Total Sale: &quot; &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">	return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用upper_bound函数可以令我们跳过与当前关键字相同的所有元素<br>它返回的是一个迭代器，指向所有与iter关键字相等的元素中最后一个元素的下一位置<br>解引用iter后将得到一个准备打印对象的shared_ptr，所以需要再解引用该shared_ptr。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">** iter是一个Quote对象(或QUote的派生类的对象)</span><br><span class="line">print_total调用了虚函数net_price，因此最终的计算结果依赖于** iter的动态类型</span><br></pre></td></tr></table></figure>
<p>隐藏指针<br>Basket用户需要处理动态内存，add_item需要接受一个shared_ptr参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Basket bsk;</span><br><span class="line">bsk.add_item(make_shared&lt;Quote&gt;(&quot;999-99&quot;, 45));</span><br><span class="line">bsk.add_item(make_shared&lt;Bulk_quote&gt;(&quot;999-9999&quot;, 50, 10, .25));</span><br><span class="line">重新定义add_item，使得它接受一个Quote对象，而非shared_ptr</span><br><span class="line">void add_item(const Quote&amp; sale);	&#x2F;&#x2F;拷贝给定对象</span><br><span class="line">void add_item(Quote&amp;&amp; sale);		&#x2F;&#x2F;移动给定对象</span><br></pre></td></tr></table></figure>
<p>但add_item不知道要分配的类型，进行内存分配时，某处可能会有：new Quote(sale)。但sale指向Bulk_quote对象时，会被迫切掉一部分</p>
<p>模拟虚拷贝<br>所以给Quote添加一个虚函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Quote &#123;</span><br><span class="line">	&#x2F;&#x2F;该虚函数返回当前对象的一份动态分配的拷贝</span><br><span class="line">	virtual Quote* clone()const&amp; &#123; return new Quote(*this); &#125;</span><br><span class="line">	virtual Quote* clone()&amp;&amp; &#123; return new Quote(move(*this)); &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Bulk_quote :public Quote &#123;</span><br><span class="line">	Bulk_quote* clone()const&amp; &#123; return new Bulk_quote(*this); &#125;</span><br><span class="line">	Bulk_quote* clone()&amp;&amp; &#123; return new Bulk_quote(move(*this)); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>const左值引用成员将它自己拷贝给新分配的对象；右值引用成员将自己移动到新数据中<br>新版本add_item：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Basket &#123;</span><br><span class="line">public:</span><br><span class="line">	void add_item(const Quote&amp; sale) &#123; items.insert(shared_ptr&lt;Quote&gt;(sale.clone())); &#125;	&#x2F;&#x2F;拷贝给定的对象</span><br><span class="line">	void add_item(Quote&amp;&amp; sale) &#123; items.insert(shared_ptr&lt;Quote&gt;(move(sale).clone())); &#125;&#x2F;&#x2F;移动给定的对象</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>clone函数是一个虚函数。sale的动态类型决定了运行Quote的函数还是Bulk_quote的函数。clone返回一个新分配对象的指针，<br>该对象与clone所属的类型一致。把一个shared_ptr绑定到这个对象上，调用insert将新分配对象添加到items中。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/30/c-primer-15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" data-id="ckhkopsda000xesvealsx5k5x" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-primer/" rel="tag">c++ primer</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/08/30/c-primer-16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          c++ primer 16 模板与泛型编程
        
      </div>
    </a>
  
  
    <a href="/2020/08/30/c-primer-14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">c++ primer 14 重载运算符与类型转换</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/02-cpp-primer/" rel="tag">02 cpp primer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c-primer/" rel="tag">c++ primer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cocos2d-x/" rel="tag">cocos2d-x</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpp-notes/" rel="tag">cpp notes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/problem-library/" rel="tag">problem library</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reading-notes-DS/" rel="tag">reading notes DS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%82%93%E4%BF%8A%E8%BE%89/" rel="tag">数据结构 邓俊辉</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/02-cpp-primer/" style="font-size: 14px;">02 cpp primer</a> <a href="/tags/c-primer/" style="font-size: 16px;">c++ primer</a> <a href="/tags/cocos2d-x/" style="font-size: 12px;">cocos2d-x</a> <a href="/tags/cpp-notes/" style="font-size: 20px;">cpp notes</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/problem-library/" style="font-size: 16px;">problem library</a> <a href="/tags/reading-notes-DS/" style="font-size: 10px;">reading notes DS</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%82%93%E4%BF%8A%E8%BE%89/" style="font-size: 18px;">数据结构 邓俊辉</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/11/18/ncpp-05/">第5章 语句</a>
          </li>
        
          <li>
            <a href="/2020/11/17/ncpp-04/">第4章 表达式</a>
          </li>
        
          <li>
            <a href="/2020/11/16/%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/">操作方法</a>
          </li>
        
          <li>
            <a href="/2020/11/16/ncpp-03/">第3章 字符串、向量和数组</a>
          </li>
        
          <li>
            <a href="/2020/11/16/ncpp-02/">第2章 变量和基本类型</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>
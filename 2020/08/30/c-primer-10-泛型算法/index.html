<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>c++ primer 10 泛型算法 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="泛型算法标准库定义了一组泛型算法来实现查找特定元素、替换或删除等操作泛型：可以用于不同各类型的元素和多种容器类型算法：实现了一些经典算法的公共接口，如排序和搜索等大多数算法都定义在头文件algorithm中，在numeric中定义了一组数值泛型算法迭代器领算法不依赖于容器，但算法依赖于元素类型的操作泛型算法本身不会执行容器的操作，它们只会运行与迭代器之上，执行迭代器的操作–》算法永远不会改变底层容">
<meta property="og:type" content="article">
<meta property="og:title" content="c++ primer 10 泛型算法">
<meta property="og:url" content="http://yoursite.com/2020/08/30/c-primer-10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="泛型算法标准库定义了一组泛型算法来实现查找特定元素、替换或删除等操作泛型：可以用于不同各类型的元素和多种容器类型算法：实现了一些经典算法的公共接口，如排序和搜索等大多数算法都定义在头文件algorithm中，在numeric中定义了一组数值泛型算法迭代器领算法不依赖于容器，但算法依赖于元素类型的操作泛型算法本身不会执行容器的操作，它们只会运行与迭代器之上，执行迭代器的操作–》算法永远不会改变底层容">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://yoursite.com/2020/08/30/c-primer-10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/10%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95_md_files/%E6%8D%95%E8%8E%B7.JPG?v=1&type=image">
<meta property="article:published_time" content="2020-08-30T02:36:34.000Z">
<meta property="article:modified_time" content="2020-08-30T02:40:07.163Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/08/30/c-primer-10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/10%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95_md_files/%E6%8D%95%E8%8E%B7.JPG?v=1&type=image">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-c-primer-10-泛型算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/30/c-primer-10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/" class="article-date">
  <time datetime="2020-08-30T02:36:34.000Z" itemprop="datePublished">2020-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      c++ primer 10 泛型算法
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="泛型算法"><a href="#泛型算法" class="headerlink" title="泛型算法"></a>泛型算法</h1><p>标准库定义了一组泛型算法来实现查找特定元素、替换或删除等操作<br>泛型：可以用于不同各类型的元素和多种容器类型<br>算法：实现了一些经典算法的公共接口，如排序和搜索等<br>大多数算法都定义在头文件algorithm中，在numeric中定义了一组数值泛型算法<br>迭代器领算法不依赖于容器，但算法依赖于元素类型的操作<br>泛型算法本身不会执行容器的操作，它们只会运行与迭代器之上，执行迭代器的操作–》算法永远不会改变底层容器的大小</p>
<p>除少数例外，标准库算法都对一个范围内的元素进行操作，“输入范围”。用要处理的第一个元素和尾元素之后位置的迭代器两个参数来表示此范围</p>
<p>只接受单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长</p>
<p>写容器元素的算法要注意确保序列原大小至少不小于要求算法写入的元素数目</p>
<p>插入迭代器(insert iterator)定义在头文件iterator中，back_inserter;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt;v;</span><br><span class="line">auto it &#x3D; back_inserter(v);</span><br><span class="line">*it &#x3D; 42; &#x2F;&#x2F;v中现在有一个元素，值为42</span><br><span class="line"></span><br><span class="line">fill_n(back_inserter(v), 10, 0); &#x2F;&#x2F;添加10个0到v</span><br></pre></td></tr></table></figure>
<p>拷贝算法是另一个向目的位置迭代器指向的输出序列中的元素写书数据的算法。接受三个迭代器，前两个表示范围，第三个表示目的序列的起始位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a1[] &#x3D; &#123; 0,1,2 &#125;;</span><br><span class="line">int a2[sizeof(a1) &#x2F; sizeof(*a1)];</span><br><span class="line">auto ret &#x3D; copy(begin(a1), end(a1), a2); &#x2F;&#x2F;把a1的内容拷贝给a2，ret指向拷贝到a2的尾元素之后的位置</span><br></pre></td></tr></table></figure>
<p>一些算法计算新元素的值，但不会将他们放置在输入序列的末尾，而是创建一个新序列保存这些结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">replace(ilst.bigin(), ilst.end(), 0, 42); &#x2F;&#x2F;将所有0替换为42</span><br><span class="line">replace(ilst.begin(), ilst.end(), back_inserter(ivec), 0, 42); &#x2F;&#x2F;ilst未改变，ivec包含ilst的一份拷贝，但其中的0替换为42</span><br></pre></td></tr></table></figure>
<h3 id="重排容器元素的算法"><a href="#重排容器元素的算法" class="headerlink" title="重排容器元素的算法"></a>重排容器元素的算法</h3><p>利用元素类型的&lt;运算符来实现排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void elimDups(vector&lt;string&gt;&amp; words) &#123;</span><br><span class="line">	sort(words.begin(), words.end());</span><br><span class="line">	auto end &#x3D; unique(words.begin(), words.end()); &#x2F;&#x2F;end指向最后一个不重复元素的下一个位置</span><br><span class="line">	erase(end, words.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>谓词是一个可调用的表达式，其返回结果是一个能用作条件的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bool isShorter(const string&amp; s1, const string&amp; s2) &#123; &#x2F;&#x2F;比较函数，按长度排序单词</span><br><span class="line">	return s1.size() &lt; s2.size();</span><br><span class="line">&#125;</span><br><span class="line">sort(words.begin(), words.end(), isShorter); &#x2F;&#x2F;由短至长排序单词</span><br><span class="line">stable_sort稳定排序算法，维持相等元素的原有顺序</span><br></pre></td></tr></table></figure>
<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>四种可调用的对象：函数、函数指针、重载了函数调用运算符的类、lambda表达式<br>一个lambda表达式表示一个可调用的代码单元。可理解为一个未命名的内联函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture list](parameter list)-&gt;return type&#123; function body &#125;</span><br></pre></td></tr></table></figure>
<p>capture list(捕获列表)是一个lambda所在函数中定义的局部变量的列表(通常为空)。lambda必须使用尾置返回来指定返回类型<br>可以忽略参数列表和返回值类型，但必须包含捕获列表和函数体</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto f &#x3D; [] &#123;return 42; &#125;</span><br></pre></td></tr></table></figure>
<p>调用方式与普通函数的调用方式相同，都是使用调用运算符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; f() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>在lambda中忽略括号和参数列表等价于指定一个空参数列表。忽略返回类型，lambda根据函数体中代码推断返回类型，返回类型可以是void<br>lambda不能有默认参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[](const string&amp; s1, const string&amp; s2) &#123;return s1.size() &lt; s2.size();&#125;</span><br></pre></td></tr></table></figure>
<p>空捕获列表表示此lambda不使用它所在函数中的任何局部变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stable_sort(words.begin(), words.end(), [](const string&amp; s1, const string&amp; s2) &#123;return s1.size() &lt; s2.size(); &#125;);</span><br></pre></td></tr></table></figure>
<p>lambda只能使用明确在捕获列表指出的局部变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto wc &#x3D; find_if(words.begin(), words.end(), [sz](const string &amp; s) &#123;return s.size() &gt;&#x3D; sz; &#125;); &#x2F;&#x2F;获取指向第一个长度不小于sz的元素的迭代器，如果不存在则返回words.end()的一个拷贝</span><br></pre></td></tr></table></figure>
<h3 id="for-each算法"><a href="#for-each算法" class="headerlink" title="for_each算法"></a>for_each算法</h3><p>打印words中长度大于等于sz的元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for_each(wc, words.end(), [](const string&amp; s) &#123;cout &lt;&lt; s &lt;&lt; &quot; &quot;; &#125;); cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h3 id="lambda捕获和返回"><a href="#lambda捕获和返回" class="headerlink" title="lambda捕获和返回"></a>lambda捕获和返回</h3><p>当定义一个lambda时，编译器生成一个与lambda对应的新的(未命名的)类类型。当向一个函数传递一个lambda时，同事定义了一个新类型和该类型的一个对象，传递的参数就是此编译器生成的类类型的未命名对象<br>默认情况下，从lambda生成的类都包含一个对应该lambda所捕获的变量的数据成员。<br>变量的捕获方式可以是值或引用<br>值捕获的前提是变量可以拷贝，在lambda创建时拷贝</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void func1() &#123;</span><br><span class="line">	size_t v1 &#x3D; 42; &#x2F;&#x2F;局部变量</span><br><span class="line">	auto f &#x3D; [v1] &#123;return v1; &#125;;</span><br><span class="line">	v1 &#x3D; 0; auto j &#x3D; f(); &#x2F;&#x2F;j为42，f保存了创建时的拷贝</span><br><span class="line">&#125;</span><br><span class="line">void func2() &#123;</span><br><span class="line">	size_t v1 &#x3D; 42;</span><br><span class="line">	auto f2 &#x3D; [&amp;v1] &#123;return v1; &#125;;</span><br><span class="line">	v1 &#x3D; 0; auto j &#x3D; f2(); &#x2F;&#x2F;j&#x3D;&#x3D;0,f2保存v1的引用而非拷贝</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当从函数返回lambda时，lambda不能包含引用捕获。</p>
<h3 id="隐式捕获"><a href="#隐式捕获" class="headerlink" title="隐式捕获"></a>隐式捕获</h3><p>[=]值捕获、[&amp;]引用捕获<br>混合捕获</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void biggies(vector&lt;string&gt;&amp; words, vector&lt;string&gt;::size_type sz, ostream&amp; os &#x3D; cout, char c &#x3D; &#39; &#39;) &#123;</span><br><span class="line">	for_each(words.begin(), words.end(), [&amp;, c](const string &amp; s) &#123;os &lt;&lt; s &lt;&lt; c; &#125;);</span><br><span class="line">	for_each(words.begin(), words.end(), [&#x3D;, &amp;os](const string &amp; s) &#123;os &lt;&lt; s &lt;&lt; c; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="10%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95_md_files/%E6%8D%95%E8%8E%B7.JPG?v=1&type=image" alt="输入图片描述"><br>可变lambda可省略参数列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void func3() &#123;</span><br><span class="line">	size_t v1 &#x3D; 42;</span><br><span class="line">	auto f &#x3D; [v1]()mutable &#123;return ++v1; &#125;;</span><br><span class="line">	v1 &#x3D; 0; auto j &#x3D; f(); &#x2F;&#x2F;j&#x3D;&#x3D;43</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个引用捕获的变量是否可以修改依赖于此引用是否指向非const类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void func4() &#123;</span><br><span class="line">	size_t v1 &#x3D; 42;</span><br><span class="line">	auto f2 &#x3D; [&amp;v1] &#123;return ++v1; &#125;;</span><br><span class="line">	v1 &#x3D; 0; auto j &#x3D; f(); &#x2F;&#x2F;j&#x3D;&#x3D;1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个lambda包含return之外的任何语句，则编译器假定此lambda返回void</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transform(vi.begin(), vi.end(), [](int i) &#123;if (i &lt; 0)return -i; else return i; &#125;); &#x2F;&#x2F;错误：不能推断lambda的返回类型</span><br><span class="line">transform(vi.begin(),vi.end(),[](int i)-&gt;int&#123;if (i &lt; 0)return -i; else return i; &#125;</span><br></pre></td></tr></table></figure>
<h3 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto newCallable &#x3D; bind(callable, arg_list);</span><br><span class="line">&#x2F;&#x2F;check6是一个可调用对象，接受一个string类型的参数</span><br><span class="line">auto check6 &#x3D; bind(check_size, _1, 6);</span><br></pre></td></tr></table></figure>
<p>_1为占位符，表示check6只接受单一参数。出现在arg_list的第一个位置，表示check6的此参数对应check_size的第一个参数。<br>此参数是一个const string&amp; ，因此，调用check6必须传给他一个string类型的参数，check6会将此参数传递给check_size</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string s &#x3D; &quot;hello&quot;;</span><br><span class="line">bool b1 &#x3D; check6(s); &#x2F;&#x2F;check6(s)会调用check_size(s,6)</span><br><span class="line">可以将lambda的find_if变为check_size版本</span><br><span class="line">auto wc &#x3D; find_if(words.begin(), words.end(), [](const string&amp; a));</span><br><span class="line">auto wc &#x3D; find_if(words.begin(), words.end(), bind(check_size, _1, sz));</span><br></pre></td></tr></table></figure>
<p>using std::placeholders::_1;<br>_1定义在命名空间placeholders中，它又定义在std中<br>另一种声明：using namespace namespace_name;<br>说明希望所有来自namespace_name的名字都可以直接使用<br>using namespace std::placeholders;</p>
<p>可以用bind绑定可调用对象中的参数或重新安排其顺序<br>auto g = bind(f, a, b, _2, c, _1);<br>生成一个新的可调用对象，有2个参数（_1, _2）。将它自己的参数作为第三个和第五个参数传递给f。调用g时，第一个参数传递给f作为最后一个参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;按单词长度由短至长排序</span><br><span class="line">sort(words.begin(), words.end(), isShorter); l</span><br><span class="line">&#x2F;&#x2F;由长至短</span><br><span class="line">sort(words.begin(), words.end(), bind(isShorter, _2, _1);</span><br><span class="line"></span><br><span class="line">bind拷贝其参数，对于不想拷贝的，使用ref函数</span><br><span class="line">for_each(words.begin(), words.end(), bind(print, ref(os), _1, &#39; &#39;));</span><br></pre></td></tr></table></figure>

<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h3 id="插入迭代器-insert-iterator"><a href="#插入迭代器-insert-iterator" class="headerlink" title="插入迭代器(insert iterator)"></a>插入迭代器(insert iterator)</h3><p>这些迭代器被绑定到一个容器上，可用来向容器插入元素<br>——————————————————–图358</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">back_inserter &#x2F; front_inserter &#x2F; inserter</span><br><span class="line"></span><br><span class="line">list&lt;int&gt;lst &#x3D; &#123; 1,2,3,4 &#125;, lst2, lst3;</span><br><span class="line">copy(lst.begin(), lst, end(), front_inserter(lst2)); &#x2F;&#x2F;4 3 2 1 </span><br><span class="line">copy(lst.begin(), lst.end(), inserter(lst3, lst3.begin())); &#x2F;&#x2F;1 2 3 4</span><br></pre></td></tr></table></figure>
<h3 id="流迭代器-stream-iterator"><a href="#流迭代器-stream-iterator" class="headerlink" title="流迭代器(stream iterator)"></a>流迭代器(stream iterator)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">istream_iterator&lt;int&gt;int_it(cin); &#x2F;&#x2F;从cin读取int</span><br><span class="line">istream_iterator&lt;int&gt;eof; &#x2F;&#x2F;istream尾后迭代器</span><br><span class="line">ifstream in(&quot;afile&quot;);</span><br><span class="line">istream_iterator&lt;string&gt;str_it(in); &#x2F;&#x2F;从&quot;afile&quot;读取字符串</span><br><span class="line"></span><br><span class="line">istream_iterator&lt;int&gt;in_iter(cin); &#x2F;&#x2F;从cin读取int</span><br><span class="line">istream_iterator&lt;int&gt;eof; &#x2F;&#x2F;istream尾后迭代器</span><br><span class="line">while (in_iter !&#x3D; eof)vec.push_back(*in_iter++); &#x2F;&#x2F;后置递增运算读取流，返回迭代器的旧值，解引用迭代器，获得从流读取的前一个值</span><br></pre></td></tr></table></figure>
<h3 id="反向迭代器-reverse-iterator"><a href="#反向迭代器-reverse-iterator" class="headerlink" title="反向迭代器(reverse iterator)"></a>反向迭代器(reverse iterator)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt;v &#x3D; &#123; 1,2,3,4,5 &#125;;</span><br><span class="line">for (auto r_iter &#x3D; v.crbegin(); r_iter !&#x3D; v.crend(); ++r_iter;) &#123;</span><br><span class="line">	cout &lt;&lt; *r_iter &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort(v.begin(), v.end()); &#x2F;&#x2F;正常排序v</span><br><span class="line">sort(v.rbegin(), v.rend()); &#x2F;&#x2F;逆序排序v</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;打印最后一个单词</span><br><span class="line">auto comma &#x3D; find(line.rbegin(), line.rend(), &#39;,&#39;);</span><br><span class="line">cout &lt;&lt; string(rcomma.base(), line.end()) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h2 id="泛型算法结构"><a href="#泛型算法结构" class="headerlink" title="泛型算法结构"></a>泛型算法结构</h2><p>输入、输出、前向、双向、随机访问，5种迭代器</p>
<p>返回void<br>图——————————————————–369</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/30/c-primer-10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/" data-id="ckhkopsd7000mesve90vh7utg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/08/30/c-primer-11-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          c++ primer 11 关联容器
        
      </div>
    </a>
  
  
    <a href="/2020/08/30/c-primer-09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">c++ primer 09 顺序容器</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/02-cpp-primer/" rel="tag">02 cpp primer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c-primer/" rel="tag">c++ primer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cocos2d-x/" rel="tag">cocos2d-x</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpp-notes/" rel="tag">cpp notes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/problem-library/" rel="tag">problem library</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reading-notes-DS/" rel="tag">reading notes DS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%82%93%E4%BF%8A%E8%BE%89/" rel="tag">数据结构 邓俊辉</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/02-cpp-primer/" style="font-size: 14px;">02 cpp primer</a> <a href="/tags/c-primer/" style="font-size: 16px;">c++ primer</a> <a href="/tags/cocos2d-x/" style="font-size: 12px;">cocos2d-x</a> <a href="/tags/cpp-notes/" style="font-size: 20px;">cpp notes</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/problem-library/" style="font-size: 16px;">problem library</a> <a href="/tags/reading-notes-DS/" style="font-size: 10px;">reading notes DS</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%82%93%E4%BF%8A%E8%BE%89/" style="font-size: 18px;">数据结构 邓俊辉</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/11/17/ncpp-04/">第4章 表达式</a>
          </li>
        
          <li>
            <a href="/2020/11/16/%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/">操作方法</a>
          </li>
        
          <li>
            <a href="/2020/11/16/ncpp-03/">第3章 字符串、向量和数组</a>
          </li>
        
          <li>
            <a href="/2020/11/16/ncpp-02/">第2章 变量和基本类型</a>
          </li>
        
          <li>
            <a href="/2020/10/27/mysql/">mysql</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>
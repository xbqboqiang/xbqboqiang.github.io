<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-problem-library-树-02" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/28/problem-library-%E6%A0%91-02/" class="article-date">
  <time datetime="2020-07-28T15:15:05.000Z" itemprop="datePublished">2020-07-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/28/problem-library-%E6%A0%91-02/">problem library 树 02</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="#106.从中序与后序遍历序列构造二叉树"></a>#106.从中序与后序遍历序列构造二叉树</h2><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p>
<p>注意:<br>你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<p>中序遍历 inorder = [9,3,15,20,7]<br>后序遍历 postorder = [9,15,7,20,3]<br>返回如下的二叉树：</p>
<pre><code>  3
 / \
9  20
  /  \
 15   7</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal" target="_blank" rel="noopener">https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;postorder, <span class="keyword">int</span> i_begin, <span class="keyword">int</span> i_end, <span class="keyword">int</span> p_begin, <span class="keyword">int</span> p_end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i_begin &gt; i_end || p_begin &gt; p_end)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode* res = <span class="keyword">new</span> TreeNode(postorder[p_end]);</span><br><span class="line">        <span class="keyword">if</span> (p_begin == p_end)<span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (postorder[p_end] != inorder[index])index++;</span><br><span class="line">        res-&gt;left = helper(inorder, postorder, i_begin, index - <span class="number">1</span>, p_begin, p_begin + index - <span class="number">1</span> - i_begin);</span><br><span class="line">        res-&gt;right = helper(inorder, postorder, index + <span class="number">1</span>, i_end, p_end - <span class="number">1</span> - (i_end - (index + <span class="number">1</span>)), p_end - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(inorder, postorder, <span class="number">0</span>, inorder.<span class="built_in">size</span>() - <span class="number">1</span>, <span class="number">0</span>, postorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="95-不同的二叉搜索树II"><a href="#95-不同的二叉搜索树II" class="headerlink" title="#95.不同的二叉搜索树II"></a>#95.不同的二叉搜索树II</h2><p>给定一个整数 n，生成所有由 1 … n 为节点所组成的 二叉搜索树 。</p>
<p>示例：</p>
<p>输入：3<br>输出：<br>[<br>  [1,null,3,2],<br>  [3,2,null,1],<br>  [3,1,null,null,2],<br>  [2,1,3],<br>  [1,null,2,null,3]<br>]<br>解释：<br>以上的输出对应以下 5 种不同结构的二叉搜索树：</p>
<pre><code>1         3     3      2      1
 \       /     /      / \      \
  3     2     1      1   3      2
 /     /       \                 \
2     1         2                 3</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-binary-search-trees-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">getrees</span><span class="params">(<span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lo &gt; hi)<span class="keyword">return</span> &#123; <span class="literal">nullptr</span> &#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt;res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt;= hi; i++) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;TreeNode*&gt; leftTrees = getrees(lo, i - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">vector</span>&lt;TreeNode*&gt; rightTrees = getrees(i + <span class="number">1</span>, hi);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; l : leftTrees)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; r : rightTrees) &#123;</span><br><span class="line">                    TreeNode* root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    root-&gt;left = l;</span><br><span class="line">                    root-&gt;right = r;</span><br><span class="line">                    res.emplace_back(root);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)<span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">return</span> getrees(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/28/problem-library-%E6%A0%91-02/" data-id="ckd64loe2001lakve6jxyhrvl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/problem-library/" rel="tag">problem library</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-DS邓俊辉-10" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/27/DS%E9%82%93%E4%BF%8A%E8%BE%89-10/" class="article-date">
  <time datetime="2020-07-27T14:34:35.000Z" itemprop="datePublished">2020-07-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/27/DS%E9%82%93%E4%BF%8A%E8%BE%89-10/">DS邓俊辉 10</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h1><p>call-by-priority</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">struct</span> <span class="title">PQ</span> &#123;</span> <span class="comment">//priority queue</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(T)</span> </span>= <span class="number">0</span>; <span class="comment">//按照优先级次序插入词条</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> T <span class="title">getMax</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">//取出优先级最高的词条</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> T <span class="title">delMax</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">//删除优先级最高的词条</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">完全二叉堆</span><br><span class="line">逻辑上等同于完全二叉树，物理上直接借助向量实现</span><br><span class="line">逻辑节点与物理元素，依层次遍历次序彼此对应</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Parent(i) ((i-1&gt;&gt;1))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LChild(i) (1+((i)&lt;&lt;1)) <span class="comment">//奇数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RChild(i) ((1+(i))&lt;&lt;1) <span class="comment">//偶数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">PQ_ComplHeap</span> :</span><span class="keyword">public</span> PQ&lt;T&gt;, <span class="keyword">public</span> Vector&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function">Rank <span class="title">percolateDown</span><span class="params">(Rank n, Rank i)</span></span>; <span class="comment">//下滤</span></span><br><span class="line">	<span class="function">Rank <span class="title">percolateUP</span><span class="params">(Rank i)</span></span>; <span class="comment">//上滤</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(Rank n)</span></span>; <span class="comment">//Floyd建堆算法</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	QP_ComplHeap(T* A,Rank n) <span class="comment">//批量构造</span></span><br><span class="line">	&#123;copuFrom(A, <span class="number">0</span>, n); heapify(n);	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(T)</span></span>; <span class="comment">//按照比较器确定的优先级次序，插入词条</span></span><br><span class="line">	<span class="function">T <span class="title">getMax</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> _elem[<span class="number">0</span>]; &#125; <span class="comment">//读取优先级最高的词条</span></span><br><span class="line">	<span class="function">T <span class="title">delMax</span><span class="params">()</span></span>; <span class="comment">//删除优先级最高的词条</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">堆序性：</span><br><span class="line">数值上，只要<span class="number">0</span> &lt; i，必满足H[i] &lt;= H[Parent(i)]，故H[<span class="number">0</span>]是全局最大元素</span><br><span class="line"></span><br><span class="line">插入与上滤</span><br><span class="line">为插入词条e，只需将e作为末元素接入向量  结构性自然保持，堆序性未必破坏</span><br><span class="line">若破坏只需和父节点交换，可能交换多次</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> PQ_ComplHeap&lt;T&gt;::insert(T e) <span class="comment">//插入</span></span><br><span class="line">	&#123;Vector&lt;T&gt;::insert(e); pervolateUp(_size - <span class="number">1</span>);&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">//对第i个词条实施上滤，i&lt;_size</span></span><br><span class="line">Rank PQ_ComplHeap&lt;T&gt;::percolateUp(Rank i) &#123;</span><br><span class="line">	<span class="keyword">while</span> (PerantValid(i)) &#123; <span class="comment">//只要i有父亲（尚未抵达堆顶），则</span></span><br><span class="line">		Rank j = Parent(i); <span class="comment">//将之记作j</span></span><br><span class="line">		<span class="keyword">if</span> (It(_elem[i], _elem[j]))<span class="keyword">break</span>; <span class="comment">//一旦父子不在逆序，上滤旋即完成</span></span><br><span class="line">		swap(_elem[i], _elem[j]); i = j; <span class="comment">//否则，交换父子位置，并上升一层</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">删除与下滤</span><br><span class="line">删除向量首元素，代之以末元素e，结构性保持，若堆序性破坏，与e孩子中大者换位</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; T PQ_ComplHeap&lt;T&gt;::delMax() &#123; <span class="comment">//删除</span></span><br><span class="line">	T maxElem = _elem[<span class="number">0</span>]; _elem[<span class="number">0</span>] = _elem[--_size]; <span class="comment">//摘除堆顶，代之以末次条</span></span><br><span class="line">	percolateDown(_size, <span class="number">0</span>); <span class="comment">//对新堆顶实施下滤</span></span><br><span class="line">	<span class="keyword">return</span> maxElem; <span class="comment">//返回此前备份的最大词条</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//对前n个词条中的第i个实施下滤，i&lt;n</span></span><br><span class="line">Rank PQ_ComplHeap&lt;T&gt;::percolateDown(Rank n, Rank i) &#123;</span><br><span class="line">	Rank j; <span class="comment">//i及其(至多两个)孩子中，堪为父者</span></span><br><span class="line">	<span class="keyword">while</span> (i != (j = ProperParent(_elem, n, i))) <span class="comment">//只要i非j，则</span></span><br><span class="line">	&#123;</span><br><span class="line">		swap(_elem[i], _elem[j]); i = j; <span class="comment">//换位，并继续考察i</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i; <span class="comment">//返回下滤抵达的位置（亦i亦j）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">批量建堆</span><br><span class="line">自上而下的上滤</span><br><span class="line">PQ_ComplHeap(T* A, Rank n) &#123; copyFrom(A, <span class="number">0</span>, n); heapify(n); &#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> PQ_ComplHeap&lt;T&gt;::heapify(Rank n) &#123; <span class="comment">//蛮力</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="comment">//按照层次遍历次序逐一</span></span><br><span class="line">		percolateUp(i); <span class="comment">//经上滤插入各节点</span></span><br><span class="line">&#125;O(nlogn)</span><br><span class="line">自下而上的下滤</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> PQ_ComplHeap&lt;T&gt;::heapify(Rank n) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = LastInternal(n); i &gt;= <span class="number">0</span>; i--) <span class="comment">//自下而上，一次</span></span><br><span class="line">		percolateDown(n, i); <span class="comment">//下滤各内部节点</span></span><br><span class="line">&#125; <span class="comment">//可以理解为子堆的逐层合并 O(n)</span></span><br><span class="line"></span><br><span class="line">堆排序</span><br><span class="line">在选择排序中，待排序部分u替换为H；</span><br><span class="line">初始化：heapify(),O(n)建堆</span><br><span class="line">迭代：delMax(),O(logn)取出堆顶并调整复原</span><br><span class="line">不变性：H&lt;=S</span><br><span class="line">有：m=H[<span class="number">0</span>],x=S[<span class="number">-1</span>]，所以swap(m,x)=H.insert(x)+S.insert(m)</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">//对向量区间[lo,hi)做就地堆排序</span></span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::heapSort(Rank lo, Rank hi) &#123;</span><br><span class="line">	PQ_ComplHeap&lt;T&gt; H(_elem + lo, hi - lo); <span class="comment">//待排序区间建堆，O(n)</span></span><br><span class="line">	<span class="keyword">while</span> (!H.empty()) <span class="comment">//反复地摘除最大元并归入已排序的后缀，直至堆空</span></span><br><span class="line">		_elem[--hi] = H.delMax(); <span class="comment">//等效于堆顶与末元素对换后下滤</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">堆合并</span><br><span class="line">H=merge(A,B):将堆A、B合二为一 <span class="comment">//设|A|=n&gt;=m=|B|</span></span><br><span class="line">方法一：A.insert(b.delMax()) O(m*<span class="built_in">log</span>(m+n))</span><br><span class="line">方法二：<span class="keyword">union</span>(A,B).heapify(m+n)  O(m+n)</span><br><span class="line"></span><br><span class="line">左式堆</span><br><span class="line">新条件：结点分布偏向于左侧，合并操作只涉及右侧，牺牲结构性，保留堆序性</span><br><span class="line">空节点路径长度：npl(<span class="literal">NULL</span>)=<span class="number">0</span>,npl(x)=<span class="number">1</span>+<span class="built_in">min</span>(npl(lc(x),npl(rc(x))</span><br><span class="line">npl(x)=x到外部结点的最近距离=以x为根的最大满子树的高度</span><br><span class="line">左倾：对任何内节点x，都有npl(lc(x))&gt;=npl(rc(x)),推论，对任何内节点x都有npl(x)=npl(rc(x))+<span class="number">1</span></span><br><span class="line">右侧链rChain(x):从节点x出发，一直沿着右分支前进</span><br><span class="line">rChain(root)的终点，必为全堆中最浅的外部节点  npl(r)==|rChain(r)|=d 存在一颗以r为根、高度为d的满子树</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  <span class="comment">//基于二叉树，以左式堆形式实现的优先级队列</span></span><br><span class="line">class PQ_ComplHeap :<span class="keyword">public</span> PQ&lt;T&gt;, <span class="keyword">public</span> BinTree&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">void</span> insert(T); <span class="comment">//（按比较器确定的优先级次序）插入元素</span></span><br><span class="line">	T getMax() &#123; <span class="keyword">return</span> _root-&gt;data; &#125; <span class="comment">//取出优先级最高的元素</span></span><br><span class="line">	T delMax(); <span class="comment">//删除优先级最高的元素</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">static</span> BinNodePosi(T) merge(BinNodePosi(T) a, BinNodePosi(T) b) &#123;</span><br><span class="line">	<span class="keyword">if</span> (!a)<span class="keyword">return</span> b; <span class="comment">//递归基</span></span><br><span class="line">	<span class="keyword">if</span> (!b)<span class="keyword">return</span> a; <span class="comment">//递归基</span></span><br><span class="line">	<span class="keyword">if</span> (lt(a-&gt;data, b-&gt;data))swap(b, a); <span class="comment">//一般情况：首先确保b不大</span></span><br><span class="line">	a-&gt;rc = merge(a-&gt;rc, b); <span class="comment">//将a的右子堆与b合并</span></span><br><span class="line">	a-&gt;rc-&gt;parent = a; <span class="comment">//并更新父子关系</span></span><br><span class="line">	<span class="keyword">if</span> (!a-&gt;lc || a-&gt;lc-&gt;npl &lt; a-&gt;rc-&gt;npl) <span class="comment">//若有必要</span></span><br><span class="line">		swap(a-&gt;lc, a-&gt;rc); <span class="comment">//交换a的左右子堆，以确保右子堆的npl不大</span></span><br><span class="line">	a-&gt;npl = a-&gt;rc ? a-&gt;rc-&gt;npl + <span class="number">1</span> : <span class="number">1</span>; <span class="comment">//更新a的npl</span></span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;O(logn)</span><br><span class="line"></span><br><span class="line">插入即是合并、删除亦是合并</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> PQ_LeftHeap&lt;T&gt;::insert(T e) &#123; <span class="comment">//O(logn)</span></span><br><span class="line">	BinNodePosi(T)v = <span class="keyword">new</span> BinNode&lt;T&gt;(e); <span class="comment">//为e创建一个二叉树节点</span></span><br><span class="line">	_root = merge(_root, v); <span class="comment">//通过合并完成新节点的插入</span></span><br><span class="line">	_root-&gt;parent = <span class="literal">NULL</span>; <span class="comment">//既然此时堆非空，还需相应设置父子链接</span></span><br><span class="line">	_size++; <span class="comment">//更新规模</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">//O(logn)</span></span><br><span class="line"><span class="keyword">void</span> PQ_LeftHeap&lt;T&gt;::delMax(T e) &#123;</span><br><span class="line">	BinNodePosi(T) lHeap = _root-&gt;lc; <span class="comment">//左子堆</span></span><br><span class="line">	BinNodePosi(T) rHeap = _root-&gt;rc; <span class="comment">//右子堆</span></span><br><span class="line">	T e = _root-&gt;data; <span class="comment">//备份堆顶处的最大元素</span></span><br><span class="line">	<span class="keyword">delete</span> _root; _size--; <span class="comment">//删除根节点</span></span><br><span class="line">	_root = merge(lHeap, rHeap); <span class="comment">//原左右子堆合并</span></span><br><span class="line">	<span class="keyword">if</span> (_root)_root-&gt;parent = <span class="literal">NULL</span>; <span class="comment">//更新父子链接</span></span><br><span class="line">	<span class="keyword">return</span> e; <span class="comment">//返回原根节点的数据项</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/27/DS%E9%82%93%E4%BF%8A%E8%BE%89-10/" data-id="ckd64lodn000dakve5i2wdckn" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%82%93%E4%BF%8A%E8%BE%89/" rel="tag">数据结构 邓俊辉</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-problem-library-树" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/26/problem-library-%E6%A0%91/" class="article-date">
  <time datetime="2020-07-26T14:21:54.000Z" itemprop="datePublished">2020-07-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/26/problem-library-%E6%A0%91/">problem library 树 01</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="#104.二叉树的最大深度"></a>#104.二叉树的最大深度</h2><p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，</p>
<pre><code>    3
   / \
  9  20
 /     \
15      7</code></pre><p>返回它的最大深度 3 。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">max</span>(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="#226.翻转二叉树"></a>#226.翻转二叉树</h2><p>翻转一棵二叉树。</p>
<p>示例：</p>
<p>输入：</p>
<pre><code>     4
   /   \
  2     7
 / \   / \
1   3 6   9</code></pre><p>输出：</p>
<pre><code>     4
   /   \
  7     2
 / \   / \
9   6 3   1</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/invert-binary-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/invert-binary-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        TreeNode* tmp = root-&gt;left;</span><br><span class="line">        root-&gt;left = invertTree(root-&gt;right);</span><br><span class="line">        root-&gt;right = invertTree(tmp);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="#617.合并二叉树"></a>#617.合并二叉树</h2><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p>
<p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p>
<p>示例 1:</p>
<p>输入: </p>
<pre><code>    1                         2                             
   / \                       / \                            
  3   2                     1   3                        
 /                           \   \                      
5                             4   7                  </code></pre><p>输出:<br>合并后的树:</p>
<pre><code>    3
   / \
  4   5
 / \   \ 
5   4   7</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/merge-two-binary-trees" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-two-binary-trees</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">NULL</span>)<span class="keyword">return</span> t2;</span><br><span class="line">        <span class="keyword">if</span> (t2 == <span class="literal">NULL</span>)<span class="keyword">return</span> t1;</span><br><span class="line">        t1-&gt;val += t2-&gt;val;</span><br><span class="line">        t1-&gt;left = mergeTrees(t1-&gt;left, t2-&gt;left);</span><br><span class="line">        t1-&gt;right = mergeTrees(t1-&gt;right, t2-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="#108.将有序数组转换为二叉搜索树"></a>#108.将有序数组转换为二叉搜索树</h2><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1。</p>
<p><strong>示例:</strong></p>
<p>给定有序数组: [-10,-3,0,5,9],</p>
<p>一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：</p>
<pre><code>     0
    / \
  -3   9
  /   /
-10  5</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getRes(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">getRes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lo &gt; hi)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> mi = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        TreeNode* res = <span class="keyword">new</span> TreeNode(nums[mi]);</span><br><span class="line">        res-&gt;left = getRes(nums, lo, mi - <span class="number">1</span>);</span><br><span class="line">        res-&gt;right = getRes(nums, mi + <span class="number">1</span>, hi);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="#100.相同的树"></a>#100.相同的树</h2><p>给定两个二叉树，编写一个函数来检验它们是否相同。</p>
<p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
<p>示例 1:</p>
<pre><code>   1         1
  / \       / \
 2   3     2   3

[1,2,3],   [1,2,3]</code></pre><p>输出: true<br>示例 2:</p>
<pre><code>   1          1
  /           \
 2             2

[1,2],     [1,null,2]</code></pre><p>输出: false</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/same-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/same-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">NULL</span> &amp;&amp; q == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!p || !q)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> p-&gt;val == q-&gt;val &amp;&amp; isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="#101.对称二叉树"></a>#101.对称二叉树</h2><p>给定一个二叉树，检查它是否是镜像对称的。</p>
<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>
<pre><code>    1
   / \
  2   2
 / \ / \
3  4 4  3</code></pre><p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p>
<pre><code>  1
 / \
2   2
 \   \
 3    3</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/symmetric-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/symmetric-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">defsym</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root1 &amp;&amp; !root2)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!root1 || !root2)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> root1-&gt;val == root2-&gt;val &amp;&amp; defsym(root1-&gt;left, root2-&gt;right) &amp;&amp; defsym(root1-&gt;right, root2-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> defsym(root, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="#235.二叉搜索树的最近公共祖先"></a>#235.二叉搜索树的最近公共祖先</h2><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。<br>例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]<br>示例 1:</p>
<p>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8<br>输出: 6<br>解释: 节点 2 和节点 8 的最近公共祖先是 6。<br>示例 2:</p>
<p>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4<br>输出: 2<br>解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rv = root-&gt;val, pv = p-&gt;val, qv = q-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> ((pv &lt; rv &amp;&amp; rv &lt; qv) || (qv &lt; rv &amp;&amp; rv &lt; pv))<span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (pv &lt; rv &amp;&amp; qv &lt; rv)<span class="keyword">return</span> lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">        <span class="keyword">if</span> (rv &lt; pv &amp;&amp; rv &lt; qv)<span class="keyword">return</span> lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="938-二叉树搜索树的范围和"><a href="#938-二叉树搜索树的范围和" class="headerlink" title="#938.二叉树搜索树的范围和"></a>#938.二叉树搜索树的范围和</h2><p>给定二叉搜索树的根结点 root，返回 L 和 R（含）之间的所有结点的值的和。</p>
<p>二叉搜索树保证具有唯一的值。</p>
<p>示例 1：</p>
<p>输入：root = [10,5,15,3,7,null,18], L = 7, R = 15<br>输出：32<br>示例 2：</p>
<p>输入：root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10<br>输出：23</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/range-sum-of-bst" target="_blank" rel="noopener">https://leetcode-cn.com/problems/range-sum-of-bst</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rangeSumBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rv = root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (L &lt; rv &amp;&amp; R &lt; rv)<span class="keyword">return</span> rangeSumBST(root-&gt;left, L, R);</span><br><span class="line">        <span class="keyword">if</span> (rv &lt; L &amp;&amp; rv &lt; R)<span class="keyword">return</span> rangeSumBST(root-&gt;right, L, R);</span><br><span class="line">        <span class="keyword">if</span> (L &lt;= root-&gt;val &amp;&amp; root-&gt;val &lt;= R)<span class="keyword">return</span> (root-&gt;val + rangeSumBST(root-&gt;left, L, R) + rangeSumBST(root-&gt;right, L, R));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="#96.不同的二叉搜索树"></a>#96.不同的二叉搜索树</h2><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p>
<p>示例:</p>
<p>输入: 3<br>输出: 5<br>解释:<br>给定 n = 3, 一共有 5 种不同结构的二叉搜索树:</p>
<pre><code>1         3     3      2      1
 \       /     /      / \      \
  3     2     1      1   3      2
 /     /       \                 \
2     1         2                 3</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/unique-binary-search-trees" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-binary-search-trees</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;G(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        G[<span class="number">0</span>] = <span class="number">1</span>; G[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">                G[i] += (G[j - <span class="number">1</span>] * G[i - j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> G[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/26/problem-library-%E6%A0%91/" data-id="ckd64loe3001qakved3we0gmi" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/problem-library/" rel="tag">problem library</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-problem-library-数组" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/26/problem-library-%E6%95%B0%E7%BB%84/" class="article-date">
  <time datetime="2020-07-26T13:41:44.000Z" itemprop="datePublished">2020-07-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/26/problem-library-%E6%95%B0%E7%BB%84/">problem library 数组</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="#53.最大子序和"></a>#53.最大子序和</h2><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例:</p>
<p>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/maximum-subarray" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-subarray</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> <span class="built_in">max</span> = INT_MIN;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; nums.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">				sum += nums[j];</span><br><span class="line">				<span class="keyword">if</span> (sum &gt; <span class="built_in">max</span>)<span class="built_in">max</span> = sum;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="121-买股票的最佳时机"><a href="#121-买股票的最佳时机" class="headerlink" title="#121.买股票的最佳时机"></a>#121.买股票的最佳时机</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">		int min &#x3D; INT_MAX, profit &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; prices.size(); i++)</span><br><span class="line">		&#123;</span><br><span class="line">			if (prices[i] &lt; min)min &#x3D; prices[i];</span><br><span class="line">			if (profit &lt; prices[i] - min)profit &#x3D; prices[i] - min;</span><br><span class="line">		&#125;</span><br><span class="line">		return profit;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="561-数组拆分"><a href="#561-数组拆分" class="headerlink" title="#561.数组拆分"></a>#561.数组拆分</h2><p>给定长度为 2n 的数组, 你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), …, (an, bn) ，使得从1 到 n 的 min(ai, bi) 总和最大。</p>
<p>示例 1:</p>
<p>输入: [1,4,3,2]</p>
<p>输出: 4<br>解释: n 等于 2, 最大总和为 4 = min(1, 2) + min(3, 4).</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/array-partition-i" target="_blank" rel="noopener">https://leetcode-cn.com/problems/array-partition-i</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">arrayPairSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i += <span class="number">2</span>)</span><br><span class="line">			sum += nums[i];</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="#169.多数元素"></a>#169.多数元素</h2><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<p>示例 1:</p>
<p>输入: [3,2,3]<br>输出: 3</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/majority-element" target="_blank" rel="noopener">https://leetcode-cn.com/problems/majority-element</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">		sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">		<span class="keyword">return</span> nums[nums.<span class="built_in">size</span>() / <span class="number">2</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="66-加一"><a href="#66-加一" class="headerlink" title="#66.加一"></a>#66.加一</h2><p>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。</p>
<p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p>
<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<p>示例 1:</p>
<p>输入: [1,2,3]<br>输出: [1,2,4]<br>解释: 输入数组表示数字 123。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/plus-one" target="_blank" rel="noopener">https://leetcode-cn.com/problems/plus-one</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">plusOne</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; digits)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = digits.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">			digits[i]++;</span><br><span class="line">			<span class="keyword">if</span> (digits[i] != <span class="number">10</span>)<span class="keyword">return</span> digits;</span><br><span class="line">			<span class="keyword">else</span> digits[i] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		digits.insert(digits.<span class="built_in">begin</span>(), <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span> digits;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="#88.合并两个有序数组"></a>#88.合并两个有序数组</h2><p>给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。</p>
<p>说明:</p>
<p>初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。<br>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</p>
<p>示例:</p>
<p>输入:<br>nums1 = [1,2,3,0,0,0], m = 3<br>nums2 = [2,5,6],       n = 3</p>
<p>输出: [1,2,2,3,5,6]</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/merge-sorted-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-sorted-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i = m + n - <span class="number">1</span>; m--; n--;</span><br><span class="line">		<span class="keyword">while</span> (n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">while</span> (m &gt;= <span class="number">0</span> &amp;&amp; nums1[m] &gt; nums2[n])swap(nums1[i--], nums1[m--]);</span><br><span class="line">			swap(nums1[i--], nums2[n--]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="283-移动零"><a href="#283-移动零" class="headerlink" title="#283.移动零"></a>#283.移动零</h2><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p>示例:</p>
<p>输入: [0,1,0,3,12]<br>输出: [1,3,12,0,0]<br>说明:</p>
<p>必须在原数组上操作，不能拷贝额外的数组。<br>尽量减少操作次数</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/move-zeroes" target="_blank" rel="noopener">https://leetcode-cn.com/problems/move-zeroes</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, count = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nums[i] != <span class="number">0</span>)swap(nums[count++], nums[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="122-买股票的最佳时机II"><a href="#122-买股票的最佳时机II" class="headerlink" title="#122.买股票的最佳时机II"></a>#122.买股票的最佳时机II</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例 1:</p>
<p>输入: [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>, <span class="built_in">min</span> = prices[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (prices[i] &lt; <span class="built_in">min</span>)<span class="built_in">min</span> = prices[i];</span><br><span class="line">			<span class="keyword">if</span> (prices[i + <span class="number">1</span>]&lt;prices[i] &amp;&amp; prices[i]&gt;<span class="built_in">min</span>) &#123; sum += prices[i] - <span class="built_in">min</span>; <span class="built_in">min</span> = prices[i]; &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (prices[prices.<span class="built_in">size</span>() - <span class="number">1</span>] &gt; <span class="built_in">min</span>)sum += (prices[prices.<span class="built_in">size</span>() - <span class="number">1</span>] - <span class="built_in">min</span>);</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="#26.  删除排序数组中的重复项"></a>#26.  删除排序数组中的重复项</h2><p>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
<p>示例 1:</p>
<p>给定数组 nums = [1,1,2], </p>
<p>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </p>
<p>你不需要考虑数组中超出新长度后面的元素。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (nums.empty())<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nums[i] != nums[count])swap(nums[i], nums[++count]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> count + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="11-盛水最多的容器"><a href="#11-盛水最多的容器" class="headerlink" title="#11.盛水最多的容器"></a>#11.盛水最多的容器</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> <span class="built_in">max</span> = INT_MIN;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="built_in">height</span>.<span class="built_in">size</span>() - <span class="number">1</span>; i &lt; j;) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">min</span>(<span class="built_in">height</span>[i], <span class="built_in">height</span>[j]) * (j - i) &gt; <span class="built_in">max</span>)<span class="built_in">max</span> = <span class="built_in">min</span>(<span class="built_in">height</span>[i], <span class="built_in">height</span>[j]) * (j - i);</span><br><span class="line">			(<span class="built_in">height</span>[i] &lt; <span class="built_in">height</span>[j]) ? i++ : j--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>#15.三数之和<br>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<p>示例：</p>
<p>给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p>
<p>满足要求的三元组集合为：<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/3sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/3sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">threeSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> j = i + <span class="number">1</span>, k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    j++; <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (k &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; nums[k] == nums[k + <span class="number">1</span>]) &#123;</span><br><span class="line">                    k--; <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] &gt; <span class="number">0</span>)k--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] &lt; <span class="number">0</span>)j++;</span><br><span class="line">                <span class="keyword">else</span> res.push_back(&#123; nums[i],nums[j++],nums[k--] &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="剑指offer11-旋转数组的最小数字"><a href="#剑指offer11-旋转数组的最小数字" class="headerlink" title="剑指offer11.旋转数组的最小数字"></a>剑指offer11.旋转数组的最小数字</h2><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  </p>
<p>示例 1：</p>
<p>输入：[3,4,5,1,2]<br>输出：1<br>示例 2：</p>
<p>输入：[2,2,2,0,1]<br>输出：0</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = numbers.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mi = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (numbers[mi] &lt; numbers[hi])hi = mi;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (numbers[hi] &lt; numbers[mi])lo = mi + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> hi -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[lo];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>#64.最小路径和<br>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>说明：每次只能向下或者向右移动一步。</p>
<p>示例:</p>
<p>输入:<br>[<br>  [1,3,1],<br>  [1,5,1],<br>  [4,2,1]<br>]<br>输出: 7<br>解释: 因为路径 1→3→1→1→1 的总和最小。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/minimum-path-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-path-sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid.<span class="built_in">size</span>() == <span class="number">0</span> || grid[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> row = grid.<span class="built_in">size</span>(), column = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">auto</span> dp = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(row, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(column));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; column; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; column; j++) &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[row - <span class="number">1</span>][column - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="1033-移动石子直到连续"><a href="#1033-移动石子直到连续" class="headerlink" title="#1033.移动石子直到连续"></a>#1033.移动石子直到连续</h2><p>三枚石子放置在数轴上，位置分别为 a，b，c。</p>
<p>每一回合，我们假设这三枚石子当前分别位于位置 x, y, z 且 x &lt; y &lt; z。从位置 x 或者是位置 z 拿起一枚石子，并将该石子移动到某一整数位置 k 处，其中 x &lt; k &lt; z 且 k != y。</p>
<p>当你无法进行任何移动时，即，这些石子的位置连续时，游戏结束。</p>
<p>要使游戏结束，你可以执行的最小和最大移动次数分别是多少？ 以长度为 2 的数组形式返回答案：answer = [minimum_moves, maximum_moves]</p>
<p>示例 1：</p>
<p>输入：a = 1, b = 2, c = 5<br>输出：[1, 2]<br>解释：将石子从 5 移动到 4 再移动到 3，或者我们可以直接将石子移动到 3。<br>示例 2：</p>
<p>输入：a = 4, b = 3, c = 2<br>输出：[0, 0]<br>解释：我们无法进行任何移动</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/moving-stones-until-consecutive" target="_blank" rel="noopener">https://leetcode-cn.com/problems/moving-stones-until-consecutive</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">numMovesStones</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v&#123; a,b,c &#125;;</span><br><span class="line">        sort(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> mMax = v[<span class="number">2</span>] - v[<span class="number">0</span>] - <span class="number">2</span>, <span class="built_in">min</span> = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> ((v[<span class="number">1</span>] - v[<span class="number">0</span>]) &lt;= <span class="number">2</span> || (v[<span class="number">2</span>] - v[<span class="number">1</span>]) &lt;= <span class="number">2</span>) <span class="built_in">min</span> = <span class="number">1</span>;;</span><br><span class="line">        <span class="keyword">if</span> ((v[<span class="number">1</span>] - v[<span class="number">0</span>]) == <span class="number">1</span> &amp;&amp; (v[<span class="number">2</span>] - v[<span class="number">1</span>]) == <span class="number">1</span>) <span class="built_in">min</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="built_in">min</span>,mMax &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="#238.除自身以外数组的乘积"></a>#238.除自身以外数组的乘积</h2><p>给你一个长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。</p>
<p>示例:</p>
<p>输入: [1,2,3,4]<br>输出: [24,12,8,6]</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/product-of-array-except-self" target="_blank" rel="noopener">https://leetcode-cn.com/problems/product-of-array-except-self</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v2;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v3;</span><br><span class="line">        <span class="keyword">int</span> n1 = <span class="number">1</span>, n2 = <span class="number">1</span>;</span><br><span class="line">        v1.push_back(<span class="number">1</span>);</span><br><span class="line">        v2.push_back(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            v1.push_back(n1 *= nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>(); j++)v2.push_back(n2 *= nums[nums.<span class="built_in">size</span>() - j - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; nums.<span class="built_in">size</span>(); k++) &#123;</span><br><span class="line">            v3.push_back(v1[k] * v2[nums.<span class="built_in">size</span>() - <span class="number">1</span> - k]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="#16.最接近的三数之和"></a>#16.最接近的三数之和</h2><p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p>
<p>示例：</p>
<p>输入：nums = [-1,2,1,-4], target = 1<br>输出：2<br>解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) </p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/3sum-closest" target="_blank" rel="noopener">https://leetcode-cn.com/problems/3sum-closest</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">min</span>=<span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>()<span class="number">-2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j=i+<span class="number">1</span>,k=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;k)&#123;</span><br><span class="line">                <span class="keyword">int</span> sum=nums[i]+nums[j]+nums[k];</span><br><span class="line">                <span class="keyword">if</span>(sum==target)<span class="keyword">return</span> target;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(sum-target)&lt;<span class="built_in">abs</span>(<span class="built_in">min</span>-target))&#123;</span><br><span class="line">                    <span class="built_in">min</span>=sum;&#125;</span><br><span class="line">                (sum&lt;target)?j++:k--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="5-6-合并区间"><a href="#5-6-合并区间" class="headerlink" title="#5 6.合并区间"></a>#5 6.合并区间</h2><p>给出一个区间的集合，请合并所有重叠的区间。</p>
<p>示例 1:</p>
<p>输入: [[1,3],[2,6],[8,10],[15,18]]<br>输出: [[1,6],[8,10],[15,18]]<br>解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/merge-intervals" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-intervals</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        sort(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.<span class="built_in">size</span>();) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> ir = intervals[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (j &lt; intervals.<span class="built_in">size</span>() &amp;&amp; intervals[j][<span class="number">0</span>] &lt;= ir) &#123;</span><br><span class="line">                ir = <span class="built_in">max</span>(ir, intervals[j][<span class="number">1</span>]);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(&#123; intervals[i][<span class="number">0</span>],ir &#125;);</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/26/problem-library-%E6%95%B0%E7%BB%84/" data-id="ckd64loef0022akve7e7a11i3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/problem-library/" rel="tag">problem library</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-DS邓俊辉09" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/26/DS%E9%82%93%E4%BF%8A%E8%BE%8909/" class="article-date">
  <time datetime="2020-07-26T13:32:35.000Z" itemprop="datePublished">2020-07-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/26/DS%E9%82%93%E4%BF%8A%E8%BE%8909/">DS邓俊辉09</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h1><p>散列(Hashing)call-by-value<br>桶(bucket):直接存放活间接指向一个词条<br>桶数组(bucket array)/散列表(hash table)，容量为M N&lt;M&lt;&lt;R 空间O(N+M)=O(N)<br>定址/杂凑/散列：根据词条的key直接确定散列表入口<br>散列函数：hash():key-&gt;&amp;entry<br>装填因子(load factor)λ=N/M<br>散列函数(hash())：<br>确定(determinism)同一关键码总是被映射至同一地址；快速(efficiency)expected-O(1)；满射(surjection)：尽可能充分地覆盖整个散列空间<br>均匀(uniformity)：关键码映射到散列表各位置的概率尽量接近，避免聚集(clustering)现象<br>除余法：hash(key)=key%M  M为素数时，数据对散列表覆盖最充分，分布最均匀<br>最大公因子gc=(S,M)=G 当且仅当G=1时，可以遍布M，所以M应取素数<br>缺陷：不动点：无论表长M取值，总有hash(0)==0；零阶均匀：[0,R),平均分配至M个桶，但相邻关键码的散列地址也必相邻<br>MAD(multiply-add-divide):取M为素数，a &gt; 0,b &gt; 0,a % M!= 0,hash(key)=(a * key + b) % M<br>更多散列函数：数字分析(selecting digits)抽取key中某几位，构成地址；平方取中(mid-square)取key^2的中间若干位构成地址<br>折叠法(folding):将key分割成等宽的若干段，取其总和作为地址 位异或法<br>(伪)随机数法:rand(x+1)=[a<em>rand(x)]%M;  hash(key)=rand(key)=[rand[0]</em>a^key]%M 可移植性差<br>多项式法:hash(s =x0x1…xn-1) = x0<em>a^(n-1)+…+xn-2</em>a^1+xn-1</p>
<p>排解冲突：<br>多槽位(multiple slots)桶单元细分成若干槽位，存放冲突的词条。但预留过多空间会浪费，极端情况可能会不够<br>独立链(linked-list/separate chaining)每个桶存放一个指针，冲突的词条组织成列表<br>无需为每个桶预留多个槽位，任一多次的冲突都可解决，删除操作实现简单、统一<br>但是指针需要额外空间，节点需要动态申请；空间未必连续分布，系统缓存几乎失效<br>开放定址(open addressing)为每个桶都事先约定若干备用桶，他们构成一个查找链(probing sequence/chain)<br>查找时沿查找链，逐个转向下一桶单元，直到命中-&gt;成功,或者抵达一个空桶-&gt;失败<br>线性试探(linear probing)一旦冲突，则试探后一紧邻桶单元:[hash(key)+1]%M.[hash(key)+2]%M….直到命中成功或者抵达空桶失败<br>无需附加的(指针、链表或溢出区等)空间；查找链具有局部性，可充分利用系统缓存，有效减少I/O<br>但是操作时间&gt;O(1),冲突增多，以往的冲突会导致后续的冲突<br>懒惰删除(lazy removal)直接删除词条将导致查找链被切断，后续词条丢失，可以在删除的时候不删除而是加一标记，查找时越过，插入时加入<br>平方试探(quadratic probing)以平方数为距离，确定下一试探桶单元 [hash(key)+n^2]%M<br>数据聚集现象有所缓解，查找链上各桶间距线性递增，但涉及外存时I/O激增，且空桶一不定能被发现<br>M若为合数，n^2%M可能的取值必然少于[m/2]种，M若为合数，恰好[M/2]种，取遍前[M/2]个桶<br>所以若M是素数，且λ&lt;50%就一定能找到<br>双向平方试探：[hash(key) + n ^ 2] % M, [hash(key) - n ^ 2] % M<br>表长取素数M=4*k+3，必然可以保证查找链的前M项均互异<br>双平方定理(two-square theorem of fermat):任一素数p可表示为一对整数的平方和，当且仅当p%4=1</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/26/DS%E9%82%93%E4%BF%8A%E8%BE%8909/" data-id="ckd64lodm000aakvedjtxd611" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%82%93%E4%BF%8A%E8%BE%89/" rel="tag">数据结构 邓俊辉</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-DS邓俊辉08" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/26/DS%E9%82%93%E4%BF%8A%E8%BE%8908/" class="article-date">
  <time datetime="2020-07-26T13:31:13.000Z" itemprop="datePublished">2020-07-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/26/DS%E9%82%93%E4%BF%8A%E8%BE%8908/">DS邓俊辉08</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="高级搜索树"><a href="#高级搜索树" class="headerlink" title="高级搜索树"></a>高级搜索树</h1><p>伸展树<br>逐层伸展：<br>局部性(locality)：刚被访问过的数据，极有可能很快地再次被访问-》自适应调整<br>节点v一旦被访问，随即转移至树根<br>自下而上，逐层单旋<br>旋转次数呈周期性的算术级数演变：每一周期累计omega(n^2)，分摊omega(n)</p>
<p>双层伸展：<br>向上追溯两层<br>子孙异侧时与逐层同效<br>子孙同侧（zig-zig）时:zig(g),zig(p)<br>折叠效果：一旦访问坏节点，对应路径的长度将随即减半，单趟伸展操作分摊O(logn)时间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Splay</span> :</span><span class="keyword">public</span> BST&lt;T&gt; &#123; <span class="comment">//由BST派生</span></span><br><span class="line"><span class="keyword">protected</span>:BinNodePosi(T) splay(BinNodePosi(T) v); <span class="comment">//将v伸展至根</span></span><br><span class="line"><span class="keyword">public</span>: <span class="comment">//伸展树的查找也会引起整数的结构调整，故search()也需要重写</span></span><br><span class="line">	BinNodePosi(T)&amp; search(<span class="keyword">const</span> T&amp; e); <span class="comment">//查找重写</span></span><br><span class="line">	BinNodePosi(T)insert(<span class="keyword">const</span> T&amp; e); <span class="comment">//插入重写</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> T&amp; e)</span></span>; <span class="comment">//删除重写</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="title">BinNodePosi</span><span class="params">(T)</span> Splay&lt;T&gt;::<span class="title">splay</span><span class="params">(BinNodePosi(T) v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!v)<span class="keyword">return</span> <span class="literal">NULL</span>; BinNodePosi(T) p; BinNodePosi(T) g; <span class="comment">//父亲，祖父</span></span><br><span class="line">	<span class="keyword">while</span> ((p = v-&gt;parent) &amp;&amp; (g = p-&gt;parent)) &#123; <span class="comment">//自下而上，反复双层伸展</span></span><br><span class="line">		BinNodePosi(T) gg = g-&gt;parent; <span class="comment">//每轮之后，v都将以原曾祖父为父</span></span><br><span class="line">		<span class="keyword">if</span>(IsLChld(*v))</span><br><span class="line">			<span class="keyword">if</span>(IsLChild(*p))&#123;</span><br><span class="line">				<span class="comment">/*zig-zig*/</span> </span><br><span class="line">				attachAsLChild(g, p-&gt;rc);</span><br><span class="line">				attachAsLChild(p, v-&gt;rc);</span><br><span class="line">				attachAsLChild(p,g);</span><br><span class="line">				attachAsLChild(v,p);</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;<span class="comment">/*zig-zag*/</span> &#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(IsRChild(*p))&#123;<span class="comment">/*zag-zag*/</span> &#125;<span class="keyword">else</span>&#123;<span class="comment">/*zag-zig*/</span> &#125;</span><br><span class="line">		<span class="keyword">if</span> (!gg)v-&gt;parent = <span class="literal">NULL</span>; <span class="comment">//若无曾祖父gg，则v现即为树根；否则，gg伺候应以v为左或右孩子</span></span><br><span class="line">		esle(g == -&gt;lc) ? attachAlLChild(gg, v) : attachAsRChild(gg, v);</span><br><span class="line">		updateHeight(g); updateHeight(p); updateHeight(v);</span><br><span class="line">	&#125; <span class="comment">//双层伸展结束时，必有g==NULL，但p可能非空</span></span><br><span class="line">	<span class="keyword">if</span>(p=v-&gt;parent)&#123;<span class="comment">/*若p果真是跟，只需在额外单旋（至多一次）*/</span> &#125;</span><br><span class="line">	v-&gt;parent = <span class="literal">NULL</span>; <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">查找算法：</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;BinNodePosi(T)&amp; Splay&lt;T&gt;::search(<span class="keyword">const</span> T&amp; e) &#123;</span><br><span class="line">	<span class="comment">//调用标准BST的内部接口定位目标节点</span></span><br><span class="line">	BinNodePosi(T) p = searchIn(_root, e, _hot = <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//无论成功与否，最后被访问的节点都将伸展至根</span></span><br><span class="line">	_root = splay(p ? p : _hot);</span><br><span class="line">	<span class="comment">//总是返回根节点</span></span><br><span class="line">	<span class="keyword">return</span> _root;</span><br><span class="line">&#125;</span><br><span class="line">伸展树的查找操作与常规BST::search()不同，很可能会改变树的拓补结构，不再属于静态操作</span><br><span class="line"></span><br><span class="line">插入算法：</span><br><span class="line">重写后的Splay::search()已集成了splay()操作，查找(失败后)，_hot即是根节点</span><br><span class="line">删除类似</span><br><span class="line"></span><br><span class="line">伸展树：无需记录节点高度或平衡因子，编程实现简单易行--优于AVL树</span><br><span class="line">		分摊复杂度O(logn)--与AVL树相当</span><br><span class="line">		局部性强，缓存命中率极高时(k&lt;&lt;n&lt;&lt;m)，效率甚至可以更高--自适应的O(logk)</span><br><span class="line">		任务连续的m次查找，都可以在O(mlogk+nlogn)时间内完成</span><br><span class="line">		仍不能保证单次最坏情况的出现，不适用于对单次效率敏感的场合</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">B-树</span><br><span class="line">平衡的多路(multi-way)搜索树，每d代合并：m=<span class="number">2</span>^d路，m<span class="number">-1</span>个关键码</span><br><span class="line">多级存储系统中使用B-树，可针对外部查找，大大减少I/O次数</span><br><span class="line">充分利用外存对批量访问的高效支持，将此特点转化为优点</span><br><span class="line">每下降一层，都以超级接待为单位，读入一组关键码</span><br><span class="line">m阶B-树，即m路平衡搜索树</span><br><span class="line">外部节点的深度统一相等，素有叶节点的深度统一相等</span><br><span class="line">树高h=外部节点深度</span><br><span class="line">内部节点有不超过m<span class="number">-1</span>个关键码，不超过m个分支</span><br><span class="line">内部结点的分支数n+<span class="number">1</span>也不能太少，树根<span class="number">2</span>&lt;=n+<span class="number">1</span>，其余[m/<span class="number">2</span>]&lt;=n+<span class="number">1</span> <span class="comment">//[]为上整</span></span><br><span class="line">也称作([m/<span class="number">2</span>,m])树</span><br><span class="line"></span><br><span class="line">BTNode:</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; struct BTNode &#123; <span class="comment">//B-树节点</span></span><br><span class="line">	BTNodePosi(T) parent; <span class="comment">//父</span></span><br><span class="line">	Vector&lt;T&gt; key; <span class="comment">//数值向量</span></span><br><span class="line">	Vector&lt;BTNodePosi(T)&gt;child; <span class="comment">//孩子向量（长度比key多一）</span></span><br><span class="line">	BTNode() &#123; parent = <span class="literal">NULL</span>; child.insert(<span class="number">0</span>, <span class="literal">NULL</span>); &#125;</span><br><span class="line">	BTNode(T e, BTNodePosi(T) lc = <span class="literal">NULL</span>, BTNodePosi(T) rc = <span class="literal">NULL</span>) &#123;</span><br><span class="line">		parent = <span class="literal">NULL</span>; <span class="comment">//作为根节点，而且初始时</span></span><br><span class="line">		key.insert(<span class="number">0</span>, e); <span class="comment">//仅一个关键码，以及</span></span><br><span class="line">		child.insert(<span class="number">0</span>, lc); chld.insert(<span class="number">1</span>, rc); <span class="comment">//两个孩子</span></span><br><span class="line">		<span class="keyword">if</span> (lc)lc-&gt;parent = <span class="keyword">this</span>; <span class="keyword">if</span> (rc)rc-&gt;parent = <span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BTNodePosi(T) BTNode<span class="meta-string">&lt;*T&gt; //B-树节点位置</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">BTree</span> &#123;</span> <span class="comment">//B-树</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> _size; <span class="keyword">int</span> _order; BTNodePosi(T) _root; <span class="comment">//关键码总数、阶次、根</span></span><br><span class="line">	BTNodePosi(T) _hot; <span class="comment">//search()最后访问的非空节点位置</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">solveOverflow</span><span class="params">(BinNodePosi(T))</span></span>; <span class="comment">//因插入而上溢后的分裂处理</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">solveUnderflow</span><span class="params">(BinNodePosi(T))</span></span>; <span class="comment">//因删除而下溢后的合并处理</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	BTNodePosi(T) search(<span class="keyword">const</span> T&amp; e); <span class="comment">//查找</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> T&amp; e)</span></span>; <span class="comment">//插入</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> T&amp; e)</span></span>; <span class="comment">//删除</span></span><br><span class="line">&#125;;</span><br><span class="line">查找：</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="title">BTNodePosi</span><span class="params">(T)</span> BTree&lt;T&gt;::<span class="title">search</span><span class="params">(<span class="keyword">const</span> T&amp; e)</span> </span>&#123;</span><br><span class="line">	BTNodePosi(T) v = _root; _hot = <span class="literal">NULL</span>; <span class="comment">//从根节点出发</span></span><br><span class="line">	<span class="keyword">while</span> (v) &#123; <span class="comment">//逐层查找</span></span><br><span class="line">		Rank r = v-&gt;key.search(e); <span class="comment">//在当前节点对应的向量中顺序查找</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="number">0</span> &lt;= r &amp;&amp; e == v-&gt;key[r])<span class="keyword">return</span> v; <span class="comment">//若成功，则返回；否则。。。</span></span><br><span class="line">		_hot = v; v = v-&gt;child[r + <span class="number">1</span>]; <span class="comment">//沿引用转至对应的下层子树，并载入其跟I/O</span></span><br><span class="line">	&#125; <span class="comment">//若因!v而退出，则意味着抵达外部节点</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">//失败</span></span><br><span class="line">&#125;</span><br><span class="line">树高：根在<span class="number">0</span>层，叶在h<span class="number">-1</span>层，外部节点在h层</span><br><span class="line">含N个关键码的m阶B-树树高h&lt;=<span class="number">1</span>+<span class="built_in">log</span>[m/<span class="number">2</span>][(n+<span class="number">1</span>)/<span class="number">2</span>]=O(logm(n))</span><br><span class="line">h&gt;=logm(N+<span class="number">1</span>)=omega(logm(N))</span><br><span class="line"></span><br><span class="line">插入：</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> BTree&lt;T&gt;::insert(<span class="keyword">const</span> T&amp; e) &#123;</span><br><span class="line">	BTNodePosi(T) v = search(e);</span><br><span class="line">	<span class="keyword">if</span> (v)<span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//确认e不存在</span></span><br><span class="line">	Rank r = _hot-&gt;key.search(e); <span class="comment">//在节点_hot中确定插入位置</span></span><br><span class="line">	_hot-&gt;key.insert(r + <span class="number">1</span>, e); <span class="comment">//将新关键码插至对应的位置</span></span><br><span class="line">	_hot-&gt;child.insert(r + <span class="number">2</span>, <span class="literal">NULL</span>); <span class="comment">//创建一个空子树指针</span></span><br><span class="line">	_size++; solveOverflow(_hot); <span class="comment">//如发生上溢，需做分裂</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//插入成功</span></span><br><span class="line">&#125;</span><br><span class="line">分裂：</span><br><span class="line">设上溢节点中的关键码依次为k0,k1...km<span class="number">-1</span></span><br><span class="line">取中位数s=[m/<span class="number">2</span>]，以关键码ks为界划分为k0,k1...ks<span class="number">-1</span>  ks  ks+<span class="number">1.</span>..km<span class="number">-1</span></span><br><span class="line">关键码ks上升一层，并分裂：以所得的两个节点作为左右孩子</span><br><span class="line">分裂到根后可能高度+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">删除：</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> BTree&lt;T&gt;::<span class="built_in">remove</span>(<span class="keyword">const</span> T&amp; e) &#123;</span><br><span class="line">	BTNodePosi(T) v = search(e);</span><br><span class="line">	<span class="keyword">if</span> (!v)<span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//确认e存在</span></span><br><span class="line">	Rank r = v-&gt;key.search(e); <span class="comment">//确定e在v中的秩</span></span><br><span class="line">	<span class="keyword">if</span> (v-&gt;child[<span class="number">0</span>]) &#123; <span class="comment">//若v非叶子</span></span><br><span class="line">		BTNodePosi(T) u = v-&gt;child[r + <span class="number">1</span>]; <span class="comment">//在右子树中一直向左，即可</span></span><br><span class="line">		<span class="keyword">while</span> (u-&gt;child[<span class="number">0</span>]) u = u-&gt;child[<span class="number">0</span>]; <span class="comment">//找到e的后继（必属于某叶节点）</span></span><br><span class="line">		v-&gt;key[r] = u-&gt;key[<span class="number">0</span>]; v = u; r = <span class="number">0</span>; <span class="comment">//并与之交换位置</span></span><br><span class="line">	&#125; <span class="comment">//至此，v必然位于最底层，且其中第r个关键码就是待删除者</span></span><br><span class="line">	v-&gt;key.<span class="built_in">remove</span>(r); v-&gt;child.<span class="built_in">remove</span>(r + <span class="number">1</span>); _size--;</span><br><span class="line">	solveUnderflow(v); <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//如有必要，需做旋转或合并</span></span><br><span class="line">&#125;</span><br><span class="line">节点v下溢时，必恰好包含：[m / <span class="number">2</span>] - <span class="number">2</span>个关键码和[m / <span class="number">2</span>] - <span class="number">1</span>个分支</span><br><span class="line">旋转：左右兄弟满足关键码 &gt;= [m / <span class="number">2</span>]时：L的最大x给父节点，父的y给到v</span><br><span class="line">合并：不满足时，将兄弟、父中节点y和v合并</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">红黑树</span><br><span class="line">一致性结构：支持对历史版本的访问</span><br><span class="line">T.search(ver, key); T.insert(ver, key);T.<span class="built_in">remove</span>(ver,key)</span><br><span class="line">蛮力实现：每个版本独立保存；各版本入口自成一个搜索结构。单次操作O(logh+logn)，累计O(h*n)时间/空间</span><br><span class="line">大量共享，少量更新：每个版本的新增复杂度仅为O(logn)</span><br><span class="line">红黑树更新O(<span class="number">1</span>)</span><br><span class="line">统一增设外部节点<span class="literal">NULL</span>，使之成为真二叉树</span><br><span class="line">树根：必为黑色；外部节点：均为黑色；其余节点：若为红，则只能有黑孩子、黑父亲；外部节点到根：途中黑节点数目相等</span><br><span class="line">红色节点提升变换后，所有底层节点都在一平齐高度----（<span class="number">2</span>，<span class="number">4</span>）树==红黑树</span><br><span class="line">包含n个内部节点的红黑树T，高度hO(logn)</span><br><span class="line">log2(n+<span class="number">1</span>)&lt;= h &lt;=<span class="number">2</span>*log2(n+<span class="number">1</span>)</span><br><span class="line">接口：</span><br><span class="line"><span class="keyword">template</span>&lt;T&gt;class RedBlack :<span class="keyword">public</span> BST&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>: <span class="comment">//BST::search()等接口可直接沿用</span></span><br><span class="line">	BinNodePosi(T) insert(<span class="keyword">const</span> T&amp; e); <span class="comment">//插入（重写）</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> T&amp; e)</span></span>; <span class="comment">//删除（重写）</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">solveDoubleRed</span><span class="params">(BinNodePosi(T) x)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">solveDoubleBlack</span><span class="params">(BinNodePosi(T) x)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">updateHeight</span><span class="params">(BinNodePosi(T) x)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="keyword">int</span> RedBlack&lt;T&gt;::updateHeight(BinNodePosi(T) x) &#123;</span><br><span class="line">	x-&gt;<span class="built_in">height</span> = <span class="built_in">max</span>(stature(x-&gt;lc), stature(x-&gt;rc));</span><br><span class="line">	<span class="keyword">if</span> (IsBlack(x))x-&gt;<span class="built_in">height</span>++; <span class="keyword">return</span> x-&gt;<span class="built_in">height</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">插入：</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;BinNodePosi(T) RedBlack&lt;T&gt;::insert(<span class="keyword">const</span> T&amp; e) &#123;</span><br><span class="line">	<span class="comment">//确认目标节点不存在（留意对_hot的设置）</span></span><br><span class="line">	BinNodePosi(T)&amp; x = search(e); <span class="keyword">if</span> (x)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">//创建红节点x，以_hot为父，黑高度-1</span></span><br><span class="line">	x = <span class="keyword">new</span> BinNode&lt;T&gt;(e, _hot, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">-1</span>); _size++;</span><br><span class="line">	<span class="comment">//如有必要，做双红修正</span></span><br><span class="line">	solveDoubleRed(x);</span><br><span class="line">	<span class="comment">//返回插入的节点</span></span><br><span class="line">	<span class="keyword">return</span> x ? x : _hot-&gt;parent;</span><br><span class="line">&#125;<span class="comment">//无论原树中是否存在e，返回时总有x-&gt;data==e</span></span><br><span class="line">双红修正</span><br><span class="line">u为黑：旋转<span class="number">1</span> - <span class="number">2</span>次，染色<span class="number">2</span>次，调整随即完成</span><br><span class="line">RR<span class="number">-1</span>:u为黑 b转黑，a或c转红</span><br><span class="line">RR<span class="number">-2</span>:u为红 在B-树中上溢 p与u转黑，g转红 节点分裂，g上升<span class="number">1</span>层</span><br><span class="line">u为红：旋转<span class="number">0</span>次，染色<span class="number">3</span>次，可能再次双红，但必上升<span class="number">2</span>层 O(logn)内完成</span><br><span class="line">每次插入最多做：O(logn)次节点染色，一次“<span class="number">3</span> + <span class="number">4</span>”重构</span><br><span class="line"></span><br><span class="line">删除：</span><br><span class="line">删除x后由r代替x的位置，可能发生双黑缺陷，黑深度变化，原B - 树中x所属节点下溢</span><br><span class="line">在新树中考察：r的父亲p = r-&gt;parent; r的兄弟s = r == p-&gt;lr ? r-&gt;rc : r-&gt;lc</span><br><span class="line">BB - <span class="number">1</span>：s为黑，且至少有一个红孩子t</span><br><span class="line"><span class="number">3</span> + <span class="number">4</span>重构：t, s, p重命名为a, b, c；r保持黑，a和c染黑，b继承p的原色</span><br><span class="line">在B - 树中：通过关键码的旋转，消除超级节点的下溢 有红孩子-&gt;兄弟节点可以往外借</span><br><span class="line">BB - <span class="number">2</span>R：s为黑，且两个孩子均为黑；p为红</span><br><span class="line">r保持黑，s转红，p转黑</span><br><span class="line">在B - 树中：下溢节点与兄弟合并， 父借一个p后合并  借的p为红，必有黑，所以不会再次发生下溢</span><br><span class="line">BB - <span class="number">2B</span>：s为黑，且两个孩子均为黑；p为黑</span><br><span class="line">s转为红</span><br><span class="line">在B - 树中，可能会再次下溢，而在红黑树中拓补结构不变，不会发生</span><br><span class="line">BB3：s为红（其孩子均为黑）</span><br><span class="line">zag(p)或zip(p);红s转黑，黑p转红 黑高度依然异常，但r有了一个新黑兄弟s’，且p已转红，接下来只能是BB<span class="number">-1</span>或BB<span class="number">-2</span>R</span><br><span class="line">经过再一轮调整后会恢复</span><br><span class="line">每一删除操作都在O(logn)</span><br><span class="line">至多做：O(logn)次重染色、<span class="number">1</span>次<span class="number">3</span>+<span class="number">4</span>重构、一次单旋</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/26/DS%E9%82%93%E4%BF%8A%E8%BE%8908/" data-id="ckd64lodl0008akve7bea3lfv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%82%93%E4%BF%8A%E8%BE%89/" rel="tag">数据结构 邓俊辉</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-DS邓俊辉07" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/26/DS%E9%82%93%E4%BF%8A%E8%BE%8907/" class="article-date">
  <time datetime="2020-07-26T13:28:19.000Z" itemprop="datePublished">2020-07-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/26/DS%E9%82%93%E4%BF%8A%E8%BE%8907/">DS邓俊辉07</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h1><p>数据项之间依照各自的关键码彼此区分call-by-key，支持大小比较与相等比对，数据集合中的数据项统一地表示和实现为词条(entry)形式<br>词条：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;<span class="class"><span class="keyword">struct</span> <span class="title">Entry</span> &#123;</span> <span class="comment">//词条模板类</span></span><br><span class="line">	K key; V value; <span class="comment">//关键码、数值</span></span><br><span class="line">	Entry(K k = K(), V v = V()) :key(k), value(v) &#123;&#125;;  <span class="comment">//默认构造函数</span></span><br><span class="line">	Entry(Entry&lt;K, V&gt;<span class="keyword">const</span>&amp; e) :key(e.key), value(e.value) &#123;&#125;; <span class="comment">//克隆</span></span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(Entry&lt;K, V&gt;<span class="keyword">const</span>&amp; e) &#123; <span class="keyword">return</span> key &lt; e.key; &#125; <span class="comment">//小于</span></span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(Entry&lt;K, V&gt;<span class="keyword">const</span>&amp; e) &#123; <span class="keyword">return</span> key &gt; e.key; &#125; <span class="comment">//大于</span></span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>==(Entry&lt;K, V&gt;<span class="keyword">const</span>&amp; e) &#123; <span class="keyword">return</span> key == e.key; &#125; <span class="comment">//等于</span></span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>!=(Entry&lt;K, V&gt;<span class="keyword">const</span>&amp; e) &#123; <span class="keyword">return</span> key != e.key; &#125; <span class="comment">//不等于</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Binary Sarch Tree(BST)：节点~词条~关键码</span><br><span class="line">顺序性：任一节点均不小于/不大于其左/右后代</span><br><span class="line">单调性：BST的中序遍历序列，必然单调非降</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="class"><span class="keyword">class</span> <span class="title">BST</span> :</span><span class="keyword">public</span> BinTree&lt;T&gt; &#123; <span class="comment">//由BinTree派生</span></span><br><span class="line"><span class="keyword">public</span>: <span class="comment">//以virtual修饰，以便派生类重写</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="title">BinNodePosi</span><span class="params">(T)</span>&amp; <span class="title">search</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>; <span class="comment">//查找</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="title">BinNodePosi</span><span class="params">(T)</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>; <span class="comment">//插入</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>; <span class="comment">//删除</span></span><br><span class="line">	<span class="keyword">protected</span>;</span><br><span class="line">	BinNodePosi(T) _hot; <span class="comment">//命中节点的父亲</span></span><br><span class="line">	BinNodePosi(T) connect34( <span class="comment">//3+4重构</span></span><br><span class="line">		BinNosePosi(T), BinNosePosi(T), BinNosePosi(T),</span><br><span class="line">		BinNosePosi(T), BinNosePosi(T), BinNosePosi(T), BinNosePosi(T)</span><br><span class="line">	);</span><br><span class="line">	BinNodePosi(T) rotateAt(BinNodePosi(T)); <span class="comment">//旋转调整</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BST查找：</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi(T) &amp; BST&lt;T&gt;::search(<span class="keyword">const</span> T &amp; E)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> searchIn(_root, e, _hot = <span class="literal">NULL</span>;) <span class="comment">//从根节点查找</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> BinNodePosi(T)&amp; searchIn( <span class="comment">//递归，可改为迭代版</span></span><br><span class="line">	BinNodePosi(T)&amp; v, <span class="comment">//当前（子）树根</span></span><br><span class="line">	<span class="keyword">const</span> T&amp; e, <span class="comment">//目标关键码</span></span><br><span class="line">	BinNodePosi(T&amp; hot) <span class="comment">//记忆热点</span></span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!v || (e == v-&gt;data))<span class="keyword">return</span> v; <span class="comment">//足以确定失败、成功，或者</span></span><br><span class="line">	hot == v; <span class="comment">//先记下当前（非空）节点，然后再。。。</span></span><br><span class="line">	<span class="keyword">return</span> searchIn(((e &lt; v-&gt;data) ? v-&gt;lChild : v-&gt;rChild), e, hot);</span><br><span class="line">&#125; <span class="comment">//运行时间正比于返回节点v的深度，不超过树高 O(h)</span></span><br><span class="line">返回的引用值：成功时，指向一个关键码为e且真实存在的节点，_hot指向该节点的父亲</span><br><span class="line">			  失败时，指向最后一次试图转向的空节点<span class="literal">NULL</span>，_hot指向最后访问的真实存在的节点</span><br><span class="line"></span><br><span class="line">插入：</span><br><span class="line">先借助search(e)确定插入位置及方向，再将新节点作为叶子插入</span><br><span class="line">若e尚不存在，则:_hot为新节点的父亲，v=search(e)为_hot对新孩子的引用</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi(T) BST&lt;T&gt;::insert(<span class="keyword">const</span> T &amp; e) &#123;</span><br><span class="line">	BinNodePosi(T)&amp; x = search(e); <span class="comment">//查找目标（留意_hot的设置）</span></span><br><span class="line">	<span class="keyword">if</span> (!x) &#123; <span class="comment">//既禁止雷同元素，故仅在查找失败时才实施插入操作</span></span><br><span class="line">		x = <span class="keyword">new</span> BinNode&lt;T&gt;(e, _hot); <span class="comment">//在x处创建新节点，以_hot为父亲</span></span><br><span class="line">		_size++; updateHeightAbove(x); <span class="comment">//更新全树规模，更新x及其历代祖先的高度</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x; <span class="comment">//无论e是否存在于原树中，至此总有x-&gt;data==e</span></span><br><span class="line">&#125;O(h)</span><br><span class="line"></span><br><span class="line">删除：</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">bool</span> BST&lt;T&gt;::<span class="built_in">remove</span>(<span class="keyword">const</span> T&amp; e) &#123;</span><br><span class="line">	BinNodePosi(T)&amp; x = search(e); <span class="comment">//定位目标节点</span></span><br><span class="line">	<span class="keyword">if</span> (!x)<span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//确认目标存在（此时_hot为x的父亲）</span></span><br><span class="line">	removeAt(x, _hot); <span class="comment">//分为两大类情况试试删除，更新全树规模</span></span><br><span class="line">	_size--; updateHeightAbove(_hot);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="keyword">static</span> <span class="title">BinNodePosi</span><span class="params">(T)</span></span></span><br><span class="line"><span class="function"><span class="title">removeAt</span><span class="params">(BinNodePosi(T)&amp; x, BinNodePosi(T)&amp; hot)</span> </span>&#123;</span><br><span class="line">	BinNodePosi(T) w = x; <span class="comment">//实际被摘除的节点，初值同x</span></span><br><span class="line">	BinNodePosi(T) succ = <span class="literal">NULL</span>; <span class="comment">//实际被删除节点的接替者</span></span><br><span class="line">	<span class="keyword">if</span> (!HasLChild(*x))succ = x = x-&gt;rChild; <span class="comment">//左子树为空</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (!HasRChild(*x))succ = x = x-&gt;lChild; <span class="comment">//右子树为空</span></span><br><span class="line">	<span class="keyword">else</span> &#123; <span class="comment">/*左右子树并存*/</span></span><br><span class="line">		w = w-&gt;succ(); swap(x-&gt;data, w-&gt;data); <span class="comment">//令*x与其后继*w互换数据</span></span><br><span class="line">		BinNodePosi(T) u = w-&gt;parent; <span class="comment">//原问题即转化为，摘除非二度的节点w</span></span><br><span class="line">		(u == x ? u-&gt;rChild : u-&gt;lChild) = succ = w-&gt;rChild;</span><br><span class="line">	&#125;</span><br><span class="line">	hot = w-&gt;parent; <span class="comment">//记录实际被删除节点的父亲</span></span><br><span class="line">	<span class="keyword">if</span> (succ)succ-&gt;parent = hot; <span class="comment">//将被删除节点的接替者与hot相联</span></span><br><span class="line">	<span class="built_in">release</span>(w-&gt;data); <span class="built_in">release</span>(w); <span class="comment">//释放被摘除节点</span></span><br><span class="line">	<span class="keyword">return</span> succ; <span class="comment">//返回接替者</span></span><br><span class="line">&#125;O(h)</span><br><span class="line">平均高度：catalan(n) O(n^<span class="number">0.5</span>)</span><br><span class="line">由n个节点组成的二叉树，高度不低于log2(n)</span><br><span class="line">等价BST:上下可变，左右不能乱</span><br><span class="line"></span><br><span class="line">平衡二叉搜索树（AVL树）：</span><br><span class="line">平衡因子：balFac(v)=<span class="built_in">height</span>(lc(v))-<span class="built_in">height</span>(rc(v))</span><br><span class="line">AVL树满足：任一v,|balFac(v)|&lt;=<span class="number">1</span></span><br><span class="line">高度为h的AVL树，至少包含S(h)=fib(h+<span class="number">3</span>)<span class="number">-1</span>个节点 S(h)=<span class="number">1</span>+S(h<span class="number">-1</span>)+S(h<span class="number">-2</span>)</span><br><span class="line">接口：</span><br><span class="line">#define Balanced(x)  \ (stature((x).lChild)==stature((x).rChild))  <span class="comment">//理想平衡</span></span><br><span class="line">#define BalFac(x) \ (stature((x).lChild)-stature((x).rChild)) <span class="comment">//平衡因子</span></span><br><span class="line">#define AvlBalanced(x) \ ((<span class="number">-2</span>&lt;BalFac(x))&amp;&amp;(BalFac(x)&lt;<span class="number">2</span>)) <span class="comment">//AVL平衡条件</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;class AVL :<span class="keyword">public</span> BST&lt;T&gt; &#123; <span class="comment">//由BST派生</span></span><br><span class="line"><span class="keyword">public</span>: <span class="comment">//BST::search()等接口，可直接沿用</span></span><br><span class="line">	BinNodePosi(T) insert(<span class="keyword">const</span> T&amp;); <span class="comment">//插入重写</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>; <span class="comment">//删除重写</span></span><br><span class="line">&#125;;</span><br><span class="line">插入可能引起多个祖先失衡，删除最多引起一个祖先失衡</span><br><span class="line"></span><br><span class="line">插入：</span><br><span class="line">单旋：同时可有多个失衡点，最低者g不低于x祖父，根节点朝向一致，zagzag</span><br><span class="line">	  复衡后子树高度复原，更高祖先也必平衡</span><br><span class="line">双旋：zigzag，之字形</span><br><span class="line">	  复衡后子树高度复原，更高祖先也必平衡</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;BinNodePosi(T) AVL&lt;T&gt;::insert(<span class="keyword">const</span> T&amp; e) &#123;</span><br><span class="line">	BinNodePosi(T)&amp; x = search(e); <span class="keyword">if</span> (x) <span class="keyword">return</span> x; <span class="comment">//若目标尚不存在</span></span><br><span class="line">	x = <span class="keyword">new</span> BinNode&lt;T&gt;(e, _hot); _size++; BinNodePosi(T) xx = x; <span class="comment">//则创建x</span></span><br><span class="line">	<span class="comment">//以下，从x的父亲触发逐层向上，一次检查各代祖先g</span></span><br><span class="line">	<span class="keyword">for</span> (BinNodePosi(T)g = x-&gt;parent; g; g = g-&gt;parent)</span><br><span class="line">		<span class="keyword">if</span> (!AvlBalanced(*g)) &#123; <span class="comment">//一旦发现g失衡，则通过调整恢复平衡</span></span><br><span class="line">			FromPatentTo(*g) = rotateAt(tallerChild(tallerChild(g)));</span><br><span class="line">			<span class="keyword">break</span>; <span class="comment">//g复衡后，局部子树高度必然复原；其祖先亦必如此，故调整结束</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="comment">//否则（在依然平衡的祖先处），只需简单地 </span></span><br><span class="line">			updateHeight(g); <span class="comment">//更新其高度</span></span><br><span class="line">	<span class="keyword">return</span> xx; <span class="comment">//返回新节点：至多只需一次调整</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">删除：</span><br><span class="line">单旋：同时至多一个失衡节点g，首个可能就是x的父亲_hot</span><br><span class="line">	  g经单旋调整后复衡，子树高度未必复原；更高祖先仍可能失衡</span><br><span class="line">	  因有失衡传播现象，可能需做O(logn)次调整</span><br><span class="line">双旋：相同</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="keyword">bool</span> AVL&lt;T&gt;::<span class="built_in">remove</span>(<span class="keyword">const</span> T&amp; e) &#123;</span><br><span class="line">	BinNodePosi(T)&amp; x = search(e); <span class="keyword">if</span> (!x)<span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//若目标的确存在</span></span><br><span class="line">	removeAt(x, _hot); _size--; <span class="comment">//则在按BST规则删除之后，_hot及祖先均有可能失衡</span></span><br><span class="line">	<span class="comment">//一下，从_hot出发逐层向上，一次检查各代祖先g</span></span><br><span class="line">	<span class="keyword">for</span> (BinNodePosi(T)g = _hot; g; g = g-&gt;parent) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!AvlBalanced(*g)) <span class="comment">//一旦发现g失衡，则通过调整恢复平衡</span></span><br><span class="line">			g = FormParentTo(*g) = retateAt(tallerChild(tallerChild(g)));</span><br><span class="line">		updateHeight(g); <span class="comment">//并更新其高度</span></span><br><span class="line">	&#125; <span class="comment">//可能需做过omega(logn)次调整；无论是否做过调整，全树高度均可能下降</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>+<span class="number">4</span>重构：</span><br><span class="line">设g(x)为最低的失衡节点，考察祖孙三代：g~p~v</span><br><span class="line">按中序遍历次序，将其重命名为：a&lt;b&lt;c</span><br><span class="line">它们总共有互不相交的四颗（可能为空的）子树</span><br><span class="line">按中序遍历次序，将其重命名为：T0&lt;T1&lt;T2&lt;T3</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="title">BinNodePosi</span><span class="params">(T)</span> BST&lt;T&gt;::<span class="title">connet34</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	BinNodePosi(T) a, BinNodePosi(T) b, BinNodePosi(T) c,</span></span></span><br><span class="line"><span class="function"><span class="params">	BinNodePosi(T) T0, BinNodePosi(T) T1, BinNodePosi(T) T2, BinNodePosi(T) T3, )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	a-&gt;lChild = T0; <span class="keyword">if</span> (T0)T0-&gt;parent = a;</span><br><span class="line">	a-&gt;rChild = T1; <span class="keyword">if</span> (T1)T1-&gt;parent = a; updateHeight(a);</span><br><span class="line">	c-&gt;lChild = T2; <span class="keyword">if</span> (T2)T2-&gt;parent = c; </span><br><span class="line">	c-&gt;rChild = T3; <span class="keyword">if</span> (T3)T3-&gt;parent = c; updateHeight(c);</span><br><span class="line">	b-&gt;lChild = a; a-&gt;parent = b;</span><br><span class="line">	b-&gt;rChild = c; c-&gt;parent = b; updateHeight(b);</span><br><span class="line">	<span class="keyword">return</span> b; <span class="comment">//该子树的新根节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="title">BinNodePosi</span><span class="params">(T)</span> BST&lt;T&gt;::<span class="title">rotateAt</span><span class="params">(BinNodePosi(T)v)</span> </span>&#123;</span><br><span class="line">	BinNodePosi(T) p = v-&gt;parent, g = p-&gt;parent; <span class="comment">//父亲，祖父</span></span><br><span class="line">	<span class="keyword">if</span>(IsLChild(*p)) <span class="comment">//zig</span></span><br><span class="line">		<span class="keyword">if</span> (IsRChild(*v)) &#123; <span class="comment">//zig-zag</span></span><br><span class="line">			p-&gt;parent = g-&gt;parent; <span class="comment">//向上联接</span></span><br><span class="line">			<span class="keyword">return</span> connect34(v, p, g, v-&gt;lChild, v-&gt;rChild, p-&gt;rChild, g-&gt;rChild);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123; <span class="comment">//zag-zig</span></span><br><span class="line">			v-&gt;parent = g-&gt;parent;</span><br><span class="line">			<span class="keyword">return</span> connect34(p, v, g, p-&gt;lChild, v-&gt;lChild, v-&gt;rChild, g-&gt;rChild);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;<span class="comment">/*...zagzig&amp;zigzag*/</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line">AVL树：</span><br><span class="line">无论查找、插入或删除，最坏情况下复杂度均为O(logn),O(n)的储存空间</span><br><span class="line">借助高度或平衡因子，为此需要改造元素结构，或额外封装</span><br><span class="line">实测复杂度于理论值尚有差距，插入/删除后的旋转成本不菲，删除操作后最多需旋转omega(logn)次(平均<span class="number">0.21</span>次)</span><br><span class="line">若需频繁进行插入/删除操作，得不偿失</span><br><span class="line">单次动态调整后，全树拖布结构的变化量可能高达omega(logn)</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/26/DS%E9%82%93%E4%BF%8A%E8%BE%8907/" data-id="ckd64lodq000kakvedtldhc25" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%82%93%E4%BF%8A%E8%BE%89/" rel="tag">数据结构 邓俊辉</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-DS邓俊辉-06" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/23/DS%E9%82%93%E4%BF%8A%E8%BE%89-06/" class="article-date">
  <time datetime="2020-07-23T14:40:23.000Z" itemprop="datePublished">2020-07-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/23/DS%E9%82%93%E4%BF%8A%E8%BE%89-06/">DS邓俊辉 06</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p>G=(V,E) vertex:n=|V| edge|arc:e=|E|<br>邻接(adjacency):v-v  关联(incidence):v-e<br>无向图、有向图、混合图<br>简单路径：不含重复节点  环/环路：v0=vk</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt;<span class="class"><span class="keyword">class</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			status(i) = UNDISCOVERED; dTime() = fTime() = <span class="number">-1</span>;</span><br><span class="line">			parent(i) = <span class="number">-1</span>; priority(i) = INT_MAX;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">exists</span>(i,j)status(i,j)=UNDETERMINED;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>;</span><br><span class="line">	<span class="comment">/*...顶点操作、边操作、图算法*/</span></span><br><span class="line">&#125;;</span><br><span class="line">邻接矩阵：n*n 关联矩阵：n*e</span><br><span class="line"></span><br><span class="line">顶点(vertex):</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;UNDISCOVERED, DISOVERED, VISITED&#125;VStatus;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv&gt;struct Vertex &#123; <span class="comment">//顶点对象（并未严格封装）</span></span><br><span class="line">	Tv data; <span class="keyword">int</span> inDegree, outDegree; <span class="comment">//数据、出入度数</span></span><br><span class="line">	VStatus status; <span class="comment">//（如上三种)状态</span></span><br><span class="line">	<span class="keyword">int</span> dTime, fTime; <span class="comment">//时间标签</span></span><br><span class="line">	<span class="keyword">int</span> parent; <span class="comment">//在遍历树中的父节点</span></span><br><span class="line">	<span class="keyword">int</span> priority; <span class="comment">//在遍历树中的优先级（最短通路、极短边等）</span></span><br><span class="line">	Vertex(Tv <span class="keyword">const</span>&amp; d);<span class="comment">//构造新顶点</span></span><br><span class="line">		data(d), inDegree(<span class="number">0</span>), outDegree(<span class="number">0</span>), status(UNDISCOVERED), dTime(<span class="number">-1</span>), fTime(<span class="number">-1</span>), parent(<span class="number">-1</span>), priority(INT_MAX) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">边(edge):</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123; UNDETERMINED, TREE, CROSS, FORWARD, BACKWARD &#125; EStatus;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Te&gt; struct Edge &#123; <span class="comment">//边对象（并未严格封装）</span></span><br><span class="line">	Te data; <span class="comment">//数据</span></span><br><span class="line">	<span class="keyword">int</span> weight; <span class="comment">//权重</span></span><br><span class="line">	EStatus status; <span class="comment">//类型</span></span><br><span class="line">	Edge(Te <span class="keyword">const</span>&amp; d,<span class="keyword">int</span> w): <span class="comment">//构造新边</span></span><br><span class="line">		data(d), weight(w), status(UNDETERMINED)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">GraphMatrix:</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt;class GraphMatrix :<span class="keyword">public</span> Graph&lt;Tv, Te&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Vector&lt;Vector&lt;Tv&gt;&gt;v; <span class="comment">//顶点集</span></span><br><span class="line">	Vector&lt;Vector&lt;Edge&lt;Te&gt;*&gt;&gt;E; <span class="comment">//边集</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">/*操作接口：顶点相关、边相关、...*/</span></span><br><span class="line">	GraphMartix() &#123; n = e = <span class="number">0</span>; &#125; <span class="comment">//构造</span></span><br><span class="line">	~GraphMatrix()&#123; <span class="comment">//析构</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">				<span class="keyword">delete</span> E[j][k]; <span class="comment">//清除所有动态申请的边记录</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">对于任意顶点i，枚举其所有的邻接顶点(neighbor)</span><br><span class="line"><span class="keyword">int</span> nextNbr(<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123; <span class="comment">//若已枚举至邻接j，则转向下一邻居</span></span><br><span class="line">	<span class="keyword">while</span> ((<span class="number">-1</span> &lt; j) &amp;&amp; !exist(i, --j)); <span class="comment">//逆向顺序查找，O(n)</span></span><br><span class="line">	<span class="keyword">return</span> j;</span><br><span class="line">&#125; <span class="comment">//改用邻接表可提高至O(1+outDegree(i))</span></span><br><span class="line"><span class="keyword">int</span> firstNbr(<span class="keyword">int</span> i) &#123;</span><br><span class="line">	<span class="keyword">return</span> nextNbr(i, n);</span><br><span class="line">&#125; <span class="comment">//首个邻居</span></span><br><span class="line"></span><br><span class="line">边操作：</span><br><span class="line"><span class="keyword">bool</span> <span class="built_in">exists</span>(<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123; <span class="comment">//判断边（i，j）是否存在</span></span><br><span class="line">	<span class="keyword">return</span> (<span class="number">0</span> &lt;= i) &amp;&amp; (i &lt; n) &amp;&amp; (<span class="number">0</span> &lt;= j) &amp;&amp; (j &lt; n) &amp;&amp; E[i][j] != <span class="literal">NULL</span>;</span><br><span class="line">&#125; <span class="comment">//以下假定exist(i,j)...</span></span><br><span class="line">Te&amp; edge(<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123; <span class="keyword">return</span> E[i][j]-&gt;data; &#125; <span class="comment">//边的数据</span></span><br><span class="line">Estatus&amp; status(<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;<span class="keyword">return</span> E[i][j]-&gt;status;&#125; <span class="comment">//边的状态</span></span><br><span class="line"><span class="keyword">int</span>&amp; weight(<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123; <span class="keyword">return</span> E[i][j]-&gt;weight; &#125; <span class="comment">//边的权重</span></span><br><span class="line">边插入：</span><br><span class="line"><span class="keyword">void</span> insert(Te <span class="keyword">const</span>&amp; edge, <span class="keyword">int</span> w, <span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123; <span class="comment">//插入(i,j,w)</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">exists</span>(i, j))<span class="keyword">return</span>; <span class="comment">//忽略已有的边</span></span><br><span class="line">	E[i][j] = <span class="keyword">new</span> Edge&lt;Te&gt;(edge, w); <span class="comment">//创建新边</span></span><br><span class="line">	e++; <span class="comment">//更新边计数</span></span><br><span class="line">	V[i].outDegree++; <span class="comment">//更新关联顶点i的出度</span></span><br><span class="line">	V[i].inDegree++; <span class="comment">//更新关联顶点j的入度</span></span><br><span class="line">&#125;</span><br><span class="line">边删除：</span><br><span class="line">Te <span class="built_in">remove</span>(<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">	Te eBak = edge(i, j);</span><br><span class="line">	<span class="keyword">delete</span> E[i][j]; E[i][j] = <span class="literal">NULL</span>;</span><br><span class="line">	e--;</span><br><span class="line">	V[i].outDegree--; <span class="comment">//更新关联顶点i的出度</span></span><br><span class="line">	V[i].inDegree--; <span class="comment">//更新关联顶点j的入度</span></span><br><span class="line">	<span class="keyword">return</span> eBak;</span><br><span class="line">&#125;</span><br><span class="line">插入顶点：</span><br><span class="line"><span class="keyword">int</span> insert(Tv <span class="keyword">const</span>&amp; vertex) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)E[j].insert(<span class="literal">NULL</span>); n++; <span class="comment">//每个行向量各自延长一个单位</span></span><br><span class="line">	E.insert(Vector&lt;Edge&lt;Te&gt;*&gt;(n, n, <span class="literal">NULL</span>)); <span class="comment">//生成长度为新n的行向量，初始为空，取出其地址，插入到边表中</span></span><br><span class="line">	<span class="keyword">return</span> V.insert(Vertex&lt;Tv&gt;(vertex));</span><br><span class="line">&#125;</span><br><span class="line">顶点删除：</span><br><span class="line">Tv <span class="built_in">remove</span>(<span class="keyword">int</span> i) &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">exists</span>(i, j)) &#123; <span class="keyword">delete</span> E[i][j]; V[j].inDegree--; &#125; <span class="comment">//删除所有出边</span></span><br><span class="line">	E.<span class="built_in">remove</span>(i); n--; <span class="comment">//删除第i行</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++) <span class="comment">//删除所有入边及第i列</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">exists</span>(i, j)) &#123; <span class="keyword">delete</span> E[j].<span class="built_in">remove</span>(i); V[j].outDegree--; &#125;</span><br><span class="line">	Tv vBak = vertex(i);</span><br><span class="line">	V.<span class="built_in">remove</span>(i);</span><br><span class="line">	<span class="keyword">return</span> vBak;</span><br><span class="line">&#125;</span><br><span class="line">邻接矩阵优点：直观、易于理解和实现；适用广泛：digraph/network/cyclic，尤其适用稠密图(dense graph)；</span><br><span class="line">判断两点之间是否存在联边、获取度数、添加删除边后更新度数：O(<span class="number">1</span>)；扩展性</span><br><span class="line">缺点：(n^<span class="number">2</span>)空间，与边数无关 空间利用率<span class="number">1</span>/n</span><br><span class="line"></span><br><span class="line">广度优先搜索：</span><br><span class="line">Graph::BFS()</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Tv,<span class="keyword">typename</span> Te&gt; <span class="comment">//顶点类型，边类型</span></span><br><span class="line"><span class="keyword">void</span> Graph&lt;Tv, Te&gt;::BFS(<span class="keyword">int</span> v, <span class="keyword">int</span>&amp; clock) &#123;</span><br><span class="line">	Queue&lt;<span class="keyword">int</span>&gt; Q; ststus(v) = DISCOVERED; Q.enqueue(v); <span class="comment">//初始化</span></span><br><span class="line">	<span class="keyword">while</span> (!Q.empty()) &#123; <span class="comment">//反复地</span></span><br><span class="line">		<span class="keyword">int</span> v = Q.dequeue();</span><br><span class="line">		dTIme(v) = ++clock; <span class="comment">//取出队首顶点，并</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> u = firstNbr(v)); <span class="number">-1</span> &lt; u; u = nextNbr(v, u)) <span class="comment">//考察v的每一邻居u</span></span><br><span class="line">		<span class="keyword">if</span> (UNDISCOVERED == status(u)) &#123; <span class="comment">//若u尚未被发现，则</span></span><br><span class="line">			status(u) = DISCOVERED; Q.enqueue(u); <span class="comment">//发现该顶点</span></span><br><span class="line">			status(v, u) = TREE; parent(u) = v; <span class="comment">//引入树边，从UNDETERMINED-&gt;TREE</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="comment">//若u已被发现（正在队列中），或已访问完毕（已出队列），则</span></span><br><span class="line">			status(v, u) = CROSS; <span class="comment">//将(u,v)归类于跨边</span></span><br><span class="line">		<span class="comment">/*...视u的状态，分别处理*/</span></span><br><span class="line">		status(v) = VISIFED;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;O(n+e)</span><br><span class="line">多连通：</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Tv,<span class="keyword">typename</span> Te&gt;</span><br><span class="line"><span class="keyword">void</span> Graph&lt;Tv, Te&gt;::bfs(<span class="keyword">int</span> s) &#123; <span class="comment">//s为起始顶点</span></span><br><span class="line">	reset(); <span class="keyword">int</span> clock = <span class="number">0</span>; <span class="keyword">int</span> v = s; <span class="comment">//初始化</span></span><br><span class="line">	<span class="keyword">do</span> <span class="comment">//逐一检查顶点，一旦遇到尚未发现的顶点</span></span><br><span class="line">		<span class="keyword">if</span> (UNDISCOVERED == status(v))</span><br><span class="line">			BFS(v, clock); <span class="comment">//即从该顶点出发启动一次BFS</span></span><br><span class="line">	<span class="keyword">while</span> (s != (v = (++v % n)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">深度优先算法(DFS)：</span><br><span class="line">访问顶点s，若s尚有未被访问的邻居，则任取其一u，递归执行DFS(u)，否则，返回</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Tv,<span class="keyword">typename</span> Te&gt;</span><br><span class="line"><span class="keyword">void</span> Graph&lt;Tv, Te&gt;::DFS(<span class="keyword">int</span> v, <span class="keyword">int</span>&amp; clock) &#123;</span><br><span class="line">	dTime(v) = ++clock; status(v) = DISCOVERED;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> u = firstNbr(v); <span class="number">-1</span> &lt; u; u = nextNbr(v, u))</span><br><span class="line">		<span class="keyword">switch</span> (status(u)) &#123;</span><br><span class="line">		<span class="keyword">case</span> UNDISCOVERED:</span><br><span class="line">			status(v, u) = TREE; parent(u) = v; DFS(u, clock); <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> DISCOVERED:</span><br><span class="line">			status(v, u) = BACKWARD; <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			status(v, u) = dTime(v) &lt; dTime(u) ? FORWARD : CROSS; <span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">/*...视u的状态分别处理*/</span></span><br><span class="line">		<span class="comment">/*...与BFS不同，含有递归*/</span></span><br><span class="line">	&#125;</span><br><span class="line">	status(v) = VISTIED; fTIme(v) = ++clock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/23/DS%E9%82%93%E4%BF%8A%E8%BE%89-06/" data-id="ckd64lodk0005akve2ui9ft8b" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%82%93%E4%BF%8A%E8%BE%89/" rel="tag">数据结构 邓俊辉</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-DS邓俊辉-05" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/23/DS%E9%82%93%E4%BF%8A%E8%BE%89-05/" class="article-date">
  <time datetime="2020-07-23T14:39:17.000Z" itemprop="datePublished">2020-07-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/23/DS%E9%82%93%E4%BF%8A%E8%BE%89-05/">DS邓俊辉 05</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line">树是特殊的图T=(v,E)，节点(vertex)数|v|=n,边(edge)数|E|=e，子树(subtree)</span><br><span class="line">指定任一节点r∈v作为根后，T即称作有根数(rooted tree)</span><br><span class="line">ri称作r的孩子(child)，ri之间互称兄弟(sibling)</span><br><span class="line">r为其父亲(parent)，d=degree(r)为r的度(degree)</span><br><span class="line">e=∑degree(r)=n<span class="number">-1</span></span><br><span class="line">v中的k+<span class="number">1</span>个节点通过E中的k条边依次相连，构成一条路径(path)，亦称通路</span><br><span class="line">路径长度：|π|=边数=k</span><br><span class="line">环路(cycle/loop)：vk=v0</span><br><span class="line">节点之间均有路径，称为连通图(<span class="built_in">connected</span>)，不含环路，称作无环图(acyclic)</span><br><span class="line">树：无环连通图、技校连通图、极大无环图</span><br><span class="line">节点v与根之间存在唯一路径 path(v,r)=path(v)</span><br><span class="line">不致歧义时，路径、节点和子树可相互指代 path(v)~v~subtree(v)</span><br><span class="line">v的深度：depth(v)=|path(v)|</span><br><span class="line">半线性：在任一深度，v的祖先/后代若存在，则必然/未必唯一</span><br><span class="line">根节点是所有节点的公共祖先，深度为<span class="number">0</span></span><br><span class="line">没有后代的节点称作叶子(leaf).所有叶子深度中的最大者称作(子)树(根)的高度<span class="built_in">height</span>(v)=<span class="built_in">height</span>(subtree(v))</span><br><span class="line">空树的高度为<span class="number">-1</span></span><br><span class="line">depth(v)+<span class="built_in">height</span>(v)&lt;=<span class="built_in">height</span>(T)</span><br><span class="line">长子+兄弟</span><br><span class="line">纵：firstChild() 横：nextSibling()</span><br><span class="line"></span><br><span class="line">二叉树：</span><br><span class="line">节点度数不超过<span class="number">2</span>的数称作二叉树(binary tree)</span><br><span class="line">同一节点的孩子和子树，均以左、右区分 lChild()~lSubtree() rChild()~rSubtree() 隐含有序</span><br><span class="line">深度为k的节点至多<span class="number">2</span>^k个，含n个节点、高度为h的二叉树中：h&lt;n&lt;<span class="number">2</span>^(h+<span class="number">1</span>)</span><br><span class="line">n=h+<span class="number">1</span>时，退化为一条单链，n=<span class="number">2</span>^(h+<span class="number">1</span>)<span class="number">-1</span>时，为满二叉树(full binary tree)</span><br><span class="line">真二叉树：每个节点的孩子都是偶数</span><br><span class="line">二叉树通过长子(lChild)兄弟(rChild)表述法描述有根有序的一般树</span><br><span class="line"></span><br><span class="line">二叉树节点binNode</span><br><span class="line"></span><br><span class="line">BinNode接口实现：</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;BinNodePosi(T) BinNode&lt;T&gt;::insertAsLC(T <span class="keyword">const</span>&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> lChild = <span class="keyword">new</span> BinNode(e, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> BinNode&lt;T&gt;::<span class="built_in">size</span>() &#123; <span class="comment">//后代总数，亦即以其为根的子树的规模</span></span><br><span class="line">	<span class="keyword">int</span> s = <span class="number">1</span>;  <span class="comment">//计入本身</span></span><br><span class="line">	<span class="keyword">if</span> (lChild) s += lChild-&gt;<span class="built_in">size</span>(); <span class="comment">//递归计入左子树规模</span></span><br><span class="line">	<span class="keyword">if</span> (rChild) s += rChild-&gt;<span class="built_in">size</span>(); <span class="comment">//递归计入右子树规模</span></span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BinTree模板类：</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="class"><span class="keyword">class</span> <span class="title">BinTree</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> _size; <span class="comment">//规模</span></span><br><span class="line">	BinNodePosi(T) _root; <span class="comment">//根节点</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">updateHeight</span><span class="params">(BinNodePosi(T) x)</span></span>; <span class="comment">//更新节点x的高度</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">uodateHeightAbove</span><span class="params">(BinNodePosi(T) x)</span></span>; <span class="comment">//更新x及祖先的高度</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _size; &#125; <span class="comment">//规模</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> !_root; &#125; <span class="comment">//判空</span></span><br><span class="line">	BinNodePosi(T) root() <span class="keyword">const</span> &#123; <span class="keyword">return</span> _root; &#125; <span class="comment">//树根</span></span><br><span class="line">	<span class="comment">/*...子树接入、删除和分离接口*/</span></span><br><span class="line">	<span class="comment">/*...遍历接口*/</span></span><br><span class="line">&#125;;</span><br><span class="line">高度更新：</span><br><span class="line"><span class="meta">#difine stature(p)((p)?(p)-&gt;height:-1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">//更新节点x高度</span></span><br><span class="line"><span class="keyword">int</span> BinTree&lt;T&gt;::updateHeight(BinNodePosi(T) x) &#123;</span><br><span class="line">	<span class="keyword">return</span> x-&gt;<span class="built_in">height</span> = <span class="number">1</span> + <span class="built_in">max</span>(stature(x-&gt;lChild), stature(x-&gt;rChild));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">//更新x及其历代祖先的高度</span></span><br><span class="line"><span class="keyword">void</span> BinTree&lt;T&gt;::updateHeightAbove(BinNodePosi(T) x) &#123;</span><br><span class="line">	<span class="keyword">while</span>(x)</span><br><span class="line">	&#123;</span><br><span class="line">		updateHeight(x); x = x-&gt;parent;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">节点插入：</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="title">BinNodePosi</span><span class="params">(T)</span></span></span><br><span class="line"><span class="function">BinTree&lt;T&gt;::<span class="title">insertAsRC</span><span class="params">(BInNodePosi(T) x, T <span class="keyword">const</span>&amp; e)</span> </span>&#123;</span><br><span class="line">	_size++; x-&gt;insertAsRC(e);</span><br><span class="line">	updateHeightAbove(x);</span><br><span class="line">	<span class="keyword">return</span> x-&gt;rChild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">先序遍历：</span><br><span class="line">递归：</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> VST&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(BinNodePosi(T) x,VST &amp; visit)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!x)<span class="keyword">return</span>;</span><br><span class="line">	visit(x-&gt;data);</span><br><span class="line">	traverse(x-&gt;lChild, visit);</span><br><span class="line">	traverse(x-&gt;rChild, visit);</span><br><span class="line">&#125; <span class="comment">//T(n)=O(1)+T(a)+T(n-a-1)=O(n)</span></span><br><span class="line">迭代<span class="number">1</span>：</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> VST&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travPre_I1</span><span class="params">(BinNodePosi(T) x, VST&amp; visit)</span> </span>&#123;</span><br><span class="line">	Stack&lt;BinNodePosi(T)&gt; S; <span class="comment">//辅助栈</span></span><br><span class="line">	<span class="keyword">if</span> (x) S.push(x); <span class="comment">//根节点入栈</span></span><br><span class="line">	<span class="keyword">while</span>(! S.empty())&#123; <span class="comment">//在栈变空之前反复循环</span></span><br><span class="line">		x = S.pop(); visit(x-&gt;data); <span class="comment">//弹出并访问当前节点</span></span><br><span class="line">		<span class="keyword">if</span> (HasRChild(*x))S.push(x-&gt;rChild); <span class="comment">//右孩子先入后出</span></span><br><span class="line">		<span class="keyword">if</span> (HasLChild(*x))S.push(x-&gt;lChild); <span class="comment">//左孩子后入先出</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">迭代<span class="number">2</span>：</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> VST&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">visitAlongLeftBranch</span><span class="params">(BinNodePosi(T) x, VST&amp; visit, Stack &lt;BinNodePosi(T)&gt;&amp; S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	whle(x) &#123; <span class="comment">//反复地</span></span><br><span class="line">		visit(x-&gt;data); <span class="comment">//访问当前节点</span></span><br><span class="line">		S.push(x-&gt;rChild); <span class="comment">//右孩子（右子树）入栈</span></span><br><span class="line">		x = x-&gt;lChild; <span class="comment">//沿左侧链下行</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> VST&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traPre_I2</span><span class="params">(BinNodePosi(T) x, VST&amp; visit)</span> </span>&#123;</span><br><span class="line">	Stack&lt;BinNodePosi(T)&gt;S;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">//以右子树为单位，逐批访问节点</span></span><br><span class="line">		visitAlongLeftBranch(x, visit, s); <span class="comment">//访问子树x的左侧链，右子树入栈缓冲</span></span><br><span class="line">		<span class="keyword">if</span> (S.empty())<span class="keyword">break</span>; </span><br><span class="line">		x = S.pop(); <span class="comment">//弹出下一子树的根</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">中序遍历：</span><br><span class="line">递归：</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(BinNodePosi(T) x, VST&amp; visit)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!x)<span class="keyword">return</span>;</span><br><span class="line">	traverse(x-&gt;lChild, visit);</span><br><span class="line">	visit(x-&gt;data);</span><br><span class="line">	traverse(x-&gt;rChild, visit);</span><br><span class="line">&#125;</span><br><span class="line">迭代：</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">goAlongLeftBranch</span><span class="params">(BinNodePosi(T) x, Stack&lt;BinNodePosi(T)&gt;&amp; S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (x) &#123; S.push(x); x = x-&gt;lChild; &#125; <span class="comment">//反复入栈，沿左分支深入</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> V&gt;<span class="function"><span class="keyword">void</span> <span class="title">travIn_I1</span><span class="params">(BinNodePosi(T) x, V&amp; visit)</span> </span>&#123;</span><br><span class="line">	Stack &lt;BinNodePosi(T)&gt; S;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">//反复地</span></span><br><span class="line">		goAlongLeftBranch(x, S); <span class="comment">//从当前节点出发，逐批入栈</span></span><br><span class="line">		<span class="keyword">if</span> (S.empty())<span class="keyword">break</span>; <span class="comment">//直至所有节点处理完毕</span></span><br><span class="line">		x = S.pop(); <span class="comment">//x的左子树或为空，或已遍历，故可以</span></span><br><span class="line">		visit(x-&gt;data); <span class="comment">//立即访问之</span></span><br><span class="line">		x = x-&gt;rChild; <span class="comment">//再转向其右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">层次遍历：</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">template</span>&lt;<span class="keyword">typename</span> VST&gt;</span><br><span class="line"><span class="keyword">void</span> BinNode&lt;T&gt;::travLevel(VST&amp; visit) &#123;</span><br><span class="line">	Queue&lt;BinNodePosi(T)&gt; Q; <span class="comment">//引入辅助队列</span></span><br><span class="line">	Q.enqueue(<span class="keyword">this</span>); <span class="comment">//根节点入队</span></span><br><span class="line">	<span class="keyword">while</span> (!Q.empty()) &#123; <span class="comment">//在队列再次变空之前，反复迭代</span></span><br><span class="line">		BinNodePosi(T) x = Q.dequeue(); <span class="comment">//取出队首节点，并随即</span></span><br><span class="line">		visit(x-&gt;data); <span class="comment">//访问之</span></span><br><span class="line">		<span class="keyword">if</span> (HasLChild(*x))Q.enqueue)(x-&gt;lChild); <span class="comment">//左孩子入队</span></span><br><span class="line">		<span class="keyword">if</span> (HasRChild(*x))Q.enqueue)(x-&gt;rChild); <span class="comment">//右孩子入队</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/23/DS%E9%82%93%E4%BF%8A%E8%BE%89-05/" data-id="ckd64lodj0004akvedhw0fdlg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%82%93%E4%BF%8A%E8%BE%89/" rel="tag">数据结构 邓俊辉</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-DS邓俊辉-04" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/23/DS%E9%82%93%E4%BF%8A%E8%BE%89-04/" class="article-date">
  <time datetime="2020-07-23T14:37:25.000Z" itemprop="datePublished">2020-07-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/23/DS%E9%82%93%E4%BF%8A%E8%BE%89-04/">DS邓俊辉 04</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="class"><span class="keyword">class</span> <span class="title">Stack</span> :</span><span class="keyword">public</span> Vector&lt;T&gt; &#123; <span class="comment">//由向量派生</span></span><br><span class="line"><span class="keyword">public</span>: <span class="comment">//size()、empty()以及其他开放接口均可直接沿用</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T <span class="keyword">const</span>&amp; e)</span> </span>&#123; insert(<span class="built_in">size</span>(), e); &#125; <span class="comment">//入栈</span></span><br><span class="line">	<span class="function">T <span class="title">pop</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">remove</span>(<span class="built_in">size</span>() - <span class="number">1</span>); &#125;<span class="comment">//出栈</span></span><br><span class="line">	<span class="function">T&amp; <span class="title">top</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> (*<span class="keyword">this</span>)[<span class="built_in">size</span>() - <span class="number">1</span>]; &#125; <span class="comment">//取顶</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">逆序输出(conversion)：</span><br><span class="line">输出次序与处理过程颠倒；递归深度和输出长度不易预知</span><br><span class="line">进制转换：</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convert</span><span class="params">(Stack&lt;<span class="keyword">char</span>&gt;&amp; S, __int64 n, <span class="keyword">int</span> base)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> digit[] = <span class="comment">//新进制下的数位符号</span></span><br><span class="line">	&#123; <span class="string">'0'</span>,<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>,<span class="string">'7'</span>,<span class="string">'8'</span>,<span class="string">'9'</span>,<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>,<span class="string">'F'</span> &#125;;</span><br><span class="line">	<span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123; <span class="comment">//由低到高，注意就散出新进制下的各数位</span></span><br><span class="line">		S.push(digit[n % base]); <span class="comment">//余数入栈</span></span><br><span class="line">		n /= base; <span class="comment">//n更新为对base的除商</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">括号匹配：</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">paren</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> <span class="built_in">exp</span>[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123; <span class="comment">//exp[lo,hi)</span></span><br><span class="line">	Stack&lt;<span class="keyword">char</span>&gt; S; <span class="comment">//使用栈记录一发现但尚未匹配的左括号</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt; hi; i++) </span><br><span class="line">		<span class="keyword">if</span> (<span class="string">'('</span> == <span class="built_in">exp</span>[i]) S.push(<span class="built_in">exp</span>[i]); <span class="comment">//遇左括号则进栈</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!S.empty()) S.pop(); <span class="comment">//遇右括号：非空则弹出左括号</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//否则必不匹配</span></span><br><span class="line">	<span class="keyword">return</span> S.empty(); <span class="comment">//最终，栈空当且仅当匹配</span></span><br><span class="line">&#125;</span><br><span class="line">栈混洗：</span><br><span class="line">计数：catalan(n) = (<span class="number">2</span>n)!/ (n + <span class="number">1</span>)!/n!;</span><br><span class="line">禁型：<span class="number">123</span>-&gt;<span class="number">312</span>，  是栈混洗 iff 不含禁型</span><br><span class="line">甄别算法O(n)：借助栈A,B,S模拟混洗过程。每次S.pop()之前，检测S是否已空；或需要弹出的元素在s中，却非栈顶元素</span><br><span class="line"></span><br><span class="line">延迟缓存(evalution)：线性扫描算法模式中，在预读足够长之后，方能确定可处理的前缀</span><br><span class="line">中缀表达式求值：</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">evaluate</span><span class="params">(<span class="keyword">char</span>* S, <span class="keyword">char</span>*&amp; RPN)</span> </span>&#123;</span><br><span class="line">	Stack&lt;<span class="keyword">float</span>&gt; opnd; Stack&lt;<span class="keyword">char</span>&gt; optr; <span class="comment">//运算数栈，运算符栈</span></span><br><span class="line">	optr.push('/0'); //尾哨兵'/0'也作为头哨兵首先入栈</span><br><span class="line">	<span class="keyword">while</span> (!optr.empty()) &#123; <span class="comment">//逐个处理各字符，直至运算符栈为空</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">isdigit</span>(*S)) <span class="comment">//若当前字符为操作数，则</span></span><br><span class="line">			readNumber(S, opnd); <span class="comment">//读入（可能多位的）操作数</span></span><br><span class="line">		<span class="keyword">else</span> <span class="comment">//若当前字符为运算符，则视其与栈顶运算符之间的优先级的高低</span></span><br><span class="line">			<span class="keyword">switch</span>(orderBetween(optr.top(),*S))&#123;&#125; <span class="comment">//分别处理</span></span><br><span class="line">	&#125;</span><br><span class="line">	retrun opnd.pop();</span><br><span class="line">&#125;</span><br><span class="line">![](DS04_md_files/<span class="built_in">image</span>.png?v=<span class="number">1</span>&amp;type=<span class="built_in">image</span>)</span><br><span class="line"><span class="keyword">switch</span> (orderBetween(optr.top(), *S)) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">'&lt;'</span>: <span class="comment">//栈顶运算符优先级低</span></span><br><span class="line">		optr.push(*S); S++; <span class="keyword">break</span>; <span class="comment">//计算推迟，当前运算符进栈</span></span><br><span class="line">	case'=': //优先级相等</span><br><span class="line">		optr.pop(); S++; <span class="keyword">break</span>; <span class="comment">//脱括号并接受下一个字符</span></span><br><span class="line">	case'&gt;': &#123; //栈顶运算符优先级高，实施相应的计算，结果入栈</span><br><span class="line">		<span class="keyword">char</span> op = optr.pop();</span><br><span class="line">		<span class="keyword">if</span> (<span class="string">'!'</span> == op)opnd.push(calcu((op, opnd.pop)));<span class="comment">//一元运算符</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">float</span> pOpnd2 = opnd.pop(), pOpnd1 = opnd.pop();<span class="comment">//二元运算符</span></span><br><span class="line">			opnd.push(calcu(pOpnd1, op, pOpnd2)); <span class="comment">//实施计算，结果入栈</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">逆波兰表达式(Reverse Polish Notation)：</span><br><span class="line">手工转换：用括号显式地表示优先级；将运算符移到对应右括号后；抹去所有括号；整理，既得。</span><br><span class="line">转换算法：</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">evaluate</span><span class="params">(<span class="keyword">char</span>* S, <span class="keyword">char</span>*&amp; RPN)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*..............*/</span></span><br><span class="line">	<span class="keyword">while</span> (!optr.empty()) &#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">isdigit</span>(*S)) <span class="comment">//若当前字符为操作数，则将其</span></span><br><span class="line">		&#123;</span><br><span class="line">			readNumber(S, opnd); append(RPN, opnd.top()); <span class="comment">//接入RPN</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="comment">//若当前字符为运算符</span></span><br><span class="line">			<span class="keyword">switch</span> (orderBetween(optr.top(), *S)) &#123;</span><br><span class="line">				<span class="comment">/*.................................*/</span></span><br><span class="line">				case'&gt;': //且可立即执行，则在执行相应技术的同时将其</span><br><span class="line">				&#123;<span class="keyword">char</span> op = optr.pop(); append(RPN, op);  <span class="comment">//接入RPN</span></span><br><span class="line">				<span class="comment">/*.................................*/</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">/*.................................*/</span></span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">队列：</span><br><span class="line">尾插（查询）：enqueue(), rear()</span><br><span class="line">头删（查询）：dequeue(), front()</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="class"><span class="keyword">class</span> <span class="title">Queue</span> :</span><span class="keyword">public</span> List&lt;T&gt; &#123; <span class="comment">//由队列派生的模板类</span></span><br><span class="line">	<span class="keyword">public</span>; <span class="comment">//size()与empty()直接沿用</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(T <span class="keyword">const</span>% e)</span> </span>&#123; insertAsLast(e); &#125; <span class="comment">//入队</span></span><br><span class="line">	<span class="function">T <span class="title">dequeue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">remove</span>(first()); &#125;<span class="comment">//出队</span></span><br><span class="line">	<span class="function">T&amp; <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> first()-&gt;data; &#125; <span class="comment">//队首</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/23/DS%E9%82%93%E4%BF%8A%E8%BE%89-04/" data-id="ckd64lodg0001akveczyggmjk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%82%93%E4%BF%8A%E8%BE%89/" rel="tag">数据结构 邓俊辉</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpp-notes/" rel="tag">cpp notes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/problem-library/" rel="tag">problem library</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reading-notes-DS/" rel="tag">reading notes DS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%82%93%E4%BF%8A%E8%BE%89/" rel="tag">数据结构 邓俊辉</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/cpp-notes/" style="font-size: 20px;">cpp notes</a> <a href="/tags/problem-library/" style="font-size: 13.33px;">problem library</a> <a href="/tags/reading-notes-DS/" style="font-size: 10px;">reading notes DS</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%82%93%E4%BF%8A%E8%BE%89/" style="font-size: 16.67px;">数据结构 邓俊辉</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/07/28/problem-library-%E6%A0%91-02/">problem library 树 02</a>
          </li>
        
          <li>
            <a href="/2020/07/27/DS%E9%82%93%E4%BF%8A%E8%BE%89-10/">DS邓俊辉 10</a>
          </li>
        
          <li>
            <a href="/2020/07/26/problem-library-%E6%A0%91/">problem library 树 01</a>
          </li>
        
          <li>
            <a href="/2020/07/26/problem-library-%E6%95%B0%E7%BB%84/">problem library 数组</a>
          </li>
        
          <li>
            <a href="/2020/07/26/DS%E9%82%93%E4%BF%8A%E8%BE%8909/">DS邓俊辉09</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>
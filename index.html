<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-第一章 计算机系统漫游1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/08/06/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B81/" class="article-date">
  <time datetime="2021-08-06T15:09:11.000Z" itemprop="datePublished">2021-08-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/08/06/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B81/">c++ primer 04 表达式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="第一章-计算机系统漫游"><a href="#第一章-计算机系统漫游" class="headerlink" title="第一章 计算机系统漫游"></a>第一章 计算机系统漫游</h1><h2 id="1-1-信息就是位-上下文"><a href="#1-1-信息就是位-上下文" class="headerlink" title="1.1 信息就是位+上下文"></a>1.1 信息就是位+上下文</h2><p>​        源程序实际上就是一个由值0和1组成的位（又称为比特）序列，8个位被组织成一组，称为<strong>字节</strong>。每个字节表示程序中的某些文本字符。</p>
<p>​        程序是以字节序列的方式储存在文件中的。每个字节都有一个整数值，对应于某些字符。系统中所有的信息都是由一串比特表示的。</p>
<h2 id="1-2-程序被其他程序翻译成不同的格式"><a href="#1-2-程序被其他程序翻译成不同的格式" class="headerlink" title="1.2 程序被其他程序翻译成不同的格式"></a>1.2 程序被其他程序翻译成不同的格式</h2><p>​        为了在系统上运行.c程序，每条C语句都必须被其他程序转化为一系列的低级<strong>机器语言</strong>指令。这些指令按照一种称为<strong>可执行目标程序</strong>的格式打好包，并以二进制磁盘文件的形式存放起来。目标程序也称为<strong>可执行目标文件</strong>。</p>
<p>![image-20210813235635339](/Users/xbq/Library/Application Support/typora-user-images/image-20210813235635339.png)</p>
<p>​        Unix系统上，从源文件到目标文件的转化是由<strong>编译器驱动程序</strong>完成的。GCC编译器启动程序读取.c源文件，并把它翻译成一个可执行目标文件。预处理器、编译器、汇编器和链接器一起构成了编译系统。</p>
<ul>
<li><p><strong>预处理阶段</strong>：预处理器根据以字符#开头的命令，修改原始的C程序。得到另一个C程序，通常以.i作为文件扩展名。</p>
</li>
<li><p><strong>编译阶段</strong>：编译器将文本文件*.i翻译成文本文件*.s，它包含一个汇编语言程序。该程序包含函数main的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 main:</span><br><span class="line">2		subq	$8, %rsp</span><br><span class="line">3		movl	$.LC0, %edi</span><br><span class="line">4 	call	puts</span><br><span class="line">5		movl	$0, %eax</span><br><span class="line">6		addq	$8,	%rsp</span><br><span class="line">7		ret</span><br></pre></td></tr></table></figure>

<p>定义中2～7行的每条语句都以一种文本格式描述了一条低级机器语言指令。</p>
</li>
<li><p><strong>汇编阶段</strong>：汇编器将<em>.s翻译成机器语言指令，把这些指令打包成一种叫做<strong>可重定位目标程序</strong>的格式，并将结果保存在目标文件\</em>.o中，*.o是一个二进制文件。</p>
</li>
<li><p><strong>链接阶段</strong>：链接器将如printf.o等单独的预编译好的目标文件以某种方式合并到*.o程序中，得到*文件，它是一个<strong>可执行目标文件</strong>（简称为可执行文件），可以被加载到内存中，由系统执行。</p>
</li>
</ul>
<h2 id="1-4-处理器读并解释储存在内存中的指令"><a href="#1-4-处理器读并解释储存在内存中的指令" class="headerlink" title="1.4 处理器读并解释储存在内存中的指令"></a>1.4 处理器读并解释储存在内存中的指令</h2><h3 id="1-4-1-系统的硬件组成"><a href="#1-4-1-系统的硬件组成" class="headerlink" title="1.4.1 系统的硬件组成"></a>1.4.1 系统的硬件组成</h3><p>![image-20210814144032071](/Users/xbq/Library/Application Support/typora-user-images/image-20210814144032071.png)</p>
<ol>
<li><p><strong>总线</strong>：贯穿整个系统的是一组电子管道，称作总线，携带信息字节并负责在各个部件间传递。通常总线被设计成传送定长的字节块，也就是<strong>字</strong>。字中的字节数（字长）是一个基本的系统参数，各个系统都不相同。大多4字节（32位）或8字节（64位）。</p>
</li>
<li><p><strong>I/O设备</strong>：每个I/O设备都通过一个<strong>控制器</strong>或<strong>适配器</strong>与I/O总线相连。控制器是I/O设备本身或者系统的主印制电路板（主板）上的芯片组，适配器是一块插在主板插槽上的卡。图内的I/O设备有：键盘和鼠标、显示器、磁盘驱动器。</p>
</li>
<li><p><strong>主存</strong>：主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。主存由一组<strong>动态随机存取储存器（DRAM）</strong>芯片组成，储存器是一个线性的字节数组，每个字节都有其唯一的从零开始的地址（数组索引）。</p>
</li>
<li><p><strong>处理器</strong>：<strong>中央处理单元（CPU）</strong>，简称处理器，是解释（或执行）存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或寄存器），称为<strong>程序计数器（PC）</strong>。在任何时刻，PC都指向主存中某条机器语言指令。处理器一直在不断执行程序计数器指向的指令，解释指令中的位，执行该指令指示的简单操作，再更新程序计数器，使其指向下一条指令。这些简单的操作围绕着主存、<strong>寄存器文件</strong>和<strong>算数/逻辑单元（ALU）</strong>进行。寄存器文件是一个小的存储设备，由一些单个字长的寄存器组成，每个寄存器都有唯一的名字。ALU计算新的数据和地址值。CPU在指令的要求下可能会执行：</p>
<ul>
<li>加载：从主存复制一个字节或者一个字到寄存器，以覆盖寄存器原来的内容。</li>
<li>存储：从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原来的内容。</li>
<li>操作：把两个寄存器的内容复制到ALU，ALU对这两个字做算术运算，并将结果放到一个寄存器中，以覆盖该寄存器中原来的内容。</li>
<li>跳转：从指令本身抽取一个字，并将这个字复制到程序计数器（PC）中，以覆盖PC中原来的值。</li>
</ul>
<p>指令集架构描述的是每条机器代码指令的效果，而微体系结构描述的是处理器实际上是如何实现的。</p>
</li>
</ol>
<h2 id="1-6-存储设备形成层次结构"><a href="#1-6-存储设备形成层次结构" class="headerlink" title="1.6 存储设备形成层次结构"></a>1.6 存储设备形成层次结构</h2><p>​        从上至下，设备的访问速度越来越慢，容量越来越大，并且每个字节的造价也越来越便宜。存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。![image-20210814155919575](/Users/xbq/Library/Application Support/typora-user-images/image-20210814155919575.png)</p>
<h2 id="1-7-操作系统管理硬件"><a href="#1-7-操作系统管理硬件" class="headerlink" title="1.7 操作系统管理硬件"></a>1.7 操作系统管理硬件</h2><p>​        可以把操作系统看成是应用程序和硬件之间插入的一层软件，所有应用程序对硬件的操作尝试都必须通过操作系统。操作系统两个基本的功能：（1）防止硬件被失控的应用程序滥用；（2）向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。操作系统通过几个基本的抽象概念（进程、虚拟内存和文件）来实现这两个功能。</p>
<p>![image-20210814160259441](/Users/xbq/Library/Application Support/typora-user-images/image-20210814160259441.png)</p>
<p>文件是对I/O设备的抽象表示，虚拟内存是对主存和磁盘I/O设备的抽象表示，进程是对处理器、主存和I/O设备的抽象表示。</p>
<h3 id="1-7-1-进程"><a href="#1-7-1-进程" class="headerlink" title="1.7.1 进程"></a>1.7.1 进程</h3><p>​        <strong>进程</strong>是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以同时运行多个进程，而每个进程都好像在独占地使用硬件。<strong>并发运行</strong>是说一个进程的指令和另一个进程的指令是交错执行的。一个CPU看上去像是在并发地执行多个进程，是通过处理器在进程间切换来实现，操作系统实现这种交错执行的机制称为<strong>上下文切换</strong>。</p>
<p>​        操作系统保持跟踪个进程运行所需的信息，也就是上下文。包括信息如：PC和寄存器文件的当前值、主存的内容。任何时刻单处理器系统都只能执行一个进程的代码，当操作系统决定把控制权从当前进程转移到某个新进程时，会进行<strong>上下文切换</strong>，即保存当前进程的上下文，恢复新进程的上下文，然后将控制权传递到新进程，新进程就会从它上次停止的地方开始。![image-20210814224848498](/Users/xbq/Library/Application Support/typora-user-images/image-20210814224848498.png)</p>
<p>​        从一个进程到另一个进程的转换是由操作系统<strong>内核</strong>管理的，内核是操作系统代码常驻主存的部分。当应用程序需要操作系统的某些操作时，就执行一条特殊的<strong>系统调用（system call）</strong>指令，将控制权传递给内核。内核执行被请求的操作并返回应用程序。内核不是一个独立的进程，而是系统管理全部进程所用代码和数据结构的集合。</p>
<h3 id="1-7-2-线程"><a href="#1-7-2-线程" class="headerlink" title="1.7.2 线程"></a>1.7.2 线程</h3><p>​        一个进程实际上可以由多个称为<strong>线程</strong>的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。多线程之间比多进程之间更容易共享数据，线程一般比进程更高效。</p>
<h3 id="1-7-3-虚拟内存"><a href="#1-7-3-虚拟内存" class="headerlink" title="1.7.3 虚拟内存"></a>1.7.3 虚拟内存</h3><p>​        虚拟内存是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为<strong>虚拟地址空间</strong>。Linux中，地址空间最上面的区域是保留给操作系统中的代码和数据的。底部区域存放用户进程定义的代码和数据。途中地址从下往上增大。![image-20210814231148965](/Users/xbq/Library/Application Support/typora-user-images/image-20210814231148965.png)</p>
<p>​        每个进程看到的虚拟地址空间由大量准确定义的区构成，每个区都有专门的功能。</p>
<ul>
<li><strong>程序代码和数据</strong>：对所有进程来说，代码是从同一固定地址开始，紧接着的是和C全局变量相对应的数据位置。代码和数据区是直接按照可执行目标文件的内容初始化的。</li>
<li><strong>堆</strong>：代码和数据区后紧随着的是运行时<strong>堆</strong>。代码和数据区在进程一开始运行时就被指定了大小。而当调用像malloc和free这样的C标准库函数时，堆可以在运行时动态地扩展和收缩。</li>
<li><strong>共享库</strong>：大约在地址空间的中间部分时一块用来存放像C标准库和数学库这样的共享库的代码和数据的区域。</li>
<li><strong>栈</strong>：位于用户虚拟地址空间顶部的是<strong>用户栈</strong>，编译器用它来实现函数调用。用户栈在程序执行期间也可以动态地扩展和收缩。每调用一个函数时，栈就会增长；从一个函数返回时，栈就会收缩。</li>
<li><strong>内核虚拟内存</strong>：地址空间顶部的区域是为内核保留的。不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。相反，它们必须调用内核来执行这些操作。</li>
</ul>
<p>​        虚拟内存的运作需要硬件和操作系统软件之间精密复杂的交互，包括对处理器生成的每个地址的硬件编译。基本思想是把一个进程虚拟内存的内容存储在磁盘上，然后用主存作为磁盘的高速缓存。</p>
<h3 id="1-7-4-文件"><a href="#1-7-4-文件" class="headerlink" title="1.7.4 文件"></a>1.7.4 文件</h3><p>​        <strong>文件</strong>就是字节序列。每个I/O设备都可以看成是文件。系统中的所有输入输出都是通过使用一小组称为Unix I/O的系统函数调用读写文件来实现的。文件向应用程序提供了一个统一的视图，来看待系统中可能含有的所有各式各样的I/O设备。</p>
<h2 id="1-8-系统之间利用网络通信"><a href="#1-8-系统之间利用网络通信" class="headerlink" title="1.8 系统之间利用网络通信"></a>1.8 系统之间利用网络通信</h2><p>​        从一个单独的系统来看，网络可视为一个I/O设备。当系统从主存复制一串字节到网络适配器时，数据流经过网络到达另一台机器。</p>
<h2 id="1-9-重要主题"><a href="#1-9-重要主题" class="headerlink" title="1.9 重要主题"></a>1.9 重要主题</h2><h3 id="1-9-1-Amdahl定律"><a href="#1-9-1-Amdahl定律" class="headerlink" title="1.9.1 Amdahl定律"></a>1.9.1 Amdahl定律</h3><p>​        Amdahl定律：当对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的主要性能和加速度。若系统执行某应用程序需要的时间为$T_{old}$，系统某部分所需执行时间与该时间比例为$\alpha$，该部分性能提升比例为k，因此，总的执行时间应为：<br>$$<br>T_{new}=(1-\alpha)T_{old}+({\alpha}T_{old})/k=T_{old}[(1-\alpha)+{\alpha}/k]<br>$$<br>​        由此可以计算加速比$S=T_{old}/T_{new}$​为：<br>$$<br>S=\frac{1}{(1-\alpha)+\alpha/k}<br>$$<br>​        所以，想要显著加速整个系统，必须提升全系统中相当大部分的速度。</p>
<h3 id="1-9-2-并发和并行"><a href="#1-9-2-并发和并行" class="headerlink" title="1.9.2 并发和并行"></a>1.9.2 并发和并行</h3><p>​        <strong>并发（concurrency）</strong>指一个同时具有多个活动的系统；<strong>并行（parallelism）</strong>指用并发来使一个系统运行得更快。并行可以在计算机系统的多个抽象层次上运用，由高到低顺序重点强调三个层次：</p>
<ol>
<li><p><strong>线程级并发</strong>：</p>
<p>​        在抽象的进程上设计出同时有多个程序执行的系统，就导致了并发。使用线程可以在一个进程中执行多个控制流。</p>
<p>​        对于多核处理器，每个核都有自己的L1和L2高速缓存，其中L1高速缓存分为保存最近收取到的指令和存放数据两部分。这些核共享更高层次的高速缓存和到主存的接口。</p>
<p>​        超线程，有时称为<strong>同时多线程（simulataneous multi-threading）</strong>，是一项允许一个CPU执行多个控制流的技术。常规的处理器需要大约20,000个时钟周期做不同线程间的转换，而超线程的处理器可以在单个周期的基础上决定执行哪一个线程。</p>
</li>
<li><p><strong>指令级并行</strong>：</p>
<p>​        在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为<strong>指令级并行</strong>。通过<strong>流水线（pipelining）</strong>，将执行一条指令所需要的活动划分成不同的步骤，将处理器的硬件组织成一系列的阶段，每个阶段执行一个步骤。这些阶段可以并行地操作，用来处理不同指令的不同部分。</p>
</li>
<li><p><strong>单指令、多数据并行</strong>：</p>
<p>​        在最低层次上，许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，这种方式称为<strong>单指令、多数据</strong>，即SIMD并行。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/08/06/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B81/" data-id="ckshhebl000009ovehwcbhvhc" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-primer/" rel="tag">c++ primer</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ncpp-09" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/23/ncpp-09/" class="article-date">
  <time datetime="2020-11-23T08:23:14.000Z" itemprop="datePublished">2020-11-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/23/ncpp-09/">第9章 顺序容器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一个容器就是一些特定类型对象的集合。顺序容器(sequential container)提供了控制元素存储和访问顺序的能力。这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应</p>
<h2 id="顺序容器概述"><a href="#顺序容器概述" class="headerlink" title="顺序容器概述"></a>顺序容器概述</h2><p>顺序容器类型：</p>
<p><img src="https://i.loli.net/2020/11/23/7IdV1bjxOhYGEgf.png" alt="Snipaste_2020-11-23_16-25-46.png"></p>
<h4 id="确定使用哪种容器"><a href="#确定使用哪种容器" class="headerlink" title="确定使用哪种容器"></a>确定使用哪种容器</h4><p>·除非有很好的理由选择其他容器，否则用vector<br>·有很多小的元素，且空间额外开销很重要，则不用list或forward_list<br>·要求随机访问元素，应使用vector或deque<br>·要求在容器中间插入或删除元素应使用list或forward_list<br>·需要在头尾插入或删除元素，但不会在中间位置，使用deque<br>·只有读取输入时才在中间位置插入，随后需要随机访问元素，则<br>    -首先是否真的需要在中间添加。可能是追加元素后用sort排序<br>    -如果必须在中间插入，考虑输入阶段用list，输入完成后拷贝到vector中</p>
<h2 id="容器库概览"><a href="#容器库概览" class="headerlink" title="容器库概览"></a>容器库概览</h2><p>·某些操作是所有容器类型都提供的<br>·另外一些仅针对顺序容器、关联容器或无序容器<br>·还有一些只适用于一小部分容器</p>
<p>容器操作：</p>
<p><img src="https://i.loli.net/2020/11/23/8IAawbK5RqeGsoD.png" alt="Snipaste_2020-11-23_16-32-42.png"></p>
<p><img src="https://i.loli.net/2020/11/23/DQtdY4G1qLTnhvI.png" alt="Snipaste_2020-11-23_16-33-02.png"></p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>与容器一样，迭代器有公共的接口：如果一个迭代器提供某个操作，那么所有提供相同操作的迭代器对这个操作的实现方式都是相同的</p>
<h4 id="迭代器范围"><a href="#迭代器范围" class="headerlink" title="迭代器范围"></a>迭代器范围</h4><p>一个迭代器范围(iterator range)由一对迭代器表示，两个别带器分别指向同一个容器中元素或者是尾元素之后的位置(one past the last element)<br>这种元素范围被称为左闭合区间[begin,end)</p>
<p>使用左闭合范围：<br>·如果begin与end相等，则范围为空<br>·如果begin与end不等，则范围至少包含一个元素，且begin指向该范围中的第一个元素<br>·可以对begin递增若干次，使得begin==end</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/11/23/ncpp-09/" data-id="ckshgb0yh00005gve8zp8ca4c" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/02-cpp-primer/" rel="tag">02 cpp primer</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ncpp-08" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/22/ncpp-08/" class="article-date">
  <time datetime="2020-11-22T11:45:59.000Z" itemprop="datePublished">2020-11-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/22/ncpp-08/">ncpp-08</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="IO类"><a href="#IO类" class="headerlink" title="IO类"></a>IO类</h2><p><img src="https://i.loli.net/2020/11/22/EJKHTav2k7qMi3y.png" alt="Snipaste_2020-11-22_19-56-23.png"></p>
<h3 id="IO对象无拷贝或赋值"><a href="#IO对象无拷贝或赋值" class="headerlink" title="IO对象无拷贝或赋值"></a>IO对象无拷贝或赋值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ofstream out1,out2;</span><br><span class="line">out1 = out2;    <span class="comment">//错误：不能对流对象赋值</span></span><br><span class="line"><span class="function">ofstream <span class="title">print</span><span class="params">(ofstream)</span></span>;   <span class="comment">//错误：不能初始化ofstream参数</span></span><br><span class="line">out2 = <span class="built_in">print</span>(out2);     <span class="comment">//错误：不能拷贝流对象</span></span><br></pre></td></tr></table></figure>

<p>由于不能拷贝IO对象，所以不能将形参或返回类型设置为流类型。进行IO操作的函数通常以引用方式传递和返回流。读写一个IO对象会改变其状态，所以传递和返回的引用不能是const的</p>
<h3 id="条件状态"><a href="#条件状态" class="headerlink" title="条件状态"></a>条件状态</h3><p>表中列出了IO类所定义的一些函数和标志，可以帮助我们访问和操纵流的条件状态(condition state)</p>
<p><img src="https://i.loli.net/2020/11/22/hgv7Ykz34Zy9GAw.png" alt="Snipaste_2020-11-22_20-02-06.png"></p>
<p><img src="https://i.loli.net/2020/11/22/CmcN5yThXrL9wGM.png" alt="Snipaste_2020-11-22_20-02-34.png"></p>
<h3 id="管理输出缓冲"><a href="#管理输出缓冲" class="headerlink" title="管理输出缓冲"></a>管理输出缓冲</h3><p>每个输出流都管理一个缓冲区，用来保存程序读写的数据<br>导致缓冲刷新的原因：<br>·程序正常结束，作为main函数的return操作的一部分，缓冲刷新被执行<br>·缓冲区满时，需要刷洗缓冲，而后新的数据才能继续写入缓冲区<br>·可以使用操纵符如endl来显示刷新缓冲区<br>·每个输出操作之后，可以用操纵符unitbuf设置流的内部状态，来情空缓冲区。默认情况下，对cerr是设置unitbuf的，因此写到cerr的内容是立即刷新的<br>·一个输出流可能被关联到另一个流。这种情况下当读写被关联的流时，关联到的流的缓冲区会被刷新</p>
<p>flush只刷新缓冲区；ends向缓冲区插入一个空字符，然后刷新缓冲区</p>
<p>可以使用unitbuf操纵符，它告诉流在接下来的每次写操作之后都进行一次flush操作。nounitbuf操纵符重置流，恢复正常的系统管理的缓冲区刷新机制</p>
<p>如果程序崩溃，输出缓冲区不会被刷新</p>
<h2 id="文件输入输出"><a href="#文件输入输出" class="headerlink" title="文件输入输出"></a>文件输入输出</h2><p><img src="https://i.loli.net/2020/11/22/8WNBf3IyimFY7so.png" alt="Snipaste_2020-11-22_22-09-13.png"></p>
<h3 id="使用文件流对象"><a href="#使用文件流对象" class="headerlink" title="使用文件流对象"></a>使用文件流对象</h3><p>当想要读写一个文件时，可以定义一个文件流对象，并将对象与文件关联起来。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(ifile)</span></span>; <span class="comment">//构造一个ifstream并打开给定文件</span></span><br><span class="line">ofstream out;       <span class="comment">//输出文件流未关联到任何文件</span></span><br></pre></td></tr></table></figure>

<h4 id="用fstream代替iostream-amp"><a href="#用fstream代替iostream-amp" class="headerlink" title="用fstream代替iostream&amp;"></a>用fstream代替iostream&amp;</h4><p>假定输入和输出文件的名字是通过传递给main函数的参数来指定的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">input</span><span class="params">(argv[<span class="number">1</span>])</span></span>;    <span class="comment">//打开销售记录文件</span></span><br><span class="line"><span class="function">ofstream <span class="title">output</span><span class="params">(argv[<span class="number">2</span>])</span></span>;   <span class="comment">// 打开输出文件</span></span><br><span class="line">Sales_data total;           <span class="comment">//保存销售总额的变量</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">read</span>(input,total))&#123;</span><br><span class="line">    Sales_data trans;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">read</span>(input,trans))&#123;</span><br><span class="line">        <span class="keyword">if</span>(total.isbn()==trans.isbn())</span><br><span class="line">            total.combine(trans);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">print</span>(output,total) &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            total = trans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(output,total) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">"No data?!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<h4 id="成员函数open和close"><a href="#成员函数open和close" class="headerlink" title="成员函数open和close"></a>成员函数open和close</h4><p>如果定义了一个空文件流对象，可以随后调用open来将它与文件关联起来：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(ifile)</span></span>; <span class="comment">//构筑一个ifstream并打开给定文件</span></span><br><span class="line">ofstream out;       <span class="comment">//输出文件流未与任何文件相关联</span></span><br><span class="line">out.<span class="built_in">open</span>(ifile+<span class="string">".copy"</span>);    <span class="comment">//打开指定文件</span></span><br></pre></td></tr></table></figure>

<h4 id="自动构造和析构"><a href="#自动构造和析构" class="headerlink" title="自动构造和析构"></a>自动构造和析构</h4><p>一个程序的main函数接受一个要处理的文件列表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对每个传递给程序的文件执行循环操作</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> p=argv+<span class="number">1</span>;p!=argv+argc;++p)&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">input</span><span class="params">(*p)</span></span>; <span class="comment">//创建输出流并打开文件</span></span><br><span class="line">    <span class="keyword">if</span>(input)&#123;  <span class="comment">//如果打开成功，“处理”此文件</span></span><br><span class="line">        <span class="built_in">process</span>(input);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cerr</span>&lt;&lt;<span class="string">"couldn't open"</span>+<span class="built_in">string</span>(*p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//每个循环步input都会离开作用域，因此会被销毁</span></span><br></pre></td></tr></table></figure>

<p>当一个fstream对象被销毁时，close会自动被调用</p>
<h3 id="文件模式"><a href="#文件模式" class="headerlink" title="文件模式"></a>文件模式</h3><p>每个流都有一个关联的文件模式(file mode)，用来指出如何使用文件</p>
<p><img src="https://i.loli.net/2020/11/22/QZO7XwRCJznMgfk.png" alt="Snipaste_2020-11-22_22-29-14.png"></p>
<p>调用open打开文件或用一个文件名初始化流来隐式打开文件时都可以指定文件模式。指定文件模式有如下限制：<br>·只可以对ofstream或fstream对象设定out模式<br>·只可以对ifstream或fstream对象设定in模式<br>·只有当out也被设定时才可以设定trunc模式<br>·只要trunc没被设定，就可以设定app模式。在app模式下，即使没有显示指定out模式，文件也总是以输出方式打开<br>·默认情况下，即使没有指定trunc，以out模式打开的文件也会被阶段。为了保留以out模式打开的文件的内容，必须同时指定app模式，这样只会讲数据追加写到末尾；或者同时指定in模式，即打开文件同时进行读写操作<br>·ate和binary模式可用于任何类型的文件流对象，且可以与任何其他文件模式组合使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file1都被截断</span></span><br><span class="line"><span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">"file1"</span>)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">out2</span><span class="params">(<span class="string">"file1"</span>,ofstream::out)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">out3</span><span class="params">(<span class="string">"file1"</span>,ofstream::out|ofstream::trunc)</span></span>;</span><br><span class="line"><span class="comment">//为了保留文件内容，必须显式指定app模式</span></span><br><span class="line"><span class="function">ofstream <span class="title">app</span><span class="params">(<span class="string">"file2"</span>,ofstream::app)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">app</span><span class="params">(<span class="string">"file2"</span>,ofstream::out|ofstream::app)</span></span>;</span><br></pre></td></tr></table></figure>

<p>保留被ofstream打开的文件中已有数据的唯一方法是显式指定app或in模式</p>
<h4 id="每次调用open时都会确定文件模式"><a href="#每次调用open时都会确定文件模式" class="headerlink" title="每次调用open时都会确定文件模式"></a>每次调用open时都会确定文件模式</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ofstream out;</span><br><span class="line">out.<span class="built_in">open</span>(<span class="string">"scratchpad"</span>);</span><br><span class="line">out.<span class="built_in">close</span>;</span><br><span class="line">out.<span class="built_in">open</span>(<span class="string">"precious"</span>,ofstream::app);</span><br><span class="line">out.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure>

<h2 id="string流"><a href="#string流" class="headerlink" title="string流"></a>string流</h2><p>istringstream从string读取数据，ostringstream向string写入数据，stringstream向string读写数据。<br>stringstream特有的操作</p>
<p><img src="https://i.loli.net/2020/11/23/8snZBbzmqh4HyS9.png" alt="Snipaste_2020-11-23_16-01-06.png"></p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用istringstream</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PersonInfo</span>&#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;phones;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">string</span> <span class="built_in">line</span>,<span class="keyword">word</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;PersonInfo&gt;people;</span><br><span class="line"><span class="comment">//逐行读取数据，直至cin遇到文件尾</span></span><br><span class="line"><span class="keyword">while</span>(getline(<span class="built_in">cin</span>,<span class="built_in">line</span>))&#123;</span><br><span class="line">    PersonInfo info;    <span class="comment">//创建一个保存此记录的对象</span></span><br><span class="line">    <span class="function"><span class="built_in">istringstream</span> <span class="title">record</span><span class="params">(<span class="built_in">line</span>)</span></span>;<span class="comment">//将记录保存到刚读入的行</span></span><br><span class="line">    record &gt;&gt; info.name;    <span class="comment">//读取名字</span></span><br><span class="line">    <span class="keyword">while</span>(record&gt;&gt;<span class="keyword">word</span>) <span class="comment">//读取电话号码</span></span><br><span class="line">        info.phones.push_back(<span class="keyword">word</span>);<span class="comment">//保持它们</span></span><br><span class="line">    people.push_back(info); <span class="comment">//将此记录追加到people末尾</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用ostringstream</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; entry:people)&#123;  <span class="comment">//对people中每一项</span></span><br><span class="line">    <span class="built_in">ostringstream</span> formatted,badNums;<span class="comment">//每个循环步创建的对象</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; nums:emtry.phones)&#123;<span class="comment">//对每个数</span></span><br><span class="line">        <span class="keyword">if</span>(!valid(nums))&#123;</span><br><span class="line">            badNums &lt;&lt; <span class="string">" "</span>&lt;&lt;nums;<span class="comment">//将数的字符串形式存入badNums</span></span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            <span class="comment">//将格式化的字符串“写入”formatted</span></span><br><span class="line">            formatted &lt;&lt;<span class="string">" "</span>&lt;&lt;format(nums);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(badNums.str().empty())   <span class="comment">//没有错误的数</span></span><br><span class="line">        os&lt;&lt;entry.name&lt;&lt;<span class="string">" "</span>     <span class="comment">//打印名字</span></span><br><span class="line">          &lt;&lt;formatted.str()&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//和格式化的数</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cerr</span>&lt;&lt;<span class="string">"input error:"</span>&lt;&lt;entry.name</span><br><span class="line">            &lt;&lt;<span class="string">" invalid number(s)"</span>&lt;&lt;badNums.str()</span><br><span class="line">            &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/11/22/ncpp-08/" data-id="ckhua8ros002mxsve4oex9fqd" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/02-cpp-primer/" rel="tag">02 cpp primer</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ncpp-07" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/20/ncpp-07/" class="article-date">
  <time datetime="2020-11-20T12:40:31.000Z" itemprop="datePublished">2020-11-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/20/ncpp-07/">第7章 类</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>类的基本思想是数据抽象(data abstraction)和封装(encapsulation)。数据抽象是一种依赖于接口(interface)和实现(implementation)分离的编程(以及设计)技术。<br>类的接口包括用户所能执行的操作；类的实现包括类的数据成员、负责接口实现的函数以及定义类所需的各种私有函数<br>封装实现了类的接口和实现的分离。封装后隐藏了它的实现细节。用户只能使用接口而无法访问实现部分</p>
<h2 id="定义抽象数据类型"><a href="#定义抽象数据类型" class="headerlink" title="定义抽象数据类型"></a>定义抽象数据类型</h2><h3 id="设计Sales-data类"><a href="#设计Sales-data类" class="headerlink" title="设计Sales_data类"></a>设计Sales_data类</h3><p>Sales_data的接口应包含以下操作：<br>·一个isbn成员函数，用于返回对象的ISBN号<br>·一个combine成员函数，用于将一个Sales_data对象加到另一个对象上<br>·一个名为add的函数，执行两个Sales_data对象的加法<br>·一个read函数，将数据从istream读入到Sales_data对象中<br>·一个print函数，将Sales_data对象的值输出到ostream</p>
<h3 id="定义改进的Sales-data类"><a href="#定义改进的Sales-data类" class="headerlink" title="定义改进的Sales_data类"></a>定义改进的Sales_data类</h3><p>成员函数的声明必须在类的内部，定义则既可以在类的内部也可以在类的外部。作为接口组成部分的非成员函数，定义和声明都在类的外部</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> bookNo;&#125;</span><br><span class="line">    <span class="function">Sales_data&amp; <span class="title">combine</span><span class="params">(<span class="keyword">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bookNo;</span><br><span class="line">    <span class="keyword">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//非成员接口函数</span></span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="keyword">const</span> Sales_data&amp;, <span class="keyword">const</span> Sales_dasta&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::ostream&amp; <span class="title">print</span><span class="params">(<span class="built_in">std</span>::ostream&amp;, <span class="keyword">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::istream&amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream&amp;,<span class="keyword">const</span> Sales_data&amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<p>定义在类内部的函数是隐式的inline函数</p>
<h4 id="引入this"><a href="#引入this" class="headerlink" title="引入this"></a>引入this</h4><p>对于total.isbn()，如果isbn指向Sales_data的成员，则它隐式的调用该函数对象的成员。实际上隐式地返回total.bookNo<br>成员函数通过一个名为<strong>this</strong>的额外的隐式参数来访问调用它的那个对象。编译器负责把total的地址传递给isbn的隐式形参this</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等价的认为如下形式</span></span><br><span class="line">Sales_data::isbn(&amp;total)</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以把isbn定义成：</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>-&gt;bookNo;&#125;</span><br></pre></td></tr></table></figure>

<p>this是一个常量指针，不允许改变this中保存的地址</p>
<h4 id="引入const成员函数"><a href="#引入const成员函数" class="headerlink" title="引入const成员函数"></a>引入const成员函数</h4><p>isbn函数中的const的作用是修改隐式this指针的类型<br>默认情况下，this的类型是指向类类型非常量版本的常量指针，即Sales_data* const。意味着不能把this绑定到一个常量对象上<br>把this设置为指向常量的指针有助于提高函数的灵活性<br>紧跟在参数列表后面的const表示this是一个指向常量的指针。像这样使用const的成员函数被称作常量成员函数(const member function)<br>可以把isbn的函数体想象成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码，非法的</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Sales_data::isbn</span><span class="params">(<span class="keyword">const</span> Sales_data*<span class="keyword">const</span> <span class="keyword">this</span>)</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>-&gt;isbn;&#125;</span><br></pre></td></tr></table></figure>

<p>常量对象，以及常量对象的引用或指针都只能调用常量成员函数</p>
<p>编译器首先编译成员的声明，然后才轮到成员函数体。所以成员函数体可以随意使用类中其它成员而无需在意这些成员出现的次序</p>
<h4 id="在类的外部定义成员函数"><a href="#在类的外部定义成员函数" class="headerlink" title="在类的外部定义成员函数"></a>在类的外部定义成员函数</h4><p>在类的外部定义成员函数时，定义必须与声明匹配。返回类型、参数列表和函数名都得与类内的声明保持一致。如果成员被声明为常量成员函数，定义时也必须在参数列表后明确指定const属性。类外定义的成员的名字必须包含它所属的类名</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Sales_data::avg_price</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(units_sold)</span><br><span class="line">        <span class="keyword">return</span> revenue/units_sold;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="定义一个返回this对象的函数"><a href="#定义一个返回this对象的函数" class="headerlink" title="定义一个返回this对象的函数"></a>定义一个返回this对象的函数</h4><p>调用combine函数的对象代表的是赋值运算符左侧的运算对象，右侧运算对象通过显式的实参被传入函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Sales_data&amp; <span class="title">Sales_data::combine</span><span class="params">(<span class="keyword">const</span> Sales_data&amp; rhs)</span></span>&#123;</span><br><span class="line">    units_sold += rhs.units_sold;   <span class="comment">//把rhs的成员加到this对象的成员上</span></span><br><span class="line">    revenue += rhs.revenue;</span><br><span class="line">    <span class="keyword">return</span>* <span class="keyword">this</span>;       <span class="comment">//返回调用该函数的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如：total.combine(trans)，total的地址被绑定到隐式的this参数上，rhs绑定到trans上</p>
<h3 id="定义类相关的非成员函数"><a href="#定义类相关的非成员函数" class="headerlink" title="定义类相关的非成员函数"></a>定义类相关的非成员函数</h3><p>通常把函数的声明和定义分离开来。如果函数在概念上属于类，但不定义在类中，则它一般应与类声明在同一个头文件内。这种方式下，用户使用个借口的任何部分都只需要引入一个文件</p>
<h4 id="定义read和print函数"><a href="#定义read和print函数" class="headerlink" title="定义read和print函数"></a>定义read和print函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">read</span><span class="params">(istream&amp; is,Sales_data&amp; item)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> price = <span class="number">0</span>;</span><br><span class="line">    is &gt;&gt; item.bookNo &gt;&gt;item.units_sold &gt;&gt; price;</span><br><span class="line">    item.revenue = price * item.units_sold;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ostream&amp; <span class="title">print</span><span class="params">(ostream&amp; os,<span class="keyword">const</span> Sales_data&amp; item)</span></span>&#123;</span><br><span class="line">    os &lt;&lt; item.isbn() &lt;&lt; <span class="string">" "</span> &lt;&lt; item.units_sold &lt;&lt; <span class="string">" "</span></span><br><span class="line">       &lt;&lt; item.revenue &lt;&lt; <span class="string">" "</span> &lt;&lt; item.avg_prive();</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IO类不能被拷贝，所以只能通过引用来传递。而且读取和写入会改变流的内容，所以两个函数接受的都是普通引用，而非对常量引用<br>print函数不负责换行。执行输出任务的函数应该尽量减少对格式的控制，这样可以确保由用户代码来决定是否换行</p>
<h4 id="定义add函数"><a href="#定义add函数" class="headerlink" title="定义add函数"></a>定义add函数</h4><p>接受两个Sales_data对象作为参数，返回值是一个新的Sales_data</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="keyword">const</span> Sales_data&amp; lhs,cosnt Sales_data&amp; rhs)</span></span>&#123;</span><br><span class="line">    Sales_data sum =lhs;</span><br><span class="line">    sum.combine(rhs);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>类通过一个或几个特殊的成员函数控制其对象的初始化过程，这些函数叫做构造函数(constructor)。构造函数的任务是初始化类对象的数据成员<br>构造函数的名字和类名相同，没有返回类型。可能有多个<br>构造函数不能被声明成const的<br>当类创建一个const对象时，知道构造函数完成初始化过程，对象才能真正取得其“常量”属性。因此构造函数在const对象的构造过程中可以向其写值</p>
<h4 id="合成的默认构造函数"><a href="#合成的默认构造函数" class="headerlink" title="合成的默认构造函数"></a>合成的默认构造函数</h4><p>类通过默认构造函数(default constructor)来控制默认初始化过程。默认构造函数无须任何实参<br>如果类没有显示地定义构造函数，编译器就会隐式地定义一个默认构造函数<br>编译器创建的构造函数又被称为合成的默认构造函数(synthesized default constructor)<br>合成的默认构造函数按照如下规则初始化类的数据成员：<br>·如果存在类内的初始值，用它来初始化成员<br>·否则，默认初始化该成员</p>
<p>编译器只有在发现类不包含任务构造函数的情况下才会生成一个默认构造函数<br>如果类包含内置类型或者符合类型的成员，只有在这些成员全部被赋予了类内初始值时，才适合使用默认构造函数。这些类型被默认初始化时，其值是未定义的<br>有时候编译器不能为某些类合成默认的构造函数</p>
<h4 id="定义Sales-data的构造函数"><a href="#定义Sales-data的构造函数" class="headerlink" title="定义Sales_data的构造函数"></a>定义Sales_data的构造函数</h4><p>·一个istream&amp;，从中读取一条信息<br>·一个const string&amp;，表示ISBN编号；一个unsigned，表示售出图书数量；以及一个double，表示图书价格<br>·一个const string&amp;，表示ISBN编号；编译器将赋予其它成员默认值<br>·一个空参数列表(即默认构造函数)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span>&#123;</span></span><br><span class="line">    Sales_data() = <span class="keyword">default</span>;</span><br><span class="line">    Sales_data(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s) : bookNo(s)&#123;&#125;</span><br><span class="line">    Sales_data(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s,<span class="keyword">unsigned</span> n,<span class="keyword">double</span> p) :</span><br><span class="line">               bookNo(s), units_sold(n), revenue(p*n)&#123;&#125;</span><br><span class="line">    Sales_data(istream&amp;);</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> bookNo;&#125;</span><br><span class="line">    <span class="function">Sales_data&amp; <span class="title">combine</span><span class="params">(<span class="keyword">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">avg_pirve</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="built_in">string</span> bookNo;</span><br><span class="line">    <span class="keyword">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="default-的含义"><a href="#default-的含义" class="headerlink" title="=default 的含义"></a>=default 的含义</h4><p>如果我们需要默认的行为，可以通过在参数列表后面写上=<strong>default</strong>来要求编译器生成构造函数</p>
<h4 id="构造函数初始值列表"><a href="#构造函数初始值列表" class="headerlink" title="构造函数初始值列表"></a>构造函数初始值列表</h4><p>对于：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sales_data(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s) : bookNo(s)&#123;&#125;</span><br><span class="line">Sales_data(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s,<span class="keyword">unsigned</span> n,<span class="keyword">double</span> p) :</span><br><span class="line">           bookNo(s), units_sold(n), revenue(p*n)&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>新出现的部分称为构造函数初始值列表(constructor initialize list)，说明一个类的数据成员的初始值，在构造函数体执行之前首先用初始值列表的值初始化数据成员。未经初始值列表初始化的成员将被默认初始化<br>它负责为新创建对象的一个或几个数据成员赋初值。构造函数初始值是成员名字的一个列表，每个名字后面紧跟括号括起来的(或者在花括号内的)成员初始值。不同成员的初始化通过逗号分隔开来<br>当某个数据成员被构造函数初始值列表忽略时，它将以与合成默认构造函数相同的方式隐式初始化<br>只接受一个string参数的构造函数等价于</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sales_data(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s):bookNo(s),units_sold(<span class="number">0</span>),revenue(<span class="number">0</span>)&#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在类的外部定义构造函数"><a href="#在类的外部定义构造函数" class="headerlink" title="在类的外部定义构造函数"></a>在类的外部定义构造函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sales_data::Sales_data(istream&amp; is)&#123;</span><br><span class="line">    <span class="built_in">read</span>(is,*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义时必须指明是哪个类的成员</p>
<h3 id="拷贝、赋值和析构"><a href="#拷贝、赋值和析构" class="headerlink" title="拷贝、赋值和析构"></a>拷贝、赋值和析构</h3><p>一般来说，编译器生成的版本将对对象的每个成员执行拷贝、赋值和销毁操作</p>
<h2 id="访问控制与封装"><a href="#访问控制与封装" class="headerlink" title="访问控制与封装"></a>访问控制与封装</h2><p>使用访问说明符(access specifiers)加强类的封装性：<br>·定义在public说明符之后的成员在整个程序内可被访问，public成员定义类的接口<br>·定义在private说明符之后的成员可被类的成员函数访问，但是不能被使用该类的代码访问，private部分封装了(即隐藏了)类的实现细节</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:         <span class="comment">//添加了访问说明符</span></span><br><span class="line">    Sales_data() = <span class="keyword">default</span>;</span><br><span class="line">    Sales_data(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s) : bookNo(s)&#123;&#125;</span><br><span class="line">    Sales_data(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s,<span class="keyword">unsigned</span> n,<span class="keyword">double</span> p) :</span><br><span class="line">               bookNo(s), units_sold(n), revenue(p*n)&#123;&#125;</span><br><span class="line">    Sales_data(istream&amp;);</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> bookNo;&#125;</span><br><span class="line">    <span class="function">Sales_data&amp; <span class="title">combine</span><span class="params">(<span class="keyword">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:        <span class="comment">//添加了访问说明符</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">avg_pirve</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;<span class="keyword">return</span> units_sold?revenue/units_sold : <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="built_in">string</span> bookNo;</span><br><span class="line">    <span class="keyword">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在类中访问说明符可以出现多次，其有效范围知道出现下一个访问说明符或到达类的结尾为止</p>
<h4 id="使用class或struct关键字"><a href="#使用class或struct关键字" class="headerlink" title="使用class或struct关键字"></a>使用class或struct关键字</h4><p>struct关键字第一个访问说明符的成员是public的；class的是private的</p>
<h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>通过友元可以允许其他类或者函数访问它的非公有成员，友元的访问权限与成员函数一样</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span>&#123;</span></span><br><span class="line"><span class="comment">//为Sales_data的非成员函数做的友元声明</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> Sales_data <span class="title">add</span><span class="params">(<span class="keyword">const</span> Sales_data&amp;,cosnt Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> istream&amp; <span class="title">read</span><span class="params">(istream&amp;, Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> ostream&amp; <span class="title">print</span><span class="params">(ostream&amp;, <span class="keyword">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Sales_data() = <span class="keyword">default</span>;</span><br><span class="line">    Sales_data(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s) : bookNo(s)&#123;&#125;</span><br><span class="line">    Sales_data(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s,<span class="keyword">unsigned</span> n,<span class="keyword">double</span> p) :</span><br><span class="line">               bookNo(s), units_sold(n), revenue(p*n)&#123;&#125;</span><br><span class="line">    Sales_data(istream&amp;);</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> bookNo;&#125;</span><br><span class="line">    <span class="function">Sales_data&amp; <span class="title">combine</span><span class="params">(<span class="keyword">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">avg_pirve</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;<span class="keyword">return</span> units_sold?revenue/units_sold : <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="built_in">string</span> bookNo;</span><br><span class="line">    <span class="keyword">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Sales_data接口的非成员组成部分的声明</span></span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="keyword">const</span> Sales_data&amp;,cosnt Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function">istream&amp; <span class="title">read</span><span class="params">(istream&amp;, Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function">ostream&amp; <span class="title">print</span><span class="params">(ostream&amp;, <span class="keyword">const</span> Sales_data&amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<p>友元声明只能出现再类定义的内部，但是在类内出现的具体位置不限<br>一般来说最好在类定义开始或结束前的位置集中声明友元</p>
<p>封装的益处：<br>·确保用户代码不会无意间破坏封装对象的状态<br>·被封装的类的具体试下细节可以随时改变，而无需调整用户级别的代码</p>
<p>友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果希望类的用户能够调用某个友元函数，就必须在友元声明之外专门对函数进行一次声明<br>为了使友元对类的用户可见，通常把友元的声明与类本身放置在同一个头文件中(类的外部)</p>
<h2 id="类的其他特性"><a href="#类的其他特性" class="headerlink" title="类的其他特性"></a>类的其他特性</h2><h3 id="类成员再探"><a href="#类成员再探" class="headerlink" title="类成员再探"></a>类成员再探</h3><h4 id="定义一个类型成员"><a href="#定义一个类型成员" class="headerlink" title="定义一个类型成员"></a>定义一个类型成员</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">string</span>::size_type pos;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    pos <span class="built_in">cursor</span> = <span class="number">0</span>;</span><br><span class="line">    pos <span class="built_in">height</span> = <span class="number">0</span>, <span class="built_in">width</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> contents;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>用来定义类型的成员必须先定义后使用</p>
<h4 id="Screen类的成员函数"><a href="#Screen类的成员函数" class="headerlink" title="Screen类的成员函数"></a>Screen类的成员函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> sring::size_type pos;</span><br><span class="line">    Screen() = <span class="keyword">default</span>;</span><br><span class="line">    Screen(pos ht,pos wd, <span class="keyword">char</span> c):<span class="built_in">height</span>(ht),<span class="built_in">width</span>(wd),</span><br><span class="line">           contents(ht*wd,c)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span>    <span class="comment">//读取光标处字符</span></span></span><br><span class="line"><span class="function">        </span>&#123;<span class="keyword">return</span> contents[<span class="built_in">cursor</span>];&#125;  <span class="comment">//隐式内联</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">get</span><span class="params">(pos ht,pos wd)</span><span class="keyword">const</span></span>;    <span class="comment">//显式内联</span></span><br><span class="line">    <span class="function">Screen&amp; <span class="title">move</span><span class="params">(pos r,pos c)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    pos <span class="built_in">cursor</span> = <span class="number">0</span>;</span><br><span class="line">    pos <span class="built_in">height</span> = <span class="number">0</span>, <span class="built_in">width</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> contents;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="令成员作为内联函数"><a href="#令成员作为内联函数" class="headerlink" title="令成员作为内联函数"></a>令成员作为内联函数</h4><p>定义在类内部的成员函数是自动内联的。也能在类的外部用inline关键字修饰函数的定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> Screen&amp; <span class="title">Screen::move</span><span class="params">(pos r,pos c)</span></span>&#123;</span><br><span class="line">    pos row = r*<span class="built_in">width</span>;  <span class="comment">//计算行的位置</span></span><br><span class="line">    <span class="built_in">cursor</span> = row + c;   <span class="comment">//在行内将光标移到指定的列</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;       <span class="comment">//以左值返回对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">Screen::get</span><span class="params">(pos r,pos c)</span><span class="keyword">const</span></span>&#123; <span class="comment">//在类内声明为inline</span></span><br><span class="line">    pos row = r * <span class="built_in">width</span>;    <span class="comment">//计算行的位置</span></span><br><span class="line">    <span class="keyword">return</span> contents[row+c]; <span class="comment">//返回给定列的字符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="可变数据成员"><a href="#可变数据成员" class="headerlink" title="可变数据成员"></a>可变数据成员</h4><p>一个可变数据成员(mutable data member)永远不会是const，几十它是const对象的成员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">some_member</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">size_t</span> access_ctr;</span><br><span class="line">    <span class="comment">//即使在一个const对象内也能被修改</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Screen::some_member</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    ++access_ctr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类数据成员的初始值"><a href="#类数据成员的初始值" class="headerlink" title="类数据成员的初始值"></a>类数据成员的初始值</h4><p>默认情况下，希望Window_mgr类开始时总是拥有一个默认初始化的Screen。可以把这个默认值声明成一个类内初始值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window_mgr</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;Screen&gt; screens&#123;Screen(<span class="number">24</span>,<span class="number">80</span>,<span class="string">' '</span>)&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当提供一个类内初始值时，必须以等号=或者花括号表示</p>
<h3 id="返回-this的成员函数"><a href="#返回-this的成员函数" class="headerlink" title="返回*this的成员函数"></a>返回*this的成员函数</h3><p>函数负责光标所在位置的字符或者其他任一给定位置的字符或者其他任一给定位置的字符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Screen&amp; <span class="title">set</span><span class="params">(<span class="keyword">char</span>)</span></span>;</span><br><span class="line">    <span class="function">Screen&amp; <span class="title">set</span><span class="params">(pos,pos,<span class="keyword">char</span>)</span></span>;</span><br><span class="line">    <span class="comment">//其他和之前一致</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Screen&amp; <span class="title">Screen::set</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    contents[<span class="built_in">cursor</span>]=c; <span class="comment">//设置光标所在位置的新值</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;       <span class="comment">//将this对象作为左值返回</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Screen&amp; <span class="title">Screen::set</span><span class="params">(pos r,pos col,<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">    contents[r*<span class="built_in">width</span>+col]=ch;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>set成员的返回值是调用set的对象的引用。返回引用的函数是左值的，意味着返回的是对象本身而非对象的副本</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">myScreen.<span class="built_in">move</span>(<span class="number">4</span>,<span class="number">0</span>).<span class="built_in">set</span>(<span class="string">'#'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">myScreen.<span class="built_in">move</span>(<span class="number">4</span>,<span class="number">0</span>);</span><br><span class="line">myScreen.<span class="built_in">set</span>(<span class="string">'#'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果move和set返回Screen，而非Screen&amp;</span></span><br><span class="line">Screen temp=myScreen.<span class="built_in">move</span>(<span class="number">4</span>,<span class="number">0</span>);</span><br><span class="line">temp.<span class="built_in">set</span>(<span class="string">'#'</span>);</span><br></pre></td></tr></table></figure>

<p>如果定义的返回类型不是引用，则move的返回值将是*this的副本，因此调用set只能改变临时副本，而不能改变myScreen的值</p>
<p>一个const成员函数如果以引用的形式返回*this，那么它的返回类型将是常量引用</p>
<h4 id="基于const的重载"><a href="#基于const的重载" class="headerlink" title="基于const的重载"></a>基于const的重载</h4><p>因为非常量版本的函数对于常量函数是不可用的，所以只能在一个常量对象上调用const成员函数；另一方面，虽然非常量对象可以调用常量或非常量版本，但非常量版本是一个更好的匹配</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Screen&amp; <span class="title">display</span><span class="params">(ostream&amp;os)</span></span>&#123;</span><br><span class="line">        do_display(os);<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Screen&amp; <span class="title">display</span><span class="params">(ostream&amp;os)</span><span class="keyword">const</span></span>&#123;</span><br><span class="line">        do_display(os);<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//该函数负责显示Screen内容</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do_display</span><span class="params">(ostream&amp; os)</span><span class="keyword">const</span></span>&#123;os &lt;&lt; contents;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h3><p>即使两个类的成员列表完全一致，它们也是不同的类型。对于一个类来说，它的成员和任何其他类的成员都不一样</p>
<p>可以把类名作为类型的名字使用，从而直接执行类类型，也可以跟在class或struct后面</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sales_data item1;   <span class="comment">//默认初始化Sales_data类型的对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span> <span class="title">item1</span>;</span> <span class="comment">//等价声明</span></span><br></pre></td></tr></table></figure>

<h4 id="类的声明"><a href="#类的声明" class="headerlink" title="类的声明"></a>类的声明</h4><p>可以仅声明类而暂时不定义它</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>;</span>   <span class="comment">//Screen类的声明</span></span><br></pre></td></tr></table></figure>

<p>这种声明被称作向前声明(forward declaration)，向程序中引入了名字Screen并且指明是一种类类型。对类型Screen来说，在它声明之后定义之前是一个不完全类型(incomplete type)，已知是一个类型，但不清楚成员<br>不完全类型可以指定指向这种类型的指针或引用，也可以声明以这种类型作为参数或返回类型的函数<br>类必须首先被定义后才能创建它的对象<br>一旦一个类的名字出现过后，它就认为是被声明过了，所以允许包含指向它自身类型的引用或指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Link_screen</span>&#123;</span></span><br><span class="line">    Screen window;</span><br><span class="line">    Link_screen* next;</span><br><span class="line">    Link_screen* prev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="友元再探"><a href="#友元再探" class="headerlink" title="友元再探"></a>友元再探</h3><p>类可以把其它的类定义成友元，也可以把其它类的成员函数定义成友元。友元能定义在类的内部，这样的函数是隐式内联的</p>
<h4 id="类之间的友元关系"><a href="#类之间的友元关系" class="headerlink" title="类之间的友元关系"></a>类之间的友元关系</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>&#123;</span></span><br><span class="line">    <span class="comment">//Window_mgr的成员可以访问Screen类的私有部分</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Window_mgr</span>;</span></span><br><span class="line">    <span class="comment">//Screen类剩余部分</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>友元类的成员函数可以访问此类包括非公有成员在内的所有成员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window_mgr</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//窗口中每个屏幕编号</span></span><br><span class="line">    <span class="keyword">using</span> ScreenIndex=<span class="built_in">vector</span>&lt;Screen&gt;::size_type;</span><br><span class="line">    <span class="comment">//按照编号将屏幕重置为空白</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(ScreenIndex)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;Screen&gt; screens&#123;Scree(<span class="number">24</span>,<span class="number">80</span>,<span class="string">' '</span>)&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Window_mgr::clear</span><span class="params">(ScreenIndex i)</span></span>&#123;</span><br><span class="line">    <span class="comment">//s是一个Screen的引用，指向想清空的屏幕</span></span><br><span class="line">    Screen &amp;s = screens[i];</span><br><span class="line">    <span class="comment">//将选定的Screen重置为空白</span></span><br><span class="line">    s.contents = <span class="built_in">string</span>(s.<span class="built_in">height</span>*s.<span class="built_in">width</span>,<span class="string">' '</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>友元关系不存在传递性。即Window_mgr的友元不能具有访问Screen的特权</p>
<h4 id="令成员函数作为友元"><a href="#令成员函数作为友元" class="headerlink" title="令成员函数作为友元"></a>令成员函数作为友元</h4><p>当把一个成员函数声明成友元时，必须明确指出属于哪个类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>&#123;</span></span><br><span class="line">    <span class="comment">//clear必须在Screen类之前被声明</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">Window_mgr::clear</span><span class="params">(ScreenIndex)</span></span>;</span><br><span class="line">    <span class="comment">//剩余部分</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>想要令某个成员函数作为友元：<br>·首先定义WIndow_mgr类，其中声明clear函数，但不能定义它。在clear使用Screen的成员之前必须先声明Screen<br>·接下来定义Screen，包括对clear的友元声明<br>·最后定义clear，此时它才可以使用Screen的成员</p>
<h4 id="函数重载和友元"><a href="#函数重载和友元" class="headerlink" title="函数重载和友元"></a>函数重载和友元</h4><p>如果一个类想把一组重载函数声明成它的友元，需要对每一个分别声明</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> ostream&amp; <span class="title">storeOn</span><span class="params">(ostream&amp;, Screen&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> BitMap&amp; <span class="title">storeOn</span><span class="params">(BitMap&amp;, Screen&amp;)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>&#123;</span></span><br><span class="line">    <span class="comment">//storeOn的ostream版本能访问Screen的私有部分</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> ostream&amp; <span class="title">storeOn</span><span class="params">(ostream&amp;, Screen&amp;)</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="友元声明和作用域"><a href="#友元声明和作用域" class="headerlink" title="友元声明和作用域"></a>友元声明和作用域</h4><p>类和非成员函数的声明不是必须在它们的友元之前。当一个名字第一次出现在一个友元声明中时，隐式地假定该名字在当前作用域中是可见的。然而友元本身不一定真的声明在当前作用域中<br>即使在类的内部定义该函数，也必须在类的外部提供相应的声明从而使该函数可见</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    X() &#123; f(); &#125;    <span class="comment">//错误：f还没有被声明</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">X::g</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> f();&#125;  <span class="comment">//错误：f还没有被声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;                   <span class="comment">//声明定义在X中的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">X::h</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> f();&#125;  <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>

<h2 id="类的作用域"><a href="#类的作用域" class="headerlink" title="类的作用域"></a>类的作用域</h2><p>在类的作用域之外，普通的数据和函数成员只能由对象、引用或指针使用成员访问运算符来访问。对于类类型成员则使用作用域运算符访问</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Screen::pos ht=<span class="number">24</span>,wd=<span class="number">80</span>;    <span class="comment">//使用Screen定义的pos类型</span></span><br><span class="line"><span class="function">Scrren <span class="title">scr</span><span class="params">(ht,wd,<span class="string">' '</span>)</span></span>;</span><br><span class="line">Screen* p=&amp;scr;</span><br><span class="line"><span class="keyword">char</span> c=scr.<span class="built_in">get</span>();   <span class="comment">//访问scr对象的get成员</span></span><br><span class="line">c=p-&gt;<span class="built_in">get</span>();         <span class="comment">//访问p所指对象的get成员</span></span><br></pre></td></tr></table></figure>

<h4 id="作用域和定义在类外部的成员"><a href="#作用域和定义在类外部的成员" class="headerlink" title="作用域和定义在类外部的成员"></a>作用域和定义在类外部的成员</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window_mgr</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//向窗口添加一个Screen，返回它的编号</span></span><br><span class="line">    <span class="function">ScreenIndex <span class="title">addScreen</span><span class="params">(<span class="keyword">const</span> Screen&amp;)</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//首先处理返回类型，之后才能进入Window_mgr的作用域</span></span><br><span class="line">Window_mgr::ScreenIndex</span><br><span class="line">Window_mgr::addScreen(<span class="keyword">const</span> Screen&amp;s)&#123;</span><br><span class="line">    screens.push_back(s);</span><br><span class="line">    <span class="keyword">return</span> screens.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回类型出现在类名之前，所以事实上它是位于Window_mgr类的作用域之外的。所以需要明确指定哪个类定义了它</p>
<h3 id="名字查找与类的作用域"><a href="#名字查找与类的作用域" class="headerlink" title="名字查找与类的作用域"></a>名字查找与类的作用域</h3><p>编译器处理完类中的全部声明才会处理成员函数的定义</p>
<h4 id="用于类声明的名字查找"><a href="#用于类声明的名字查找" class="headerlink" title="用于类声明的名字查找"></a>用于类声明的名字查找</h4><p>声明中使用的名字，包括返回类型或者参数列表中使用的名字，都必须确保使用前可见。如果某个成员的声明使用了类中尚未出现的名字，则编译器会在定义该类的作用域中继续查找</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> Money;</span><br><span class="line"><span class="built_in">string</span> bal;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Money <span class="title">balance</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> bal;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Money bal;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于balance函数的声明，编译器只考虑Account中在使用Money钱出现的声明，没有找到匹配的成员，编译器接着到Account的外层作用域中去找。<br>该例子中编译器会找到typedef语句，该类型被用作balance的返回累心高一级数据成员bal的类型。函数体在整个类可见后才会被处理，所以return语句返回名为bal的成员，而非外层的string对象</p>
<h4 id="类型名要特殊处理"><a href="#类型名要特殊处理" class="headerlink" title="类型名要特殊处理"></a>类型名要特殊处理</h4><p>内层作用域可以重新定义外层作用域的名字，即使该名字已经在内层作用域使用过。然而在类中，如果成员使用了外层作用域中的某个名字，而该名字代表一种类型，则类不能在之后重新定义该名字</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> Money;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//使用外层作用域的Money</span></span><br><span class="line">    <span class="function">Money <span class="title">balance</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> bal;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//错误：不能重新定义Money</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">double</span> Money;</span><br><span class="line">    Money bal;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>即使Account中定义的Money类型与外层作用域一致，仍然是错误的</p>
<h4 id="成员定义中的普通快作用域的名字查找"><a href="#成员定义中的普通快作用域的名字查找" class="headerlink" title="成员定义中的普通快作用域的名字查找"></a>成员定义中的普通快作用域的名字查找</h4><p>成员函数中使用的名字按照以下方式解析：<br>·在成员函数内查找该名字的声明。只有在函数使用之前出现的声明才被考虑<br>·再类内继续查找，类的所有成员都可以被考虑<br>·如果类内也没有，在成员函数定义之前的作用域内继续查找</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//仅为说明，不提倡</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">string</span>::size_type pos;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dummy_fcn</span><span class="params">(pos <span class="built_in">height</span>)</span></span>&#123;</span><br><span class="line">        <span class="built_in">cursor</span> = <span class="built_in">width</span>*<span class="built_in">height</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    pos <span class="built_in">cursor</span>=<span class="number">0</span>;</span><br><span class="line">    pos <span class="built_in">height</span>=<span class="number">0</span>,<span class="built_in">width</span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于height，首先在函数作用域内查找表达式中用到的名字。函数的参数位于函数作用域内，因此dummy_fcn函数体内用到的名字height指的是参数声明<br>此例中height参数隐藏了同名的成员。如果想绕开上面的查找规则：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Screen::dummy_fcn</span><span class="params">(pos <span class="built_in">height</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cursor</span>=<span class="built_in">width</span>*<span class="keyword">this</span>-&gt;<span class="built_in">height</span>;  <span class="comment">//成员height</span></span><br><span class="line">    <span class="comment">//另一种方式</span></span><br><span class="line">    <span class="built_in">cursor</span>=<span class="built_in">width</span>*Screen::<span class="built_in">height</span>;<span class="comment">//成员height</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最好的方式是给参数起个其它名字</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Screen::dummy_fcn</span><span class="params">(pos ht)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cursor</span> = <span class="built_in">width</span> * <span class="built_in">height</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用外层作用域的height</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Screen::dummy_fcn</span><span class="params">(pos <span class="built_in">height</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cursor</span>=<span class="built_in">width</span> * ::<span class="built_in">height</span>;</span><br></pre></td></tr></table></figure>

<h2 id="构造函数再探"><a href="#构造函数再探" class="headerlink" title="构造函数再探"></a>构造函数再探</h2><h3 id="构造函数初始值列表-1"><a href="#构造函数初始值列表-1" class="headerlink" title="构造函数初始值列表"></a>构造函数初始值列表</h3><p>如果没有在构造函数的初始值列表中显式地初始化成员，则该成员在构造函数体之前执行默认初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Sales_data::Sales_data(<span class="keyword">const</span> <span class="built_in">string</span>&amp;s,</span><br><span class="line">                        <span class="keyword">unsigned</span> cnt,<span class="keyword">double</span> price)&#123;</span><br><span class="line">    bookNo = s;</span><br><span class="line">    units_sold = cnt;</span><br><span class="line">    revenue = cnt * price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段和使用初始化列表的效果是相同的：当构造函数完成后，数据成员的值相同。区别是初始化列表版本初始化了它的数据成员，这个版本是对数据成员执行了赋值操作</p>
<h4 id="构造函数的初始值有时必不可少"><a href="#构造函数的初始值有时必不可少" class="headerlink" title="构造函数的初始值有时必不可少"></a>构造函数的初始值有时必不可少</h4><p>如果成员是const或者是引用的话，必须将其初始化。当成员属于某种类类型且该类没有定义默认构造函数时，也必须将这个成员初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConstRef</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ConstRef(<span class="keyword">int</span> i);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> ci;</span><br><span class="line">    <span class="keyword">int</span> &amp;ri;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//和其它常量对象或引用一样，ci和ri都必须被初始化</span></span><br><span class="line"><span class="comment">//因此，将引发错误</span></span><br><span class="line">ConstRef::ConstRef(<span class="keyword">int</span> ii)&#123;</span><br><span class="line">    i = ii;     <span class="comment">//正确</span></span><br><span class="line">    ci = ii;    <span class="comment">//错误：不能给const赋值</span></span><br><span class="line">    ri = ii;    <span class="comment">//错误：ri没被初始化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正确的形式应该是</span></span><br><span class="line">ConstRef::ConstRef(<span class="keyword">int</span> ii):i(ii),ci(ii),ri(ii)&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>如果成员是const、引用，或属于某种未提供默认构造函数的类类型，必须通过构造函数初始值列表为这些成员提供初始值</p>
<h4 id="成员初始化的顺序"><a href="#成员初始化的顺序" class="headerlink" title="成员初始化的顺序"></a>成员初始化的顺序</h4><p>成员初始化顺序与它们在类定义的中出现的顺序一致。构造函数初始值列表中初始值的前后位置不会影响实际的初始化顺序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//未定义的：i在j前被初始化</span></span><br><span class="line">    X(<span class="keyword">int</span> val):j(val),i(j)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="默认实参和构造函数"><a href="#默认实参和构造函数" class="headerlink" title="默认实参和构造函数"></a>默认实参和构造函数</h4><p>一个使用默认实参的构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Sales_data(<span class="built_in">string</span> s=<span class="string">" "</span>):bookNo(s)&#123;&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h3><p>委托构造函数(delegating constructor)使用它所属的类的其他构造函数执行它自己的初始化过程，或者说它把它自己的一些(或全部)职责委托给了其他构造函数<br>一个委托构造函数也有一个成员初始值的列表和一个函数体。在委托构造函数内，成员初始值列表只有唯一一个入口，就是类名本身。类名后面紧跟圆括号括起来的参数列表，参数列表必须与类中另外一个构造函数匹配</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//非维多构造函数使用对应的实参初始化成员</span></span><br><span class="line">    Sales_data(<span class="built_in">string</span> s, <span class="keyword">unsigned</span> cnt,<span class="keyword">double</span> price):</span><br><span class="line">        bookNo(s),units_sold(cnt),revenue(cnt*price)&#123;&#125;</span><br><span class="line">    <span class="comment">//其余构造函数全部委托给另一个构造函数</span></span><br><span class="line">    Sales_data():Sales_data(<span class="string">" "</span>,<span class="number">0</span>,<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    Sales_data(<span class="built_in">string</span> s):Sales_data(s,<span class="number">0</span>,<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    Sales_data(istream&amp; is):Sales_data()&#123;<span class="built_in">read</span>(is,*<span class="keyword">this</span>);&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="默认构造函数的作用"><a href="#默认构造函数的作用" class="headerlink" title="默认构造函数的作用"></a>默认构造函数的作用</h3><p>当对象被默认初始化或值初始化时自动执行默认构造函数。默认初始化在以下情况发生：<br>·在块作用域内不适用任何初始值定义一个非静态变量或者数组时<br>·当一个类本身含有类类型的成员且使用合成的默认构造函数时<br>·当类类型的成员没有在构造函数初始值列表中显示地初始化时<br>值初始化在以下情况发生：<br>·在数组初始化的过程中如果提供的初始值数量少于数组的大小时<br>·当我们不使用初始值定义一个局部静态变量时<br>·当通过书写形如T()的表达式显示地请求值初始化时，其中T是类型名</p>
<p>类必须包含一个默认构造函数以便在上述情况下使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoDefault</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NoDefault(<span class="keyword">const</span> <span class="built_in">string</span>&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    NoDefault my_mem;</span><br><span class="line">&#125;;</span><br><span class="line">A a;    <span class="comment">//错误：不能为A合成构造函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>&#123;</span></span><br><span class="line">    B()&#123;&#125;   <span class="comment">//错误：b_member没有初始值</span></span><br><span class="line">    NoDefault b_member;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="使用默认构造函数"><a href="#使用默认构造函数" class="headerlink" title="使用默认构造函数"></a>使用默认构造函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Sales_data <span class="title">obj</span><span class="params">()</span></span>;   <span class="comment">//声明了一个函数而非对象</span></span><br><span class="line">Sales_data obj2;    <span class="comment">//obj2是一个对象而非函数</span></span><br></pre></td></tr></table></figure>

<p>如果想定义一个使用默认构造函数进行初始化的对象，需要去掉对象名后的空括号对</p>
<h3 id="隐式的类类型转换"><a href="#隐式的类类型转换" class="headerlink" title="隐式的类类型转换"></a>隐式的类类型转换</h3><p>如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制，把这种构造函数称作转换构造函数(converting constructor)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> null_book=<span class="string">"999-9"</span>;</span><br><span class="line"><span class="comment">//构造一个临时的Sales_data对象</span></span><br><span class="line"><span class="comment">//units_sold和revenue等于0，bookNo等于null_book</span></span><br><span class="line">item.combine(null_book);</span><br></pre></td></tr></table></figure>

<h4 id="只允许一步类类型转换"><a href="#只允许一步类类型转换" class="headerlink" title="只允许一步类类型转换"></a>只允许一步类类型转换</h4><p>编译器只会自动地执行一步类型转换。下面代码隐式地使用了两种转换规则，所以是错误的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//"999-9"-&gt;string-&gt;Sales_data</span></span><br><span class="line">item.combine(<span class="string">"999-9"</span>);</span><br><span class="line"></span><br><span class="line">item.combine(<span class="built_in">string</span>(<span class="string">"999-9"</span>));      <span class="comment">//正确</span></span><br><span class="line">item.combine(Sales_data(<span class="string">"999-9"</span>));  <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>

<h4 id="抑制构造函数的隐式转换"><a href="#抑制构造函数的隐式转换" class="headerlink" title="抑制构造函数的隐式转换"></a>抑制构造函数的隐式转换</h4><p>可以通过将构造函数声明为explicit加以阻止</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Sales_data()=<span class="keyword">default</span>;</span><br><span class="line">    Sales_data(<span class="keyword">const</span> <span class="built_in">string</span>&amp;s,<span class="keyword">unsigned</span> n,<span class="keyword">double</span> p):</span><br><span class="line">            bookNo(s),units_sold(n),revenue(p*n)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Sales_data</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)</span>:<span class="title">bookNo</span><span class="params">(s)</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Sales_data</span><span class="params">(istream&amp;)</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此时，没有任何构造函数能用于隐式地创建Sales_data对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">item.combine(null_book);</span><br><span class="line">item.combine(<span class="built_in">cin</span>);  <span class="comment">//错误：构造函数都是explicit的</span></span><br></pre></td></tr></table></figure>

<p>explicit只对一个实参的构造函数游戏。只能在类内声明构造函数时使用explicit，在类外定义时不应重复</p>
<h4 id="explicit构造函数只能用于直接初始化"><a href="#explicit构造函数只能用于直接初始化" class="headerlink" title="explicit构造函数只能用于直接初始化"></a>explicit构造函数只能用于直接初始化</h4><p>发生隐式转换的一种情况是执行拷贝形式的初始化(使用=)。此时只能使用直接初始化而不能使用explicit构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Sales_data <span class="title">item1</span><span class="params">(null_book)</span></span>;<span class="comment">//正确：直接初始化</span></span><br><span class="line"><span class="comment">//错误：不能将explicit构造函数用于拷贝形式的初始化过程</span></span><br><span class="line">Sales_data item2=null_book;</span><br></pre></td></tr></table></figure>

<h4 id="为转换显示地使用构造函数"><a href="#为转换显示地使用构造函数" class="headerlink" title="为转换显示地使用构造函数"></a>为转换显示地使用构造函数</h4><p>可以使用explicit构造函数显示地强制进行转换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">item.combine(Sales_data(null_book));</span><br><span class="line">item.combine(<span class="keyword">static_cast</span>&lt;Sales_data&gt;(<span class="built_in">cin</span>));</span><br></pre></td></tr></table></figure>

<h4 id="标准库中含有显示构造函数的类"><a href="#标准库中含有显示构造函数的类" class="headerlink" title="标准库中含有显示构造函数的类"></a>标准库中含有显示构造函数的类</h4><p>接受一个单参数的const char*的string构造函数，不是explicit的<br>接受一个容量参数的vector构造函数，是explicit的</p>
<h3 id="聚合类"><a href="#聚合类" class="headerlink" title="聚合类"></a>聚合类</h3><p>聚合类(aggregate class)使得用户可以直接访问其成员，并且具有特殊的初始化语法形式<br>当一个类满足如下条件时，说它是聚合的：<br>·所有成员都是public的<br>·没有定义任何构造函数<br>·没有类内初始值<br>·没有基类，没有virtual函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ival;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以通过一个花括号括起来的成员初始值列表来初始化</span></span><br><span class="line">Data val1=&#123;<span class="number">0</span>,<span class="string">"Anna"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序必须一致</span></span><br><span class="line">Data val2=&#123;<span class="string">"Anna"</span>, <span class="number">1024</span>&#125;;   <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<p>显示地初始化类的对象成员存在的缺点：<br>·要求类的所有成员都是public的<br>·将正确初始化每个对象的每个成员的重任交给了类的用户。初始化过程冗长且容易出错<br>·添加或删除一个成员后，所有的初始化语句都需要更新</p>
<h3 id="字面值常量类"><a href="#字面值常量类" class="headerlink" title="字面值常量类"></a>字面值常量类</h3><p>数据成员都是字面值类型的聚合类是字面值常量类。如果一个类不是聚合类，但符合以下要求，则也是字面值常量类：<br>·数据成员都必须是字面值类型<br>·类必须至少含有一个constexpr构造函数<br>·如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，则初始值必须使用成员自己的constexpr构造函数<br>·类必须使用析构函数的默认定义，该成员负责销毁类的对象</p>
<h4 id="constexpr构造函数"><a href="#constexpr构造函数" class="headerlink" title="constexpr构造函数"></a>constexpr构造函数</h4><p>尽管构造函数不能是const的，但字面值常量类的构造函数可以是constexpr函数。constexpr构造函数可以声明成=default形式，或者是删除函数的形式。constexpr构造函数体应该是空的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Debug</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">Debug</span><span class="params">(<span class="keyword">bool</span> b=<span class="literal">true</span>)</span>:</span></span><br><span class="line">        hw(b),io(b),other(b)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">Debug</span><span class="params">(<span class="keyword">bool</span> h,<span class="keyword">bool</span> i,<span class="keyword">bool</span> o)</span>:</span></span><br><span class="line">        hw(h),io(i),other(o)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="title">any</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> hw||io||other;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_io</span><span class="params">(<span class="keyword">bool</span> b)</span></span>&#123;io=b;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_hw</span><span class="params">(<span class="keyword">bool</span> b)</span></span>&#123;hw=b;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_other</span><span class="params">(<span class="keyword">bool</span> b)</span></span>&#123;other=b;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> hw;</span><br><span class="line">    <span class="keyword">bool</span> io;</span><br><span class="line">    <span class="keyword">bool</span> other;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>constexpr构造函数必须初始化所有数据成员，初始值或者使用constexpr构造函数，或者是一条常量表达式</p>
<h2 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h2><h4 id="声明静态成员"><a href="#声明静态成员" class="headerlink" title="声明静态成员"></a>声明静态成员</h4><p>通过在成员的声明之前加上static使得其与类关联在一起</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">calculate</span><span class="params">()</span></span>&#123;amount+=amount*interestRate;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">rate</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> interestRate;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rate</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> owner;</span><br><span class="line">    <span class="keyword">double</span> amount;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> interestRate;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">initRate</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>类的静态成员存在于任何对象之外，对象中不包含任何与静态成员有关的数据。interestRate对象被所有Account对象共享<br>静态成员函数也不与任何对象绑定在一起，它们不包含this指针，静态成员函数不能声明成const的</p>
<h4 id="使用类的静态成员"><a href="#使用类的静态成员" class="headerlink" title="使用类的静态成员"></a>使用类的静态成员</h4><p>使用作用域运算符直接访问静态成员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> r;</span><br><span class="line">r=Account::rate();</span><br></pre></td></tr></table></figure>

<p>也可以使用类的对象、引用或指针来访问静态成员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Account ac1;</span><br><span class="line">Account* ac2=&amp;ac1;</span><br><span class="line"><span class="comment">//等价形式</span></span><br><span class="line">r=ac1.rate();</span><br><span class="line">r=ac2-&gt;rate();</span><br></pre></td></tr></table></figure>

<p>成员函数不用通过作用域运算符就能直接访问静态成员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">calulate</span><span class="params">()</span></span>&#123;amount+=amount*interestRate;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> interestRate;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="定义静态成员"><a href="#定义静态成员" class="headerlink" title="定义静态成员"></a>定义静态成员</h4><p>可以在类的内外定义静态成员函数。在类外时，不能重复static关键字。该关键字只出现在类内的声明语句</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Account::rate</span><span class="params">(<span class="keyword">double</span> newRate)</span></span>&#123;</span><br><span class="line">    interestRate=newRate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态数据成员不属于类的任何一个对象，所有他们并不是在创建类的对象时被定义的。意味着它们不是由类的构造函数初始化的。必须在类的外部定义和初始化每个静态成员<br>类似于全局变量，静态数据成员定义在任何函数之外。一旦被定义，就将一直存在于程序的整个生命周期中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义并初始化一个静态成员</span></span><br><span class="line"><span class="keyword">double</span> Account::interestRate=initRate();</span><br></pre></td></tr></table></figure>

<h4 id="静态成员的类内初始化"><a href="#静态成员的类内初始化" class="headerlink" title="静态成员的类内初始化"></a>静态成员的类内初始化</h4><p>通常情况下，类的静态成员不应该在类内初始化。但可以为静态成员提供const整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的constexpr。初始值必须是常量表达式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">rate</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> interestRate;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rate</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> period = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">double</span> daily_tbl[period];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>即使一个静态常量数据成员在类内被初始化了，通常情况下也应该在类外定义一下该成员</p>
<h4 id="静态成员能用于某些场景，而普通成员不能"><a href="#静态成员能用于某些场景，而普通成员不能" class="headerlink" title="静态成员能用于某些场景，而普通成员不能"></a>静态成员能用于某些场景，而普通成员不能</h4><p>静态数据成员可以是不完全类型。静态数据成员的类型可以就是它所属的类型，而费静态数据成员则受到限制，只能声明成它所属类的指针或引用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Bar mem1;    <span class="comment">//正确：静态成员可以是不完全类型</span></span><br><span class="line">    Bar* mem2;  <span class="comment">//正确：指针成员可以是不完全类型</span></span><br><span class="line">    Bar mem3;   <span class="comment">//错误：数据成员必须是完全类型</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>

<p>静态成员可以作为默认实参</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//bkground表示一个在类中稍后定义的静态成员</span></span><br><span class="line">    <span class="function">Screen&amp; <span class="title">clear</span><span class="params">(<span class="keyword">char</span> = bkground)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> bkground;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>非静态成员不能作为默认实参，因为它的值本身属于对象的一部分，这么做的结果是无法真正提供一个对象以便从中获取成员的值，最终将引发错误</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/11/20/ncpp-07/" data-id="ckhua8row002yxsve6wyu2mjt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/02-cpp-primer/" rel="tag">02 cpp primer</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ncpp-06" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/19/ncpp-06/" class="article-date">
  <time datetime="2020-11-19T05:08:47.000Z" itemprop="datePublished">2020-11-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/19/ncpp-06/">第6章 函数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>函数是一个命名了的代码块，通过调用函数执行相应的代码</p>
<h2 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h2><p>一个典型的函数(function)定义包括：返回类型(return type)、函数名字、由0个或多个形参(parameter)组成的列表以及函数体<br>通过调用运算符(call operator，())来执行函数<br>它作用于一个表达式，该表达式是函数或者指向函数的指针；圆括号内是实参(argument)列表，用实参初始化函数的形参。调用表达式的类型就是函数的返回类型</p>
<h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><p>函数的调用完成两项工作：用实参初始化函数对应的形参；将控制权转移给被调用的函数。此时主调函数(calling function)的执行被暂时中断，被调函数(called function)开始执行<br>return语句结束函数执行过程。返回return语句中的值(如果有)；将控制权从被调函数转移回主调函数</p>
<h4 id="形参和实参"><a href="#形参和实参" class="headerlink" title="形参和实参"></a>形参和实参</h4><p>实参是形参的初始值。没有规定实参的求值顺序，编译器能以任意可行的顺序对实参求值。形参一定会被初始化<br>函数的形参列表可以为空但不能省略</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;&#125;     <span class="comment">//隐式地定义空形参列表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;&#125; <span class="comment">//显式地定义空形参列表</span></span><br></pre></td></tr></table></figure>

<p>形参列表中的形参通常用逗号隔开，每个形参都是含有一个声明符的声明</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f3</span><span class="params">(<span class="keyword">int</span> v1,v2)</span></span>&#123;&#125;;    <span class="comment">//错误</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f4</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span></span>&#123;&#125;; <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>

<p>任意两个形参都不能同名，函数最外层作用域中的局部变量也不能使用与函数形参一样的名字</p>
<h4 id="函数返回值类型"><a href="#函数返回值类型" class="headerlink" title="函数返回值类型"></a>函数返回值类型</h4><p>void返回类型表示函数不返回任何值<br>返回类型不能是数组或函数类型，但可以是指向数组或函数的指针</p>
<h3 id="局部对象"><a href="#局部对象" class="headerlink" title="局部对象"></a>局部对象</h3><p>名字的作用域是程序文本的一部分，名字在其中可见<br>对象的生命周期是程序执行过程中该对象存在的一段时间</p>
<p>形参和函数体内部定义的变量统称为局部变量(local variable)。仅在函数的作用域内可见。局部变量还会隐藏在外层作用域中同名的其他所有声明中</p>
<h4 id="自动对象"><a href="#自动对象" class="headerlink" title="自动对象"></a>自动对象</h4><p>把只存在于块执行期间的对象称为自动对象(automatic object)</p>
<h4 id="局部静态对象"><a href="#局部静态对象" class="headerlink" title="局部静态对象"></a>局部静态对象</h4><p>局部静态对象(local static object)在程序的执行路径进第一次经过对象定义语句是初始化，并且直到程序终止才被销毁<br>可以将局部对象定义成static类型从而获得这样的对象</p>
<h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>函数只能定义一次， 但可以声明多次。声明无须函数体</p>
<p>函数和变量应在头文件中声明在源文件中定义<br>把函数的声明直接放在源文件中是合法的，但繁琐且容易出错；放在头文件中能确保同一函数的所有声明保持一致。且一旦想改变函数的接口，只需改变一条声明即可</p>
<h3 id="分离式编译"><a href="#分离式编译" class="headerlink" title="分离式编译"></a>分离式编译</h3><p>分离式编译(separate compilation)允许把程序分个到几个文件中去，每个文件独立编译</p>
<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>形参的类型决定了形参和实参的交互方法<br>形参是引用类型时，它对应的实参被引用传递(passed by reference)或者函数被传引用调用(called by reference)。它将绑定到对应的实参上。<br>当实参的值被拷贝给形参时，形参和实参是两个互相独立的对象。叫实参被值传递(passed by value)或者函数被传值调用(called by value)</p>
<h3 id="传值参数"><a href="#传值参数" class="headerlink" title="传值参数"></a>传值参数</h3><p>当初始化一个非引用类型的变量时，初始值被拷贝给变量。此时，对变量的改动不会影响初始值</p>
<p>当执行指针拷贝参数时，拷贝的是指针的值。拷贝之后，两个指针是不同的指针</p>
<h3 id="传引用参数"><a href="#传引用参数" class="headerlink" title="传引用参数"></a>传引用参数</h3><p>通过使用引用形参，允许函数改变一个或多个实参的值</p>
<p>拷贝大的类类型对象或者容器对象比较低效，甚至有的类类型(包括IO类型在内)不支持拷贝操作，就只能通过引用形参访问该类型对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//string对象可能会非常长，尽量避免直接拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isShorter</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s1, <span class="keyword">const</span> <span class="built_in">string</span>&amp; s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt; s2.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果无须改变引用形参的值，最好将其声明为常量引用</p>
<h4 id="使用引用形参返回额外信息"><a href="#使用引用形参返回额外信息" class="headerlink" title="使用引用形参返回额外信息"></a>使用引用形参返回额外信息</h4><p>一个函数只能返回一个值，引用形参为我们一次返回多个结果提供了有效途径</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回在string对象中某个指定字符第一次出现的位置和出现的总次数</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>::size_type <span class="title">find_char</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s, <span class="keyword">char</span> c, <span class="built_in">string</span>::size_type&amp; occurs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ret = s.<span class="built_in">size</span>();</span><br><span class="line">    occurs=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">decltype</span>(ret) i = <span class="number">0</span>; i != s.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==c)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ret == s.<span class="built_in">size</span>())</span><br><span class="line">                ret = i;</span><br><span class="line">            ++occurs;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="const形参和实参"><a href="#const形参和实参" class="headerlink" title="const形参和实参"></a>const形参和实参</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">42</span>;<span class="comment">//不能改变ci，const是顶层的</span></span><br><span class="line"><span class="keyword">int</span> i=ci;       <span class="comment">//正确：拷贝时忽略了顶层const</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p=&amp;i;<span class="comment">//const是顶层的，不能给p赋值</span></span><br><span class="line">*p = <span class="number">0</span>;         <span class="comment">//正确：i变成0</span></span><br></pre></td></tr></table></figure>

<p>和其它初始化过程一样，当使用实参初始化形参时会忽略掉顶层const，即形参的顶层const被忽略掉了<br>当形参有顶层const时，传给它常量对象或者非常量对象都是可以的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i)</span></span>&#123; <span class="comment">/* fcn能够读取i，但不能向i写值 */</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;&#125;  <span class="comment">//错误：重复定义了fcn(int)</span></span><br></pre></td></tr></table></figure>

<h4 id="指针或引用形参与const"><a href="#指针或引用形参与const" class="headerlink" title="指针或引用形参与const"></a>指针或引用形参与const</h4><p>形参的初始化方式和变量的初始化方式是一样的。可以使用非常量初始化一个底层const对象，但反过来不行<br>一个普通的引用必须用同类型的对象初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* cp = &amp;i; <span class="comment">//正确：但cp不能改变i</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; r = i;   <span class="comment">//正确：但r不能改变i</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; r2 = <span class="number">42</span>; <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">int</span>* p = cp;        <span class="comment">//错误：类型不匹配</span></span><br><span class="line"><span class="keyword">int</span>&amp; r3 = r;        <span class="comment">//错误：类型不匹配</span></span><br><span class="line"><span class="keyword">int</span>&amp; r4 = <span class="number">42</span>;       <span class="comment">//错误：不能用字面值常量初始化一个非常量引用</span></span><br></pre></td></tr></table></figure>

<p>将同样的初始化规则应用到参数传递上可得：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i;</span><br><span class="line"><span class="built_in">string</span>::size_type ctr=<span class="number">0</span>;</span><br><span class="line">reset(&amp;i);  <span class="comment">//调用形参类型是int*的reset函数</span></span><br><span class="line">reset(&amp;ci); <span class="comment">//错误：不能用指向const int对象的指针初始化int*</span></span><br><span class="line">reset(i);   <span class="comment">//调用形参类型是int&amp;的reset函数</span></span><br><span class="line">reset(ci);  <span class="comment">//错误：不能把普通引用绑定到const对象ci上</span></span><br><span class="line">reset(<span class="number">42</span>);  <span class="comment">//错误：不能把普通引用绑定到字面值上</span></span><br><span class="line">reset(ctr); <span class="comment">//错误：类型不匹配，ctr是无符号类型</span></span><br><span class="line"><span class="comment">//正确：find_char的第一个参数是对常量的引用</span></span><br><span class="line">find_char (<span class="string">"Hello World!"</span>, <span class="string">'o'</span>, ctr);</span><br></pre></td></tr></table></figure>

<h4 id="尽量使用常量引用"><a href="#尽量使用常量引用" class="headerlink" title="尽量使用常量引用"></a>尽量使用常量引用</h4><p>把函数不会改变的形参定义成普通的引用会带给调用者误导。此外普通引用也会限制接受的参数类型，不能把const对象，字面值或者需要类型转换的对象传递给普通引用形参</p>
<h3 id="数组形参"><a href="#数组形参" class="headerlink" title="数组形参"></a>数组形参</h3><p>数组不允许拷贝；使用数组时(通常)会将其转换成指针<br>所以无法通过值传递的方式使用数组；传递数组时，实际传递的是指向数组首元素的指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三个print函数是等价的</span></span><br><span class="line"><span class="comment">//每个函数都有一个const int*类型的形参</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>[<span class="number">10</span>])</span></span>;</span><br><span class="line"><span class="comment">//函数的意图是作用于一个数组</span></span><br><span class="line"><span class="comment">//维度表示期望数组含有的元素，实际不一定</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>,j[<span class="number">2</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">print</span>(&amp;i);  <span class="comment">//正确：&amp;i的类型是int*</span></span><br><span class="line"><span class="built_in">print</span>(j);   <span class="comment">//正确：j转换成int*并指向j[0]</span></span><br></pre></td></tr></table></figure>

<p>数组是以指针的形式传递给函数的，所以函数并不知道数组确切的尺寸，调用者应该为此提供额外的信息<br>一般有三种方式：使用标记指定数组长度、使用标准库规范、显示传递一个表示数组大小的形参</p>
<h4 id="使用标记指定数组长度"><a href="#使用标记指定数组长度" class="headerlink" title="使用标记指定数组长度"></a>使用标记指定数组长度</h4><p>典型示例是C风格字符串，在最后一个字符后面跟着一个空字符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* cp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cp)          <span class="comment">//若cp不是空指针</span></span><br><span class="line">        <span class="keyword">while</span>(*cp)  <span class="comment">//指针所指的字符不是空字符</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; *cp++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用标准库规范"><a href="#使用标准库规范" class="headerlink" title="使用标准库规范"></a>使用标准库规范</h4><p>传递指向数组首元素和尾后元素的指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* beg,<span class="keyword">const</span> <span class="keyword">int</span>* <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(beg!=<span class="built_in">end</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *beg++ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> j[<span class="number">2</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">begin</span>(j),<span class="built_in">end</span>(j));</span><br></pre></td></tr></table></figure>

<h4 id="显示传递一个表示数组大小的形参"><a href="#显示传递一个表示数组大小的形参" class="headerlink" title="显示传递一个表示数组大小的形参"></a>显示传递一个表示数组大小的形参</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//const int ia[]等价于const int* ia</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> ia[],<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>;i!=<span class="built_in">size</span>;++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ia[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> j[]=&#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">print</span>(j,<span class="built_in">end</span>(j)-<span class="built_in">begin</span>(j));</span><br></pre></td></tr></table></figure>

<h4 id="数组引用形参"><a href="#数组引用形参" class="headerlink" title="数组引用形参"></a>数组引用形参</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确：形参是数组的引用，维度是类型的一部分</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> (&amp;arr)[<span class="number">10</span>])</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:arr)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="keyword">int</span> &amp;arr[<span class="number">10</span>])     <span class="comment">//错误：将arr声明成了引用的数组</span></span><br><span class="line">f(<span class="keyword">int</span> (&amp;arr)[<span class="number">10</span>])   <span class="comment">//正确：arr是具有10个整数数组的引用</span></span><br></pre></td></tr></table></figure>

<p>因为数组的大小是构成数组类型的一部分，所以也限制了函数的可用性，只能作用于大小为10的数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>,j[<span class="number">2</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> k[<span class="number">10</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="built_in">print</span>(&amp;i);  <span class="comment">//错误：实参不是含有10个整数的数组</span></span><br><span class="line"><span class="built_in">print</span>(j);   <span class="comment">//错误</span></span><br><span class="line"><span class="built_in">print</span>(k);   <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>

<h4 id="传递多维数组"><a href="#传递多维数组" class="headerlink" title="传递多维数组"></a>传递多维数组</h4><p>将多维数组传递给函数时，真正传递的是数组首元素的指针。此时数组首元素本身是一个数组，指针就是一个指向数组的指针。数组第二位的大小都是数组类型的一部分，不能省略</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//matrix指向数组的首元素，该数组的元素是由10个整数构成的数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> (*matrix)[<span class="number">10</span>], <span class="keyword">int</span> rowSize)</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//*matrix两端的括号不可少</span></span><br><span class="line"><span class="keyword">int</span>* matrix[<span class="number">10</span>];    <span class="comment">//10个指针构成的数组</span></span><br><span class="line"><span class="keyword">int</span> (*matrix)[<span class="number">10</span>];  <span class="comment">//指向含有10个整数的数组的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//等价定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> matrix[][<span class="number">10</span>], <span class="keyword">int</span> rowSize)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="含有可变形参的函数"><a href="#含有可变形参的函数" class="headerlink" title="含有可变形参的函数"></a>含有可变形参的函数</h3><p>为了编写能处理不同数量实参的函数，提供两种主要方法：所有的实参类型相同，可以传递一个名为initializer_list的标准库类型；类型不同，可以编写可变参数模板<br>还可以用省略福传递可变数量的形参</p>
<h4 id="initializer-list形参"><a href="#initializer-list形参" class="headerlink" title="initializer_list形参"></a>initializer_list形参</h4><p>initializer_list是一种标准库类型，用于表示某种热定类型的值的数组</p>
<p>提供的操作：</p>
<p><img src="https://i.loli.net/2020/11/19/38osKZ2JirjVIG9.png" alt="Snipaste_2020-11-19_22-26-56.png"></p>
<p>和vector不同的是，initializer_list对象中的元素永远是常量值，无法改变其中对象中元素的值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_msg</span><span class="params">(<span class="built_in">initializer_list</span>&lt;<span class="built_in">string</span>&gt; il)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> beg=il.<span class="built_in">begin</span>();beg!=il.<span class="built_in">end</span>();++beg)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *beg &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传递值的序列</span></span><br><span class="line"><span class="comment">//expected和actual是string对象</span></span><br><span class="line"><span class="keyword">if</span>(expected != actual)</span><br><span class="line">    error_msg(&#123;<span class="string">"functionX"</span>, expected, actual&#125;);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    error_msg(&#123;<span class="string">"functionX"</span>, <span class="string">"okay"</span>&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="省略符形参"><a href="#省略符形参" class="headerlink" title="省略符形参"></a>省略符形参</h4><p>省略符形参应该仅仅用于C和C++通用的类型。只能出现在形参列表最后一个位置</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(parm_list, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(...)</span></span>;</span><br></pre></td></tr></table></figure>

<p>省略符形参所对应的实参无须类型检查</p>
<h2 id="返回类型和return语句"><a href="#返回类型和return语句" class="headerlink" title="返回类型和return语句"></a>返回类型和return语句</h2><p>return语句终止当前正在执行的函数并将控制权返回到调用该函数的地方。两种形式：<br>return；<br>return <em>expression</em>；</p>
<h3 id="无返回值函数"><a href="#无返回值函数" class="headerlink" title="无返回值函数"></a>无返回值函数</h3><p>没有返回值的return语句只能用在返回类型是void的函数。返回void的函数不要求非得有return语句，会隐式地执行return<br>一个返回类型是void的函数也能使用return语句的第二种形式，不过<em>expression</em>必须是另一个返回void的函数。返回其它类型将产生编译错误</p>
<h3 id="有返回值函数"><a href="#有返回值函数" class="headerlink" title="有返回值函数"></a>有返回值函数</h3><p>只要函数的返回类型不是void，则该函数内每条return语句必须返回一个类型与函数返回类型相同或能转换成返回类型的类型</p>
<p>在含有return语句的循环后面也应该有一条return语句，没有的话该程序就是错误的</p>
<p>返回一个值的方式和初始化一个变量或形参的方式完全一样：返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">make_plural</span><span class="params">(<span class="keyword">size_t</span> ctr,<span class="keyword">const</span> <span class="built_in">string</span>&amp; <span class="keyword">word</span>, <span class="keyword">const</span> <span class="built_in">string</span>&amp; ending)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (ctr&gt;<span class="number">1</span>) ? <span class="keyword">word</span> + ending : <span class="keyword">word</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数的返回类型是string，意味着返回值将被拷贝到调用点。因此该函数将返回word的副本或者一个未命名的临时string对象，内容是word和ending的和</p>
<p>如果函数返回引用，则该引用仅是它所引对象的一个别名</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span>&amp; <span class="title">shorterString</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s1, <span class="keyword">const</span> <span class="built_in">string</span>&amp; s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>()&lt;=s2.<span class="built_in">size</span>() ? s1 : s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>形参和返回类型都是const string的引用，调用函数和返回结果都不会真正拷贝string对象</p>
<h4 id="不要返回局部对象的引用或指针"><a href="#不要返回局部对象的引用或指针" class="headerlink" title="不要返回局部对象的引用或指针"></a>不要返回局部对象的引用或指针</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span>&amp; <span class="title">manip</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> ret;</span><br><span class="line">    <span class="keyword">if</span>(!ret.empty())<span class="keyword">return</span> ret; <span class="comment">//错误：返回局部对象的引用</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">"Empty"</span>;        <span class="comment">//错误：“Empty”是一个局部临时量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="返回类类型的函数和调用运算符"><a href="#返回类类型的函数和调用运算符" class="headerlink" title="返回类类型的函数和调用运算符"></a>返回类类型的函数和调用运算符</h4><p>调用运算符的优先级与点运算符和箭头运算符相同，符合左结合律<br>如果函数返回指针、引用或类的对象，能使用函数调用的结果访问结果对象的成员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用string对象的size成员</span></span><br><span class="line"><span class="comment">//该string对象是由shorterSize函数返回的</span></span><br><span class="line"><span class="keyword">auto</span> sz=shorterString(s1,s2).<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure>

<h4 id="引用返回左值"><a href="#引用返回左值" class="headerlink" title="引用返回左值"></a>引用返回左值</h4><p>调用一个返回引用的函数得到左值，其它返回类型得到右值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>&amp; <span class="title">get_val</span><span class="params">(<span class="built_in">string</span>&amp; str, <span class="built_in">string</span>::size_type ix)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str[ix];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"a value"</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; s &lt;&lt;<span class="built_in">endl</span>;    <span class="comment">//输出a value</span></span><br><span class="line">    get_val(s,<span class="number">0</span>)=<span class="string">'A'</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; s &lt;&lt;<span class="built_in">endl</span>;    <span class="comment">//输出A value</span></span><br><span class="line"></span><br><span class="line">    shorterString(<span class="string">"hi"</span>,<span class="string">"bye"</span>)=<span class="string">"X"</span>;</span><br><span class="line">    <span class="comment">//错误：返回值是个常量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="列表初始化返回值"><a href="#列表初始化返回值" class="headerlink" title="列表初始化返回值"></a>列表初始化返回值</h4><p>函数可以返回花括号包围的值的列表。此处的列表也用来对表示函数返回的临时量进行初始化<br>如果列表为空，临时量执行值初始化；否则返回的值由函数的返回类型决定</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;<span class="built_in">process</span>()&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span>(expected.empty())</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;  <span class="comment">//返回一个空vector对象</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(expected==actual)</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">"functionX"</span>, <span class="string">"okay"</span>&#125;;</span><br><span class="line">        <span class="comment">//返回列表初始化的vector对象</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">"functionX"</span>,expected,actual&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果函数返回的是内置类型，则花括号包围的列表最多包含一个值，且该值所占的空间不应该大于目标类型的空间</p>
<h4 id="主函数main的返回值"><a href="#主函数main的返回值" class="headerlink" title="主函数main的返回值"></a>主函数main的返回值</h4><p>main函数会隐式地插入一条返回0的return语句<br>返回0表示执行成功，其它值表示失败，具体含义依机器而定<br>为使返回值与机器无关，cstdlib头文件定义了两个预处理变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(some_failure)</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>如果一个函数调用了它自身，称该函数为递归函数(recursive function)<br>main函数不能调用它自己</p>
<h3 id="返回数组指针"><a href="#返回数组指针" class="headerlink" title="返回数组指针"></a>返回数组指针</h3><p>因为数组不能被拷贝，所以函数不能返回数组。可以返回数组的指针或引用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> arrT[<span class="number">10</span>];   <span class="comment">//arrT是一个类型别名</span></span><br><span class="line">                        <span class="comment">//表示的类型是含有10个整数的数组</span></span><br><span class="line"><span class="keyword">using</span> arrT=<span class="keyword">int</span>[<span class="number">10</span>];     <span class="comment">//等价声明</span></span><br><span class="line"><span class="function">arrT* <span class="title">func</span><span class="params">(<span class="keyword">int</span> i)</span></span>;      <span class="comment">//func返回一个指向含有10个整数数组的指针</span></span><br></pre></td></tr></table></figure>

<h4 id="声明一个返回数组指针的函数"><a href="#声明一个返回数组指针的函数" class="headerlink" title="声明一个返回数组指针的函数"></a>声明一个返回数组指针的函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];    <span class="comment">//arr是一个含有10个整数的数组</span></span><br><span class="line"><span class="keyword">int</span>* p1[<span class="number">10</span>];    <span class="comment">//p1是一个含有10个指针的数组</span></span><br><span class="line"><span class="keyword">int</span> (*p2)[<span class="number">10</span>];  <span class="comment">//p2是一个指针，指向含有10个整数的数组</span></span><br></pre></td></tr></table></figure>

<p>如果想定义一个返回数组指针的函数，则数组的维度必须跟在函数名字之后。然而形参列表也跟在名字后，且先于数组的维度<br><em>Type</em> (<em>\</em>function(parameter_list)<em>) [</em>dimension<em>]<br>如：int (</em>func(int i))[10];</p>
<h4 id="使用尾置返回类型"><a href="#使用尾置返回类型" class="headerlink" title="使用尾置返回类型"></a>使用尾置返回类型</h4><p>尾置返回类型跟在形参列表后并以一个”-&gt;”符号开头，在本应该出现返回类型的地方放一个”auto”</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto func(int i) -&gt; int(*)[10];</span><br></pre></td></tr></table></figure>

<h4 id="使用decltype"><a href="#使用decltype" class="headerlink" title="使用decltype"></a>使用decltype</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> odd[]=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> even[]=&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">decltype</span>(odd) *arrPtr(<span class="keyword">int</span> i)&#123;</span><br><span class="line">    <span class="keyword">return</span> (i%<span class="number">2</span>)?&amp;odd:&amp;even;</span><br><span class="line">    <span class="comment">//返回一个知指向数组的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>decltype并不负责把数组类型转换成指针，所以还需要在声明时加一个”*”符号</p>
<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为重载(overload)函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* cp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* beg,<span class="keyword">const</span> <span class="keyword">int</span>* <span class="built_in">end</span>)</span></span>;l</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> ia[], <span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这些函数接受的形参类型不一样。调用时编译器根据传递的实参类型推断需要的函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> j[<span class="number">2</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Hello World!"</span>);      <span class="comment">//调用print(const char*)</span></span><br><span class="line"><span class="built_in">print</span>(j,<span class="built_in">end</span>(j)-<span class="built_in">begin</span>(j));   <span class="comment">//调用print(const int*,size_t)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">begin</span>(j),<span class="built_in">end</span>(j));     <span class="comment">//调用print(const int*,const int*)</span></span><br></pre></td></tr></table></figure>

<p>对于重载函数，它们应该在形参数量或类型上有所不同。不允许两个函数除了返回类型外其他所有要素都相同</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每对声明的是同一个函数</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Account&amp; acct)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Account&amp;)</span></span>;  <span class="comment">//省略了形参名字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Phone Telno;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Phone&amp;)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Telno&amp;)</span></span>;    <span class="comment">//Phone和Telno类型相同</span></span><br></pre></td></tr></table></figure>

<h4 id="重载和const形参"><a href="#重载和const形参" class="headerlink" title="重载和const形参"></a>重载和const形参</h4><p>顶层const不影响传入函数的对象。一个拥有顶层const的形参无法和另一个没有的区分开来</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Phone)</span></span>; <span class="comment">//重复声明</span></span><br><span class="line"></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone*)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone* <span class="keyword">const</span>)</span></span>;<span class="comment">//重复声明</span></span><br></pre></td></tr></table></figure>

<p>如果形参是某种类型的指针或引用，通过区分底层const可以实现函数重载</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account&amp;)</span></span>;    <span class="comment">//函数作用于Account的引用</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Account&amp;)</span></span>;<span class="comment">//新函数，作用于常量引用</span></span><br><span class="line"></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account*)</span></span>;    <span class="comment">//作用于指向Account的指针</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Account*)</span></span>;<span class="comment">//新函数，作用于指向常量的指针</span></span><br></pre></td></tr></table></figure>

<p>const不能转换成其它类型，所以只能把const对象(或指向const的对象)传递给const形参。相反的，非常量可以转换成const，所以4个函数都能作用于非常量对象或者指向非常量对象的指针。<br>当传递一个非常量对象或者指向非常量对象的指针，编译器会优先选用非常量版本的函数</p>
<h4 id="const-cast和重载"><a href="#const-cast和重载" class="headerlink" title="const_cast和重载"></a>const_cast和重载</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span>&amp; <span class="title">shorterString</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;s1,<span class="keyword">const</span> <span class="built_in">string</span>&amp;s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>()&lt;=s2.<span class="built_in">size</span>()?s1:s2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">shorterString</span><span class="params">(<span class="built_in">string</span>&amp;s1,<span class="built_in">string</span>&amp;s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;r=shorterString(<span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="built_in">string</span>&amp;&gt;(s1),</span><br><span class="line">                        <span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="built_in">string</span>&amp;&gt;(s2));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="built_in">string</span>&amp;&gt;(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二个版本的函数中，先将它的实参强制转换成对const的引用，然后调用了函数的const版本，返回对const string的引用，这个引用事实上绑定在某个初始的非常量版本上。因此可以再将其转换回一个普通的string&amp;是非常安全的</p>
<h4 id="调用重载的函数"><a href="#调用重载的函数" class="headerlink" title="调用重载的函数"></a>调用重载的函数</h4><p>函数匹配(function matching)是指一个过程，在这个过程中我们把函数调用与一组重载函数中的某一个关联起来，也叫做重载确定(overload resolution)<br>三个可能的结果：<br>·编译器找到一个与实参最佳匹配(best match)的函数，并生成调用该函数的代码<br>·找不到任何一个函数与调用的实参匹配，此时编译器发出无匹配(no match)的错误信息<br>·有多于一个函数可以匹配，但是每一个都不是明显的最佳选择。此时也发生错误，称为二义性调用(ambiguous call)</p>
<h3 id="重载与作用域"><a href="#重载与作用域" class="headerlink" title="重载与作用域"></a>重载与作用域</h3><p>如果在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体。在不同作用域中无法重载函数名<br>C++中，名字查找发生在类型检查之前</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">road</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fooBar</span><span class="params">(<span class="keyword">int</span> ival)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> <span class="built_in">read</span> = <span class="literal">false</span>;  <span class="comment">//新作用域，隐藏了外层的read()</span></span><br><span class="line">    <span class="built_in">string</span> s=<span class="built_in">read</span>();    <span class="comment">//错误：read是布尔值而非函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>)</span></span>;    <span class="comment">//隐藏了之前的print</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Value: "</span>);   <span class="comment">//错误：print(const string&amp;)被隐藏掉了</span></span><br><span class="line">    <span class="built_in">print</span>(iVal);        <span class="comment">//正确</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">3.14</span>);        <span class="comment">//正确：调用print(int),pring(double)被隐藏掉了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="特殊用途语言特性"><a href="#特殊用途语言特性" class="headerlink" title="特殊用途语言特性"></a>特殊用途语言特性</h2><h3 id="默认实参"><a href="#默认实参" class="headerlink" title="默认实参"></a>默认实参</h3><p>调用含有默认实参(default argument)的函数时，可以包含该实参，也可以省略</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">string</span>::size_type sz;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">screen</span><span class="params">(sz ht=<span class="number">24</span>,sz wid=<span class="number">80</span>,<span class="keyword">char</span> backgrnd=<span class="string">' '</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>可以为一个或多个形参定义默认值，一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值</p>
<h4 id="使用默认实参调用函数"><a href="#使用默认实参调用函数" class="headerlink" title="使用默认实参调用函数"></a>使用默认实参调用函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> window;</span><br><span class="line">window= screen();           <span class="comment">//screen(24,80,' ')</span></span><br><span class="line">window= screen(<span class="number">66</span>);         <span class="comment">//screen(66,80,' ')</span></span><br><span class="line">window= screen(<span class="number">66</span>,<span class="number">256</span>);     <span class="comment">//screen(66,256,' ')</span></span><br><span class="line">window= screen(<span class="number">66</span>,<span class="number">256</span>,<span class="string">'#'</span>); <span class="comment">//screen(66,256,'#')</span></span><br><span class="line"></span><br><span class="line">window= screen(, , <span class="string">'?'</span>);<span class="comment">//错误：只能省略尾部的实参</span></span><br><span class="line">window= screen(<span class="string">'?'</span>);    <span class="comment">//screen('?',80,' ')</span></span><br><span class="line"><span class="comment">//第二个是合法的调用，char类型转换为string::size_type</span></span><br></pre></td></tr></table></figure>

<p>给定的作用域中一个形参只能被赋予一次默认实参，即后续的声明只能为之前那些没有默认值的形参添加默认实参，且该形参右侧的所有形参都必须有默认值</p>
<p>局部变量不能作为默认实参，除此之外，只要能转换成形参所需的类型，该表达式就能作为默认实参</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sz wd=<span class="number">80</span>;</span><br><span class="line"><span class="keyword">char</span> def=<span class="string">' '</span>;</span><br><span class="line"><span class="function">sz <span class="title">ht</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">screen</span><span class="params">(sz=ht(),sz=wd,<span class="keyword">char</span>=def)</span></span>;</span><br><span class="line"><span class="built_in">string</span> window=screen(); <span class="comment">//调用screen(ht(),80,' ')</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    def=<span class="string">'*'</span>;    <span class="comment">//改变默认实参的值</span></span><br><span class="line">    sz wd=<span class="number">100</span>;  <span class="comment">//隐藏了外层的wd，但没有改变默认值</span></span><br><span class="line">    window = screen();</span><br><span class="line">    <span class="comment">//调用screen(ht(),80,'*')</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数f2内改变了def的值，所以对screen的调用会传递这个更新过的值。函数声明了一个局部变量用于隐藏外层的wd，但与传递给screen的默认实参没有关系</p>
<h3 id="内联函数和constexpr函数"><a href="#内联函数和constexpr函数" class="headerlink" title="内联函数和constexpr函数"></a>内联函数和constexpr函数</h3><p>把规模较小的操作定义成函数有很多好处：<br>·阅读和理解函数的调用相对容易<br>·使用函数可以确保行为的统一<br>·如果需要修改计算过程，修改函数更容易<br>·函数可以被其它应用重复利用，省去重复编写<br>但函数调用相对较慢。一次函数调用包括：调用前先保存寄存器，并在返回时恢复；可能需要可拷贝实参；程序转向一个新的位置继续执行</p>
<h4 id="内联函数可避免函数调用的开销"><a href="#内联函数可避免函数调用的开销" class="headerlink" title="内联函数可避免函数调用的开销"></a>内联函数可避免函数调用的开销</h4><p>将函数指定为内联函数(inline)，通常就是讲它在每个调用点上“内联地”展开。从而消除运行时开销。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">const</span> <span class="built_in">string</span>&amp;</span><br><span class="line">shorterString(<span class="keyword">const</span> <span class="built_in">string</span>&amp;s1,<span class="keyword">const</span> <span class="built_in">string</span>&amp;s2)&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>()&lt;s2.<span class="built_in">size</span>()?s1:s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般来说，内联机制用于优化规模较小、流程直接、频繁调用的函数。很多编译器不支持内联递归函数</p>
<h4 id="constexpr函数"><a href="#constexpr函数" class="headerlink" title="constexpr函数"></a>constexpr函数</h4><p>constexpr函数(constexpr function)是指能用于常量表达式的函数<br>函数的返回类型以及所有形参的类型都得是字面值类型，而且函数体中必须有且只有一条return语句</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">new_sz</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">42</span>;&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> foo=new_sz();</span><br></pre></td></tr></table></figure>

<p>编译器把对constexpr函数的调用替换成其结果值。为了能在编译过程中随时展开，constexpr函数被隐式地指定为内联函数<br>constexpr函数体内也可以包含其他语句，只要这些语句在运行时不执行任何操作。如空语句、类型别名以及using声明</p>
<p>允许constexpr函数的返回值并非一个常量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">size_t</span> <span class="title">scale</span><span class="params">(<span class="keyword">size_t</span> cnt)</span></span>&#123;<span class="keyword">return</span> new_sz()*cnt;&#125;</span><br><span class="line"><span class="keyword">int</span> arr[scale(<span class="number">2</span>)];  <span class="comment">//正确：scale(2)是常量表达式</span></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> a2[scale(i)];   <span class="comment">//错误：scale(i)不是常量表达式</span></span><br></pre></td></tr></table></figure>

<p>当把scale函数用在需要常量表达式的上下文中时，由编译器负责检查函数的结果是否符合要求。如果不是则报错</p>
<h3 id="调试帮助"><a href="#调试帮助" class="headerlink" title="调试帮助"></a>调试帮助</h3><p>有时会用到一种类似于头文件保护的技术，以便有选择的执行调试代码。基本思想是，程序可以包含一段用于调试的代码，但这些代码只在开发程序时使用。编写完成准备发布时，先屏蔽掉调试代码</p>
<h4 id="assert预处理宏"><a href="#assert预处理宏" class="headerlink" title="assert预处理宏"></a>assert预处理宏</h4><p>assert是一种预处理宏(preprocessor marco)。<br>assert(<em>expr</em>);<br>首先对<em>expr</em>求值，如果为假，assert输出信息并终止程序的执行；如果为真，assert什么也不做<br>assert宏常用于检查“不能发生”的条件。如：一个对输入文本进行操作的程序可能要求给定单词的长度都大于某个阈值<br>assert(word.size()&gt;threshold);</p>
<h4 id="NDEBUG预处理变量"><a href="#NDEBUG预处理变量" class="headerlink" title="NDEBUG预处理变量"></a>NDEBUG预处理变量</h4><p>assert的行为依赖于一个名为NDEBUG的预处理变量的状态。如果定义了NDEBUG，则assert什么也不做<br>可以使用一条#define语句定义NDEBUG，从而关闭调试状态</p>
<h2 id="函数匹配"><a href="#函数匹配" class="headerlink" title="函数匹配"></a>函数匹配</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span>,<span class="keyword">double</span>=<span class="number">3.14</span>)</span></span>;</span><br><span class="line">f(<span class="number">5.6</span>);     <span class="comment">//调用f(double,double)</span></span><br></pre></td></tr></table></figure>

<p>函数匹配第一步是选定本次调用对应的重载函数集，集合中的函数称为候选函数(candidate function)。特征：与被调用函数同名，声明在调用点可见<br>第二部是选出可行参数(viable function)。特征：形参数量与本次调用提供的实参相等；每个实参的类型与对应的形参类型相同，或者能转换成形参的类型<br>第三步是从可行函数中选择与本次调用最匹配的函数。实参与形参类型越接近匹配得越好</p>
<h3 id="实参类型转换"><a href="#实参类型转换" class="headerlink" title="实参类型转换"></a>实参类型转换</h3><p>转换等级排序：<br>·精确匹配：类型相同；实参从数组类型或函数类型转换成对应的指针类型；向实参添加顶层const或从实参删除顶层const<br>·通过const转换实现的匹配<br>·通过类型提升实现的匹配<br>·通过算术类型转换或指针转换实现的匹配<br>·通过类类型转换实现的匹配</p>
<p>所有算术类型转换的级别都一样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ff</span><span class="params">(<span class="keyword">long</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ff</span><span class="params">(<span class="keyword">float</span>)</span></span>;</span><br><span class="line">ff(<span class="number">3.14</span>);   <span class="comment">//错误：二义性调用</span></span><br></pre></td></tr></table></figure>

<p>如果重载函数的区别在于他们的引用类型的形参是否引用了const，或者指针类型的形参是否指向const，则当调用发生时编译器通过实参是否是常量来决定调用哪个函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account&amp;)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Account&amp;)</span></span>;</span><br><span class="line"><span class="keyword">const</span> Account a;</span><br><span class="line">Account a;</span><br><span class="line"></span><br><span class="line">lookup(a);  <span class="comment">//调用lookup(const Account&amp;)</span></span><br><span class="line">lookup(b);  <span class="comment">//调用lookup(Account&amp;)</span></span><br></pre></td></tr></table></figure>

<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>函数指针指向的是函数而非对象。函数指针指向某种特定的类型。函数的类型由它的返回类型和形参类型共同决定，与函数名无关</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">lengthCompare</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;,<span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line"><span class="comment">//pf指向一个函数，该函数的参数是两个const string引用，返回值是bool类型</span></span><br><span class="line"><span class="keyword">bool</span> (*pf)(<span class="keyword">const</span> <span class="built_in">string</span>&amp;,<span class="keyword">const</span> <span class="built_in">string</span>&amp;);    <span class="comment">//未初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明一个名为pf的函数，返回bool*</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span>* <span class="title">pf</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;,<span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<p>把函数名作为一个值使用时，该函数自动地转换为指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pf = lengthCompare;     <span class="comment">//pf指向名为lengthCompare的函数</span></span><br><span class="line">pf = &amp;lengthCompare;    <span class="comment">//等价的赋值语句，&amp;符号是可选的</span></span><br></pre></td></tr></table></figure>

<p>还能直接使用指向函数的指针调用该函数，无需提前解引用指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> b1=pf(<span class="string">"hello"</span>,<span class="string">"goodbye"</span>);      <span class="comment">//调用lengthCompare函数</span></span><br><span class="line"><span class="keyword">bool</span> b2=(*pf)(<span class="string">"hello"</span>,<span class="string">"goodbye"</span>);   <span class="comment">//等价调用</span></span><br><span class="line"><span class="keyword">bool</span> b3=lengthCompare(<span class="string">"hello"</span>,<span class="string">"goodbye"</span>);<span class="comment">//等价调用</span></span><br></pre></td></tr></table></figure>

<p>指向不同函数类型的指针间不存在转换规则。但可以为函数指针赋值一个nullptr或者0的整型常量表达式，表示没有指向任何一个函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span>::size_type <span class="title">sumLength</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;,cosnt <span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cstringCompare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*,<span class="keyword">const</span> <span class="keyword">char</span>*)</span></span>;</span><br><span class="line">pf = <span class="number">0</span>;                 <span class="comment">//正确：pf不指向任何函数</span></span><br><span class="line">pf = sumLength;         <span class="comment">//错误：返回类型不匹配</span></span><br><span class="line">pf = cstringCompare;    <span class="comment">//错误：返回类型不匹配</span></span><br><span class="line">pf = lengthCompare;     <span class="comment">//正确：函数和指针的类型精确匹配</span></span><br></pre></td></tr></table></figure>

<h4 id="重载函数的指针"><a href="#重载函数的指针" class="headerlink" title="重载函数的指针"></a>重载函数的指针</h4><p>当我们使用重载函数时，必须清晰界定到底应该选择用哪个函数。编译器通过指针类型决定使用哪个函数，指针类型必须与重载函数中的某一个精确匹配</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ff</span><span class="params">(<span class="keyword">int</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ff</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> (*pf1)(<span class="keyword">unsigned</span> <span class="keyword">int</span>) = ff; <span class="comment">//pf1指向ff(unsigned)</span></span><br><span class="line"><span class="keyword">void</span> (*pf2)(<span class="keyword">int</span>) = ff;      <span class="comment">//错误：没有任何一个ff与该类型参数匹配</span></span><br><span class="line"><span class="keyword">double</span> (*pf3)(<span class="keyword">int</span>*) = ff;   <span class="comment">//错误：ff和pf3返回类型不匹配</span></span><br></pre></td></tr></table></figure>

<h4 id="函数指针形参"><a href="#函数指针形参" class="headerlink" title="函数指针形参"></a>函数指针形参</h4><p>和数组类似，虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。此时形参看起来是函数类型，实际上却是当成指针使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第三个参数是函数类型，会自动地转换成指向函数的指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;s1,<span class="keyword">const</span> <span class="built_in">string</span>&amp;s2,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">bool</span> pf(<span class="keyword">const</span> <span class="built_in">string</span>&amp;,<span class="keyword">const</span> <span class="built_in">string</span>&amp;))</span></span>;</span><br><span class="line"><span class="comment">//等价的声明：显示地将形参定义成指向函数的指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;s1,<span class="keyword">const</span> <span class="built_in">string</span>&amp;s2,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">bool</span> (*pf)(<span class="keyword">const</span> <span class="built_in">string</span>&amp;,<span class="keyword">const</span> <span class="built_in">string</span>&amp;))</span></span>;</span><br><span class="line"><span class="comment">//自动将函数lengthCompare转换成指向该函数的指针</span></span><br><span class="line">useBigger(s1,s2,lengthCompare);</span><br></pre></td></tr></table></figure>

<p>类型别名和decltype能简化使用了函数指针的代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Func和Func2是函数类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">bool</span> <span class="title">Func</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;,<span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> Func2</span>;  <span class="comment">//等价的类型</span></span><br><span class="line"><span class="comment">//FuncP和FuncP2是指向函数的指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(*FuncP)</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;,<span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> *FuncP2</span>;    <span class="comment">//等价的类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//useBigger的等价声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;,<span class="keyword">const</span> <span class="built_in">string</span>&amp;,Func)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span><span class="params">(cosnt <span class="built_in">string</span>&amp;,<span class="keyword">const</span> <span class="built_in">string</span>&amp;,FuncP2)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="返回指向函数的指针"><a href="#返回指向函数的指针" class="headerlink" title="返回指向函数的指针"></a>返回指向函数的指针</h4><p>和数组类型，虽然不能返回一个函数，但能返回指向函数类型的指针。必须把返回类型写成指针形式，编译器不会自动地将函数返回类型当成对应的指针类型处理</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> F = <span class="keyword">int</span> (<span class="keyword">int</span>*,<span class="keyword">int</span>);   <span class="comment">//F是函数类型，不是指针</span></span><br><span class="line"><span class="keyword">using</span> Pf = <span class="keyword">int</span>(*)(<span class="keyword">int</span>*,<span class="keyword">int</span>);<span class="comment">//PF是指针类型</span></span><br><span class="line"></span><br><span class="line"><span class="function">PF <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">//正确：PF是指向函数的指针，f1返回指向函数的指针</span></span><br><span class="line"><span class="function">F <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;  <span class="comment">//错误：F是函数类型，f1不能返回一个函数</span></span><br><span class="line"><span class="function">F* <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">//正确：显示地指定返回类型是指向函数的指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> (*f1(<span class="keyword">int</span>))(<span class="keyword">int</span>*,<span class="keyword">int</span>);   <span class="comment">//直接声明f1</span></span><br><span class="line"><span class="comment">//f1有形参列表，所以是个函数；前面有*，所以返回一个指针；</span></span><br><span class="line"><span class="comment">//指针的类型本身也有形参列表，所以该指针指向函数，该函数返回int</span></span><br><span class="line"></span><br><span class="line">auto f1(int) -&gt; int(*)(int*,int);</span><br></pre></td></tr></table></figure>

<h4 id="将auto和decltype用于函数指针类型"><a href="#将auto和decltype用于函数指针类型" class="headerlink" title="将auto和decltype用于函数指针类型"></a>将auto和decltype用于函数指针类型</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span>::size_type <span class="title">sumLength</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;,<span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span>::size_type <span class="title">largerLength</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;,<span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line"><span class="comment">//getFcn函数接受一个string类型的形参，返回一个指向sumLength</span></span><br><span class="line"><span class="comment">//或者largerLength的指针</span></span><br><span class="line"><span class="keyword">decltype</span>(sumLength) *getFcn(<span class="keyword">const</span> <span class="built_in">string</span>&amp;);</span><br></pre></td></tr></table></figure>

<p>decltype作用于某个函数时返回函数类型而非指针类型，需要显示地加上*以表明需要返回指针而非函数本身</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/11/19/ncpp-06/" data-id="ckhua8rov002txsve2wyg3wuw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/02-cpp-primer/" rel="tag">02 cpp primer</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ncpp-05" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/18/ncpp-05/" class="article-date">
  <time datetime="2020-11-18T14:08:21.000Z" itemprop="datePublished">2020-11-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/18/ncpp-05/">第5章 语句</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="简单语句"><a href="#简单语句" class="headerlink" title="简单语句"></a>简单语句</h2><p>最简单的语句是空语句(null statement)，只含有一个单独的分号</p>
<p>复合语句(compound statement)是指用花括号括起来的语句和声明的序列(可能为空)，也被称为块(block)<br>一个块就是一个作用域，在块中引入的名字只能在块内部以及嵌套在块中的子块里访问<br>块不以分号作为结束</p>
<h4 id="悬垂else"><a href="#悬垂else" class="headerlink" title="悬垂else"></a>悬垂else</h4><p>else与离它最近的尚未匹配的if匹配，从而消除程序的二义性</p>
<h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><p>switch语句(switch statement)提供了一条便利的途径是的我们能够在若干固定选项中做出抉择</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> aCnt=<span class="number">0</span>,eCnt=<span class="number">0</span>,iCne=<span class="number">0</span>,oCnt=<span class="number">0</span>,uCnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;ch)&#123;</span><br><span class="line">    <span class="keyword">switch</span>(ch)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">            ++aCnt;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'e'</span>:</span><br><span class="line">            ++eCnt;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'i'</span>:</span><br><span class="line">            ++icnt;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'o'</span>:</span><br><span class="line">            ++oCnt;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'u'</span>:</span><br><span class="line">            ++uCnt;<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>case关键字和它对应的值一起被称为case标签(case label)。case标签必须是整型常量表达式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch = getVal();</span><br><span class="line"><span class="keyword">int</span> ival = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">switch</span>(ch)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3.14</span>:  <span class="comment">//错误：不是一个整数</span></span><br><span class="line">    <span class="keyword">case</span> ival:  <span class="comment">//错误：不是一个常量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果某个case标签匹配成功，将从该标签开始往后顺序执行所有case分支</p>
<p>如果没有任何一个case标签能匹配上switch表达式的值，程序将执行紧跟在default标签(default label)后面的语句</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(ch)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'a'</span>: <span class="keyword">case</span> <span class="string">'e'</span>: <span class="keyword">case</span> <span class="string">'i'</span>: <span class="keyword">case</span> <span class="string">'o'</span>: <span class="keyword">case</span> <span class="string">'u'</span>:</span><br><span class="line">    ++vowelCnt;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ++otherCnt;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="迭代语句"><a href="#迭代语句" class="headerlink" title="迭代语句"></a>迭代语句</h2><h3 id="传统for语句"><a href="#传统for语句" class="headerlink" title="传统for语句"></a>传统for语句</h3><p>for语句头中的定义可以定义多个对象，但只能有一条声明语句，因此所有变量的基础类型必须相同</p>
<h2 id="try语句块和异常处理"><a href="#try语句块和异常处理" class="headerlink" title="try语句块和异常处理"></a>try语句块和异常处理</h2><p>异常是指存在于运行时的反常行为，这些行为超出了函数正常功能的范围<br>异常处理包括：<br>·throw表达式(throw expression)，异常检测部分使用throw表达式来表示它遇到了无法处理的问题。说throw引发(raise)了异常<br>·try语句块(try block)，异常处理部分使用try语句块处理异常。try语句块以try开始，并以一个或多个catch子句(catch clause)结束。try语句块中代码抛出的异常通常会被某个catch子句处理。因为catch子句“处理”异常，所以它们也被称作异常处理代码(exception handler)<br>·一套异常类(exception class)，用于在throw表达式和相关的catch子句指甲传递异常的具体信息</p>
<h3 id="throw表达式"><a href="#throw表达式" class="headerlink" title="throw表达式"></a>throw表达式</h3><p>程序的异常检测部分使用throw表达式引发一个异常。throw表达式包含关键字throw和紧随其后的一个表达式，其中表达式的类型就是抛出的异常类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(item1.isbn() != item2.isbn())</span><br><span class="line">    <span class="keyword">throw</span> runtime_error(<span class="string">"Data must refer to same ISBN"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; item1 + item2 &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>如果ISBN不一样就抛出一个类型为runtime_error的异常，抛出异常将终止当前函数，并把控制权转移给能处理该异常的代码</p>
<h3 id="try语句块"><a href="#try语句块" class="headerlink" title="try语句块"></a>try语句块</h3><p>try语句块的通用语法形式是:<br>try{<br>    <em>program-</em><br>}catch (<em>exception-declaration</em>){<br>    <em>handler-statements</em><br>}catch (<em>exception-declaration</em>){<br>    <em>handler-statements</em><br>}   // …<br>当选中了某个catch子句处理异常之后，执行与之对应的块。catch一旦完成，程序跳转到try语句块最后一个catch子句之后的那条语句继续执行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;item1&gt;&gt;item2)&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//执行添加两个Sales_data对象的代码</span></span><br><span class="line">        <span class="comment">//如果失败，抛出runtime_error异常</span></span><br><span class="line">    &#125;<span class="keyword">catch</span>(runtime_error err)&#123;</span><br><span class="line">        <span class="comment">//提醒用户两个ISBN必须一致，询问是否重新输入</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; err.whar()</span><br><span class="line">             &lt;&lt; <span class="string">"\nTry Again? Enter y or n"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">cin</span> || c==<span class="string">'n'</span>)</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">//跳出while循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个标准库异常类都定义了名为what的成员函数，这些函数没有参数，返回值是C风格字符串(const char*)<br>runtime_error的what成员返回的是初始化一个具体对象时所用的string对象是副本</p>
<p>如果没有找到匹配的catch子句，程序转到名为terminate的标准库函数。该函数的行为与系统有关，一般情况下，执行该函数将导致程序非正常退出</p>
<h3 id="标准异常"><a href="#标准异常" class="headerlink" title="标准异常"></a>标准异常</h3><p>C++标准库定义了一组类，用于报告标准库函数遇到的问题。分别定义在四个头文件中</p>
<p><img src="https://i.loli.net/2020/11/18/6EiUHaWA9R3gcXZ.png" alt="Snipaste_2020-11-19_00-05-26.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/11/18/ncpp-05/" data-id="ckhua8ros002lxsve2grn4imj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/02-cpp-primer/" rel="tag">02 cpp primer</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ncpp-04" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/17/ncpp-04/" class="article-date">
  <time datetime="2020-11-17T14:02:18.000Z" itemprop="datePublished">2020-11-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/17/ncpp-04/">第4章 表达式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>表达式由一个或多个运算对象(operand)组成，对表达式求值将得到一个结果(result)。字面值和变量是最简单的表达式(expression)，其结果就是字面值和变量的值。吧一个运算符(operator)和一个或多个运算对象组合起来可以生成较复杂的表达式</p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>C++定义了一元运算符(unary operator，&amp;，*)和二元运算符(binary operator, ==, +)和一个三元运算符。函数调用也是一种特殊的运算符，对运算对象数量没有限制</p>
<h4 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h4><p>当一个对象被做右值的时候，用的是对象的值(内容)；当对象被用作左值时，用的是对象的身份(在内存中的位置)<br>在需要右值的地方可以用左值来代替，但是不能把它当成左值(也就是位置)使用。实际使用的是它的内容(值)</p>
<h3 id="求值顺序"><a href="#求值顺序" class="headerlink" title="求值顺序"></a>求值顺序</h3><p>对于没有指定执行顺序的运算符，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; ++i &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//未定义的</span></span><br></pre></td></tr></table></figure>

<p>四种运算符明确规定了运算对象的求值顺序：逻辑与(&amp;&amp;)、逻辑或(||)、条件运算符(?:)、逗号运算符(,)</p>
<h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p><img src="https://i.loli.net/2020/11/18/OASMdPic8CX2Rao.png" alt="Snipaste_2020-11-18_15-23-06.png"></p>
<p>算术运算符的运算对象和求值结果都是右值。所有运算对象最终会转换成同一类型<br>除法运算中商一律向0取整。取余运算m%n的结果符号和m相同</p>
<h2 id="逻辑和关系运算符"><a href="#逻辑和关系运算符" class="headerlink" title="逻辑和关系运算符"></a>逻辑和关系运算符</h2><p><img src="https://i.loli.net/2020/11/18/PhQuJKtYlk5Vvn2.png" alt="Snipaste_2020-11-18_15-38-27.png"></p>
<p>逻辑与和逻辑或运算符均为短路求值(short-circuit evaluation)：当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(val == <span class="literal">true</span>) &#123;<span class="comment">/* ... */</span>&#125; <span class="comment">//只有当val等于1时条件才为真</span></span><br></pre></td></tr></table></figure>

<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>赋值运算符的左侧运算对象必须是一个可修改的左值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i;</span><br><span class="line"></span><br><span class="line"><span class="number">1024</span> = k;   <span class="comment">//错误：字面值是右值</span></span><br><span class="line">i + j = k;  <span class="comment">//错误：算术表达式是右值</span></span><br><span class="line">ci = k;     <span class="comment">//错误：ci是常量(不可修改的)左值</span></span><br><span class="line"></span><br><span class="line">k = <span class="number">0</span>;      <span class="comment">//结果：类型是int，值是0</span></span><br><span class="line">k = <span class="number">3.14</span>;   <span class="comment">//结果：类型是int，值是3</span></span><br><span class="line"></span><br><span class="line">k = &#123;<span class="number">3.14</span>&#125;; <span class="comment">//错误：窄化转换</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi; <span class="comment">//初始为空</span></span><br><span class="line">vi = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;; <span class="comment">//vi含有6个元素</span></span><br></pre></td></tr></table></figure>

<p>赋值运算符满足右结合律<br>靠右的赋值运算jval=0作为靠左的赋值运算符的右侧运算对象。赋值运算返回的是其左侧的运算对象，所以靠右的赋值运算的结果(即jval)被赋给了ival</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival, jval;</span><br><span class="line">ival = jval = <span class="number">0</span>;    <span class="comment">//正确：都被赋值为0</span></span><br></pre></td></tr></table></figure>

<p>对于多重赋值语句中的每一个对象，它的类型或者与右边对象相同，或者可由右边对象的类型转换得到</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival, *pval;</span><br><span class="line">ival = pval =<span class="number">0</span>; <span class="comment">//错误：不能把指针的值赋给int</span></span><br><span class="line"><span class="built_in">string</span> s1, s2;</span><br><span class="line">s1 = s2 = <span class="string">"ok"</span>; <span class="comment">//字符串字面值“ok”转换成string对象</span></span><br></pre></td></tr></table></figure>

<p>复合赋值运算符</p>
<p><img src="https://i.loli.net/2020/11/18/Fkths1jEuSU9nZC.png" alt="Snipaste_2020-11-18_16-05-32.png"></p>
<p>任意一种复合运算符都完全等价于 a = a <em>op</em> b，唯一的区别是使用复合运算符左侧的对象只求值一次，普通则求值两次<br>一次是作为右边子表达式求值，一次是作为复制运算的左侧运算对象求值</p>
<h2 id="递增和递减运算符"><a href="#递增和递减运算符" class="headerlink" title="递增和递减运算符"></a>递增和递减运算符</h2><p>除非必须，否则不用递增递减运算符的后置版本<br>后置版本需要将原始值储存下来以便返回这个未修改的内容</p>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>位运算符作用于整数类型的运算对象，并把运算对象看成是二进制位的集合</p>
<p><img src="https://i.loli.net/2020/11/18/x62zuHFOyc3RAfj.png" alt="Snipaste_2020-11-18_20-28-01.png"></p>
<p>位移运算符：令左侧运算对象的内容按照右侧运算对象的要求移动指定位数，然后将经过移动的左侧运算对象的拷贝作为求值结果<br>右侧的运算对象不能为负，值严格小于结果的位数，否则会产生未定义的行为</p>
<p>位求反运算符(~)：将运算对象逐位求反后生成一个新值<br>位与运算符(&amp;)：如果两个运算对象的对应位置都是1则结果中该位为1，否则为0<br>位或运算符(|)：如果两个运算对象的对应位置至少一个为1则结果中该位为1，否则为0<br>位异或运算符(^)：如果两个运算对象的对应位置有且只有一个为1则运算结果中该位为1，否则为0</p>
<p>30个学生的测验结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> quiz1 = <span class="number">0</span>;    <span class="comment">//把这个值当做位的集合</span></span><br><span class="line">quiz1 |= <span class="number">1U</span>L &lt;&lt; <span class="number">27</span>; <span class="comment">//表示第27位学生通过了测验</span></span><br><span class="line">quiz1 &amp;= ~(<span class="number">1U</span>L&lt;&lt;<span class="number">27</span>);    <span class="comment">//修正，第27位学生没有通过测验</span></span><br><span class="line"><span class="keyword">bool</span> status = quiz1 &amp; (<span class="number">1U</span>L &lt;&lt; <span class="number">27</span>);  <span class="comment">//第27位学生是否通过测验？</span></span><br></pre></td></tr></table></figure>

<h2 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a>sizeof运算符</h2><p>sizeof运算符返回一条表达式或一个类型名字所占的字节数。满足右结合律，其所得的值是一个size_t类型的常量表达式<br>两种形式： sizeof (<em>type</em>)  sizeof <em>expr</em><br>第二种形式中，sizeof返回的是表达式结果类型的大小</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Sales_data data,*p;</span><br><span class="line"><span class="keyword">sizeof</span>(Sales_data); <span class="comment">//存储Sales_data类型的对象所占空间的大小</span></span><br><span class="line"><span class="keyword">sizeof</span> data;        <span class="comment">//data类型的大小，即sizeof(Sales_data)</span></span><br><span class="line"><span class="keyword">sizeof</span> p;           <span class="comment">//指针所占空间的大小</span></span><br><span class="line"><span class="keyword">sizeof</span> *p;          <span class="comment">//p所指类型所占空间的大小，即sizeof(Sales_data)</span></span><br><span class="line"><span class="keyword">sizeof</span> data.revenue;<span class="comment">//Sales_data成员revenue的大小</span></span><br><span class="line"><span class="keyword">sizeof</span> Sales_data.revenue;  <span class="comment">//另一种获取revenue大小的方式</span></span><br></pre></td></tr></table></figure>

<p>sizeof运算符的结果部分地依赖于其作用的类型：<br>·对char类型或者类型为char的表达式执行sizeof运算，结果为1<br>·对引用类型执行sizeof运算得到被引用对象所占空间的大小<br>·对指针执行sizeof运算得到指针本身所占空间的大小<br>·对解引用指针执行sizeof运算得到指针指向的对象所占空间的大小，指针不需要有效<br>·对数组执行sizeof运算得到整个数组所占空间的大小<br>·对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">size_t</span> sz = <span class="keyword">sizeof</span>(ia)/<span class="keyword">sizeof</span>(*ia);   <span class="comment">//得到ia的元素数量</span></span><br></pre></td></tr></table></figure>

<h2 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h2><p>逗号运算符含有两个对象，按照从左到右的顺序依次求值。逗号运算符真正的结果是右侧表达式的值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sonmeValue ? ++x, ++y : --x, --y;</span><br><span class="line"><span class="comment">//等效于</span></span><br><span class="line">(sonmeValue ? ++x, ++y : --x), --y;</span><br></pre></td></tr></table></figure>

<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>int ival = 3.14 + 3;<br>3先被转换成double型，执行浮点数加法；初始化时又转换成int型</p>
<p>发生隐式转换：<br>·大多数表达式中，比int类型小的整型值先提升为表达的整数类型<br>·在条件中，非布尔类型转换成布尔类型<br>·初始化过程中，初始值转换成变量的类型；赋值语句中，右侧运算对象转换成左侧运算对象的类型<br>·如果算术运算或关系运算的运算对象有多种类型，需要转换成同一类型<br>·函数调用时也会发生转换</p>
<h3 id="算术转换"><a href="#算术转换" class="headerlink" title="算术转换"></a>算术转换</h3><p>算术转换(arithmetic conversion)的含义是把一种算术类型转换成另外一种算术类型</p>
<h4 id="整型提升"><a href="#整型提升" class="headerlink" title="整型提升"></a>整型提升</h4><p>整型提升(integral promotion)负责把小整数类型转换成较大的整数类型<br>bool,char,signed char,unsigned char,short和unsigned short等类型来说只要它们所有可能的值都能存在in里，就会提升成int类型，否则提升成unsigned int类型<br>较大的char类型(wchar_t,char16_t,char32_t)提升成int,unsigned int,long,unsigned long,long long和unsigned long long中最小的一种类型</p>
<h4 id="无符号类型的运算对象"><a href="#无符号类型的运算对象" class="headerlink" title="无符号类型的运算对象"></a>无符号类型的运算对象</h4><p><img src="https://i.loli.net/2020/11/18/WYJKbi1c4PT6xDg.png" alt="Snipaste_2020-11-18_21-38-25.png"></p>
<p><img src="https://i.loli.net/2020/11/18/oM2JHqDVK1SG7xR.png" alt="Snipaste_2020-11-18_21-38-38.png"></p>
<p><img src="https://i.loli.net/2020/11/18/zoigZMkCQcRBhGb.png" alt="Snipaste_2020-11-18_21-38-49.png"></p>
<h3 id="其它隐式类型转换"><a href="#其它隐式类型转换" class="headerlink" title="其它隐式类型转换"></a>其它隐式类型转换</h3><p>数组转换成指针；常量整数值0或字面值nullptr转换成任意类型的指针；指向任意非常量的指针能转换成void<em>；指向任意对象的指针能转换成const void</em><br>算术类型或指针转换成布尔类型；非常量类型的指针或引用转换成常量</p>
<h3 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h3><h4 id="命名的强制类型转换"><a href="#命名的强制类型转换" class="headerlink" title="命名的强制类型转换"></a>命名的强制类型转换</h4><p><em>cast-name</em>&lt;<em>type</em>&gt;(<em>expression</em>)<br>type是转换的目标类型，expression是要转换的值<br>cast-name是static_cast,dynamic_cast,const_cast,reinterpret_cast中的一种。dynamic_cast支持运行时类型识别</p>
<h4 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h4><p>任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> slope = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(j)/i;</span><br></pre></td></tr></table></figure>

<h4 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h4><p>const_cast只能改变运算对象的底层const</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* pc;</span><br><span class="line"><span class="keyword">char</span>* p = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(pc);    <span class="comment">//正确：但通过p写值是未定义的行为</span></span><br></pre></td></tr></table></figure>

<h4 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h4><p>reinterpret_cast通常为运算对象的位模式提供较低层上的重新解释</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p;</span><br><span class="line"><span class="keyword">char</span>* pc = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(p);</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/11/18/ntDfr2vgkELibe1.png" alt="Snipaste_2020-11-18_22-04-56.png"></p>
<p><img src="https://i.loli.net/2020/11/18/j4qigKCo3sO1hlf.png" alt="Snipaste_2020-11-18_22-05-18.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/11/17/ncpp-04/" data-id="ckhua8ror002jxsve866ladc5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/02-cpp-primer/" rel="tag">02 cpp primer</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-操作方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/16/%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/" class="article-date">
  <time datetime="2020-11-16T15:14:59.000Z" itemprop="datePublished">2020-11-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/16/%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/">操作方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;blog</span><br><span class="line">hexo g		&#x2F;&#x2F;生成</span><br><span class="line">hexo s		&#x2F;&#x2F;本地预览</span><br><span class="line">hexo d		&#x2F;&#x2F;部署</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/11/16/%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/" data-id="ckhua8rpu003sxsve0edi3pn3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ncpp-03" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/16/ncpp-03/" class="article-date">
  <time datetime="2020-11-16T15:11:10.000Z" itemprop="datePublished">2020-11-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/16/ncpp-03/">第3章 字符串、向量和数组</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="命名空间的using声明"><a href="#命名空间的using声明" class="headerlink" title="命名空间的using声明"></a>命名空间的using声明</h2><p>using声明(using declaration)形式：using namespace::name;<br>声明之后可以直接访问命名空间中的名字，无需专门的前缀<br>每个using声明引入命名空间中的一个成员<br>头文件不应包含using声明</p>
<h2 id="标准库类型string"><a href="#标准库类型string" class="headerlink" title="标准库类型string"></a>标准库类型string</h2><p>标准库类型string表示可变长的字符序列</p>
<h3 id="定义和初始化string对象"><a href="#定义和初始化string对象" class="headerlink" title="定义和初始化string对象"></a>定义和初始化string对象</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1;          <span class="comment">//默认初始化，s1是一个空字符串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(s1)</span></span>;</span><br><span class="line"><span class="built_in">string</span> s2 = s1;     <span class="comment">//s2是s1的副本</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s3</span><span class="params">(<span class="string">"hiya"</span>)</span></span>;</span><br><span class="line"><span class="built_in">string</span> s3 = <span class="string">"hiya"</span>; <span class="comment">//s3是该字符串字面值的副本</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(<span class="number">10</span>, <span class="string">'c'</span>)</span></span>; <span class="comment">//s4的内容是cccccccccc</span></span><br></pre></td></tr></table></figure>

<p>使用等号(= )初始化一个变量，实际上执行的是拷贝初始化(copy initialization)，编译器把等号右侧的初始值拷贝到新闯将的对象中去<br>不使用等号则执行的是直接初始化(direct initialization)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s5 = <span class="string">"hiya"</span>;</span><br><span class="line"><span class="built_in">string</span> s6 = (<span class="string">"hiya"</span>);</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s7</span><span class="params">(<span class="number">10</span>, <span class="string">'c'</span>)</span></span>;</span><br><span class="line"><span class="built_in">string</span> s8 = <span class="built_in">string</span>(<span class="number">10</span>, <span class="string">'c'</span>);    <span class="comment">//创建出一个临时string对象，拷贝给s8</span></span><br><span class="line"><span class="comment">//本质上等价于</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">temp</span><span class="params">(<span class="number">10</span>, <span class="string">'c'</span>)</span></span>;</span><br><span class="line"><span class="built_in">string</span> s8 = temp;</span><br></pre></td></tr></table></figure>

<h3 id="string对象上的操作"><a href="#string对象上的操作" class="headerlink" title="string对象上的操作"></a>string对象上的操作</h3><p><img src="https://i.loli.net/2020/11/16/YpJMt6gsc82TybF.png" alt="Snipaste_2020-11-16_22-44-00.png"></p>
<p>执行读取操作时，string对象会自动忽略开头的空白(空格符、换行符、制表符等)并从第一个真正的字符开始读起，直到遇到下一处空白为止</p>
<p>getline读取一整行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> <span class="built_in">line</span>;</span><br><span class="line"><span class="keyword">while</span> (getline(<span class="built_in">cin</span>, <span class="built_in">line</span>))</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">line</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>成员函数line.empty()根据是否为空返回对应布尔值</p>
<p>size函数返回string对象的长度。是string::size_type类型，无符号类型且能存放下任何string对象的大小<br>若n是一个负int，则s.size() &lt; n几乎肯定是true</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">"Hello"</span>, phrase = <span class="string">"Hello World"</span>, slang = <span class="string">"Hiya"</span>;</span><br><span class="line">slang &gt; phrase &gt; str</span><br></pre></td></tr></table></figure>

<h4 id="字面值和string相加"><a href="#字面值和string相加" class="headerlink" title="字面值和string相加"></a>字面值和string相加</h4><p>必须保证’+’运算符两侧运算对象至少有一个是string</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1 = <span class="string">"hello"</span>;</span><br><span class="line"><span class="built_in">string</span> s2 = s1 + <span class="string">", "</span>;              <span class="comment">//正确</span></span><br><span class="line"><span class="built_in">string</span> s3 = s1 + <span class="string">", "</span> + <span class="string">"world"</span>;    <span class="comment">//正确：(s1+", ")+"world"</span></span><br><span class="line"><span class="built_in">string</span> s4 = <span class="string">"hello"</span> + <span class="string">", "</span> + <span class="string">"s2"</span>;  <span class="comment">//错误</span></span><br><span class="line"><span class="built_in">string</span> s5 = <span class="string">"hello"</span> + <span class="string">", "</span>;         <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/11/16/2SBnUzZPQDuNRGq.png" alt="Snipaste_2020-11-16_22-45-53.png"></p>
<p>使用范围for语句改变字符串中的字符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"hello World!!!"</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : s)</span><br><span class="line">    c = <span class="built_in">toupper</span>(c); <span class="comment">//引用才可以改变值</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//HELLO WORDL!!!</span></span><br></pre></td></tr></table></figure>

<h2 id="标准库类型vector"><a href="#标准库类型vector" class="headerlink" title="标准库类型vector"></a>标准库类型vector</h2><p>标准库类型vector表示对象的集合，其中所有对象的类型都相同</p>
<h3 id="定义和初始化vector对象"><a href="#定义和初始化vector对象" class="headerlink" title="定义和初始化vector对象"></a>定义和初始化vector对象</h3><p><img src="https://i.loli.net/2020/11/16/DV6PNmQ7G5vqheB.png" alt="Snipaste_2020-11-16_22-46-57.png"></p>
<h4 id="列表初始值或元素数量"><a href="#列表初始值或元素数量" class="headerlink" title="列表初始值或元素数量"></a>列表初始值或元素数量</h4><p>通过使用花括号或圆括号来区分</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v1(<span class="number">10</span>);      <span class="comment">//10个元素，每个都是0</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v2&#123; <span class="number">10</span> &#125;;    <span class="comment">//1个元素10</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v3(<span class="number">10</span>, <span class="number">1</span>);   <span class="comment">//10个元素1</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v4&#123; <span class="number">10</span>,<span class="number">1</span> &#125;;  <span class="comment">//2个元素10和1</span></span><br><span class="line"><span class="comment">//用花括号时，若无法执行列表初始化才会考虑其他初始化方式</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;v5&#123; <span class="string">"hi"</span> &#125;;       <span class="comment">//列表初始化，有一个"hi"</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;v6(<span class="string">"hi"</span>);         <span class="comment">//错误：不能使用字符串字面值构建vector对象</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;v7&#123; <span class="number">10</span> &#125;;         <span class="comment">//10个默认初始化的元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;v8&#123; <span class="number">10</span>,<span class="string">"hi"</span> &#125;;    <span class="comment">//10个"hi" vector&lt;string&gt;v8(10 , "hi")效果相同</span></span><br></pre></td></tr></table></figure>

<h3 id="向vector对象中添加元素"><a href="#向vector对象中添加元素" class="headerlink" title="向vector对象中添加元素"></a>向vector对象中添加元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> <span class="keyword">word</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;<span class="built_in">text</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; <span class="keyword">word</span>)</span><br><span class="line">    <span class="built_in">text</span>.push_back(<span class="keyword">word</span>);</span><br></pre></td></tr></table></figure>

<p>如果循环体内包含有向vector对象添加元素的语句，则不能使用范围for循环</p>
<h3 id="其它vector操作"><a href="#其它vector操作" class="headerlink" title="其它vector操作"></a>其它vector操作</h3><p><img src="https://i.loli.net/2020/11/16/NmlJMAVwsaj6cXd.png" alt="Snipaste_2020-11-16_22-47-58.png"></p>
<p>size_type需要首先指定它是由哪种类型定义的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type  <span class="comment">//正确</span></span><br><span class="line"><span class="built_in">vector</span>::size_type       <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<p>vector对象的大小关系由第一对相异的元素值的大小关系决定</p>
<p>只能对确知已存在的元素执行下标操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;ivec;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ivec[<span class="number">0</span>];    <span class="comment">//错误：ivec不包含任何元素</span></span><br><span class="line">vecator&lt;<span class="keyword">int</span>&gt;ivec2(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ivec2[<span class="number">10</span>];  <span class="comment">//错误：ivec2的合法索引是0-9</span></span><br></pre></td></tr></table></figure>

<p>用下标的形式去访问一个不存在的元素将引发错误，不会被编译器发现，而是在运行时产生一个不可预知的值<br>缓冲区溢出(buffer overflow)指的就是这种错误</p>
<h2 id="迭代器介绍"><a href="#迭代器介绍" class="headerlink" title="迭代器介绍"></a>迭代器介绍</h2><p>迭代器提供了对对象的间接访问。<br>有效迭代器：指向某个元素或指向容器中尾元素的下一位置；其它所有情况都属于无效</p>
<h3 id="使用迭代器"><a href="#使用迭代器" class="headerlink" title="使用迭代器"></a>使用迭代器</h3><p>如果容器为空，begin和end返回的是同一个迭代器，都是尾后迭代器</p>
<h4 id="迭代器运算符"><a href="#迭代器运算符" class="headerlink" title="迭代器运算符"></a>迭代器运算符</h4><p><img src="https://i.loli.net/2020/11/16/OqUB6AsimFGxey9.png" alt="Snipaste_2020-11-16_23-52-23.png"></p>
<p>试图解引用一个非法迭代器或者尾后迭代器都是未被定义的行为</p>
<h4 id="迭代器类型"><a href="#迭代器类型" class="headerlink" title="迭代器类型"></a>迭代器类型</h4><p>拥有迭代器的标准库类型使用iterator和const_iterator来表示迭代器的类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;   <span class="comment">//it能读写vector&lt;int&gt;的元素</span></span><br><span class="line"><span class="built_in">string</span>::iterator it2;       <span class="comment">//it2能读写string对象中的元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;const_iterator it3;  <span class="comment">//it3只能读元素，不能写</span></span><br><span class="line"><span class="built_in">string</span>::const_iterator it4;     <span class="comment">//it4只能读字符，不能写</span></span><br></pre></td></tr></table></figure>

<p>如果vector或string的对象是一个常量，只能使用const_iterator；如果不是常量，则两种都能使用</p>
<h4 id="begin和end运算符"><a href="#begin和end运算符" class="headerlink" title="begin和end运算符"></a>begin和end运算符</h4><p>begin和end返回的具体类型由对象是否是常量决定</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;cv;</span><br><span class="line"><span class="keyword">auto</span> it1 = v.<span class="built_in">begin</span>();   <span class="comment">//it1的类型是vector&lt;int&gt;::iterator</span></span><br><span class="line"><span class="keyword">auto</span> it2 = cv.<span class="built_in">end</span>();    <span class="comment">//it2的类型是vector&lt;int&gt;::const_iterator</span></span><br><span class="line"><span class="keyword">auto</span> it3 = v.cbegin();  <span class="comment">//it3的类型是vector&lt;int&gt;::const_iterator</span></span><br></pre></td></tr></table></figure>

<h4 id="结合解引用和成员访问操作"><a href="#结合解引用和成员访问操作" class="headerlink" title="结合解引用和成员访问操作"></a>结合解引用和成员访问操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(*it).empty();  <span class="comment">//解引用it，然后调用结果对象的empty成员</span></span><br><span class="line">*it.empty();    <span class="comment">//错误：试图访问it的名为empty的成员</span></span><br><span class="line">                <span class="comment">//但it是个迭代器，没有empty成员</span></span><br><span class="line">it-&gt;empty();    <span class="comment">//正确：it-&gt;mem和(*it).mem相同</span></span><br></pre></td></tr></table></figure>

<h3 id="迭代器运算"><a href="#迭代器运算" class="headerlink" title="迭代器运算"></a>迭代器运算</h3><p><img src="https://i.loli.net/2020/11/17/xjFDdBJuOs5In1l.png" alt="Snipaste_2020-11-17_13-16-01.png"></p>
<p>两个迭代器相减的结果是之间的距离，是类型为difference_type的带符号整型数</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组运行时性能较好，但大小确定不变，不能随意向数组中增加元素</p>
<h3 id="定义和初始化数组"><a href="#定义和初始化数组" class="headerlink" title="定义和初始化数组"></a>定义和初始化数组</h3><p>数组是一种符合类型。数组的声明形如a[d]，其中a是数组的名字，d是数组的维度，必须大于0，必须是一个常量表达式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> cnt = <span class="number">42</span>;          <span class="comment">//不是常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">unsigned</span> sz = <span class="number">42</span>; <span class="comment">//常量表达式</span></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];                <span class="comment">//含有10个整数的数组</span></span><br><span class="line"><span class="keyword">int</span>* parr[sz];              <span class="comment">//含有42个整型指针的数组</span></span><br><span class="line"><span class="built_in">string</span> bad[cnt];            <span class="comment">//错误：cnt不是常量表达式</span></span><br><span class="line"><span class="built_in">string</span> strs[get_size()];    <span class="comment">//当get_size()是constexpr时正确，否则错误</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，数组的元素被默认初始化<br>定义数组的时候必须指定数组的类型，不允许用auto关键字<br>数组的元素应为对象，不存在引用的数组</p>
<h4 id="显式初始化数组元素"><a href="#显式初始化数组元素" class="headerlink" title="显式初始化数组元素"></a>显式初始化数组元素</h4><p>声明时没有指明维度，编译器会根据初始值的数量计算并推测出来<br>如果维度比提供的数量大，用提供的初始化靠前的元素，剩下的默认初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> sz = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> ia1[sz] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;        <span class="comment">//含有3个元素的数组</span></span><br><span class="line"><span class="keyword">int</span> a2[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;           <span class="comment">//维度是3的数组</span></span><br><span class="line"><span class="keyword">int</span> a3[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;          <span class="comment">//等价于a3[]=&#123;0,1,2,0,0&#125;</span></span><br><span class="line"><span class="built_in">string</span> a4[<span class="number">4</span>] = &#123;<span class="string">"hi"</span>, <span class="string">"bye"</span>&#125;;   <span class="comment">//等价于a4[]=&#123;"hi","bye",""&#125;</span></span><br><span class="line"><span class="keyword">int</span> a5[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;          <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<p>可以用字符串字面值对数组初始化，字符串字面值的结尾处还有一个空字符，也会被拷贝到字符数组中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a1[]=&#123; <span class="string">'C'</span>,<span class="string">'+'</span>,<span class="string">'+'</span> &#125;;          <span class="comment">//列表初始化，没有空字符，维度为3</span></span><br><span class="line"><span class="keyword">char</span> a2[] = &#123; <span class="string">'C'</span>,<span class="string">'+'</span>,<span class="string">'+'</span> ,<span class="string">'\0'</span> &#125;;  <span class="comment">//列表初始化，含有显式的空字符，维度为4</span></span><br><span class="line"><span class="keyword">char</span> a3[] = <span class="string">"C++"</span>;                  <span class="comment">//自动添加表示字符串结束的空字符，维度为4</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> a4[<span class="number">6</span>] = <span class="string">"Daniel"</span>;        <span class="comment">//错误：没有空间可存放空字符</span></span><br></pre></td></tr></table></figure>

<p>不能将数组的内容拷贝给其它数组作为初始值，也不能用数组为其它数组赋值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> a2[] = a;   <span class="comment">//错误</span></span><br><span class="line">a2 = a;         <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<h4 id="复杂的数组声明"><a href="#复杂的数组声明" class="headerlink" title="复杂的数组声明"></a>复杂的数组声明</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* ptrs[<span class="number">10</span>];          <span class="comment">//含有10个整型指针的数组</span></span><br><span class="line"><span class="keyword">int</span>&amp; refs[<span class="number">10</span>] =<span class="comment">/* ? */</span>; <span class="comment">//错误：不存在引用的数组</span></span><br><span class="line"><span class="keyword">int</span>(*Parray)[<span class="number">10</span>] = &amp;arr;<span class="comment">//Parray指向一个含有10个整数的数组</span></span><br><span class="line"><span class="keyword">int</span>(&amp;arrRef)[<span class="number">10</span>] = arr; <span class="comment">//arrRef引用一个含有10个整数的数组</span></span><br><span class="line"><span class="keyword">int</span>* (&amp;<span class="built_in">array</span>)[<span class="number">10</span>] = ptrs;<span class="comment">//arry是数组的引用，数组含有10个整型指针</span></span><br></pre></td></tr></table></figure>

<p>类型修饰符从右向左理解，ptrs：定义了一个大小为10的数组，名字是ptrs，数组存放的是int类型指针<br>Parray：括号内表明是个指针，指向大小为10的数组，数组中元素是int型</p>
<h3 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h3><p>使用数组下标时，通常定义为size_t类型，是一种机器相关的无符号类型</p>
<h3 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h3><p>在很多用到数组名字的地方，编译器会自动地将其替换为一个指向数组首元素的指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> nums[] = &#123;<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>&#125;;</span><br><span class="line"><span class="built_in">string</span>* p = &amp;nums[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">string</span>* p2 = nums;  <span class="comment">//等价于p2 = &amp;nums[0]</span></span><br></pre></td></tr></table></figure>

<p>当使用数组作为一个auto变量的初始值时，推断得到的类型是指针而非数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ia2</span><span class="params">(ia)</span></span>;   <span class="comment">//ia2是一个整型指针，指向ia的第一个元素</span></span><br><span class="line"><span class="comment">//类似于 auto ia2(&amp;ia[0])</span></span><br><span class="line">ia2 = <span class="number">42</span>;       <span class="comment">//错误：ia2是一个整型指针，不能用int值赋值</span></span><br></pre></td></tr></table></figure>

<p>使用decltype关键字时转换不会发生</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ia3是一个含有5个整数的数组</span></span><br><span class="line"><span class="keyword">decltype</span>(ia) ia3 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">ia3 = p;    <span class="comment">//错误：不能用整型指针给数组赋值</span></span><br><span class="line">ia3[<span class="number">4</span>] = i; <span class="comment">//正确：把i赋值给ia3的元素</span></span><br></pre></td></tr></table></figure>

<h4 id="指针也是迭代器"><a href="#指针也是迭代器" class="headerlink" title="指针也是迭代器"></a>指针也是迭代器</h4><p>数组的指针支持vector和string迭代器支持的全部运算<br>获取数组尾元素后元素的地址</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>* e = &amp;arr[<span class="number">5</span>];   <span class="comment">//指向arr尾元素的下一位置的指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span>* b = arr; b != e; ++b)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *b &lt;&lt; <span class="built_in">endl</span>;     <span class="comment">//输出arr的元素</span></span><br></pre></td></tr></table></figure>

<p>尾后指针不指向具体的元素，不能对其解引用或递增</p>
<h4 id="标准库函数begin和end"><a href="#标准库函数begin和end" class="headerlink" title="标准库函数begin和end"></a>标准库函数begin和end</h4><p>这两个函数不是成员函数。用数组作为它们的参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>* beg = <span class="built_in">begin</span>(ia);</span><br><span class="line"><span class="keyword">int</span>* <span class="built_in">end</span> = <span class="built_in">end</span>(ia);</span><br></pre></td></tr></table></figure>

<p>begin函数返回指向ia首元素的指针，end返回指向ia尾元素下一位置的指针</p>
<h4 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h4><p>指针加(减)某整数值，结果仍是指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">size_t</span> sz = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> arr[sz] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>* ip = arr;      <span class="comment">//等价于int* ip=&amp;arr[0]</span></span><br><span class="line"><span class="keyword">int</span>* ip2 = ip + <span class="number">4</span>;  <span class="comment">//ip2指向arr[4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* ip3 = arr + sz;<span class="comment">//指向尾元素的下一位置</span></span><br><span class="line"><span class="keyword">int</span>* ip4 = arr + <span class="number">10</span>;<span class="comment">//错误：只有5个元素，ip4的值未定义</span></span><br></pre></td></tr></table></figure>

<p>相减的结果是之间的距离，两个指针必须指向同一数组当中的元素<br>类型为ptrdiff_t，是一种机器相关的带符号类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> n = <span class="built_in">end</span>(arr) - <span class="built_in">begin</span>(arr); <span class="comment">//n=5</span></span><br></pre></td></tr></table></figure>

<p>允许给空指针加上或减去一个值为0的整型常量表达式。两个空指针允许相减，结果为0</p>
<h4 id="解引用和指针运算的交互"><a href="#解引用和指针运算的交互" class="headerlink" title="解引用和指针运算的交互"></a>解引用和指针运算的交互</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> last = *(ia+<span class="number">3</span>); <span class="comment">//last=ia[3]</span></span><br><span class="line"><span class="keyword">int</span> a = *ia + <span class="number">3</span>;    <span class="comment">//a=0+3</span></span><br></pre></td></tr></table></figure>

<p>数组使用下标运算时，编译器会将数组名字转换为指向数组首元素的指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> i = ia[<span class="number">2</span>];  <span class="comment">//i=4</span></span><br><span class="line"><span class="keyword">int</span>* p = ia;</span><br><span class="line">i = *(p+<span class="number">2</span>);     <span class="comment">//i=4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* p = &amp;ia[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> j = p[<span class="number">1</span>];   <span class="comment">//j=6</span></span><br><span class="line"><span class="keyword">int</span> k = p[<span class="number">-2</span>];  <span class="comment">//k=0</span></span><br></pre></td></tr></table></figure>

<p>内置的下标运算符不是无符号类型，与vector和string不同</p>
<h3 id="C风格字符串"><a href="#C风格字符串" class="headerlink" title="C风格字符串"></a>C风格字符串</h3><p>C风格字符串的函数<br><img src="https://i.loli.net/2020/11/17/Ryrf9zEuPhlXHn1.png" alt="Snipaste_2020-11-17_16-05-23.png"></p>
<p>传入此类函数的指针必须指向以空字符作为结束的数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ca[] = &#123;<span class="string">'C'</span>,<span class="string">'+'</span>,<span class="string">'+'</span>&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">strlen</span>(ca) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//错误：ca没有以空字符结束</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> ca1[]=&#123;<span class="string">"A string example"</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> ca2[]=&#123;<span class="string">"A different string"</span>&#125;;</span><br><span class="line"><span class="keyword">if</span>(ca1 &lt; ca2)   <span class="comment">//未定义的：试图比较两个无关的地址</span></span><br><span class="line"><span class="comment">//实际比较的是指针而非字符本身</span></span><br></pre></td></tr></table></figure>

<h3 id="与旧代码的接口"><a href="#与旧代码的接口" class="headerlink" title="与旧代码的接口"></a>与旧代码的接口</h3><p>·允许使用以空字符结束的字符数组来初始化string对象或为string对象赋值<br>·在string对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象<br>反过来不成立</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* str = s;      <span class="comment">//错误：不能用string对象初始化char*</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* str = s.c_str();    <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>

<p>允许使用数组来初始化vector对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> int_arr[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ivec</span><span class="params">(<span class="built_in">begin</span>(int_arr),<span class="built_in">end</span>(int_arr))</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">subVec</span><span class="params">(int_arr+<span class="number">1</span>,int_arr+<span class="number">3</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>多维数组其实是数组的数组</p>
<h4 id="多维数组的初始化"><a href="#多维数组的初始化" class="headerlink" title="多维数组的初始化"></a>多维数组的初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;,</span><br><span class="line">    &#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>，<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span>，<span class="number">5</span>，<span class="number">6</span>，<span class="number">7</span>，<span class="number">8</span>，<span class="number">9</span>，<span class="number">10</span>，<span class="number">11</span>&#125;；</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0</span>&#125;,&#123;<span class="number">4</span>&#125;,&#123;<span class="number">8</span>&#125;&#125;;   <span class="comment">//仅初始化每行第一个元素，其它默认初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ix[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>&#125;;   <span class="comment">//初始化第一行，其它默认初始化</span></span><br></pre></td></tr></table></figure>

<h4 id="使用范围for语句处理多维数组"><a href="#使用范围for语句处理多维数组" class="headerlink" title="使用范围for语句处理多维数组"></a>使用范围for语句处理多维数组</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;row : ia)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; col : row)&#123;</span><br><span class="line">        col = cnt;</span><br><span class="line">        ++cnt;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>外层循环是引用形式防止转换成指针，除最内层外，都应是引用类型</p>
<h4 id="指针和多维数组"><a href="#指针和多维数组" class="headerlink" title="指针和多维数组"></a>指针和多维数组</h4><p>当程序使用多维数组的名字时，也会自动将其转换成指向数组首元素的指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> (*p)[<span class="number">4</span>] = ia;   <span class="comment">//p指向含有4个整数的数组</span></span><br><span class="line">p = &amp;ia[<span class="number">2</span>];         <span class="comment">//p指向ia的尾元素</span></span><br><span class="line"><span class="comment">//声明中的圆括号不可少</span></span><br><span class="line"><span class="keyword">int</span>* ip[<span class="number">4</span>];     <span class="comment">//整型指针的数组</span></span><br><span class="line"><span class="keyword">int</span> (*ip)[<span class="number">4</span>];   <span class="comment">//指向含有4个整数的数组</span></span><br></pre></td></tr></table></figure>

<p>通过使用auto或decltype能尽可能地在数组前加上指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//p指向含有4个整数的数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> p = ia; p != ia+<span class="number">3</span>; ++p)&#123;</span><br><span class="line">    <span class="comment">//q指向4个整数数组的首元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> q = *p; q != p+<span class="number">4</span>; ++q)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *q &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> p = <span class="built_in">begin</span>(ia); p != <span class="built_in">end</span>(ia); ++p)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> q = <span class="built_in">begin</span>(*p); q != <span class="built_in">end</span>(*p); ++q)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *q &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/11/16/ncpp-03/" data-id="ckhua8rot002pxsve5mby477s" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/02-cpp-primer/" rel="tag">02 cpp primer</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ncpp-02" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/16/ncpp-02/" class="article-date">
  <time datetime="2020-11-16T14:56:31.000Z" itemprop="datePublished">2020-11-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/16/ncpp-02/">第2章 变量和基本类型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h1><p>算术类型(arithmetic)，包括字符、整型数、布尔值和浮点数。<br>空类型(void)不对应具体的值，仅用于一些特殊场合</p>
<h2 id="算术类型"><a href="#算术类型" class="headerlink" title="算术类型"></a>算术类型</h2><p>分为整型(integral type，包括字符和布尔类型等)和浮点型<br><img src="https://i.loli.net/2020/11/16/X5dCpOBoTg2ElNY.png" alt="Snipaste_2020-11-16_22-58-27.png"></p>
<p>通过在带符号的类型int, short, long long前添加unsigned就可以得到无符号类型<br>unsigned int可以缩写为unsigned<br>无符号仅能表示大于等于0的值</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsigned char c &#x3D; -1;	&#x2F;&#x2F;假设char占8比特，c的值为255</span><br><span class="line">signed char c2 &#x3D; 256;	&#x2F;&#x2F;假设char占8比特，c2的值是未定义的</span><br></pre></td></tr></table></figure>
<p>·把非布尔类型的算术值赋给布尔类型时，初始值为0则为false，否则为true。<br>·把布尔类型赋给非布尔类型时，初始值为false则结果为0，true则结果为1。<br>·把浮点数赋给整数类型时，结果值仅保留小数点之前部分。<br>·把整数值赋给浮点类型时，小数部分记为0。若该整数所占空间超过浮点数容量，精度可能损失。<br>·赋给无符号类型一个超过它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。<br>·赋给带符号类型超出表示范围的值时，结果是未定义的(undefined)。程序可能继续工作、崩溃，也可能产生垃圾数据。</p>
<p>当算术表达式中既有无符号数又有int时，int会转换成无符号数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">unsigned u &#x3D; 10,u2&#x3D;42;</span><br><span class="line">int i &#x3D; -42;</span><br><span class="line">cout &lt;&lt; u + i &lt;&lt; endl;	&#x2F;&#x2F;如果int占32位，输出4294967264</span><br><span class="line">cout &lt;&lt; u - u2 &lt;&lt; endl;	&#x2F;&#x2F;输出4294967264</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;错误：u永远不会小于0，循环条件一直成立</span><br><span class="line">for (unsigned u &#x3D; 10; u &gt;&#x3D; 0; --u)</span><br><span class="line">	cout &lt;&lt; u &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h3 id="字面值常量"><a href="#字面值常量" class="headerlink" title="字面值常量"></a>字面值常量</h3><p>字面值常量的形式和值决定了它的数据类型</p>
<h3 id="整型和浮点型字面值"><a href="#整型和浮点型字面值" class="headerlink" title="整型和浮点型字面值"></a>整型和浮点型字面值</h3><p>整型字面值具体的数据类型由它的值和符号决定。默认情况下，十进制字面值是带符号数，八和十六进制字面值既可能是带符号的也可能是无符号的。<br>类型是满足容纳的条件下尺寸最小的。<br>默认浮点型字面值是double<br>用后缀来表示字面值类型</p>
<p><img src="https://i.loli.net/2020/11/16/Kaif5PYEUgQILlt.png" alt="Snipaste_2020-11-16_22-59-22.png"></p>
<h3 id="字符和字符串字面值"><a href="#字符和字符串字面值" class="headerlink" title="字符和字符串字面值"></a>字符和字符串字面值</h3><p>单引号括起来的一个字符称为char型字面值，双引号括起来的零个或多个字符构成字符串型字面值<br>字符串字面值的类型是由常量字符构成的数组<br>编译器在每个字符串的结尾处添加一个空字符(‘\0’)，实际长度比内容多1</p>
<h3 id="转义序列"><a href="#转义序列" class="headerlink" title="转义序列"></a>转义序列</h3><p>两类字符串不能直接使用：不可打印(nonprintable)的字符，如退格，没有可视的图符；有特殊含义的字符(单双引号等)。<br>此时需要用到转义序列</p>
<p><img src="https://i.loli.net/2020/11/16/Qg3GkSIYhUPA7Ev.png" alt="Snipaste_2020-11-16_23-00-13.png"></p>
<h3 id="指定字面值的类型"><a href="#指定字面值的类型" class="headerlink" title="指定字面值的类型"></a>指定字面值的类型</h3><p>通过添加前缀和后缀，可以改变整型、浮点型和字符型字面值的默认类型<br>L’a’;        //宽字符型字面值，类型是wchar_t<br>u8”hi!”;    //utf-8字符串字面值<br>42ULL;        //无符号整型字面值，类型是unsigned long long</p>
<p>nullptr是指针字面值</p>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>变量提供一个具名的、可供程序操作的存储空间，数据类型决定着变量所占内存空间的大小和布局方式、该空间能储存的值的范围，以及变量能参与的运算。</p>
<h2 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h2><p>首先是类型说明符(type specifier)，随后紧跟由一个或多个变量名组成的列表，以逗号分隔，以分号结束。<br>string book(“aasf”);//book通过一个string字面值初始化</p>
<h3 id="初始值"><a href="#初始值" class="headerlink" title="初始值"></a>初始值</h3><p>当对象在创建时获得了一个特定的值，我们是这个对象被初始化(initialized)了<br>当一次定义了多个变量时，对象的名字随着定义也就马上可以使用了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;正确，price先被定义并赋值，随后被用于初始化discount</span><br><span class="line">double price &#x3D; 109.99, discount &#x3D; price * 0.16;</span><br></pre></td></tr></table></figure>
<p>初始化的含义是创建变量时赋予一个初始值，赋值是把对象的当前值擦除，而以一个新值来替代</p>
<h3 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int units_sold &#x3D; 0;</span><br><span class="line">int units_sold &#x3D; &#123; 0 &#125;;</span><br><span class="line">int units_sold&#123; 0 &#125;;</span><br><span class="line">int units_sold(0);</span><br></pre></td></tr></table></figure>
<p>列表初始化(list initialization)时，若初始值存在丢失信息的风险，则编译器将报错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">long double ld &#x3D; 3.1415926536;</span><br><span class="line">int a&#123; ld &#125;, b &#x3D; &#123; ld &#125;;	&#x2F;&#x2F;错误：转换未执行，因为存在丢失信息的危险</span><br><span class="line">int c(ld), d &#x3D; ld;			&#x2F;&#x2F;正确：转换执行，且确实丢失了部分值</span><br><span class="line"></span><br><span class="line">### 默认初始化</span><br><span class="line">定义变量时没有指定初始值，则变量被默认初始化(default initialized)，被赋予默认值，由类型和位置决定</span><br><span class="line">定义于函数外的内置类型默认初始化为0。函数体内部的内置类型变量将不被初始化(uninitialized)。未被初始化的内置类型变量的值是未定义的，访问此类值将引发错误。</span><br><span class="line"></span><br><span class="line">## 变量声明和定义</span><br></pre></td></tr></table></figure>
<p>extern int i;                //声明而非定义i<br>int j;                        //声明并定义j<br>extern double pi = 3.1416;    //定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">在函数体内部，初始化一个由extern关键字标记的变量将引发错误</span><br><span class="line">变量只能被定义一次，可以被多次声明</span><br><span class="line"></span><br><span class="line">extern可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。此外extern也可用来进行链接指定。</span><br><span class="line"></span><br><span class="line">### 标识符</span><br><span class="line">标识符(identifier)由字母、数字和下画线组成，必须以字母或下画线开头</span><br><span class="line">不能连续出现两个下画线，不能以下画线紧连大写字母开头，定义在函数体外的标识符不能以下画线开头</span><br><span class="line"></span><br><span class="line">## 名字的作用域 </span><br><span class="line">名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结束</span><br><span class="line"></span><br><span class="line">### 嵌套的作用域</span><br></pre></td></tr></table></figure>
<p>int reused = 42;<br>int main() {<br>    int unique = 0;<br>    cout &lt;&lt; reused &lt;&lt; “ “ &lt;&lt; unique &lt;&lt; endl;    //42 0<br>    int reused = 0;<br>    cout &lt;&lt; reused &lt;&lt; “ “ &lt;&lt; unique &lt;&lt; endl;    //0 0<br>    cout &lt;&lt; ::reused &lt;&lt; “ “ &lt;&lt; unique &lt;&lt; endl;    //42 0<br>}</p>
<h1 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h1><p>复合类型(compund type)是指基于其它类型定义的类型。<br>一条声明语句由一个基本数据类型(base type)和紧随其后的一个声明符(declarator)列表组成。每个声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>引用(reference)为对象起了另一个名字，引用类型引用(refer to)另外一种类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int ival &#x3D; 1024;</span><br><span class="line">int&amp; refVal &#x3D; ival;	&#x2F;&#x2F;refVal指向ival</span><br><span class="line">int&amp; refVal12;		&#x2F;&#x2F;报错：引用必须被初始化</span><br></pre></td></tr></table></figure>
<p>定义引用时，程序吧引用和它的初始值绑定(bind)在一起，而不是将初始值拷贝给引用。无法令引用重新绑定到另一个对象，引用必须初始化<br>引用本身不是一个对象，不能定义引用的引用</p>
<p>允许在一条语句中定义多个引用，其中每个引用标识符都必须以&amp; 开头</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D; 1024, i2 &#x3D; 2048;	&#x2F;&#x2F;i和i2都是int</span><br><span class="line">int&amp; r &#x3D; i, r2 &#x3D; i2;		&#x2F;&#x2F;r是引用，r2是int</span><br><span class="line">int i3 &#x3D; 1024, &amp; ri &#x3D; i3;	</span><br><span class="line">int&amp; r3 &#x3D; i3, &amp; r4 &#x3D; i2;</span><br><span class="line">int&amp; refVal4 &#x3D; 10;		&#x2F;&#x2F;错误：引用类型的初始值必须是一个对象</span><br><span class="line">double dval &#x3D; 3.14;</span><br><span class="line">int&amp; refVal &#x3D; dval;		&#x2F;&#x2F;错误：此处引用类型的初始值必须是int对象</span><br></pre></td></tr></table></figure>

<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>指针(pointer)是“指向(point to)”另外一种类型的复合类型<br>指针本身就是一个对象，允许对指针赋值和拷贝，生命周期内可以先后指向几个不同的对象<br>指针无须在定义时赋值<br>在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int ival &#x3D; 42;</span><br><span class="line">int* p &#x3D; &amp;ival;	&#x2F;&#x2F;p存放变量ival的地址，或者说p是指向变量ival的指针</span><br><span class="line"></span><br><span class="line">double dval;</span><br><span class="line">double* pd &#x3D; &amp;dval;	&#x2F;&#x2F;正确：初始值double型对象的地址</span><br><span class="line">double* pd2 &#x3D; pd;	&#x2F;&#x2F;正确：初始值是指向double对象的指针</span><br><span class="line"></span><br><span class="line">int* pi &#x3D; pd;	&#x2F;&#x2F;错误：指针pi的类型和pd的不匹配</span><br><span class="line">pi &#x3D; &amp;dval;		&#x2F;&#x2F;错误：试图把double型对象的地址赋给int型指针</span><br></pre></td></tr></table></figure>
<p>对指针解引用会得出所指对象</p>
<h3 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h3><p>空指针(null pointer)不指向任何对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int* p1 &#x3D; nullptr;	&#x2F;&#x2F;等价于int* p1&#x3D;0</span><br><span class="line">int* p2 &#x3D; 0;		&#x2F;&#x2F;直接将p2初始化为字面常量0</span><br><span class="line">int* p3 &#x3D; NULL;		&#x2F;&#x2F;等价于int* p3&#x3D;0</span><br></pre></td></tr></table></figure>
<p>两个指针相等：都为空、都指向同一个对象、都指向同一个对象的下一个地址</p>
<h3 id="void-指针"><a href="#void-指针" class="headerlink" title="void*指针"></a>void*指针</h3><p>void* 指针可用于存放任意对象的地址，但对地址中对象类型并不了解<br>只能和别的指针比较、作为函数的输入或输出、赋给另一个void* 指针。不能直接操作void* 指针所指的对象</p>
<h3 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int ival &#x3D; 1024;	</span><br><span class="line">int* pi &#x3D; &amp;ival;	&#x2F;&#x2F;pi指向一个int型的数</span><br><span class="line">int** ppi &#x3D; &amp;pi;	&#x2F;&#x2F;ppi指向一个int型的指针</span><br></pre></td></tr></table></figure>

<h3 id="指向指针的引用"><a href="#指向指针的引用" class="headerlink" title="指向指针的引用"></a>指向指针的引用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D; 42;</span><br><span class="line">int* p;		&#x2F;&#x2F;p是一个int型的指针</span><br><span class="line">int*&amp; r &#x3D; p;&#x2F;&#x2F;r是对指针p的引用</span><br><span class="line"></span><br><span class="line">r &#x3D; &amp;i;		&#x2F;&#x2F;r引用了一个指针，因此给r赋值&amp;i就是令p指向i</span><br><span class="line">*r &#x3D; 0;		&#x2F;&#x2F;解引用r得到i，也就是p指向的对象，将i值改为0</span><br></pre></td></tr></table></figure>
<p>从右向左读r的定义，最近的&amp; 对r有最直接的影响，所以r是一个引用，* 说明r引用的是一个指针，int表示是一个int型指针</p>
<h1 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h1><p>const对象一旦创建后值不能改变，必须初始化</p>
<p>默认状态下，const对象仅在文件内有效</p>
<p>想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;file_1.cc定义并初始化了一个常量，该常量能被其它文件访问</span><br><span class="line">extern const int bufSize &#x3D; fcn();</span><br><span class="line">&#x2F;&#x2F;file_1.h头文件</span><br><span class="line">extern const int bufSize;	&#x2F;&#x2F;与file_1.cc中定义的bufSize是同一个</span><br></pre></td></tr></table></figure>

<h2 id="const的引用"><a href="#const的引用" class="headerlink" title="const的引用"></a>const的引用</h2><p>可以把引用绑定到const对象上，称为对常量的引用(reference to const)。对常量的引用不能被用作修改它所绑定的对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const int ci &#x3D; 1024;	</span><br><span class="line">const int&amp; r1 &#x3D; ci;	&#x2F;&#x2F;正确：引用及其对应的对象都是常量</span><br><span class="line">r1 &#x3D; 42;			&#x2F;&#x2F;错误：r1是对常量的引用</span><br><span class="line">int&amp; r2 &#x3D; ci;		&#x2F;&#x2F;错误：试图让一个非常量引用指向一个常量对象</span><br></pre></td></tr></table></figure>

<h3 id="初始化和对const的引用"><a href="#初始化和对const的引用" class="headerlink" title="初始化和对const的引用"></a>初始化和对const的引用</h3><p>引用的类型必须与其所引用的对象类型一直，例外：<br>初始化常量引用时允许用任意表达式作为初始值，只要能转换成引用的类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D; 42;</span><br><span class="line">const int&amp; r1 &#x3D; i;		&#x2F;&#x2F;允许将const int&amp;绑定到一个普通int对象上</span><br><span class="line">const int&amp; r2 &#x3D; 42;		&#x2F;&#x2F;正确：r2是一个常量引用</span><br><span class="line">const int&amp; r3 &#x3D; r1 * 2;	&#x2F;&#x2F;正确</span><br><span class="line">int&amp; r4 &#x3D; r1 * 2;		&#x2F;&#x2F;错误：r4是一个普通的非常量引用</span><br></pre></td></tr></table></figure>

<p>对const的引用可能引用一个并非const的对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D; 42;</span><br><span class="line">int&amp; r1 &#x3D; i;		&#x2F;&#x2F;引用r1绑定对象i</span><br><span class="line">const int&amp; r2 &#x3D; i;	&#x2F;&#x2F;r2也绑定对象i，但不允许通过r2修改i的值</span><br><span class="line">r1 &#x3D; 0;				&#x2F;&#x2F;r1并非常量，i的值修改为0</span><br><span class="line">r2 &#x3D; 0;				&#x2F;&#x2F;错误：r2是一个常量引用</span><br></pre></td></tr></table></figure>

<h2 id="指针和const"><a href="#指针和const" class="headerlink" title="指针和const"></a>指针和const</h2><p>指向常量的指针(pointer to const)不能用于改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const double pi &#x3D; 3.14;</span><br><span class="line">double* ptr &#x3D; &amp;pi;			&#x2F;&#x2F;错误：ptr是一个普通指针</span><br><span class="line">const double* cptr &#x3D; &amp;pi;	&#x2F;&#x2F;正确：cptr可以指向一个双精度常量</span><br><span class="line">*cptr &#x3D; 42;					&#x2F;&#x2F;错误：不能给*cptr赋值</span><br><span class="line"></span><br><span class="line">double dval &#x3D; 3.14;	</span><br><span class="line">cptr &#x3D; &amp;dval;		&#x2F;&#x2F;正确：但是不能通过cptr改变dval的值</span><br></pre></td></tr></table></figure>

<h3 id="const指针"><a href="#const指针" class="headerlink" title="const指针"></a>const指针</h3><p>常量指针(const pointer)必须初始化，且它的值不能改变。不变的是指针本身，而非指向的那个值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int errNumb &#x3D; 0;</span><br><span class="line">int* const curErr &#x3D; &amp;errNumb;	&#x2F;&#x2F;curErr将一直指向errNumb</span><br><span class="line">const double pi - 3.14159;</span><br><span class="line">const double* const pip &#x3D; &amp;pi;	&#x2F;&#x2F;pip是一个指向常量的常量指针</span><br><span class="line"></span><br><span class="line">*pip &#x3D; 2.72;	&#x2F;&#x2F;错误：pip是一个指向常量的指针</span><br><span class="line"></span><br><span class="line">if (*curErr) &#123;</span><br><span class="line">	errorHandler();</span><br><span class="line">	*curErr &#x3D; 0;	&#x2F;&#x2F;正确：把curErr所指的对象重置</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从右向左看，curErr是一个常量，是一个常量指针，是一个指向int型的常量指针</p>
<h2 id="顶层const"><a href="#顶层const" class="headerlink" title="顶层const"></a>顶层const</h2><p>顶层const(top - level const)表示指针本身是个常量，底层const(low - level const)表示指针所指的对象是个常量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D; 0;</span><br><span class="line">int* const p1 &#x3D; &amp;i;			&#x2F;&#x2F;不能改变p1的值，顶层const</span><br><span class="line">const int ci &#x3D; 42;			&#x2F;&#x2F;不能改变ci的值，顶层const</span><br><span class="line">const int* p2 &#x3D; &amp;ci;		&#x2F;&#x2F;允许改变p2的值，底层const</span><br><span class="line">const int* const p3 &#x3D; p2;	&#x2F;&#x2F;靠右的是顶层，左是低层</span><br><span class="line">const int&amp; r &#x3D; ci;			&#x2F;&#x2F;用于声明引用的const都是底层const</span><br><span class="line"></span><br><span class="line">i &#x3D; ci;		&#x2F;&#x2F;正确：ci是一个顶层const，对此操作无影响</span><br><span class="line">p2 &#x3D; p3;	&#x2F;&#x2F;正确：p2和p3指向的对象类型相同，p3顶层const的部分不影响</span><br><span class="line"></span><br><span class="line">int* p &#x3D; p3;		&#x2F;&#x2F;错误：p3包含底层const的定义，而p没有</span><br><span class="line">p2 &#x3D; p3;			&#x2F;&#x2F;正确：p2和p3都是底层const</span><br><span class="line">p2 &#x3D; &amp;i;			&#x2F;&#x2F;正确：int*能转换成const int*</span><br><span class="line">int&amp; r &#x3D; ci;		&#x2F;&#x2F;错误：普通的int&amp;不能绑定到int常量上</span><br><span class="line">const int&amp; r2 &#x3D; i;	&#x2F;&#x2F;正确：const int&amp;可以绑定到一个普通int上</span><br></pre></td></tr></table></figure>

<h2 id="constexpr和常量表达式"><a href="#constexpr和常量表达式" class="headerlink" title="constexpr和常量表达式"></a>constexpr和常量表达式</h2><p>常量表达式(const expression)是指值不会改变并且在编译过程就能得到计算结果的表达式<br>一个对象(或表达式)是不是常量表达式由它的数据类型和初始值共同决定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const int max_files &#x3D; 20;			&#x2F;&#x2F;max_files是常量表达式</span><br><span class="line">const int limit &#x3D; max_files + 1;	&#x2F;&#x2F;limit是常量表达式</span><br><span class="line">int staff_size &#x3D; 27;				&#x2F;&#x2F;staff_size不是常量表达式</span><br><span class="line">cosnt int sz &#x3D; get_size();			&#x2F;&#x2F;sz不是常量表达式，值到运行时才能获取到</span><br></pre></td></tr></table></figure>

<p>允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式<br>声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">constexpr int mf &#x3D; 20;			&#x2F;&#x2F;20是常量表达式</span><br><span class="line">constexpr int limit &#x3D; mf + 1;	&#x2F;&#x2F;mf+1是常量表达式</span><br><span class="line">constexpr int sz &#x3D; size();		&#x2F;&#x2F;只有当size是一个constexpr函数时才是一条正确的声明语句</span><br></pre></td></tr></table></figure>

<p>一个constexpr指针的初始值必须是nullptr或0，或是存储于某个固定地址中的对象<br>函数体内定义的变量一般并非存放在固定的地址中，定义于所有函数体之外的对象其地址固定不变</p>
<p>在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与所指对象无关<br>constexpr指针既可以指向常量也可以指向非常量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const int* p &#x3D; nullptr;		&#x2F;&#x2F;p是一个指向整型常量的指针</span><br><span class="line">constexpr int* q &#x3D; nullptr;	&#x2F;&#x2F;q是一个指向整数的常量指针</span><br></pre></td></tr></table></figure>

<h1 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h1><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>类型别名(type alias)是一个名字，是某种类型的同义词</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef double wages;		&#x2F;&#x2F;wage是double的同义词</span><br><span class="line">typedef wages base, * p;	&#x2F;&#x2F;base是double的同义词，p是double*的同义词</span><br><span class="line"></span><br><span class="line">using SI &#x3D; Sales_item;		&#x2F;&#x2F;SI是Sales_item的同义词</span><br><span class="line"></span><br><span class="line">typedef cahr* pstring;</span><br><span class="line">const pstring cstr &#x3D; 0;	&#x2F;&#x2F;cstr是指向char的常量指针</span><br><span class="line">&#x2F;&#x2F;const是对给定类型的修饰，数据类型都是const pstring，pstring是指向char的指针</span><br><span class="line">&#x2F;&#x2F;因此，const pstring是指向char的常量指针，而非指向常量字符的指针</span><br><span class="line">const pstring* ps;		&#x2F;&#x2F;ps是一个指针，它的对象是指向char的常量指针</span><br><span class="line">const char* cstr &#x3D; 0;	&#x2F;&#x2F;是对const pstring cstr&#x3D;0的错误理解</span><br></pre></td></tr></table></figure>

<h2 id="auto类型说明符"><a href="#auto类型说明符" class="headerlink" title="auto类型说明符"></a>auto类型说明符</h2><p>auto类型说明符让编译器通过初始值来推算变量的类型。auto定义的变量必须有初始值<br>auto也能在一条语句中声明多个变量，所有变量的初始基本数据类型必须一样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;由val1和val2想家的结果可以推断出item的类型</span><br><span class="line">auto item &#x3D; val1 + val2;	&#x2F;&#x2F;item初始化为val1和val2相加的结果</span><br><span class="line"></span><br><span class="line">auto i &#x3D; 0, * p &#x3D; &amp;i;	&#x2F;&#x2F;正确：i是整数，p是整型指针</span><br><span class="line">auto sz &#x3D; 0, pi &#x3D; 3.14;	&#x2F;&#x2F;错误：类型不一致</span><br></pre></td></tr></table></figure>

<p>编译器会适当地改变结果类型使其更符合初始化规则。引用做初始值时，真正参与初始化的是引用对象的值，此时编译器以引用对象的类型作为auto的类型<br>auto一般会忽略掉顶层const，保留底层const</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D; 0, &amp; r &#x3D; i;</span><br><span class="line">auto a &#x3D; r;		&#x2F;&#x2F;a是一个整数</span><br><span class="line"></span><br><span class="line">const int ci &#x3D; i, &amp; cr &#x3D; ci;</span><br><span class="line">auto b &#x3D; ci;	&#x2F;&#x2F;b是一个整数</span><br><span class="line">auto c &#x3D; cr;	&#x2F;&#x2F;c是一个整数</span><br><span class="line">auto d &#x3D; &amp;i;	&#x2F;&#x2F;d是一个整型指针</span><br><span class="line">auto e &#x3D; &amp;ci;	&#x2F;&#x2F;e是一个指向整数常量的指针</span><br><span class="line"></span><br><span class="line">const auto f &#x3D; ci;	&#x2F;&#x2F;f是const int</span><br><span class="line"></span><br><span class="line">auto&amp; g &#x3D; ci;		&#x2F;&#x2F;g是一个整型常量引用，绑定到ci</span><br><span class="line">auto&amp; h &#x3D; 42;		&#x2F;&#x2F;错误：不能为非常量引用绑定字面值</span><br><span class="line">const auto&amp; j &#x3D; 42;	&#x2F;&#x2F;正确：可以为常量引用绑定字面值</span><br><span class="line"></span><br><span class="line">auto&amp; n &#x3D; i, * p2 &#x3D; &amp;ci;	&#x2F;&#x2F;错误：i的类型是int，而&amp;ci类型是const int</span><br></pre></td></tr></table></figure>

<h2 id="decltype类型指示符"><a href="#decltype类型指示符" class="headerlink" title="decltype类型指示符"></a>decltype类型指示符</h2><p>decltype的作用是选择并返回操作数的数据类型。编译器分析表达式并得到它的类型，却不实际计算表达式的值<br>如果decltype使用的表达式是一个变量，则返回该变量的类型(包括顶层const和引用在内)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">decltype(f()) sum &#x3D; x;	&#x2F;&#x2F;sum的类型是函数f的返回类型</span><br><span class="line"></span><br><span class="line">const int ci &#x3D; 0, &amp; cj &#x3D; ci;</span><br><span class="line">decltype(ci) x &#x3D; 0;	&#x2F;&#x2F;x的类型是const int</span><br><span class="line">decltype(cj) y &#x3D; x;	&#x2F;&#x2F;y的类型是const int&amp;，y绑定到变量x</span><br><span class="line">decltype(cj) z;		&#x2F;&#x2F;错误：z是一个引用，必须初始化</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;decltype的结果可以是引用类型</span><br><span class="line">int i &#x3D; 42, * p &#x3D; &amp;i, &amp; r &#x3D; i;</span><br><span class="line">decltype(r + 0) b;	&#x2F;&#x2F;正确：加法的结果是int，因此b是一个未初始化的int</span><br><span class="line">decltype(*p) c;		&#x2F;&#x2F;错误：c是int&amp;，必须初始化</span><br></pre></td></tr></table></figure>
<p>表达式的内容是解引用操作，则decltype将得到引用类型。decltype(*p)的结果类型是int&amp; ，而非int</p>
<p>如果变量名加上了一对括号，则得到的类型与不加括号时会有不同。<br>不加括号的变量，得到的结果就是该变量的类型；<br>给变量加上一层或多层括号，编译器会把它当做一个表达式。变量是一种可以作为赋值语句左值的特殊表达式，所以这样的decltype就会得到引用类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">decltype((i)) d;	&#x2F;&#x2F;错误：d是int&amp;，必须初始化</span><br><span class="line">decltype(i) e;		&#x2F;&#x2F;正确：e是一个未初始化的int</span><br></pre></td></tr></table></figure>
<p>decltype((variable))的结果永远是引用，而decltype(variable)结果只有当variable本身就是一个引用才是引用</p>
<p>##预处理器概述<br>预处理器(preprocessor)是在编译之前执行的一段程序，可以部分地改变所写的程序<br>当预处理器看到#include标记时就会用指定的头文件的内容代替#include<br>头文件保护符(header guard)依赖于预处理变量。预处理变量有两种状态：已定义和未定义<br>#define指令把一个名字设定为预处理变量；#ifdef仅当变量已定义时为真，#ifndef仅当变量未定义时为真<br>一旦检查结果为真，执行后续操作直到遇到#endif为止<br>预处理变量无视C++语言中关于作用域的规则</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/11/16/ncpp-02/" data-id="ckhua8roq002gxsve9483c1v4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/02-cpp-primer/" rel="tag">02 cpp primer</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/02-cpp-primer/" rel="tag">02 cpp primer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c-primer/" rel="tag">c++ primer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cocos2d-x/" rel="tag">cocos2d-x</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpp-notes/" rel="tag">cpp notes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/problem-library/" rel="tag">problem library</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reading-notes-DS/" rel="tag">reading notes DS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%82%93%E4%BF%8A%E8%BE%89/" rel="tag">数据结构 邓俊辉</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/02-cpp-primer/" style="font-size: 15px;">02 cpp primer</a> <a href="/tags/c-primer/" style="font-size: 17.5px;">c++ primer</a> <a href="/tags/cocos2d-x/" style="font-size: 12.5px;">cocos2d-x</a> <a href="/tags/cpp-notes/" style="font-size: 20px;">cpp notes</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/problem-library/" style="font-size: 15px;">problem library</a> <a href="/tags/reading-notes-DS/" style="font-size: 10px;">reading notes DS</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%82%93%E4%BF%8A%E8%BE%89/" style="font-size: 17.5px;">数据结构 邓俊辉</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/08/06/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B81/">c++ primer 04 表达式</a>
          </li>
        
          <li>
            <a href="/2020/11/23/ncpp-09/">第9章 顺序容器</a>
          </li>
        
          <li>
            <a href="/2020/11/22/ncpp-08/">ncpp-08</a>
          </li>
        
          <li>
            <a href="/2020/11/20/ncpp-07/">第7章 类</a>
          </li>
        
          <li>
            <a href="/2020/11/19/ncpp-06/">第6章 函数</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-ncpp-06" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/19/ncpp-06/" class="article-date">
  <time datetime="2020-11-19T05:08:47.000Z" itemprop="datePublished">2020-11-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/19/ncpp-06/">第6章 函数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>函数是一个命名了的代码块，通过调用函数执行相应的代码</p>
<h2 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h2><p>一个典型的函数(function)定义包括：返回类型(return type)、函数名字、由0个或多个形参(parameter)组成的列表以及函数体<br>通过调用运算符(call operator，())来执行函数<br>它作用于一个表达式，该表达式是函数或者指向函数的指针；圆括号内是实参(argument)列表，用实参初始化函数的形参。调用表达式的类型就是函数的返回类型</p>
<h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><p>函数的调用完成两项工作：用实参初始化函数对应的形参；将控制权转移给被调用的函数。此时主调函数(calling function)的执行被暂时中断，被调函数(called function)开始执行<br>return语句结束函数执行过程。返回return语句中的值(如果有)；将控制权从被调函数转移回主调函数</p>
<h4 id="形参和实参"><a href="#形参和实参" class="headerlink" title="形参和实参"></a>形参和实参</h4><p>实参是形参的初始值。没有规定实参的求值顺序，编译器能以任意可行的顺序对实参求值。形参一定会被初始化<br>函数的形参列表可以为空但不能省略</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;&#125;     <span class="comment">//隐式地定义空形参列表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;&#125; <span class="comment">//显式地定义空形参列表</span></span><br></pre></td></tr></table></figure>

<p>形参列表中的形参通常用逗号隔开，每个形参都是含有一个声明符的声明</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f3</span><span class="params">(<span class="keyword">int</span> v1,v2)</span></span>&#123;&#125;;    <span class="comment">//错误</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f4</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span></span>&#123;&#125;; <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>

<p>任意两个形参都不能同名，函数最外层作用域中的局部变量也不能使用与函数形参一样的名字</p>
<h4 id="函数返回值类型"><a href="#函数返回值类型" class="headerlink" title="函数返回值类型"></a>函数返回值类型</h4><p>void返回类型表示函数不返回任何值<br>返回类型不能是数组或函数类型，但可以是指向数组或函数的指针</p>
<h3 id="局部对象"><a href="#局部对象" class="headerlink" title="局部对象"></a>局部对象</h3><p>名字的作用域是程序文本的一部分，名字在其中可见<br>对象的生命周期是程序执行过程中该对象存在的一段时间</p>
<p>形参和函数体内部定义的变量统称为局部变量(local variable)。仅在函数的作用域内可见。局部变量还会隐藏在外层作用域中同名的其他所有声明中</p>
<h4 id="自动对象"><a href="#自动对象" class="headerlink" title="自动对象"></a>自动对象</h4><p>把只存在于块执行期间的对象称为自动对象(automatic object)</p>
<h4 id="局部静态对象"><a href="#局部静态对象" class="headerlink" title="局部静态对象"></a>局部静态对象</h4><p>局部静态对象(local static object)在程序的执行路径进第一次经过对象定义语句是初始化，并且直到程序终止才被销毁<br>可以将局部对象定义成static类型从而获得这样的对象</p>
<h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>函数只能定义一次， 但可以声明多次。声明无须函数体</p>
<p>函数和变量应在头文件中声明在源文件中定义<br>把函数的声明直接放在源文件中是合法的，但繁琐且容易出错；放在头文件中能确保同一函数的所有声明保持一致。且一旦想改变函数的接口，只需改变一条声明即可</p>
<h3 id="分离式编译"><a href="#分离式编译" class="headerlink" title="分离式编译"></a>分离式编译</h3><p>分离式编译(separate compilation)允许把程序分个到几个文件中去，每个文件独立编译</p>
<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>形参的类型决定了形参和实参的交互方法<br>形参是引用类型时，它对应的实参被引用传递(passed by reference)或者函数被传引用调用(called by reference)。它将绑定到对应的实参上。<br>当实参的值被拷贝给形参时，形参和实参是两个互相独立的对象。叫实参被值传递(passed by value)或者函数被传值调用(called by value)</p>
<h3 id="传值参数"><a href="#传值参数" class="headerlink" title="传值参数"></a>传值参数</h3><p>当初始化一个非引用类型的变量时，初始值被拷贝给变量。此时，对变量的改动不会影响初始值</p>
<p>当执行指针拷贝参数时，拷贝的是指针的值。拷贝之后，两个指针是不同的指针</p>
<h3 id="传引用参数"><a href="#传引用参数" class="headerlink" title="传引用参数"></a>传引用参数</h3><p>通过使用引用形参，允许函数改变一个或多个实参的值</p>
<p>拷贝大的类类型对象或者容器对象比较低效，甚至有的类类型(包括IO类型在内)不支持拷贝操作，就只能通过引用形参访问该类型对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//string对象可能会非常长，尽量避免直接拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isShorter</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s1, <span class="keyword">const</span> <span class="built_in">string</span>&amp; s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt; s2.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果无须改变引用形参的值，最好将其声明为常量引用</p>
<h4 id="使用引用形参返回额外信息"><a href="#使用引用形参返回额外信息" class="headerlink" title="使用引用形参返回额外信息"></a>使用引用形参返回额外信息</h4><p>一个函数只能返回一个值，引用形参为我们一次返回多个结果提供了有效途径</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回在string对象中某个指定字符第一次出现的位置和出现的总次数</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>::size_type <span class="title">find_char</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s, <span class="keyword">char</span> c, <span class="built_in">string</span>::size_type&amp; occurs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ret = s.<span class="built_in">size</span>();</span><br><span class="line">    occurs=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">decltype</span>(ret) i = <span class="number">0</span>; i != s.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==c)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ret == s.<span class="built_in">size</span>())</span><br><span class="line">                ret = i;</span><br><span class="line">            ++occurs;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="const形参和实参"><a href="#const形参和实参" class="headerlink" title="const形参和实参"></a>const形参和实参</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">42</span>;<span class="comment">//不能改变ci，const是顶层的</span></span><br><span class="line"><span class="keyword">int</span> i=ci;       <span class="comment">//正确：拷贝时忽略了顶层const</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p=&amp;i;<span class="comment">//const是顶层的，不能给p赋值</span></span><br><span class="line">*p = <span class="number">0</span>;         <span class="comment">//正确：i变成0</span></span><br></pre></td></tr></table></figure>

<p>和其它初始化过程一样，当使用实参初始化形参时会忽略掉顶层const，即形参的顶层const被忽略掉了<br>当形参有顶层const时，传给它常量对象或者非常量对象都是可以的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i)</span></span>&#123; <span class="comment">/* fcn能够读取i，但不能向i写值 */</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;&#125;  <span class="comment">//错误：重复定义了fcn(int)</span></span><br></pre></td></tr></table></figure>

<h4 id="指针或引用形参与const"><a href="#指针或引用形参与const" class="headerlink" title="指针或引用形参与const"></a>指针或引用形参与const</h4><p>形参的初始化方式和变量的初始化方式是一样的。可以使用非常量初始化一个底层const对象，但反过来不行<br>一个普通的引用必须用同类型的对象初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* cp = &amp;i; <span class="comment">//正确：但cp不能改变i</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; r = i;   <span class="comment">//正确：但r不能改变i</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; r2 = <span class="number">42</span>; <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">int</span>* p = cp;        <span class="comment">//错误：类型不匹配</span></span><br><span class="line"><span class="keyword">int</span>&amp; r3 = r;        <span class="comment">//错误：类型不匹配</span></span><br><span class="line"><span class="keyword">int</span>&amp; r4 = <span class="number">42</span>;       <span class="comment">//错误：不能用字面值常量初始化一个非常量引用</span></span><br></pre></td></tr></table></figure>

<p>将同样的初始化规则应用到参数传递上可得：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i;</span><br><span class="line"><span class="built_in">string</span>::size_type ctr=<span class="number">0</span>;</span><br><span class="line">reset(&amp;i);  <span class="comment">//调用形参类型是int*的reset函数</span></span><br><span class="line">reset(&amp;ci); <span class="comment">//错误：不能用指向const int对象的指针初始化int*</span></span><br><span class="line">reset(i);   <span class="comment">//调用形参类型是int&amp;的reset函数</span></span><br><span class="line">reset(ci);  <span class="comment">//错误：不能把普通引用绑定到const对象ci上</span></span><br><span class="line">reset(<span class="number">42</span>);  <span class="comment">//错误：不能把普通引用绑定到字面值上</span></span><br><span class="line">reset(ctr); <span class="comment">//错误：类型不匹配，ctr是无符号类型</span></span><br><span class="line"><span class="comment">//正确：find_char的第一个参数是对常量的引用</span></span><br><span class="line">find_char (<span class="string">"Hello World!"</span>, <span class="string">'o'</span>, ctr);</span><br></pre></td></tr></table></figure>

<h4 id="尽量使用常量引用"><a href="#尽量使用常量引用" class="headerlink" title="尽量使用常量引用"></a>尽量使用常量引用</h4><p>把函数不会改变的形参定义成普通的引用会带给调用者误导。此外普通引用也会限制接受的参数类型，不能把const对象，字面值或者需要类型转换的对象传递给普通引用形参</p>
<h3 id="数组形参"><a href="#数组形参" class="headerlink" title="数组形参"></a>数组形参</h3><p>数组不允许拷贝；使用数组时(通常)会将其转换成指针<br>所以无法通过值传递的方式使用数组；传递数组时，实际传递的是指向数组首元素的指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三个print函数是等价的</span></span><br><span class="line"><span class="comment">//每个函数都有一个const int*类型的形参</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>[<span class="number">10</span>])</span></span>;</span><br><span class="line"><span class="comment">//函数的意图是作用于一个数组</span></span><br><span class="line"><span class="comment">//维度表示期望数组含有的元素，实际不一定</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>,j[<span class="number">2</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">print</span>(&amp;i);  <span class="comment">//正确：&amp;i的类型是int*</span></span><br><span class="line"><span class="built_in">print</span>(j);   <span class="comment">//正确：j转换成int*并指向j[0]</span></span><br></pre></td></tr></table></figure>

<p>数组是以指针的形式传递给函数的，所以函数并不知道数组确切的尺寸，调用者应该为此提供额外的信息<br>一般有三种方式：使用标记指定数组长度、使用标准库规范、显示传递一个表示数组大小的形参</p>
<h4 id="使用标记指定数组长度"><a href="#使用标记指定数组长度" class="headerlink" title="使用标记指定数组长度"></a>使用标记指定数组长度</h4><p>典型示例是C风格字符串，在最后一个字符后面跟着一个空字符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* cp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cp)          <span class="comment">//若cp不是空指针</span></span><br><span class="line">        <span class="keyword">while</span>(*cp)  <span class="comment">//指针所指的字符不是空字符</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; *cp++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用标准库规范"><a href="#使用标准库规范" class="headerlink" title="使用标准库规范"></a>使用标准库规范</h4><p>传递指向数组首元素和尾后元素的指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* beg,<span class="keyword">const</span> <span class="keyword">int</span>* <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(beg!=<span class="built_in">end</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *beg++ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> j[<span class="number">2</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">begin</span>(j),<span class="built_in">end</span>(j));</span><br></pre></td></tr></table></figure>

<h4 id="显示传递一个表示数组大小的形参"><a href="#显示传递一个表示数组大小的形参" class="headerlink" title="显示传递一个表示数组大小的形参"></a>显示传递一个表示数组大小的形参</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//const int ia[]等价于const int* ia</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> ia[],<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>;i!=<span class="built_in">size</span>;++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ia[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> j[]=&#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">print</span>(j,<span class="built_in">end</span>(j)-<span class="built_in">begin</span>(j));</span><br></pre></td></tr></table></figure>

<h4 id="数组引用形参"><a href="#数组引用形参" class="headerlink" title="数组引用形参"></a>数组引用形参</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确：形参是数组的引用，维度是类型的一部分</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> (&amp;arr)[<span class="number">10</span>])</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:arr)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="keyword">int</span> &amp;arr[<span class="number">10</span>])     <span class="comment">//错误：将arr声明成了引用的数组</span></span><br><span class="line">f(<span class="keyword">int</span> (&amp;arr)[<span class="number">10</span>])   <span class="comment">//正确：arr是具有10个整数数组的引用</span></span><br></pre></td></tr></table></figure>

<p>因为数组的大小是构成数组类型的一部分，所以也限制了函数的可用性，只能作用于大小为10的数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>,j[<span class="number">2</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> k[<span class="number">10</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="built_in">print</span>(&amp;i);  <span class="comment">//错误：实参不是含有10个整数的数组</span></span><br><span class="line"><span class="built_in">print</span>(j);   <span class="comment">//错误</span></span><br><span class="line"><span class="built_in">print</span>(k);   <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>

<h4 id="传递多维数组"><a href="#传递多维数组" class="headerlink" title="传递多维数组"></a>传递多维数组</h4><p>将多维数组传递给函数时，真正传递的是数组首元素的指针。此时数组首元素本身是一个数组，指针就是一个指向数组的指针。数组第二位的大小都是数组类型的一部分，不能省略</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//matrix指向数组的首元素，该数组的元素是由10个整数构成的数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> (*matrix)[<span class="number">10</span>], <span class="keyword">int</span> rowSize)</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//*matrix两端的括号不可少</span></span><br><span class="line"><span class="keyword">int</span>* matrix[<span class="number">10</span>];    <span class="comment">//10个指针构成的数组</span></span><br><span class="line"><span class="keyword">int</span> (*matrix)[<span class="number">10</span>];  <span class="comment">//指向含有10个整数的数组的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//等价定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> matrix[][<span class="number">10</span>], <span class="keyword">int</span> rowSize)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="含有可变形参的函数"><a href="#含有可变形参的函数" class="headerlink" title="含有可变形参的函数"></a>含有可变形参的函数</h3><p>为了编写能处理不同数量实参的函数，提供两种主要方法：所有的实参类型相同，可以传递一个名为initializer_list的标准库类型；类型不同，可以编写可变参数模板<br>还可以用省略福传递可变数量的形参</p>
<h4 id="initializer-list形参"><a href="#initializer-list形参" class="headerlink" title="initializer_list形参"></a>initializer_list形参</h4><p>initializer_list是一种标准库类型，用于表示某种热定类型的值的数组</p>
<p>提供的操作：</p>
<p><img src="https://i.loli.net/2020/11/19/38osKZ2JirjVIG9.png" alt="Snipaste_2020-11-19_22-26-56.png"></p>
<p>和vector不同的是，initializer_list对象中的元素永远是常量值，无法改变其中对象中元素的值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_msg</span><span class="params">(<span class="built_in">initializer_list</span>&lt;<span class="built_in">string</span>&gt; il)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> beg=il.<span class="built_in">begin</span>();beg!=il.<span class="built_in">end</span>();++beg)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *beg &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传递值的序列</span></span><br><span class="line"><span class="comment">//expected和actual是string对象</span></span><br><span class="line"><span class="keyword">if</span>(expected != actual)</span><br><span class="line">    error_msg(&#123;<span class="string">"functionX"</span>, expected, actual&#125;);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    error_msg(&#123;<span class="string">"functionX"</span>, <span class="string">"okay"</span>&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="省略符形参"><a href="#省略符形参" class="headerlink" title="省略符形参"></a>省略符形参</h4><p>省略符形参应该仅仅用于C和C++通用的类型。只能出现在形参列表最后一个位置</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(parm_list, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(...)</span></span>;</span><br></pre></td></tr></table></figure>

<p>省略符形参所对应的实参无须类型检查</p>
<h2 id="返回类型和return语句"><a href="#返回类型和return语句" class="headerlink" title="返回类型和return语句"></a>返回类型和return语句</h2><p>return语句终止当前正在执行的函数并将控制权返回到调用该函数的地方。两种形式：<br>return；<br>return <em>expression</em>；</p>
<h3 id="无返回值函数"><a href="#无返回值函数" class="headerlink" title="无返回值函数"></a>无返回值函数</h3><p>没有返回值的return语句只能用在返回类型是void的函数。返回void的函数不要求非得有return语句，会隐式地执行return<br>一个返回类型是void的函数也能使用return语句的第二种形式，不过<em>expression</em>必须是另一个返回void的函数。返回其它类型将产生编译错误</p>
<h3 id="有返回值函数"><a href="#有返回值函数" class="headerlink" title="有返回值函数"></a>有返回值函数</h3><p>只要函数的返回类型不是void，则该函数内每条return语句必须返回一个类型与函数返回类型相同或能转换成返回类型的类型</p>
<p>在含有return语句的循环后面也应该有一条return语句，没有的话该程序就是错误的</p>
<p>返回一个值的方式和初始化一个变量或形参的方式完全一样：返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">make_plural</span><span class="params">(<span class="keyword">size_t</span> ctr,<span class="keyword">const</span> <span class="built_in">string</span>&amp; <span class="keyword">word</span>, <span class="keyword">const</span> <span class="built_in">string</span>&amp; ending)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (ctr&gt;<span class="number">1</span>) ? <span class="keyword">word</span> + ending : <span class="keyword">word</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数的返回类型是string，意味着返回值将被拷贝到调用点。因此该函数将返回word的副本或者一个未命名的临时string对象，内容是word和ending的和</p>
<p>如果函数返回引用，则该引用仅是它所引对象的一个别名</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span>&amp; <span class="title">shorterString</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s1, <span class="keyword">const</span> <span class="built_in">string</span>&amp; s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>()&lt;=s2.<span class="built_in">size</span>() ? s1 : s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>形参和返回类型都是const string的引用，调用函数和返回结果都不会真正拷贝string对象</p>
<h4 id="不要返回局部对象的引用或指针"><a href="#不要返回局部对象的引用或指针" class="headerlink" title="不要返回局部对象的引用或指针"></a>不要返回局部对象的引用或指针</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span>&amp; <span class="title">manip</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> ret;</span><br><span class="line">    <span class="keyword">if</span>(!ret.empty())<span class="keyword">return</span> ret; <span class="comment">//错误：返回局部对象的引用</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">"Empty"</span>;        <span class="comment">//错误：“Empty”是一个局部临时量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="返回类类型的函数和调用运算符"><a href="#返回类类型的函数和调用运算符" class="headerlink" title="返回类类型的函数和调用运算符"></a>返回类类型的函数和调用运算符</h4><p>调用运算符的优先级与点运算符和箭头运算符相同，符合左结合律<br>如果函数返回指针、引用或类的对象，能使用函数调用的结果访问结果对象的成员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用string对象的size成员</span></span><br><span class="line"><span class="comment">//该string对象是由shorterSize函数返回的</span></span><br><span class="line"><span class="keyword">auto</span> sz=shorterString(s1,s2).<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure>

<h4 id="引用返回左值"><a href="#引用返回左值" class="headerlink" title="引用返回左值"></a>引用返回左值</h4><p>调用一个返回引用的函数得到左值，其它返回类型得到右值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>&amp; <span class="title">get_val</span><span class="params">(<span class="built_in">string</span>&amp; str, <span class="built_in">string</span>::size_type ix)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str[ix];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"a value"</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; s &lt;&lt;<span class="built_in">endl</span>;    <span class="comment">//输出a value</span></span><br><span class="line">    get_val(s,<span class="number">0</span>)=<span class="string">'A'</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; s &lt;&lt;<span class="built_in">endl</span>;    <span class="comment">//输出A value</span></span><br><span class="line"></span><br><span class="line">    shorterString(<span class="string">"hi"</span>,<span class="string">"bye"</span>)=<span class="string">"X"</span>;</span><br><span class="line">    <span class="comment">//错误：返回值是个常量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="列表初始化返回值"><a href="#列表初始化返回值" class="headerlink" title="列表初始化返回值"></a>列表初始化返回值</h4><p>函数可以返回花括号包围的值的列表。此处的列表也用来对表示函数返回的临时量进行初始化<br>如果列表为空，临时量执行值初始化；否则返回的值由函数的返回类型决定</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;<span class="built_in">process</span>()&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span>(expected.empty())</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;  <span class="comment">//返回一个空vector对象</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(expected==actual)</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">"functionX"</span>, <span class="string">"okay"</span>&#125;;</span><br><span class="line">        <span class="comment">//返回列表初始化的vector对象</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">"functionX"</span>,expected,actual&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果函数返回的是内置类型，则花括号包围的列表最多包含一个值，且该值所占的空间不应该大于目标类型的空间</p>
<h4 id="主函数main的返回值"><a href="#主函数main的返回值" class="headerlink" title="主函数main的返回值"></a>主函数main的返回值</h4><p>main函数会隐式地插入一条返回0的return语句<br>返回0表示执行成功，其它值表示失败，具体含义依机器而定<br>为使返回值与机器无关，cstdlib头文件定义了两个预处理变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(some_failure)</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>如果一个函数调用了它自身，称该函数为递归函数(recursive function)<br>main函数不能调用它自己</p>
<h3 id="返回数组指针"><a href="#返回数组指针" class="headerlink" title="返回数组指针"></a>返回数组指针</h3><p>因为数组不能被拷贝，所以函数不能返回数组。可以返回数组的指针或引用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> arrT[<span class="number">10</span>];   <span class="comment">//arrT是一个类型别名</span></span><br><span class="line">                        <span class="comment">//表示的类型是含有10个整数的数组</span></span><br><span class="line"><span class="keyword">using</span> arrT=<span class="keyword">int</span>[<span class="number">10</span>];     <span class="comment">//等价声明</span></span><br><span class="line"><span class="function">arrT* <span class="title">func</span><span class="params">(<span class="keyword">int</span> i)</span></span>;      <span class="comment">//func返回一个指向含有10个整数数组的指针</span></span><br></pre></td></tr></table></figure>

<h4 id="声明一个返回数组指针的函数"><a href="#声明一个返回数组指针的函数" class="headerlink" title="声明一个返回数组指针的函数"></a>声明一个返回数组指针的函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];    <span class="comment">//arr是一个含有10个整数的数组</span></span><br><span class="line"><span class="keyword">int</span>* p1[<span class="number">10</span>];    <span class="comment">//p1是一个含有10个指针的数组</span></span><br><span class="line"><span class="keyword">int</span> (*p2)[<span class="number">10</span>];  <span class="comment">//p2是一个指针，指向含有10个整数的数组</span></span><br></pre></td></tr></table></figure>

<p>如果想定义一个返回数组指针的函数，则数组的维度必须跟在函数名字之后。然而形参列表也跟在名字后，且先于数组的维度<br><em>Type</em> (<em>\</em>function(parameter_list)<em>) [</em>dimension<em>]<br>如：int (</em>func(int i))[10];</p>
<h4 id="使用尾置返回类型"><a href="#使用尾置返回类型" class="headerlink" title="使用尾置返回类型"></a>使用尾置返回类型</h4><p>尾置返回类型跟在形参列表后并以一个”-&gt;”符号开头，在本应该出现返回类型的地方放一个”auto”</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto func(int i) -&gt; int(*)[10];</span><br></pre></td></tr></table></figure>

<h4 id="使用decltype"><a href="#使用decltype" class="headerlink" title="使用decltype"></a>使用decltype</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> odd[]=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> even[]=&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">decltype</span>(odd) *arrPtr(<span class="keyword">int</span> i)&#123;</span><br><span class="line">    <span class="keyword">return</span> (i%<span class="number">2</span>)?&amp;odd:&amp;even;</span><br><span class="line">    <span class="comment">//返回一个知指向数组的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>decltype并不负责把数组类型转换成指针，所以还需要在声明时加一个”*”符号</p>
<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为重载(overload)函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* cp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* beg,<span class="keyword">const</span> <span class="keyword">int</span>* <span class="built_in">end</span>)</span></span>;l</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> ia[], <span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这些函数接受的形参类型不一样。调用时编译器根据传递的实参类型推断需要的函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> j[<span class="number">2</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Hello World!"</span>);      <span class="comment">//调用print(const char*)</span></span><br><span class="line"><span class="built_in">print</span>(j,<span class="built_in">end</span>(j)-<span class="built_in">begin</span>(j));   <span class="comment">//调用print(const int*,size_t)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">begin</span>(j),<span class="built_in">end</span>(j));     <span class="comment">//调用print(const int*,const int*)</span></span><br></pre></td></tr></table></figure>

<p>对于重载函数，它们应该在形参数量或类型上有所不同。不允许两个函数除了返回类型外其他所有要素都相同</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每对声明的是同一个函数</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Account&amp; acct)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Account&amp;)</span></span>;  <span class="comment">//省略了形参名字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Phone Telno;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Phone&amp;)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Telno&amp;)</span></span>;    <span class="comment">//Phone和Telno类型相同</span></span><br></pre></td></tr></table></figure>

<h4 id="重载和const形参"><a href="#重载和const形参" class="headerlink" title="重载和const形参"></a>重载和const形参</h4><p>顶层const不影响传入函数的对象。一个拥有顶层const的形参无法和另一个没有的区分开来</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Phone)</span></span>; <span class="comment">//重复声明</span></span><br><span class="line"></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone*)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone* <span class="keyword">const</span>)</span></span>;<span class="comment">//重复声明</span></span><br></pre></td></tr></table></figure>

<p>如果形参是某种类型的指针或引用，通过区分底层const可以实现函数重载</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account&amp;)</span></span>;    <span class="comment">//函数作用于Account的引用</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Account&amp;)</span></span>;<span class="comment">//新函数，作用于常量引用</span></span><br><span class="line"></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account*)</span></span>;    <span class="comment">//作用于指向Account的指针</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Account*)</span></span>;<span class="comment">//新函数，作用于指向常量的指针</span></span><br></pre></td></tr></table></figure>

<p>const不能转换成其它类型，所以只能把const对象(或指向const的对象)传递给const形参。相反的，非常量可以转换成const，所以4个函数都能作用于非常量对象或者指向非常量对象的指针。<br>当传递一个非常量对象或者指向非常量对象的指针，编译器会优先选用非常量版本的函数</p>
<h4 id="const-cast和重载"><a href="#const-cast和重载" class="headerlink" title="const_cast和重载"></a>const_cast和重载</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span>&amp; <span class="title">shorterString</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;s1,<span class="keyword">const</span> <span class="built_in">string</span>&amp;s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>()&lt;=s2.<span class="built_in">size</span>()?s1:s2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">shorterString</span><span class="params">(<span class="built_in">string</span>&amp;s1,<span class="built_in">string</span>&amp;s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;r=shorterString(<span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="built_in">string</span>&amp;&gt;(s1),</span><br><span class="line">                        <span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="built_in">string</span>&amp;&gt;(s2));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="built_in">string</span>&amp;&gt;(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二个版本的函数中，先将它的实参强制转换成对const的引用，然后调用了函数的const版本，返回对const string的引用，这个引用事实上绑定在某个初始的非常量版本上。因此可以再将其转换回一个普通的string&amp;是非常安全的</p>
<h4 id="调用重载的函数"><a href="#调用重载的函数" class="headerlink" title="调用重载的函数"></a>调用重载的函数</h4><p>函数匹配(function matching)是指一个过程，在这个过程中我们把函数调用与一组重载函数中的某一个关联起来，也叫做重载确定(overload resolution)<br>三个可能的结果：<br>·编译器找到一个与实参最佳匹配(best match)的函数，并生成调用该函数的代码<br>·找不到任何一个函数与调用的实参匹配，此时编译器发出无匹配(no match)的错误信息<br>·有多于一个函数可以匹配，但是每一个都不是明显的最佳选择。此时也发生错误，称为二义性调用(ambiguous call)</p>
<h3 id="重载与作用域"><a href="#重载与作用域" class="headerlink" title="重载与作用域"></a>重载与作用域</h3><p>如果在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体。在不同作用域中无法重载函数名<br>C++中，名字查找发生在类型检查之前</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">road</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fooBar</span><span class="params">(<span class="keyword">int</span> ival)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> <span class="built_in">read</span> = <span class="literal">false</span>;  <span class="comment">//新作用域，隐藏了外层的read()</span></span><br><span class="line">    <span class="built_in">string</span> s=<span class="built_in">read</span>();    <span class="comment">//错误：read是布尔值而非函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>)</span></span>;    <span class="comment">//隐藏了之前的print</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Value: "</span>);   <span class="comment">//错误：print(const string&amp;)被隐藏掉了</span></span><br><span class="line">    <span class="built_in">print</span>(iVal);        <span class="comment">//正确</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">3.14</span>);        <span class="comment">//正确：调用print(int),pring(double)被隐藏掉了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="特殊用途语言特性"><a href="#特殊用途语言特性" class="headerlink" title="特殊用途语言特性"></a>特殊用途语言特性</h2><h3 id="默认实参"><a href="#默认实参" class="headerlink" title="默认实参"></a>默认实参</h3><p>调用含有默认实参(default argument)的函数时，可以包含该实参，也可以省略</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">string</span>::size_type sz;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">screen</span><span class="params">(sz ht=<span class="number">24</span>,sz wid=<span class="number">80</span>,<span class="keyword">char</span> backgrnd=<span class="string">' '</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>可以为一个或多个形参定义默认值，一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值</p>
<h4 id="使用默认实参调用函数"><a href="#使用默认实参调用函数" class="headerlink" title="使用默认实参调用函数"></a>使用默认实参调用函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> window;</span><br><span class="line">window= screen();           <span class="comment">//screen(24,80,' ')</span></span><br><span class="line">window= screen(<span class="number">66</span>);         <span class="comment">//screen(66,80,' ')</span></span><br><span class="line">window= screen(<span class="number">66</span>,<span class="number">256</span>);     <span class="comment">//screen(66,256,' ')</span></span><br><span class="line">window= screen(<span class="number">66</span>,<span class="number">256</span>,<span class="string">'#'</span>); <span class="comment">//screen(66,256,'#')</span></span><br><span class="line"></span><br><span class="line">window= screen(, , <span class="string">'?'</span>);<span class="comment">//错误：只能省略尾部的实参</span></span><br><span class="line">window= screen(<span class="string">'?'</span>);    <span class="comment">//screen('?',80,' ')</span></span><br><span class="line"><span class="comment">//第二个是合法的调用，char类型转换为string::size_type</span></span><br></pre></td></tr></table></figure>

<p>给定的作用域中一个形参只能被赋予一次默认实参，即后续的声明只能为之前那些没有默认值的形参添加默认实参，且该形参右侧的所有形参都必须有默认值</p>
<p>局部变量不能作为默认实参，除此之外，只要能转换成形参所需的类型，该表达式就能作为默认实参</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sz wd=<span class="number">80</span>;</span><br><span class="line"><span class="keyword">char</span> def=<span class="string">' '</span>;</span><br><span class="line"><span class="function">sz <span class="title">ht</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">screen</span><span class="params">(sz=ht(),sz=wd,<span class="keyword">char</span>=def)</span></span>;</span><br><span class="line"><span class="built_in">string</span> window=screen(); <span class="comment">//调用screen(ht(),80,' ')</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    def=<span class="string">'*'</span>;    <span class="comment">//改变默认实参的值</span></span><br><span class="line">    sz wd=<span class="number">100</span>;  <span class="comment">//隐藏了外层的wd，但没有改变默认值</span></span><br><span class="line">    window = screen();</span><br><span class="line">    <span class="comment">//调用screen(ht(),80,'*')</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数f2内改变了def的值，所以对screen的调用会传递这个更新过的值。函数声明了一个局部变量用于隐藏外层的wd，但与传递给screen的默认实参没有关系</p>
<h3 id="内联函数和constexpr函数"><a href="#内联函数和constexpr函数" class="headerlink" title="内联函数和constexpr函数"></a>内联函数和constexpr函数</h3><p>把规模较小的操作定义成函数有很多好处：<br>·阅读和理解函数的调用相对容易<br>·使用函数可以确保行为的统一<br>·如果需要修改计算过程，修改函数更容易<br>·函数可以被其它应用重复利用，省去重复编写<br>但函数调用相对较慢。一次函数调用包括：调用前先保存寄存器，并在返回时恢复；可能需要可拷贝实参；程序转向一个新的位置继续执行</p>
<h4 id="内联函数可避免函数调用的开销"><a href="#内联函数可避免函数调用的开销" class="headerlink" title="内联函数可避免函数调用的开销"></a>内联函数可避免函数调用的开销</h4><p>将函数指定为内联函数(inline)，通常就是讲它在每个调用点上“内联地”展开。从而消除运行时开销。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">const</span> <span class="built_in">string</span>&amp;</span><br><span class="line">shorterString(<span class="keyword">const</span> <span class="built_in">string</span>&amp;s1,<span class="keyword">const</span> <span class="built_in">string</span>&amp;s2)&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>()&lt;s2.<span class="built_in">size</span>()?s1:s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般来说，内联机制用于优化规模较小、流程直接、频繁调用的函数。很多编译器不支持内联递归函数</p>
<h4 id="constexpr函数"><a href="#constexpr函数" class="headerlink" title="constexpr函数"></a>constexpr函数</h4><p>constexpr函数(constexpr function)是指能用于常量表达式的函数<br>函数的返回类型以及所有形参的类型都得是字面值类型，而且函数体中必须有且只有一条return语句</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">new_sz</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">42</span>;&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> foo=new_sz();</span><br></pre></td></tr></table></figure>

<p>编译器把对constexpr函数的调用替换成其结果值。为了能在编译过程中随时展开，constexpr函数被隐式地指定为内联函数<br>constexpr函数体内也可以包含其他语句，只要这些语句在运行时不执行任何操作。如空语句、类型别名以及using声明</p>
<p>允许constexpr函数的返回值并非一个常量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">size_t</span> <span class="title">scale</span><span class="params">(<span class="keyword">size_t</span> cnt)</span></span>&#123;<span class="keyword">return</span> new_sz()*cnt;&#125;</span><br><span class="line"><span class="keyword">int</span> arr[scale(<span class="number">2</span>)];  <span class="comment">//正确：scale(2)是常量表达式</span></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> a2[scale(i)];   <span class="comment">//错误：scale(i)不是常量表达式</span></span><br></pre></td></tr></table></figure>

<p>当把scale函数用在需要常量表达式的上下文中时，由编译器负责检查函数的结果是否符合要求。如果不是则报错</p>
<h3 id="调试帮助"><a href="#调试帮助" class="headerlink" title="调试帮助"></a>调试帮助</h3><p>有时会用到一种类似于头文件保护的技术，以便有选择的执行调试代码。基本思想是，程序可以包含一段用于调试的代码，但这些代码只在开发程序时使用。编写完成准备发布时，先屏蔽掉调试代码</p>
<h4 id="assert预处理宏"><a href="#assert预处理宏" class="headerlink" title="assert预处理宏"></a>assert预处理宏</h4><p>assert是一种预处理宏(preprocessor marco)。<br>assert(<em>expr</em>);<br>首先对<em>expr</em>求值，如果为假，assert输出信息并终止程序的执行；如果为真，assert什么也不做<br>assert宏常用于检查“不能发生”的条件。如：一个对输入文本进行操作的程序可能要求给定单词的长度都大于某个阈值<br>assert(word.size()&gt;threshold);</p>
<h4 id="NDEBUG预处理变量"><a href="#NDEBUG预处理变量" class="headerlink" title="NDEBUG预处理变量"></a>NDEBUG预处理变量</h4><p>assert的行为依赖于一个名为NDEBUG的预处理变量的状态。如果定义了NDEBUG，则assert什么也不做<br>可以使用一条#define语句定义NDEBUG，从而关闭调试状态</p>
<h2 id="函数匹配"><a href="#函数匹配" class="headerlink" title="函数匹配"></a>函数匹配</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span>,<span class="keyword">double</span>=<span class="number">3.14</span>)</span></span>;</span><br><span class="line">f(<span class="number">5.6</span>);     <span class="comment">//调用f(double,double)</span></span><br></pre></td></tr></table></figure>

<p>函数匹配第一步是选定本次调用对应的重载函数集，集合中的函数称为候选函数(candidate function)。特征：与被调用函数同名，声明在调用点可见<br>第二部是选出可行参数(viable function)。特征：形参数量与本次调用提供的实参相等；每个实参的类型与对应的形参类型相同，或者能转换成形参的类型<br>第三步是从可行函数中选择与本次调用最匹配的函数。实参与形参类型越接近匹配得越好</p>
<h3 id="实参类型转换"><a href="#实参类型转换" class="headerlink" title="实参类型转换"></a>实参类型转换</h3><p>转换等级排序：<br>·精确匹配：类型相同；实参从数组类型或函数类型转换成对应的指针类型；向实参添加顶层const或从实参删除顶层const<br>·通过const转换实现的匹配<br>·通过类型提升实现的匹配<br>·通过算术类型转换或指针转换实现的匹配<br>·通过类类型转换实现的匹配</p>
<p>所有算术类型转换的级别都一样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ff</span><span class="params">(<span class="keyword">long</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ff</span><span class="params">(<span class="keyword">float</span>)</span></span>;</span><br><span class="line">ff(<span class="number">3.14</span>);   <span class="comment">//错误：二义性调用</span></span><br></pre></td></tr></table></figure>

<p>如果重载函数的区别在于他们的引用类型的形参是否引用了const，或者指针类型的形参是否指向const，则当调用发生时编译器通过实参是否是常量来决定调用哪个函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account&amp;)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Account&amp;)</span></span>;</span><br><span class="line"><span class="keyword">const</span> Account a;</span><br><span class="line">Account a;</span><br><span class="line"></span><br><span class="line">lookup(a);  <span class="comment">//调用lookup(const Account&amp;)</span></span><br><span class="line">lookup(b);  <span class="comment">//调用lookup(Account&amp;)</span></span><br></pre></td></tr></table></figure>

<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>函数指针指向的是函数而非对象。函数指针指向某种特定的类型。函数的类型由它的返回类型和形参类型共同决定，与函数名无关</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">lengthCompare</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;,<span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line"><span class="comment">//pf指向一个函数，该函数的参数是两个const string引用，返回值是bool类型</span></span><br><span class="line"><span class="keyword">bool</span> (*pf)(<span class="keyword">const</span> <span class="built_in">string</span>&amp;,<span class="keyword">const</span> <span class="built_in">string</span>&amp;);    <span class="comment">//未初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明一个名为pf的函数，返回bool*</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span>* <span class="title">pf</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;,<span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<p>把函数名作为一个值使用时，该函数自动地转换为指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pf = lengthCompare;     <span class="comment">//pf指向名为lengthCompare的函数</span></span><br><span class="line">pf = &amp;lengthCompare;    <span class="comment">//等价的赋值语句，&amp;符号是可选的</span></span><br></pre></td></tr></table></figure>

<p>还能直接使用指向函数的指针调用该函数，无需提前解引用指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> b1=pf(<span class="string">"hello"</span>,<span class="string">"goodbye"</span>);      <span class="comment">//调用lengthCompare函数</span></span><br><span class="line"><span class="keyword">bool</span> b2=(*pf)(<span class="string">"hello"</span>,<span class="string">"goodbye"</span>);   <span class="comment">//等价调用</span></span><br><span class="line"><span class="keyword">bool</span> b3=lengthCompare(<span class="string">"hello"</span>,<span class="string">"goodbye"</span>);<span class="comment">//等价调用</span></span><br></pre></td></tr></table></figure>

<p>指向不同函数类型的指针间不存在转换规则。但可以为函数指针赋值一个nullptr或者0的整型常量表达式，表示没有指向任何一个函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span>::size_type <span class="title">sumLength</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;,cosnt <span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cstringCompare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*,<span class="keyword">const</span> <span class="keyword">char</span>*)</span></span>;</span><br><span class="line">pf = <span class="number">0</span>;                 <span class="comment">//正确：pf不指向任何函数</span></span><br><span class="line">pf = sumLength;         <span class="comment">//错误：返回类型不匹配</span></span><br><span class="line">pf = cstringCompare;    <span class="comment">//错误：返回类型不匹配</span></span><br><span class="line">pf = lengthCompare;     <span class="comment">//正确：函数和指针的类型精确匹配</span></span><br></pre></td></tr></table></figure>

<h4 id="重载函数的指针"><a href="#重载函数的指针" class="headerlink" title="重载函数的指针"></a>重载函数的指针</h4><p>当我们使用重载函数时，必须清晰界定到底应该选择用哪个函数。编译器通过指针类型决定使用哪个函数，指针类型必须与重载函数中的某一个精确匹配</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ff</span><span class="params">(<span class="keyword">int</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ff</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> (*pf1)(<span class="keyword">unsigned</span> <span class="keyword">int</span>) = ff; <span class="comment">//pf1指向ff(unsigned)</span></span><br><span class="line"><span class="keyword">void</span> (*pf2)(<span class="keyword">int</span>) = ff;      <span class="comment">//错误：没有任何一个ff与该类型参数匹配</span></span><br><span class="line"><span class="keyword">double</span> (*pf3)(<span class="keyword">int</span>*) = ff;   <span class="comment">//错误：ff和pf3返回类型不匹配</span></span><br></pre></td></tr></table></figure>

<h4 id="函数指针形参"><a href="#函数指针形参" class="headerlink" title="函数指针形参"></a>函数指针形参</h4><p>和数组类似，虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。此时形参看起来是函数类型，实际上却是当成指针使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第三个参数是函数类型，会自动地转换成指向函数的指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;s1,<span class="keyword">const</span> <span class="built_in">string</span>&amp;s2,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">bool</span> pf(<span class="keyword">const</span> <span class="built_in">string</span>&amp;,<span class="keyword">const</span> <span class="built_in">string</span>&amp;))</span></span>;</span><br><span class="line"><span class="comment">//等价的声明：显示地将形参定义成指向函数的指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;s1,<span class="keyword">const</span> <span class="built_in">string</span>&amp;s2,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">bool</span> (*pf)(<span class="keyword">const</span> <span class="built_in">string</span>&amp;,<span class="keyword">const</span> <span class="built_in">string</span>&amp;))</span></span>;</span><br><span class="line"><span class="comment">//自动将函数lengthCompare转换成指向该函数的指针</span></span><br><span class="line">useBigger(s1,s2,lengthCompare);</span><br></pre></td></tr></table></figure>

<p>类型别名和decltype能简化使用了函数指针的代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Func和Func2是函数类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">bool</span> <span class="title">Func</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;,<span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> Func2</span>;  <span class="comment">//等价的类型</span></span><br><span class="line"><span class="comment">//FuncP和FuncP2是指向函数的指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(*FuncP)</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;,<span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> *FuncP2</span>;    <span class="comment">//等价的类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//useBigger的等价声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;,<span class="keyword">const</span> <span class="built_in">string</span>&amp;,Func)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span><span class="params">(cosnt <span class="built_in">string</span>&amp;,<span class="keyword">const</span> <span class="built_in">string</span>&amp;,FuncP2)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="返回指向函数的指针"><a href="#返回指向函数的指针" class="headerlink" title="返回指向函数的指针"></a>返回指向函数的指针</h4><p>和数组类型，虽然不能返回一个函数，但能返回指向函数类型的指针。必须把返回类型写成指针形式，编译器不会自动地将函数返回类型当成对应的指针类型处理</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> F = <span class="keyword">int</span> (<span class="keyword">int</span>*,<span class="keyword">int</span>);   <span class="comment">//F是函数类型，不是指针</span></span><br><span class="line"><span class="keyword">using</span> Pf = <span class="keyword">int</span>(*)(<span class="keyword">int</span>*,<span class="keyword">int</span>);<span class="comment">//PF是指针类型</span></span><br><span class="line"></span><br><span class="line"><span class="function">PF <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">//正确：PF是指向函数的指针，f1返回指向函数的指针</span></span><br><span class="line"><span class="function">F <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;  <span class="comment">//错误：F是函数类型，f1不能返回一个函数</span></span><br><span class="line"><span class="function">F* <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">//正确：显示地指定返回类型是指向函数的指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> (*f1(<span class="keyword">int</span>))(<span class="keyword">int</span>*,<span class="keyword">int</span>);   <span class="comment">//直接声明f1</span></span><br><span class="line"><span class="comment">//f1有形参列表，所以是个函数；前面有*，所以返回一个指针；</span></span><br><span class="line"><span class="comment">//指针的类型本身也有形参列表，所以该指针指向函数，该函数返回int</span></span><br><span class="line"></span><br><span class="line">auto f1(int) -&gt; int(*)(int*,int);</span><br></pre></td></tr></table></figure>

<h4 id="将auto和decltype用于函数指针类型"><a href="#将auto和decltype用于函数指针类型" class="headerlink" title="将auto和decltype用于函数指针类型"></a>将auto和decltype用于函数指针类型</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span>::size_type <span class="title">sumLength</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;,<span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span>::size_type <span class="title">largerLength</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;,<span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line"><span class="comment">//getFcn函数接受一个string类型的形参，返回一个指向sumLength</span></span><br><span class="line"><span class="comment">//或者largerLength的指针</span></span><br><span class="line"><span class="keyword">decltype</span>(sumLength) *getFcn(<span class="keyword">const</span> <span class="built_in">string</span>&amp;);</span><br></pre></td></tr></table></figure>

<p>decltype作用于某个函数时返回函数类型而非指针类型，需要显示地加上*以表明需要返回指针而非函数本身</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/11/19/ncpp-06/" data-id="ckhq93pu8002da0ve5mv0h44j" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/02-cpp-primer/" rel="tag">02 cpp primer</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ncpp-05" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/18/ncpp-05/" class="article-date">
  <time datetime="2020-11-18T14:08:21.000Z" itemprop="datePublished">2020-11-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/18/ncpp-05/">第5章 语句</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="简单语句"><a href="#简单语句" class="headerlink" title="简单语句"></a>简单语句</h2><p>最简单的语句是空语句(null statement)，只含有一个单独的分号</p>
<p>复合语句(compound statement)是指用花括号括起来的语句和声明的序列(可能为空)，也被称为块(block)<br>一个块就是一个作用域，在块中引入的名字只能在块内部以及嵌套在块中的子块里访问<br>块不以分号作为结束</p>
<h4 id="悬垂else"><a href="#悬垂else" class="headerlink" title="悬垂else"></a>悬垂else</h4><p>else与离它最近的尚未匹配的if匹配，从而消除程序的二义性</p>
<h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><p>switch语句(switch statement)提供了一条便利的途径是的我们能够在若干固定选项中做出抉择</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> aCnt=<span class="number">0</span>,eCnt=<span class="number">0</span>,iCne=<span class="number">0</span>,oCnt=<span class="number">0</span>,uCnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;ch)&#123;</span><br><span class="line">    <span class="keyword">switch</span>(ch)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">            ++aCnt;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'e'</span>:</span><br><span class="line">            ++eCnt;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'i'</span>:</span><br><span class="line">            ++icnt;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'o'</span>:</span><br><span class="line">            ++oCnt;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'u'</span>:</span><br><span class="line">            ++uCnt;<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>case关键字和它对应的值一起被称为case标签(case label)。case标签必须是整型常量表达式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch = getVal();</span><br><span class="line"><span class="keyword">int</span> ival = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">switch</span>(ch)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3.14</span>:  <span class="comment">//错误：不是一个整数</span></span><br><span class="line">    <span class="keyword">case</span> ival:  <span class="comment">//错误：不是一个常量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果某个case标签匹配成功，将从该标签开始往后顺序执行所有case分支</p>
<p>如果没有任何一个case标签能匹配上switch表达式的值，程序将执行紧跟在default标签(default label)后面的语句</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(ch)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'a'</span>: <span class="keyword">case</span> <span class="string">'e'</span>: <span class="keyword">case</span> <span class="string">'i'</span>: <span class="keyword">case</span> <span class="string">'o'</span>: <span class="keyword">case</span> <span class="string">'u'</span>:</span><br><span class="line">    ++vowelCnt;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ++otherCnt;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="迭代语句"><a href="#迭代语句" class="headerlink" title="迭代语句"></a>迭代语句</h2><h3 id="传统for语句"><a href="#传统for语句" class="headerlink" title="传统for语句"></a>传统for语句</h3><p>for语句头中的定义可以定义多个对象，但只能有一条声明语句，因此所有变量的基础类型必须相同</p>
<h2 id="try语句块和异常处理"><a href="#try语句块和异常处理" class="headerlink" title="try语句块和异常处理"></a>try语句块和异常处理</h2><p>异常是指存在于运行时的反常行为，这些行为超出了函数正常功能的范围<br>异常处理包括：<br>·throw表达式(throw expression)，异常检测部分使用throw表达式来表示它遇到了无法处理的问题。说throw引发(raise)了异常<br>·try语句块(try block)，异常处理部分使用try语句块处理异常。try语句块以try开始，并以一个或多个catch子句(catch clause)结束。try语句块中代码抛出的异常通常会被某个catch子句处理。因为catch子句“处理”异常，所以它们也被称作异常处理代码(exception handler)<br>·一套异常类(exception class)，用于在throw表达式和相关的catch子句指甲传递异常的具体信息</p>
<h3 id="throw表达式"><a href="#throw表达式" class="headerlink" title="throw表达式"></a>throw表达式</h3><p>程序的异常检测部分使用throw表达式引发一个异常。throw表达式包含关键字throw和紧随其后的一个表达式，其中表达式的类型就是抛出的异常类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(item1.isbn() != item2.isbn())</span><br><span class="line">    <span class="keyword">throw</span> runtime_error(<span class="string">"Data must refer to same ISBN"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; item1 + item2 &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>如果ISBN不一样就抛出一个类型为runtime_error的异常，抛出异常将终止当前函数，并把控制权转移给能处理该异常的代码</p>
<h3 id="try语句块"><a href="#try语句块" class="headerlink" title="try语句块"></a>try语句块</h3><p>try语句块的通用语法形式是:<br>try{<br>    <em>program-</em><br>}catch (<em>exception-declaration</em>){<br>    <em>handler-statements</em><br>}catch (<em>exception-declaration</em>){<br>    <em>handler-statements</em><br>}   // …<br>当选中了某个catch子句处理异常之后，执行与之对应的块。catch一旦完成，程序跳转到try语句块最后一个catch子句之后的那条语句继续执行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;item1&gt;&gt;item2)&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//执行添加两个Sales_data对象的代码</span></span><br><span class="line">        <span class="comment">//如果失败，抛出runtime_error异常</span></span><br><span class="line">    &#125;<span class="keyword">catch</span>(runtime_error err)&#123;</span><br><span class="line">        <span class="comment">//提醒用户两个ISBN必须一致，询问是否重新输入</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; err.whar()</span><br><span class="line">             &lt;&lt; <span class="string">"\nTry Again? Enter y or n"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">cin</span> || c==<span class="string">'n'</span>)</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">//跳出while循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个标准库异常类都定义了名为what的成员函数，这些函数没有参数，返回值是C风格字符串(const char*)<br>runtime_error的what成员返回的是初始化一个具体对象时所用的string对象是副本</p>
<p>如果没有找到匹配的catch子句，程序转到名为terminate的标准库函数。该函数的行为与系统有关，一般情况下，执行该函数将导致程序非正常退出</p>
<h3 id="标准异常"><a href="#标准异常" class="headerlink" title="标准异常"></a>标准异常</h3><p>C++标准库定义了一组类，用于报告标准库函数遇到的问题。分别定义在四个头文件中</p>
<p><img src="https://i.loli.net/2020/11/18/6EiUHaWA9R3gcXZ.png" alt="Snipaste_2020-11-19_00-05-26.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/11/18/ncpp-05/" data-id="ckhq93pub002na0vegp9ufjoq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/02-cpp-primer/" rel="tag">02 cpp primer</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ncpp-04" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/17/ncpp-04/" class="article-date">
  <time datetime="2020-11-17T14:02:18.000Z" itemprop="datePublished">2020-11-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/17/ncpp-04/">第4章 表达式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>表达式由一个或多个运算对象(operand)组成，对表达式求值将得到一个结果(result)。字面值和变量是最简单的表达式(expression)，其结果就是字面值和变量的值。吧一个运算符(operator)和一个或多个运算对象组合起来可以生成较复杂的表达式</p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>C++定义了一元运算符(unary operator，&amp;，*)和二元运算符(binary operator, ==, +)和一个三元运算符。函数调用也是一种特殊的运算符，对运算对象数量没有限制</p>
<h4 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h4><p>当一个对象被做右值的时候，用的是对象的值(内容)；当对象被用作左值时，用的是对象的身份(在内存中的位置)<br>在需要右值的地方可以用左值来代替，但是不能把它当成左值(也就是位置)使用。实际使用的是它的内容(值)</p>
<h3 id="求值顺序"><a href="#求值顺序" class="headerlink" title="求值顺序"></a>求值顺序</h3><p>对于没有指定执行顺序的运算符，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; ++i &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//未定义的</span></span><br></pre></td></tr></table></figure>

<p>四种运算符明确规定了运算对象的求值顺序：逻辑与(&amp;&amp;)、逻辑或(||)、条件运算符(?:)、逗号运算符(,)</p>
<h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p><img src="https://i.loli.net/2020/11/18/OASMdPic8CX2Rao.png" alt="Snipaste_2020-11-18_15-23-06.png"></p>
<p>算术运算符的运算对象和求值结果都是右值。所有运算对象最终会转换成同一类型<br>除法运算中商一律向0取整。取余运算m%n的结果符号和m相同</p>
<h2 id="逻辑和关系运算符"><a href="#逻辑和关系运算符" class="headerlink" title="逻辑和关系运算符"></a>逻辑和关系运算符</h2><p><img src="https://i.loli.net/2020/11/18/PhQuJKtYlk5Vvn2.png" alt="Snipaste_2020-11-18_15-38-27.png"></p>
<p>逻辑与和逻辑或运算符均为短路求值(short-circuit evaluation)：当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(val == <span class="literal">true</span>) &#123;<span class="comment">/* ... */</span>&#125; <span class="comment">//只有当val等于1时条件才为真</span></span><br></pre></td></tr></table></figure>

<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>赋值运算符的左侧运算对象必须是一个可修改的左值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i;</span><br><span class="line"></span><br><span class="line"><span class="number">1024</span> = k;   <span class="comment">//错误：字面值是右值</span></span><br><span class="line">i + j = k;  <span class="comment">//错误：算术表达式是右值</span></span><br><span class="line">ci = k;     <span class="comment">//错误：ci是常量(不可修改的)左值</span></span><br><span class="line"></span><br><span class="line">k = <span class="number">0</span>;      <span class="comment">//结果：类型是int，值是0</span></span><br><span class="line">k = <span class="number">3.14</span>;   <span class="comment">//结果：类型是int，值是3</span></span><br><span class="line"></span><br><span class="line">k = &#123;<span class="number">3.14</span>&#125;; <span class="comment">//错误：窄化转换</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi; <span class="comment">//初始为空</span></span><br><span class="line">vi = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;; <span class="comment">//vi含有6个元素</span></span><br></pre></td></tr></table></figure>

<p>赋值运算符满足右结合律<br>靠右的赋值运算jval=0作为靠左的赋值运算符的右侧运算对象。赋值运算返回的是其左侧的运算对象，所以靠右的赋值运算的结果(即jval)被赋给了ival</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival, jval;</span><br><span class="line">ival = jval = <span class="number">0</span>;    <span class="comment">//正确：都被赋值为0</span></span><br></pre></td></tr></table></figure>

<p>对于多重赋值语句中的每一个对象，它的类型或者与右边对象相同，或者可由右边对象的类型转换得到</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival, *pval;</span><br><span class="line">ival = pval =<span class="number">0</span>; <span class="comment">//错误：不能把指针的值赋给int</span></span><br><span class="line"><span class="built_in">string</span> s1, s2;</span><br><span class="line">s1 = s2 = <span class="string">"ok"</span>; <span class="comment">//字符串字面值“ok”转换成string对象</span></span><br></pre></td></tr></table></figure>

<p>复合赋值运算符</p>
<p><img src="https://i.loli.net/2020/11/18/Fkths1jEuSU9nZC.png" alt="Snipaste_2020-11-18_16-05-32.png"></p>
<p>任意一种复合运算符都完全等价于 a = a <em>op</em> b，唯一的区别是使用复合运算符左侧的对象只求值一次，普通则求值两次<br>一次是作为右边子表达式求值，一次是作为复制运算的左侧运算对象求值</p>
<h2 id="递增和递减运算符"><a href="#递增和递减运算符" class="headerlink" title="递增和递减运算符"></a>递增和递减运算符</h2><p>除非必须，否则不用递增递减运算符的后置版本<br>后置版本需要将原始值储存下来以便返回这个未修改的内容</p>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>位运算符作用于整数类型的运算对象，并把运算对象看成是二进制位的集合</p>
<p><img src="https://i.loli.net/2020/11/18/x62zuHFOyc3RAfj.png" alt="Snipaste_2020-11-18_20-28-01.png"></p>
<p>位移运算符：令左侧运算对象的内容按照右侧运算对象的要求移动指定位数，然后将经过移动的左侧运算对象的拷贝作为求值结果<br>右侧的运算对象不能为负，值严格小于结果的位数，否则会产生未定义的行为</p>
<p>位求反运算符(~)：将运算对象逐位求反后生成一个新值<br>位与运算符(&amp;)：如果两个运算对象的对应位置都是1则结果中该位为1，否则为0<br>位或运算符(|)：如果两个运算对象的对应位置至少一个为1则结果中该位为1，否则为0<br>位异或运算符(^)：如果两个运算对象的对应位置有且只有一个为1则运算结果中该位为1，否则为0</p>
<p>30个学生的测验结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> quiz1 = <span class="number">0</span>;    <span class="comment">//把这个值当做位的集合</span></span><br><span class="line">quiz1 |= <span class="number">1U</span>L &lt;&lt; <span class="number">27</span>; <span class="comment">//表示第27位学生通过了测验</span></span><br><span class="line">quiz1 &amp;= ~(<span class="number">1U</span>L&lt;&lt;<span class="number">27</span>);    <span class="comment">//修正，第27位学生没有通过测验</span></span><br><span class="line"><span class="keyword">bool</span> status = quiz1 &amp; (<span class="number">1U</span>L &lt;&lt; <span class="number">27</span>);  <span class="comment">//第27位学生是否通过测验？</span></span><br></pre></td></tr></table></figure>

<h2 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a>sizeof运算符</h2><p>sizeof运算符返回一条表达式或一个类型名字所占的字节数。满足右结合律，其所得的值是一个size_t类型的常量表达式<br>两种形式： sizeof (<em>type</em>)  sizeof <em>expr</em><br>第二种形式中，sizeof返回的是表达式结果类型的大小</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Sales_data data,*p;</span><br><span class="line"><span class="keyword">sizeof</span>(Sales_data); <span class="comment">//存储Sales_data类型的对象所占空间的大小</span></span><br><span class="line"><span class="keyword">sizeof</span> data;        <span class="comment">//data类型的大小，即sizeof(Sales_data)</span></span><br><span class="line"><span class="keyword">sizeof</span> p;           <span class="comment">//指针所占空间的大小</span></span><br><span class="line"><span class="keyword">sizeof</span> *p;          <span class="comment">//p所指类型所占空间的大小，即sizeof(Sales_data)</span></span><br><span class="line"><span class="keyword">sizeof</span> data.revenue;<span class="comment">//Sales_data成员revenue的大小</span></span><br><span class="line"><span class="keyword">sizeof</span> Sales_data.revenue;  <span class="comment">//另一种获取revenue大小的方式</span></span><br></pre></td></tr></table></figure>

<p>sizeof运算符的结果部分地依赖于其作用的类型：<br>·对char类型或者类型为char的表达式执行sizeof运算，结果为1<br>·对引用类型执行sizeof运算得到被引用对象所占空间的大小<br>·对指针执行sizeof运算得到指针本身所占空间的大小<br>·对解引用指针执行sizeof运算得到指针指向的对象所占空间的大小，指针不需要有效<br>·对数组执行sizeof运算得到整个数组所占空间的大小<br>·对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">size_t</span> sz = <span class="keyword">sizeof</span>(ia)/<span class="keyword">sizeof</span>(*ia);   <span class="comment">//得到ia的元素数量</span></span><br></pre></td></tr></table></figure>

<h2 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h2><p>逗号运算符含有两个对象，按照从左到右的顺序依次求值。逗号运算符真正的结果是右侧表达式的值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sonmeValue ? ++x, ++y : --x, --y;</span><br><span class="line"><span class="comment">//等效于</span></span><br><span class="line">(sonmeValue ? ++x, ++y : --x), --y;</span><br></pre></td></tr></table></figure>

<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>int ival = 3.14 + 3;<br>3先被转换成double型，执行浮点数加法；初始化时又转换成int型</p>
<p>发生隐式转换：<br>·大多数表达式中，比int类型小的整型值先提升为表达的整数类型<br>·在条件中，非布尔类型转换成布尔类型<br>·初始化过程中，初始值转换成变量的类型；赋值语句中，右侧运算对象转换成左侧运算对象的类型<br>·如果算术运算或关系运算的运算对象有多种类型，需要转换成同一类型<br>·函数调用时也会发生转换</p>
<h3 id="算术转换"><a href="#算术转换" class="headerlink" title="算术转换"></a>算术转换</h3><p>算术转换(arithmetic conversion)的含义是把一种算术类型转换成另外一种算术类型</p>
<h4 id="整型提升"><a href="#整型提升" class="headerlink" title="整型提升"></a>整型提升</h4><p>整型提升(integral promotion)负责把小整数类型转换成较大的整数类型<br>bool,char,signed char,unsigned char,short和unsigned short等类型来说只要它们所有可能的值都能存在in里，就会提升成int类型，否则提升成unsigned int类型<br>较大的char类型(wchar_t,char16_t,char32_t)提升成int,unsigned int,long,unsigned long,long long和unsigned long long中最小的一种类型</p>
<h4 id="无符号类型的运算对象"><a href="#无符号类型的运算对象" class="headerlink" title="无符号类型的运算对象"></a>无符号类型的运算对象</h4><p><img src="https://i.loli.net/2020/11/18/WYJKbi1c4PT6xDg.png" alt="Snipaste_2020-11-18_21-38-25.png"></p>
<p><img src="https://i.loli.net/2020/11/18/oM2JHqDVK1SG7xR.png" alt="Snipaste_2020-11-18_21-38-38.png"></p>
<p><img src="https://i.loli.net/2020/11/18/zoigZMkCQcRBhGb.png" alt="Snipaste_2020-11-18_21-38-49.png"></p>
<h3 id="其它隐式类型转换"><a href="#其它隐式类型转换" class="headerlink" title="其它隐式类型转换"></a>其它隐式类型转换</h3><p>数组转换成指针；常量整数值0或字面值nullptr转换成任意类型的指针；指向任意非常量的指针能转换成void<em>；指向任意对象的指针能转换成const void</em><br>算术类型或指针转换成布尔类型；非常量类型的指针或引用转换成常量</p>
<h3 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h3><h4 id="命名的强制类型转换"><a href="#命名的强制类型转换" class="headerlink" title="命名的强制类型转换"></a>命名的强制类型转换</h4><p><em>cast-name</em>&lt;<em>type</em>&gt;(<em>expression</em>)<br>type是转换的目标类型，expression是要转换的值<br>cast-name是static_cast,dynamic_cast,const_cast,reinterpret_cast中的一种。dynamic_cast支持运行时类型识别</p>
<h4 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h4><p>任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> slope = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(j)/i;</span><br></pre></td></tr></table></figure>

<h4 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h4><p>const_cast只能改变运算对象的底层const</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* pc;</span><br><span class="line"><span class="keyword">char</span>* p = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(pc);    <span class="comment">//正确：但通过p写值是未定义的行为</span></span><br></pre></td></tr></table></figure>

<h4 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h4><p>reinterpret_cast通常为运算对象的位模式提供较低层上的重新解释</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p;</span><br><span class="line"><span class="keyword">char</span>* pc = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(p);</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/11/18/ntDfr2vgkELibe1.png" alt="Snipaste_2020-11-18_22-04-56.png"></p>
<p><img src="https://i.loli.net/2020/11/18/j4qigKCo3sO1hlf.png" alt="Snipaste_2020-11-18_22-05-18.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/11/17/ncpp-04/" data-id="ckhq93pua002ja0vebbdscgqs" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/02-cpp-primer/" rel="tag">02 cpp primer</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-操作方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/16/%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/" class="article-date">
  <time datetime="2020-11-16T15:14:59.000Z" itemprop="datePublished">2020-11-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/16/%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/">操作方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;blog</span><br><span class="line">hexo g		&#x2F;&#x2F;生成</span><br><span class="line">hexo s		&#x2F;&#x2F;本地预览</span><br><span class="line">hexo d		&#x2F;&#x2F;部署</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/11/16/%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/" data-id="ckhq93puh0039a0ve7fcedupf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ncpp-03" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/16/ncpp-03/" class="article-date">
  <time datetime="2020-11-16T15:11:10.000Z" itemprop="datePublished">2020-11-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/16/ncpp-03/">第3章 字符串、向量和数组</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="命名空间的using声明"><a href="#命名空间的using声明" class="headerlink" title="命名空间的using声明"></a>命名空间的using声明</h2><p>using声明(using declaration)形式：using namespace::name;<br>声明之后可以直接访问命名空间中的名字，无需专门的前缀<br>每个using声明引入命名空间中的一个成员<br>头文件不应包含using声明</p>
<h2 id="标准库类型string"><a href="#标准库类型string" class="headerlink" title="标准库类型string"></a>标准库类型string</h2><p>标准库类型string表示可变长的字符序列</p>
<h3 id="定义和初始化string对象"><a href="#定义和初始化string对象" class="headerlink" title="定义和初始化string对象"></a>定义和初始化string对象</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1;          <span class="comment">//默认初始化，s1是一个空字符串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(s1)</span></span>;</span><br><span class="line"><span class="built_in">string</span> s2 = s1;     <span class="comment">//s2是s1的副本</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s3</span><span class="params">(<span class="string">"hiya"</span>)</span></span>;</span><br><span class="line"><span class="built_in">string</span> s3 = <span class="string">"hiya"</span>; <span class="comment">//s3是该字符串字面值的副本</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(<span class="number">10</span>, <span class="string">'c'</span>)</span></span>; <span class="comment">//s4的内容是cccccccccc</span></span><br></pre></td></tr></table></figure>

<p>使用等号(= )初始化一个变量，实际上执行的是拷贝初始化(copy initialization)，编译器把等号右侧的初始值拷贝到新闯将的对象中去<br>不使用等号则执行的是直接初始化(direct initialization)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s5 = <span class="string">"hiya"</span>;</span><br><span class="line"><span class="built_in">string</span> s6 = (<span class="string">"hiya"</span>);</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s7</span><span class="params">(<span class="number">10</span>, <span class="string">'c'</span>)</span></span>;</span><br><span class="line"><span class="built_in">string</span> s8 = <span class="built_in">string</span>(<span class="number">10</span>, <span class="string">'c'</span>);    <span class="comment">//创建出一个临时string对象，拷贝给s8</span></span><br><span class="line"><span class="comment">//本质上等价于</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">temp</span><span class="params">(<span class="number">10</span>, <span class="string">'c'</span>)</span></span>;</span><br><span class="line"><span class="built_in">string</span> s8 = temp;</span><br></pre></td></tr></table></figure>

<h3 id="string对象上的操作"><a href="#string对象上的操作" class="headerlink" title="string对象上的操作"></a>string对象上的操作</h3><p><img src="https://i.loli.net/2020/11/16/YpJMt6gsc82TybF.png" alt="Snipaste_2020-11-16_22-44-00.png"></p>
<p>执行读取操作时，string对象会自动忽略开头的空白(空格符、换行符、制表符等)并从第一个真正的字符开始读起，直到遇到下一处空白为止</p>
<p>getline读取一整行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> <span class="built_in">line</span>;</span><br><span class="line"><span class="keyword">while</span> (getline(<span class="built_in">cin</span>, <span class="built_in">line</span>))</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">line</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>成员函数line.empty()根据是否为空返回对应布尔值</p>
<p>size函数返回string对象的长度。是string::size_type类型，无符号类型且能存放下任何string对象的大小<br>若n是一个负int，则s.size() &lt; n几乎肯定是true</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">"Hello"</span>, phrase = <span class="string">"Hello World"</span>, slang = <span class="string">"Hiya"</span>;</span><br><span class="line">slang &gt; phrase &gt; str</span><br></pre></td></tr></table></figure>

<h4 id="字面值和string相加"><a href="#字面值和string相加" class="headerlink" title="字面值和string相加"></a>字面值和string相加</h4><p>必须保证’+’运算符两侧运算对象至少有一个是string</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1 = <span class="string">"hello"</span>;</span><br><span class="line"><span class="built_in">string</span> s2 = s1 + <span class="string">", "</span>;              <span class="comment">//正确</span></span><br><span class="line"><span class="built_in">string</span> s3 = s1 + <span class="string">", "</span> + <span class="string">"world"</span>;    <span class="comment">//正确：(s1+", ")+"world"</span></span><br><span class="line"><span class="built_in">string</span> s4 = <span class="string">"hello"</span> + <span class="string">", "</span> + <span class="string">"s2"</span>;  <span class="comment">//错误</span></span><br><span class="line"><span class="built_in">string</span> s5 = <span class="string">"hello"</span> + <span class="string">", "</span>;         <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/11/16/2SBnUzZPQDuNRGq.png" alt="Snipaste_2020-11-16_22-45-53.png"></p>
<p>使用范围for语句改变字符串中的字符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"hello World!!!"</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : s)</span><br><span class="line">    c = <span class="built_in">toupper</span>(c); <span class="comment">//引用才可以改变值</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//HELLO WORDL!!!</span></span><br></pre></td></tr></table></figure>

<h2 id="标准库类型vector"><a href="#标准库类型vector" class="headerlink" title="标准库类型vector"></a>标准库类型vector</h2><p>标准库类型vector表示对象的集合，其中所有对象的类型都相同</p>
<h3 id="定义和初始化vector对象"><a href="#定义和初始化vector对象" class="headerlink" title="定义和初始化vector对象"></a>定义和初始化vector对象</h3><p><img src="https://i.loli.net/2020/11/16/DV6PNmQ7G5vqheB.png" alt="Snipaste_2020-11-16_22-46-57.png"></p>
<h4 id="列表初始值或元素数量"><a href="#列表初始值或元素数量" class="headerlink" title="列表初始值或元素数量"></a>列表初始值或元素数量</h4><p>通过使用花括号或圆括号来区分</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v1(<span class="number">10</span>);      <span class="comment">//10个元素，每个都是0</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v2&#123; <span class="number">10</span> &#125;;    <span class="comment">//1个元素10</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v3(<span class="number">10</span>, <span class="number">1</span>);   <span class="comment">//10个元素1</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v4&#123; <span class="number">10</span>,<span class="number">1</span> &#125;;  <span class="comment">//2个元素10和1</span></span><br><span class="line"><span class="comment">//用花括号时，若无法执行列表初始化才会考虑其他初始化方式</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;v5&#123; <span class="string">"hi"</span> &#125;;       <span class="comment">//列表初始化，有一个"hi"</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;v6(<span class="string">"hi"</span>);         <span class="comment">//错误：不能使用字符串字面值构建vector对象</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;v7&#123; <span class="number">10</span> &#125;;         <span class="comment">//10个默认初始化的元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;v8&#123; <span class="number">10</span>,<span class="string">"hi"</span> &#125;;    <span class="comment">//10个"hi" vector&lt;string&gt;v8(10 , "hi")效果相同</span></span><br></pre></td></tr></table></figure>

<h3 id="向vector对象中添加元素"><a href="#向vector对象中添加元素" class="headerlink" title="向vector对象中添加元素"></a>向vector对象中添加元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> <span class="keyword">word</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;<span class="built_in">text</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; <span class="keyword">word</span>)</span><br><span class="line">    <span class="built_in">text</span>.push_back(<span class="keyword">word</span>);</span><br></pre></td></tr></table></figure>

<p>如果循环体内包含有向vector对象添加元素的语句，则不能使用范围for循环</p>
<h3 id="其它vector操作"><a href="#其它vector操作" class="headerlink" title="其它vector操作"></a>其它vector操作</h3><p><img src="https://i.loli.net/2020/11/16/NmlJMAVwsaj6cXd.png" alt="Snipaste_2020-11-16_22-47-58.png"></p>
<p>size_type需要首先指定它是由哪种类型定义的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type  <span class="comment">//正确</span></span><br><span class="line"><span class="built_in">vector</span>::size_type       <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<p>vector对象的大小关系由第一对相异的元素值的大小关系决定</p>
<p>只能对确知已存在的元素执行下标操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;ivec;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ivec[<span class="number">0</span>];    <span class="comment">//错误：ivec不包含任何元素</span></span><br><span class="line">vecator&lt;<span class="keyword">int</span>&gt;ivec2(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ivec2[<span class="number">10</span>];  <span class="comment">//错误：ivec2的合法索引是0-9</span></span><br></pre></td></tr></table></figure>

<p>用下标的形式去访问一个不存在的元素将引发错误，不会被编译器发现，而是在运行时产生一个不可预知的值<br>缓冲区溢出(buffer overflow)指的就是这种错误</p>
<h2 id="迭代器介绍"><a href="#迭代器介绍" class="headerlink" title="迭代器介绍"></a>迭代器介绍</h2><p>迭代器提供了对对象的间接访问。<br>有效迭代器：指向某个元素或指向容器中尾元素的下一位置；其它所有情况都属于无效</p>
<h3 id="使用迭代器"><a href="#使用迭代器" class="headerlink" title="使用迭代器"></a>使用迭代器</h3><p>如果容器为空，begin和end返回的是同一个迭代器，都是尾后迭代器</p>
<h4 id="迭代器运算符"><a href="#迭代器运算符" class="headerlink" title="迭代器运算符"></a>迭代器运算符</h4><p><img src="https://i.loli.net/2020/11/16/OqUB6AsimFGxey9.png" alt="Snipaste_2020-11-16_23-52-23.png"></p>
<p>试图解引用一个非法迭代器或者尾后迭代器都是未被定义的行为</p>
<h4 id="迭代器类型"><a href="#迭代器类型" class="headerlink" title="迭代器类型"></a>迭代器类型</h4><p>拥有迭代器的标准库类型使用iterator和const_iterator来表示迭代器的类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;   <span class="comment">//it能读写vector&lt;int&gt;的元素</span></span><br><span class="line"><span class="built_in">string</span>::iterator it2;       <span class="comment">//it2能读写string对象中的元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;const_iterator it3;  <span class="comment">//it3只能读元素，不能写</span></span><br><span class="line"><span class="built_in">string</span>::const_iterator it4;     <span class="comment">//it4只能读字符，不能写</span></span><br></pre></td></tr></table></figure>

<p>如果vector或string的对象是一个常量，只能使用const_iterator；如果不是常量，则两种都能使用</p>
<h4 id="begin和end运算符"><a href="#begin和end运算符" class="headerlink" title="begin和end运算符"></a>begin和end运算符</h4><p>begin和end返回的具体类型由对象是否是常量决定</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;cv;</span><br><span class="line"><span class="keyword">auto</span> it1 = v.<span class="built_in">begin</span>();   <span class="comment">//it1的类型是vector&lt;int&gt;::iterator</span></span><br><span class="line"><span class="keyword">auto</span> it2 = cv.<span class="built_in">end</span>();    <span class="comment">//it2的类型是vector&lt;int&gt;::const_iterator</span></span><br><span class="line"><span class="keyword">auto</span> it3 = v.cbegin();  <span class="comment">//it3的类型是vector&lt;int&gt;::const_iterator</span></span><br></pre></td></tr></table></figure>

<h4 id="结合解引用和成员访问操作"><a href="#结合解引用和成员访问操作" class="headerlink" title="结合解引用和成员访问操作"></a>结合解引用和成员访问操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(*it).empty();  <span class="comment">//解引用it，然后调用结果对象的empty成员</span></span><br><span class="line">*it.empty();    <span class="comment">//错误：试图访问it的名为empty的成员</span></span><br><span class="line">                <span class="comment">//但it是个迭代器，没有empty成员</span></span><br><span class="line">it-&gt;empty();    <span class="comment">//正确：it-&gt;mem和(*it).mem相同</span></span><br></pre></td></tr></table></figure>

<h3 id="迭代器运算"><a href="#迭代器运算" class="headerlink" title="迭代器运算"></a>迭代器运算</h3><p><img src="https://i.loli.net/2020/11/17/xjFDdBJuOs5In1l.png" alt="Snipaste_2020-11-17_13-16-01.png"></p>
<p>两个迭代器相减的结果是之间的距离，是类型为difference_type的带符号整型数</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组运行时性能较好，但大小确定不变，不能随意向数组中增加元素</p>
<h3 id="定义和初始化数组"><a href="#定义和初始化数组" class="headerlink" title="定义和初始化数组"></a>定义和初始化数组</h3><p>数组是一种符合类型。数组的声明形如a[d]，其中a是数组的名字，d是数组的维度，必须大于0，必须是一个常量表达式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> cnt = <span class="number">42</span>;          <span class="comment">//不是常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">unsigned</span> sz = <span class="number">42</span>; <span class="comment">//常量表达式</span></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];                <span class="comment">//含有10个整数的数组</span></span><br><span class="line"><span class="keyword">int</span>* parr[sz];              <span class="comment">//含有42个整型指针的数组</span></span><br><span class="line"><span class="built_in">string</span> bad[cnt];            <span class="comment">//错误：cnt不是常量表达式</span></span><br><span class="line"><span class="built_in">string</span> strs[get_size()];    <span class="comment">//当get_size()是constexpr时正确，否则错误</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，数组的元素被默认初始化<br>定义数组的时候必须指定数组的类型，不允许用auto关键字<br>数组的元素应为对象，不存在引用的数组</p>
<h4 id="显式初始化数组元素"><a href="#显式初始化数组元素" class="headerlink" title="显式初始化数组元素"></a>显式初始化数组元素</h4><p>声明时没有指明维度，编译器会根据初始值的数量计算并推测出来<br>如果维度比提供的数量大，用提供的初始化靠前的元素，剩下的默认初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> sz = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> ia1[sz] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;        <span class="comment">//含有3个元素的数组</span></span><br><span class="line"><span class="keyword">int</span> a2[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;           <span class="comment">//维度是3的数组</span></span><br><span class="line"><span class="keyword">int</span> a3[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;          <span class="comment">//等价于a3[]=&#123;0,1,2,0,0&#125;</span></span><br><span class="line"><span class="built_in">string</span> a4[<span class="number">4</span>] = &#123;<span class="string">"hi"</span>, <span class="string">"bye"</span>&#125;;   <span class="comment">//等价于a4[]=&#123;"hi","bye",""&#125;</span></span><br><span class="line"><span class="keyword">int</span> a5[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;          <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<p>可以用字符串字面值对数组初始化，字符串字面值的结尾处还有一个空字符，也会被拷贝到字符数组中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a1[]=&#123; <span class="string">'C'</span>,<span class="string">'+'</span>,<span class="string">'+'</span> &#125;;          <span class="comment">//列表初始化，没有空字符，维度为3</span></span><br><span class="line"><span class="keyword">char</span> a2[] = &#123; <span class="string">'C'</span>,<span class="string">'+'</span>,<span class="string">'+'</span> ,<span class="string">'\0'</span> &#125;;  <span class="comment">//列表初始化，含有显式的空字符，维度为4</span></span><br><span class="line"><span class="keyword">char</span> a3[] = <span class="string">"C++"</span>;                  <span class="comment">//自动添加表示字符串结束的空字符，维度为4</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> a4[<span class="number">6</span>] = <span class="string">"Daniel"</span>;        <span class="comment">//错误：没有空间可存放空字符</span></span><br></pre></td></tr></table></figure>

<p>不能将数组的内容拷贝给其它数组作为初始值，也不能用数组为其它数组赋值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> a2[] = a;   <span class="comment">//错误</span></span><br><span class="line">a2 = a;         <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<h4 id="复杂的数组声明"><a href="#复杂的数组声明" class="headerlink" title="复杂的数组声明"></a>复杂的数组声明</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* ptrs[<span class="number">10</span>];          <span class="comment">//含有10个整型指针的数组</span></span><br><span class="line"><span class="keyword">int</span>&amp; refs[<span class="number">10</span>] =<span class="comment">/* ? */</span>; <span class="comment">//错误：不存在引用的数组</span></span><br><span class="line"><span class="keyword">int</span>(*Parray)[<span class="number">10</span>] = &amp;arr;<span class="comment">//Parray指向一个含有10个整数的数组</span></span><br><span class="line"><span class="keyword">int</span>(&amp;arrRef)[<span class="number">10</span>] = arr; <span class="comment">//arrRef引用一个含有10个整数的数组</span></span><br><span class="line"><span class="keyword">int</span>* (&amp;<span class="built_in">array</span>)[<span class="number">10</span>] = ptrs;<span class="comment">//arry是数组的引用，数组含有10个整型指针</span></span><br></pre></td></tr></table></figure>

<p>类型修饰符从右向左理解，ptrs：定义了一个大小为10的数组，名字是ptrs，数组存放的是int类型指针<br>Parray：括号内表明是个指针，指向大小为10的数组，数组中元素是int型</p>
<h3 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h3><p>使用数组下标时，通常定义为size_t类型，是一种机器相关的无符号类型</p>
<h3 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h3><p>在很多用到数组名字的地方，编译器会自动地将其替换为一个指向数组首元素的指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> nums[] = &#123;<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>&#125;;</span><br><span class="line"><span class="built_in">string</span>* p = &amp;nums[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">string</span>* p2 = nums;  <span class="comment">//等价于p2 = &amp;nums[0]</span></span><br></pre></td></tr></table></figure>

<p>当使用数组作为一个auto变量的初始值时，推断得到的类型是指针而非数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ia2</span><span class="params">(ia)</span></span>;   <span class="comment">//ia2是一个整型指针，指向ia的第一个元素</span></span><br><span class="line"><span class="comment">//类似于 auto ia2(&amp;ia[0])</span></span><br><span class="line">ia2 = <span class="number">42</span>;       <span class="comment">//错误：ia2是一个整型指针，不能用int值赋值</span></span><br></pre></td></tr></table></figure>

<p>使用decltype关键字时转换不会发生</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ia3是一个含有5个整数的数组</span></span><br><span class="line"><span class="keyword">decltype</span>(ia) ia3 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">ia3 = p;    <span class="comment">//错误：不能用整型指针给数组赋值</span></span><br><span class="line">ia3[<span class="number">4</span>] = i; <span class="comment">//正确：把i赋值给ia3的元素</span></span><br></pre></td></tr></table></figure>

<h4 id="指针也是迭代器"><a href="#指针也是迭代器" class="headerlink" title="指针也是迭代器"></a>指针也是迭代器</h4><p>数组的指针支持vector和string迭代器支持的全部运算<br>获取数组尾元素后元素的地址</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>* e = &amp;arr[<span class="number">5</span>];   <span class="comment">//指向arr尾元素的下一位置的指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span>* b = arr; b != e; ++b)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *b &lt;&lt; <span class="built_in">endl</span>;     <span class="comment">//输出arr的元素</span></span><br></pre></td></tr></table></figure>

<p>尾后指针不指向具体的元素，不能对其解引用或递增</p>
<h4 id="标准库函数begin和end"><a href="#标准库函数begin和end" class="headerlink" title="标准库函数begin和end"></a>标准库函数begin和end</h4><p>这两个函数不是成员函数。用数组作为它们的参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>* beg = <span class="built_in">begin</span>(ia);</span><br><span class="line"><span class="keyword">int</span>* <span class="built_in">end</span> = <span class="built_in">end</span>(ia);</span><br></pre></td></tr></table></figure>

<p>begin函数返回指向ia首元素的指针，end返回指向ia尾元素下一位置的指针</p>
<h4 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h4><p>指针加(减)某整数值，结果仍是指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">size_t</span> sz = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> arr[sz] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>* ip = arr;      <span class="comment">//等价于int* ip=&amp;arr[0]</span></span><br><span class="line"><span class="keyword">int</span>* ip2 = ip + <span class="number">4</span>;  <span class="comment">//ip2指向arr[4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* ip3 = arr + sz;<span class="comment">//指向尾元素的下一位置</span></span><br><span class="line"><span class="keyword">int</span>* ip4 = arr + <span class="number">10</span>;<span class="comment">//错误：只有5个元素，ip4的值未定义</span></span><br></pre></td></tr></table></figure>

<p>相减的结果是之间的距离，两个指针必须指向同一数组当中的元素<br>类型为ptrdiff_t，是一种机器相关的带符号类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> n = <span class="built_in">end</span>(arr) - <span class="built_in">begin</span>(arr); <span class="comment">//n=5</span></span><br></pre></td></tr></table></figure>

<p>允许给空指针加上或减去一个值为0的整型常量表达式。两个空指针允许相减，结果为0</p>
<h4 id="解引用和指针运算的交互"><a href="#解引用和指针运算的交互" class="headerlink" title="解引用和指针运算的交互"></a>解引用和指针运算的交互</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> last = *(ia+<span class="number">3</span>); <span class="comment">//last=ia[3]</span></span><br><span class="line"><span class="keyword">int</span> a = *ia + <span class="number">3</span>;    <span class="comment">//a=0+3</span></span><br></pre></td></tr></table></figure>

<p>数组使用下标运算时，编译器会将数组名字转换为指向数组首元素的指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> i = ia[<span class="number">2</span>];  <span class="comment">//i=4</span></span><br><span class="line"><span class="keyword">int</span>* p = ia;</span><br><span class="line">i = *(p+<span class="number">2</span>);     <span class="comment">//i=4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* p = &amp;ia[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> j = p[<span class="number">1</span>];   <span class="comment">//j=6</span></span><br><span class="line"><span class="keyword">int</span> k = p[<span class="number">-2</span>];  <span class="comment">//k=0</span></span><br></pre></td></tr></table></figure>

<p>内置的下标运算符不是无符号类型，与vector和string不同</p>
<h3 id="C风格字符串"><a href="#C风格字符串" class="headerlink" title="C风格字符串"></a>C风格字符串</h3><p>C风格字符串的函数<br><img src="https://i.loli.net/2020/11/17/Ryrf9zEuPhlXHn1.png" alt="Snipaste_2020-11-17_16-05-23.png"></p>
<p>传入此类函数的指针必须指向以空字符作为结束的数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ca[] = &#123;<span class="string">'C'</span>,<span class="string">'+'</span>,<span class="string">'+'</span>&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">strlen</span>(ca) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//错误：ca没有以空字符结束</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> ca1[]=&#123;<span class="string">"A string example"</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> ca2[]=&#123;<span class="string">"A different string"</span>&#125;;</span><br><span class="line"><span class="keyword">if</span>(ca1 &lt; ca2)   <span class="comment">//未定义的：试图比较两个无关的地址</span></span><br><span class="line"><span class="comment">//实际比较的是指针而非字符本身</span></span><br></pre></td></tr></table></figure>

<h3 id="与旧代码的接口"><a href="#与旧代码的接口" class="headerlink" title="与旧代码的接口"></a>与旧代码的接口</h3><p>·允许使用以空字符结束的字符数组来初始化string对象或为string对象赋值<br>·在string对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象<br>反过来不成立</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* str = s;      <span class="comment">//错误：不能用string对象初始化char*</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* str = s.c_str();    <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>

<p>允许使用数组来初始化vector对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> int_arr[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ivec</span><span class="params">(<span class="built_in">begin</span>(int_arr),<span class="built_in">end</span>(int_arr))</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">subVec</span><span class="params">(int_arr+<span class="number">1</span>,int_arr+<span class="number">3</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>多维数组其实是数组的数组</p>
<h4 id="多维数组的初始化"><a href="#多维数组的初始化" class="headerlink" title="多维数组的初始化"></a>多维数组的初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;,</span><br><span class="line">    &#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>，<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span>，<span class="number">5</span>，<span class="number">6</span>，<span class="number">7</span>，<span class="number">8</span>，<span class="number">9</span>，<span class="number">10</span>，<span class="number">11</span>&#125;；</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0</span>&#125;,&#123;<span class="number">4</span>&#125;,&#123;<span class="number">8</span>&#125;&#125;;   <span class="comment">//仅初始化每行第一个元素，其它默认初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ix[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>&#125;;   <span class="comment">//初始化第一行，其它默认初始化</span></span><br></pre></td></tr></table></figure>

<h4 id="使用范围for语句处理多维数组"><a href="#使用范围for语句处理多维数组" class="headerlink" title="使用范围for语句处理多维数组"></a>使用范围for语句处理多维数组</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;row : ia)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; col : row)&#123;</span><br><span class="line">        col = cnt;</span><br><span class="line">        ++cnt;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>外层循环是引用形式防止转换成指针，除最内层外，都应是引用类型</p>
<h4 id="指针和多维数组"><a href="#指针和多维数组" class="headerlink" title="指针和多维数组"></a>指针和多维数组</h4><p>当程序使用多维数组的名字时，也会自动将其转换成指向数组首元素的指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> (*p)[<span class="number">4</span>] = ia;   <span class="comment">//p指向含有4个整数的数组</span></span><br><span class="line">p = &amp;ia[<span class="number">2</span>];         <span class="comment">//p指向ia的尾元素</span></span><br><span class="line"><span class="comment">//声明中的圆括号不可少</span></span><br><span class="line"><span class="keyword">int</span>* ip[<span class="number">4</span>];     <span class="comment">//整型指针的数组</span></span><br><span class="line"><span class="keyword">int</span> (*ip)[<span class="number">4</span>];   <span class="comment">//指向含有4个整数的数组</span></span><br></pre></td></tr></table></figure>

<p>通过使用auto或decltype能尽可能地在数组前加上指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//p指向含有4个整数的数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> p = ia; p != ia+<span class="number">3</span>; ++p)&#123;</span><br><span class="line">    <span class="comment">//q指向4个整数数组的首元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> q = *p; q != p+<span class="number">4</span>; ++q)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *q &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> p = <span class="built_in">begin</span>(ia); p != <span class="built_in">end</span>(ia); ++p)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> q = <span class="built_in">begin</span>(*p); q != <span class="built_in">end</span>(*p); ++q)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *q &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/11/16/ncpp-03/" data-id="ckhq93pu9002ga0veg881edhg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/02-cpp-primer/" rel="tag">02 cpp primer</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ncpp-02" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/16/ncpp-02/" class="article-date">
  <time datetime="2020-11-16T14:56:31.000Z" itemprop="datePublished">2020-11-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/16/ncpp-02/">第2章 变量和基本类型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h1><p>算术类型(arithmetic)，包括字符、整型数、布尔值和浮点数。<br>空类型(void)不对应具体的值，仅用于一些特殊场合</p>
<h2 id="算术类型"><a href="#算术类型" class="headerlink" title="算术类型"></a>算术类型</h2><p>分为整型(integral type，包括字符和布尔类型等)和浮点型<br><img src="https://i.loli.net/2020/11/16/X5dCpOBoTg2ElNY.png" alt="Snipaste_2020-11-16_22-58-27.png"></p>
<p>通过在带符号的类型int, short, long long前添加unsigned就可以得到无符号类型<br>unsigned int可以缩写为unsigned<br>无符号仅能表示大于等于0的值</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsigned char c &#x3D; -1;	&#x2F;&#x2F;假设char占8比特，c的值为255</span><br><span class="line">signed char c2 &#x3D; 256;	&#x2F;&#x2F;假设char占8比特，c2的值是未定义的</span><br></pre></td></tr></table></figure>
<p>·把非布尔类型的算术值赋给布尔类型时，初始值为0则为false，否则为true。<br>·把布尔类型赋给非布尔类型时，初始值为false则结果为0，true则结果为1。<br>·把浮点数赋给整数类型时，结果值仅保留小数点之前部分。<br>·把整数值赋给浮点类型时，小数部分记为0。若该整数所占空间超过浮点数容量，精度可能损失。<br>·赋给无符号类型一个超过它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。<br>·赋给带符号类型超出表示范围的值时，结果是未定义的(undefined)。程序可能继续工作、崩溃，也可能产生垃圾数据。</p>
<p>当算术表达式中既有无符号数又有int时，int会转换成无符号数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">unsigned u &#x3D; 10,u2&#x3D;42;</span><br><span class="line">int i &#x3D; -42;</span><br><span class="line">cout &lt;&lt; u + i &lt;&lt; endl;	&#x2F;&#x2F;如果int占32位，输出4294967264</span><br><span class="line">cout &lt;&lt; u - u2 &lt;&lt; endl;	&#x2F;&#x2F;输出4294967264</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;错误：u永远不会小于0，循环条件一直成立</span><br><span class="line">for (unsigned u &#x3D; 10; u &gt;&#x3D; 0; --u)</span><br><span class="line">	cout &lt;&lt; u &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h3 id="字面值常量"><a href="#字面值常量" class="headerlink" title="字面值常量"></a>字面值常量</h3><p>字面值常量的形式和值决定了它的数据类型</p>
<h3 id="整型和浮点型字面值"><a href="#整型和浮点型字面值" class="headerlink" title="整型和浮点型字面值"></a>整型和浮点型字面值</h3><p>整型字面值具体的数据类型由它的值和符号决定。默认情况下，十进制字面值是带符号数，八和十六进制字面值既可能是带符号的也可能是无符号的。<br>类型是满足容纳的条件下尺寸最小的。<br>默认浮点型字面值是double<br>用后缀来表示字面值类型</p>
<p><img src="https://i.loli.net/2020/11/16/Kaif5PYEUgQILlt.png" alt="Snipaste_2020-11-16_22-59-22.png"></p>
<h3 id="字符和字符串字面值"><a href="#字符和字符串字面值" class="headerlink" title="字符和字符串字面值"></a>字符和字符串字面值</h3><p>单引号括起来的一个字符称为char型字面值，双引号括起来的零个或多个字符构成字符串型字面值<br>字符串字面值的类型是由常量字符构成的数组<br>编译器在每个字符串的结尾处添加一个空字符(‘\0’)，实际长度比内容多1</p>
<h3 id="转义序列"><a href="#转义序列" class="headerlink" title="转义序列"></a>转义序列</h3><p>两类字符串不能直接使用：不可打印(nonprintable)的字符，如退格，没有可视的图符；有特殊含义的字符(单双引号等)。<br>此时需要用到转义序列</p>
<p><img src="https://i.loli.net/2020/11/16/Qg3GkSIYhUPA7Ev.png" alt="Snipaste_2020-11-16_23-00-13.png"></p>
<h3 id="指定字面值的类型"><a href="#指定字面值的类型" class="headerlink" title="指定字面值的类型"></a>指定字面值的类型</h3><p>通过添加前缀和后缀，可以改变整型、浮点型和字符型字面值的默认类型<br>L’a’;        //宽字符型字面值，类型是wchar_t<br>u8”hi!”;    //utf-8字符串字面值<br>42ULL;        //无符号整型字面值，类型是unsigned long long</p>
<p>nullptr是指针字面值</p>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>变量提供一个具名的、可供程序操作的存储空间，数据类型决定着变量所占内存空间的大小和布局方式、该空间能储存的值的范围，以及变量能参与的运算。</p>
<h2 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h2><p>首先是类型说明符(type specifier)，随后紧跟由一个或多个变量名组成的列表，以逗号分隔，以分号结束。<br>string book(“aasf”);//book通过一个string字面值初始化</p>
<h3 id="初始值"><a href="#初始值" class="headerlink" title="初始值"></a>初始值</h3><p>当对象在创建时获得了一个特定的值，我们是这个对象被初始化(initialized)了<br>当一次定义了多个变量时，对象的名字随着定义也就马上可以使用了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;正确，price先被定义并赋值，随后被用于初始化discount</span><br><span class="line">double price &#x3D; 109.99, discount &#x3D; price * 0.16;</span><br></pre></td></tr></table></figure>
<p>初始化的含义是创建变量时赋予一个初始值，赋值是把对象的当前值擦除，而以一个新值来替代</p>
<h3 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int units_sold &#x3D; 0;</span><br><span class="line">int units_sold &#x3D; &#123; 0 &#125;;</span><br><span class="line">int units_sold&#123; 0 &#125;;</span><br><span class="line">int units_sold(0);</span><br></pre></td></tr></table></figure>
<p>列表初始化(list initialization)时，若初始值存在丢失信息的风险，则编译器将报错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">long double ld &#x3D; 3.1415926536;</span><br><span class="line">int a&#123; ld &#125;, b &#x3D; &#123; ld &#125;;	&#x2F;&#x2F;错误：转换未执行，因为存在丢失信息的危险</span><br><span class="line">int c(ld), d &#x3D; ld;			&#x2F;&#x2F;正确：转换执行，且确实丢失了部分值</span><br><span class="line"></span><br><span class="line">### 默认初始化</span><br><span class="line">定义变量时没有指定初始值，则变量被默认初始化(default initialized)，被赋予默认值，由类型和位置决定</span><br><span class="line">定义于函数外的内置类型默认初始化为0。函数体内部的内置类型变量将不被初始化(uninitialized)。未被初始化的内置类型变量的值是未定义的，访问此类值将引发错误。</span><br><span class="line"></span><br><span class="line">## 变量声明和定义</span><br></pre></td></tr></table></figure>
<p>extern int i;                //声明而非定义i<br>int j;                        //声明并定义j<br>extern double pi = 3.1416;    //定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">在函数体内部，初始化一个由extern关键字标记的变量将引发错误</span><br><span class="line">变量只能被定义一次，可以被多次声明</span><br><span class="line"></span><br><span class="line">extern可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。此外extern也可用来进行链接指定。</span><br><span class="line"></span><br><span class="line">### 标识符</span><br><span class="line">标识符(identifier)由字母、数字和下画线组成，必须以字母或下画线开头</span><br><span class="line">不能连续出现两个下画线，不能以下画线紧连大写字母开头，定义在函数体外的标识符不能以下画线开头</span><br><span class="line"></span><br><span class="line">## 名字的作用域 </span><br><span class="line">名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结束</span><br><span class="line"></span><br><span class="line">### 嵌套的作用域</span><br></pre></td></tr></table></figure>
<p>int reused = 42;<br>int main() {<br>    int unique = 0;<br>    cout &lt;&lt; reused &lt;&lt; “ “ &lt;&lt; unique &lt;&lt; endl;    //42 0<br>    int reused = 0;<br>    cout &lt;&lt; reused &lt;&lt; “ “ &lt;&lt; unique &lt;&lt; endl;    //0 0<br>    cout &lt;&lt; ::reused &lt;&lt; “ “ &lt;&lt; unique &lt;&lt; endl;    //42 0<br>}</p>
<h1 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h1><p>复合类型(compund type)是指基于其它类型定义的类型。<br>一条声明语句由一个基本数据类型(base type)和紧随其后的一个声明符(declarator)列表组成。每个声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>引用(reference)为对象起了另一个名字，引用类型引用(refer to)另外一种类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int ival &#x3D; 1024;</span><br><span class="line">int&amp; refVal &#x3D; ival;	&#x2F;&#x2F;refVal指向ival</span><br><span class="line">int&amp; refVal12;		&#x2F;&#x2F;报错：引用必须被初始化</span><br></pre></td></tr></table></figure>
<p>定义引用时，程序吧引用和它的初始值绑定(bind)在一起，而不是将初始值拷贝给引用。无法令引用重新绑定到另一个对象，引用必须初始化<br>引用本身不是一个对象，不能定义引用的引用</p>
<p>允许在一条语句中定义多个引用，其中每个引用标识符都必须以&amp; 开头</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D; 1024, i2 &#x3D; 2048;	&#x2F;&#x2F;i和i2都是int</span><br><span class="line">int&amp; r &#x3D; i, r2 &#x3D; i2;		&#x2F;&#x2F;r是引用，r2是int</span><br><span class="line">int i3 &#x3D; 1024, &amp; ri &#x3D; i3;	</span><br><span class="line">int&amp; r3 &#x3D; i3, &amp; r4 &#x3D; i2;</span><br><span class="line">int&amp; refVal4 &#x3D; 10;		&#x2F;&#x2F;错误：引用类型的初始值必须是一个对象</span><br><span class="line">double dval &#x3D; 3.14;</span><br><span class="line">int&amp; refVal &#x3D; dval;		&#x2F;&#x2F;错误：此处引用类型的初始值必须是int对象</span><br></pre></td></tr></table></figure>

<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>指针(pointer)是“指向(point to)”另外一种类型的复合类型<br>指针本身就是一个对象，允许对指针赋值和拷贝，生命周期内可以先后指向几个不同的对象<br>指针无须在定义时赋值<br>在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int ival &#x3D; 42;</span><br><span class="line">int* p &#x3D; &amp;ival;	&#x2F;&#x2F;p存放变量ival的地址，或者说p是指向变量ival的指针</span><br><span class="line"></span><br><span class="line">double dval;</span><br><span class="line">double* pd &#x3D; &amp;dval;	&#x2F;&#x2F;正确：初始值double型对象的地址</span><br><span class="line">double* pd2 &#x3D; pd;	&#x2F;&#x2F;正确：初始值是指向double对象的指针</span><br><span class="line"></span><br><span class="line">int* pi &#x3D; pd;	&#x2F;&#x2F;错误：指针pi的类型和pd的不匹配</span><br><span class="line">pi &#x3D; &amp;dval;		&#x2F;&#x2F;错误：试图把double型对象的地址赋给int型指针</span><br></pre></td></tr></table></figure>
<p>对指针解引用会得出所指对象</p>
<h3 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h3><p>空指针(null pointer)不指向任何对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int* p1 &#x3D; nullptr;	&#x2F;&#x2F;等价于int* p1&#x3D;0</span><br><span class="line">int* p2 &#x3D; 0;		&#x2F;&#x2F;直接将p2初始化为字面常量0</span><br><span class="line">int* p3 &#x3D; NULL;		&#x2F;&#x2F;等价于int* p3&#x3D;0</span><br></pre></td></tr></table></figure>
<p>两个指针相等：都为空、都指向同一个对象、都指向同一个对象的下一个地址</p>
<h3 id="void-指针"><a href="#void-指针" class="headerlink" title="void*指针"></a>void*指针</h3><p>void* 指针可用于存放任意对象的地址，但对地址中对象类型并不了解<br>只能和别的指针比较、作为函数的输入或输出、赋给另一个void* 指针。不能直接操作void* 指针所指的对象</p>
<h3 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int ival &#x3D; 1024;	</span><br><span class="line">int* pi &#x3D; &amp;ival;	&#x2F;&#x2F;pi指向一个int型的数</span><br><span class="line">int** ppi &#x3D; &amp;pi;	&#x2F;&#x2F;ppi指向一个int型的指针</span><br></pre></td></tr></table></figure>

<h3 id="指向指针的引用"><a href="#指向指针的引用" class="headerlink" title="指向指针的引用"></a>指向指针的引用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D; 42;</span><br><span class="line">int* p;		&#x2F;&#x2F;p是一个int型的指针</span><br><span class="line">int*&amp; r &#x3D; p;&#x2F;&#x2F;r是对指针p的引用</span><br><span class="line"></span><br><span class="line">r &#x3D; &amp;i;		&#x2F;&#x2F;r引用了一个指针，因此给r赋值&amp;i就是令p指向i</span><br><span class="line">*r &#x3D; 0;		&#x2F;&#x2F;解引用r得到i，也就是p指向的对象，将i值改为0</span><br></pre></td></tr></table></figure>
<p>从右向左读r的定义，最近的&amp; 对r有最直接的影响，所以r是一个引用，* 说明r引用的是一个指针，int表示是一个int型指针</p>
<h1 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h1><p>const对象一旦创建后值不能改变，必须初始化</p>
<p>默认状态下，const对象仅在文件内有效</p>
<p>想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;file_1.cc定义并初始化了一个常量，该常量能被其它文件访问</span><br><span class="line">extern const int bufSize &#x3D; fcn();</span><br><span class="line">&#x2F;&#x2F;file_1.h头文件</span><br><span class="line">extern const int bufSize;	&#x2F;&#x2F;与file_1.cc中定义的bufSize是同一个</span><br></pre></td></tr></table></figure>

<h2 id="const的引用"><a href="#const的引用" class="headerlink" title="const的引用"></a>const的引用</h2><p>可以把引用绑定到const对象上，称为对常量的引用(reference to const)。对常量的引用不能被用作修改它所绑定的对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const int ci &#x3D; 1024;	</span><br><span class="line">const int&amp; r1 &#x3D; ci;	&#x2F;&#x2F;正确：引用及其对应的对象都是常量</span><br><span class="line">r1 &#x3D; 42;			&#x2F;&#x2F;错误：r1是对常量的引用</span><br><span class="line">int&amp; r2 &#x3D; ci;		&#x2F;&#x2F;错误：试图让一个非常量引用指向一个常量对象</span><br></pre></td></tr></table></figure>

<h3 id="初始化和对const的引用"><a href="#初始化和对const的引用" class="headerlink" title="初始化和对const的引用"></a>初始化和对const的引用</h3><p>引用的类型必须与其所引用的对象类型一直，例外：<br>初始化常量引用时允许用任意表达式作为初始值，只要能转换成引用的类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D; 42;</span><br><span class="line">const int&amp; r1 &#x3D; i;		&#x2F;&#x2F;允许将const int&amp;绑定到一个普通int对象上</span><br><span class="line">const int&amp; r2 &#x3D; 42;		&#x2F;&#x2F;正确：r2是一个常量引用</span><br><span class="line">const int&amp; r3 &#x3D; r1 * 2;	&#x2F;&#x2F;正确</span><br><span class="line">int&amp; r4 &#x3D; r1 * 2;		&#x2F;&#x2F;错误：r4是一个普通的非常量引用</span><br></pre></td></tr></table></figure>

<p>对const的引用可能引用一个并非const的对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D; 42;</span><br><span class="line">int&amp; r1 &#x3D; i;		&#x2F;&#x2F;引用r1绑定对象i</span><br><span class="line">const int&amp; r2 &#x3D; i;	&#x2F;&#x2F;r2也绑定对象i，但不允许通过r2修改i的值</span><br><span class="line">r1 &#x3D; 0;				&#x2F;&#x2F;r1并非常量，i的值修改为0</span><br><span class="line">r2 &#x3D; 0;				&#x2F;&#x2F;错误：r2是一个常量引用</span><br></pre></td></tr></table></figure>

<h2 id="指针和const"><a href="#指针和const" class="headerlink" title="指针和const"></a>指针和const</h2><p>指向常量的指针(pointer to const)不能用于改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const double pi &#x3D; 3.14;</span><br><span class="line">double* ptr &#x3D; &amp;pi;			&#x2F;&#x2F;错误：ptr是一个普通指针</span><br><span class="line">const double* cptr &#x3D; &amp;pi;	&#x2F;&#x2F;正确：cptr可以指向一个双精度常量</span><br><span class="line">*cptr &#x3D; 42;					&#x2F;&#x2F;错误：不能给*cptr赋值</span><br><span class="line"></span><br><span class="line">double dval &#x3D; 3.14;	</span><br><span class="line">cptr &#x3D; &amp;dval;		&#x2F;&#x2F;正确：但是不能通过cptr改变dval的值</span><br></pre></td></tr></table></figure>

<h3 id="const指针"><a href="#const指针" class="headerlink" title="const指针"></a>const指针</h3><p>常量指针(const pointer)必须初始化，且它的值不能改变。不变的是指针本身，而非指向的那个值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int errNumb &#x3D; 0;</span><br><span class="line">int* const curErr &#x3D; &amp;errNumb;	&#x2F;&#x2F;curErr将一直指向errNumb</span><br><span class="line">const double pi - 3.14159;</span><br><span class="line">const double* const pip &#x3D; &amp;pi;	&#x2F;&#x2F;pip是一个指向常量的常量指针</span><br><span class="line"></span><br><span class="line">*pip &#x3D; 2.72;	&#x2F;&#x2F;错误：pip是一个指向常量的指针</span><br><span class="line"></span><br><span class="line">if (*curErr) &#123;</span><br><span class="line">	errorHandler();</span><br><span class="line">	*curErr &#x3D; 0;	&#x2F;&#x2F;正确：把curErr所指的对象重置</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从右向左看，curErr是一个常量，是一个常量指针，是一个指向int型的常量指针</p>
<h2 id="顶层const"><a href="#顶层const" class="headerlink" title="顶层const"></a>顶层const</h2><p>顶层const(top - level const)表示指针本身是个常量，底层const(low - level const)表示指针所指的对象是个常量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D; 0;</span><br><span class="line">int* const p1 &#x3D; &amp;i;			&#x2F;&#x2F;不能改变p1的值，顶层const</span><br><span class="line">const int ci &#x3D; 42;			&#x2F;&#x2F;不能改变ci的值，顶层const</span><br><span class="line">const int* p2 &#x3D; &amp;ci;		&#x2F;&#x2F;允许改变p2的值，底层const</span><br><span class="line">const int* const p3 &#x3D; p2;	&#x2F;&#x2F;靠右的是顶层，左是低层</span><br><span class="line">const int&amp; r &#x3D; ci;			&#x2F;&#x2F;用于声明引用的const都是底层const</span><br><span class="line"></span><br><span class="line">i &#x3D; ci;		&#x2F;&#x2F;正确：ci是一个顶层const，对此操作无影响</span><br><span class="line">p2 &#x3D; p3;	&#x2F;&#x2F;正确：p2和p3指向的对象类型相同，p3顶层const的部分不影响</span><br><span class="line"></span><br><span class="line">int* p &#x3D; p3;		&#x2F;&#x2F;错误：p3包含底层const的定义，而p没有</span><br><span class="line">p2 &#x3D; p3;			&#x2F;&#x2F;正确：p2和p3都是底层const</span><br><span class="line">p2 &#x3D; &amp;i;			&#x2F;&#x2F;正确：int*能转换成const int*</span><br><span class="line">int&amp; r &#x3D; ci;		&#x2F;&#x2F;错误：普通的int&amp;不能绑定到int常量上</span><br><span class="line">const int&amp; r2 &#x3D; i;	&#x2F;&#x2F;正确：const int&amp;可以绑定到一个普通int上</span><br></pre></td></tr></table></figure>

<h2 id="constexpr和常量表达式"><a href="#constexpr和常量表达式" class="headerlink" title="constexpr和常量表达式"></a>constexpr和常量表达式</h2><p>常量表达式(const expression)是指值不会改变并且在编译过程就能得到计算结果的表达式<br>一个对象(或表达式)是不是常量表达式由它的数据类型和初始值共同决定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const int max_files &#x3D; 20;			&#x2F;&#x2F;max_files是常量表达式</span><br><span class="line">const int limit &#x3D; max_files + 1;	&#x2F;&#x2F;limit是常量表达式</span><br><span class="line">int staff_size &#x3D; 27;				&#x2F;&#x2F;staff_size不是常量表达式</span><br><span class="line">cosnt int sz &#x3D; get_size();			&#x2F;&#x2F;sz不是常量表达式，值到运行时才能获取到</span><br></pre></td></tr></table></figure>

<p>允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式<br>声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">constexpr int mf &#x3D; 20;			&#x2F;&#x2F;20是常量表达式</span><br><span class="line">constexpr int limit &#x3D; mf + 1;	&#x2F;&#x2F;mf+1是常量表达式</span><br><span class="line">constexpr int sz &#x3D; size();		&#x2F;&#x2F;只有当size是一个constexpr函数时才是一条正确的声明语句</span><br></pre></td></tr></table></figure>

<p>一个constexpr指针的初始值必须是nullptr或0，或是存储于某个固定地址中的对象<br>函数体内定义的变量一般并非存放在固定的地址中，定义于所有函数体之外的对象其地址固定不变</p>
<p>在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与所指对象无关<br>constexpr指针既可以指向常量也可以指向非常量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const int* p &#x3D; nullptr;		&#x2F;&#x2F;p是一个指向整型常量的指针</span><br><span class="line">constexpr int* q &#x3D; nullptr;	&#x2F;&#x2F;q是一个指向整数的常量指针</span><br></pre></td></tr></table></figure>

<h1 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h1><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>类型别名(type alias)是一个名字，是某种类型的同义词</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef double wages;		&#x2F;&#x2F;wage是double的同义词</span><br><span class="line">typedef wages base, * p;	&#x2F;&#x2F;base是double的同义词，p是double*的同义词</span><br><span class="line"></span><br><span class="line">using SI &#x3D; Sales_item;		&#x2F;&#x2F;SI是Sales_item的同义词</span><br><span class="line"></span><br><span class="line">typedef cahr* pstring;</span><br><span class="line">const pstring cstr &#x3D; 0;	&#x2F;&#x2F;cstr是指向char的常量指针</span><br><span class="line">&#x2F;&#x2F;const是对给定类型的修饰，数据类型都是const pstring，pstring是指向char的指针</span><br><span class="line">&#x2F;&#x2F;因此，const pstring是指向char的常量指针，而非指向常量字符的指针</span><br><span class="line">const pstring* ps;		&#x2F;&#x2F;ps是一个指针，它的对象是指向char的常量指针</span><br><span class="line">const char* cstr &#x3D; 0;	&#x2F;&#x2F;是对const pstring cstr&#x3D;0的错误理解</span><br></pre></td></tr></table></figure>

<h2 id="auto类型说明符"><a href="#auto类型说明符" class="headerlink" title="auto类型说明符"></a>auto类型说明符</h2><p>auto类型说明符让编译器通过初始值来推算变量的类型。auto定义的变量必须有初始值<br>auto也能在一条语句中声明多个变量，所有变量的初始基本数据类型必须一样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;由val1和val2想家的结果可以推断出item的类型</span><br><span class="line">auto item &#x3D; val1 + val2;	&#x2F;&#x2F;item初始化为val1和val2相加的结果</span><br><span class="line"></span><br><span class="line">auto i &#x3D; 0, * p &#x3D; &amp;i;	&#x2F;&#x2F;正确：i是整数，p是整型指针</span><br><span class="line">auto sz &#x3D; 0, pi &#x3D; 3.14;	&#x2F;&#x2F;错误：类型不一致</span><br></pre></td></tr></table></figure>

<p>编译器会适当地改变结果类型使其更符合初始化规则。引用做初始值时，真正参与初始化的是引用对象的值，此时编译器以引用对象的类型作为auto的类型<br>auto一般会忽略掉顶层const，保留底层const</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D; 0, &amp; r &#x3D; i;</span><br><span class="line">auto a &#x3D; r;		&#x2F;&#x2F;a是一个整数</span><br><span class="line"></span><br><span class="line">const int ci &#x3D; i, &amp; cr &#x3D; ci;</span><br><span class="line">auto b &#x3D; ci;	&#x2F;&#x2F;b是一个整数</span><br><span class="line">auto c &#x3D; cr;	&#x2F;&#x2F;c是一个整数</span><br><span class="line">auto d &#x3D; &amp;i;	&#x2F;&#x2F;d是一个整型指针</span><br><span class="line">auto e &#x3D; &amp;ci;	&#x2F;&#x2F;e是一个指向整数常量的指针</span><br><span class="line"></span><br><span class="line">const auto f &#x3D; ci;	&#x2F;&#x2F;f是const int</span><br><span class="line"></span><br><span class="line">auto&amp; g &#x3D; ci;		&#x2F;&#x2F;g是一个整型常量引用，绑定到ci</span><br><span class="line">auto&amp; h &#x3D; 42;		&#x2F;&#x2F;错误：不能为非常量引用绑定字面值</span><br><span class="line">const auto&amp; j &#x3D; 42;	&#x2F;&#x2F;正确：可以为常量引用绑定字面值</span><br><span class="line"></span><br><span class="line">auto&amp; n &#x3D; i, * p2 &#x3D; &amp;ci;	&#x2F;&#x2F;错误：i的类型是int，而&amp;ci类型是const int</span><br></pre></td></tr></table></figure>

<h2 id="decltype类型指示符"><a href="#decltype类型指示符" class="headerlink" title="decltype类型指示符"></a>decltype类型指示符</h2><p>decltype的作用是选择并返回操作数的数据类型。编译器分析表达式并得到它的类型，却不实际计算表达式的值<br>如果decltype使用的表达式是一个变量，则返回该变量的类型(包括顶层const和引用在内)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">decltype(f()) sum &#x3D; x;	&#x2F;&#x2F;sum的类型是函数f的返回类型</span><br><span class="line"></span><br><span class="line">const int ci &#x3D; 0, &amp; cj &#x3D; ci;</span><br><span class="line">decltype(ci) x &#x3D; 0;	&#x2F;&#x2F;x的类型是const int</span><br><span class="line">decltype(cj) y &#x3D; x;	&#x2F;&#x2F;y的类型是const int&amp;，y绑定到变量x</span><br><span class="line">decltype(cj) z;		&#x2F;&#x2F;错误：z是一个引用，必须初始化</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;decltype的结果可以是引用类型</span><br><span class="line">int i &#x3D; 42, * p &#x3D; &amp;i, &amp; r &#x3D; i;</span><br><span class="line">decltype(r + 0) b;	&#x2F;&#x2F;正确：加法的结果是int，因此b是一个未初始化的int</span><br><span class="line">decltype(*p) c;		&#x2F;&#x2F;错误：c是int&amp;，必须初始化</span><br></pre></td></tr></table></figure>
<p>表达式的内容是解引用操作，则decltype将得到引用类型。decltype(*p)的结果类型是int&amp; ，而非int</p>
<p>如果变量名加上了一对括号，则得到的类型与不加括号时会有不同。<br>不加括号的变量，得到的结果就是该变量的类型；<br>给变量加上一层或多层括号，编译器会把它当做一个表达式。变量是一种可以作为赋值语句左值的特殊表达式，所以这样的decltype就会得到引用类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">decltype((i)) d;	&#x2F;&#x2F;错误：d是int&amp;，必须初始化</span><br><span class="line">decltype(i) e;		&#x2F;&#x2F;正确：e是一个未初始化的int</span><br></pre></td></tr></table></figure>
<p>decltype((variable))的结果永远是引用，而decltype(variable)结果只有当variable本身就是一个引用才是引用</p>
<p>##预处理器概述<br>预处理器(preprocessor)是在编译之前执行的一段程序，可以部分地改变所写的程序<br>当预处理器看到#include标记时就会用指定的头文件的内容代替#include<br>头文件保护符(header guard)依赖于预处理变量。预处理变量有两种状态：已定义和未定义<br>#define指令把一个名字设定为预处理变量；#ifdef仅当变量已定义时为真，#ifndef仅当变量未定义时为真<br>一旦检查结果为真，执行后续操作直到遇到#endif为止<br>预处理变量无视C++语言中关于作用域的规则</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/11/16/ncpp-02/" data-id="ckhq93pu9002ia0ve9hy4a0um" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/02-cpp-primer/" rel="tag">02 cpp primer</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-mysql" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/27/mysql/" class="article-date">
  <time datetime="2020-10-27T14:26:12.000Z" itemprop="datePublished">2020-10-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/27/mysql/">mysql</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h3 id="my-ini"><a href="#my-ini" class="headerlink" title="my.ini"></a>my.ini</h3><p>[mysqld]<br># 设置3306端口<br>port=3306<br># 设置mysql的安装目录<br>basedir=D:\Mysql\mysql-8.0.19-winx64<br># 设置mysql数据库的数据的存放目录<br>datadir=D:\Mysql\mysql-8.0.19-winx64\data<br># 允许最大连接数<br>max_connections=200<br># 允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统<br>max_connect_errors=10<br># 服务端使用的字符集默认为UTF8<br>character-set-server=utf8<br># 创建新表时将使用的默认存储引擎<br>default-storage-engine=INNODB<br># 默认使用“mysql_native_password”插件认证<br>default_authentication_plugin=mysql_native_password<br>[mysql]<br># 设置mysql客户端默认字符集<br>default-character-set=utf8<br>[client]<br># 设置mysql客户端连接服务端时默认使用的端口<br>port=3306<br>default-character-set=utf8</p>
<h3 id="新建系统变量"><a href="#新建系统变量" class="headerlink" title="新建系统变量"></a>新建系统变量</h3><p>变量名：Mysql<br>变量值：~\bin</p>
<h3 id="命令提示符"><a href="#命令提示符" class="headerlink" title="命令提示符"></a>命令提示符</h3><p>cd ~/bin<br>mysqld –initialize –console</p>
<p>mysqld -install mysql（自己命名）<br>net start mysql<br>mysql -uroot -p+密码<br>改密码：ALTER USER ‘root’@‘localhost’ IDENTIFIED WITH mysql_nativa_password BY ‘新密码’</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">登陆：mysql -uroot -p+密码</span><br><span class="line">查询服务其中所有数据库：show databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">| test               |</span><br><span class="line">+--------------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br><span class="line">创建：create database test;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">选中：use test</span><br><span class="line">Database changed</span><br><span class="line">查看数据表：show tables;</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line">创建数据表：create table pet(name VARCHAR(20),owner VARCHAR(20),sex CHAR(1),birth DATE);</span><br><span class="line">Query OK, 0 rows affected (0.04 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show tables;</span><br><span class="line">+----------------+</span><br><span class="line">| Tables_in_test |</span><br><span class="line">+----------------+</span><br><span class="line">| pet            |</span><br><span class="line">+----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">查看数据表结构：describe pet;</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field | Type        | Null | Key | Default | Extra |</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">| name  | varchar(20) | YES  |     | NULL    |       |</span><br><span class="line">| owner | varchar(20) | YES  |     | NULL    |       |</span><br><span class="line">| sex   | char(1)     | YES  |     | NULL    |       |</span><br><span class="line">| birth | date        | YES  |     | NULL    |       |</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line">查看数据表中的记录：select *from pet;</span><br><span class="line">Empty set (0.01 sec)</span><br><span class="line">添加记录： INSERT INTO pet VALUES (&#39;Puffball&#39;,&#39;Diane&#39;,&#39;f&#39;,&#39;1999-03-30&#39;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">select *from pet;</span><br><span class="line">+----------+-------+------+------------+</span><br><span class="line">| name     | owner | sex  | birth      |</span><br><span class="line">+----------+-------+------+------------+</span><br><span class="line">| Puffball | Diane | f    | 1999-03-30 |</span><br><span class="line">+----------+-------+------+------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">INSERT INTO pet VALUES (&#39;大黄&#39;,&#39;小明&#39;,&#39;公&#39;,&#39;1999-01-01&#39;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">select * from pet;</span><br><span class="line">+----------+--------+------+------------+</span><br><span class="line">| name     | owner  | sex  | birth      |</span><br><span class="line">+----------+--------+------+------------+</span><br><span class="line">| Puffball | Diane  | f    | 1999-03-30 |</span><br><span class="line">| 大黄     | 小明   | 公   | 1999-01-01 |</span><br><span class="line">+----------+--------+------+------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h1 id="Mysql-数据类型"><a href="#Mysql-数据类型" class="headerlink" title="Mysql 数据类型"></a>Mysql 数据类型</h1><h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">类型					大小			范围（有符号）					范围（无符号）			用途</span><br><span class="line"></span><br><span class="line">TINYINT		 		1 byte			(-128，127)						 (0，255)				小整数值</span><br><span class="line"></span><br><span class="line">SMALLINT			2 bytes		(-32 768，32 767)			(0，65 535)			大整数值</span><br><span class="line"></span><br><span class="line">MEDIUMINT		3 bytes	(-8 388 608，8 388 607)		(0，16 777 215)	大整数值</span><br><span class="line"></span><br><span class="line">INT或INTEGER	4 bytes	(-2 147 483 648，2 147 483 647)	(0，4 294 967 295)大整数值</span><br><span class="line"></span><br><span class="line">BIGINT	8 bytes	(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)	(0，18 446 744 073 709 551 615)	极大整数值</span><br><span class="line"></span><br><span class="line">FLOAT	4 bytes	(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</span><br><span class="line"></span><br><span class="line">0，(1.175 494 351 E-38，3.402 823 466 E+38)</span><br><span class="line"></span><br><span class="line">单精度  </span><br><span class="line">浮点数值</span><br><span class="line">DOUBLE	8 bytes	(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)	0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</span><br><span class="line"></span><br><span class="line">双精度  </span><br><span class="line">浮点数值</span><br><span class="line">DECIMAL</span><br><span class="line">对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2	依赖于M和D的值	依赖于M和D的值	小数值</span><br><span class="line"></span><br><span class="line"> create table testType(number TINYINT);</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line">describe testtype;</span><br><span class="line">+--------+---------+------+-----+---------+-------+</span><br><span class="line">| Field  | Type    | Null | Key | Default | Extra |</span><br><span class="line">+--------+---------+------+-----+---------+-------+</span><br><span class="line">| number | tinyint | YES  |     | NULL    |       |</span><br><span class="line">+--------+---------+------+-----+---------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line">insert into testtype values(127);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"> select * from testtype;</span><br><span class="line">+--------+</span><br><span class="line">| number |</span><br><span class="line">+--------+</span><br><span class="line">|    127 |</span><br><span class="line">+--------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line">insert into testtype values(128);</span><br><span class="line">ERROR 1264 (22003): Out of range value for column &#39;number&#39; at row 1</span><br></pre></td></tr></table></figure>
<h2 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">类型		大小( bytes)		范围								格式							用途</span><br><span class="line"></span><br><span class="line">DATE		3				1000-01-01&#x2F;9999-12-31	YYYY-MM-DD			日期值</span><br><span class="line"></span><br><span class="line">TIME 		3 				&#39;-838:59:59&#39;&#x2F;&#39;838:59:59&#39; 		HH:MM:SS 			时间值或持续时间</span><br><span class="line"></span><br><span class="line">YEAR 		1 					1901&#x2F;2155							 YYYY 					年份值</span><br><span class="line"></span><br><span class="line">DATETIME 8 1000-01-01 00:00:00&#x2F;9999-12-31 23:59:59  YYYY-MM-DD HH:MM:SS 混合日期和时间值</span><br><span class="line"></span><br><span class="line">TIMESTAMP 4 1970-01-01 00:00:00&#x2F;2038 结束时间是第 **2147483647** 秒，北京时间 **2038-1-19 11:14:07**，格林尼治时间 2038年1月19日 凌晨 03:14:07	YYYYMMDD HHMMSS	混合日期和时间值，时间戳</span><br></pre></td></tr></table></figure>
<h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">类型 大小 用途</span><br><span class="line">CHAR 0-255 bytes  定长字符串</span><br><span class="line"></span><br><span class="line">VARCHAR 0-65535 bytes 变长字符串</span><br><span class="line"></span><br><span class="line">TINYBLOB 0-255 bytes 不超过 255 个字符的二进制字符串</span><br><span class="line"></span><br><span class="line">TINYTEXT 0-255 bytes 短文本字符串</span><br><span class="line"></span><br><span class="line">BLOB 0-65 535 bytes 二进制形式的长文本数据</span><br><span class="line"></span><br><span class="line">TEXT 0-65 535 bytes 长文本数据</span><br><span class="line"></span><br><span class="line">MEDIUMBLOB 0-16 777 215 bytes 二进制形式的中等长度文本数据</span><br><span class="line"></span><br><span class="line">MEDIUMTEXT 0-16 777 215 bytes 中等长度文本数据 </span><br><span class="line"></span><br><span class="line">LONGBLOB 0-4 294 967 295 bytes 二进制形式的极大文本数据</span><br><span class="line"></span><br><span class="line">LONGTEXT 0-4 294 967 295 bytes 极大文本数据</span><br></pre></td></tr></table></figure>
<h1 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">删除：delete from pet where name &#x3D; &#39;Puffball&#39;;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">修改：update pet set name &#x3D;&#39;旺旺&#39; where owner &#x3D; &#39;小明&#39;;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br></pre></td></tr></table></figure>
<h1 id="建表约束"><a href="#建表约束" class="headerlink" title="建表约束"></a>建表约束</h1><h2 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h2><p>唯一确定一张表中的记录，字段不为空且不重复</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table user(id int primary key,name varchar(20));</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into usr values (1,&#39;tom&#39;);</span><br><span class="line">ERROR 1146 (42S02): Table &#39;test.usr&#39; doesn&#39;t exist</span><br><span class="line">mysql&gt; insert into user values (1,&#39;tom&#39;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into user values (1,&#39;tom&#39;);</span><br><span class="line">ERROR 1062 (23000): Duplicate entry &#39;1&#39; for key &#39;user.PRIMARY&#39;</span><br><span class="line">mysql&gt; insert into user values (2,&#39;tom&#39;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">mysql&gt; insert into user values(NULL,&#39;tom&#39;);</span><br><span class="line">ERROR 1048 (23000): Column &#39;id&#39; cannot be null</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from user;</span><br><span class="line">+----+------+</span><br><span class="line">| id | name |</span><br><span class="line">+----+------+</span><br><span class="line">|  1 | tom  |</span><br><span class="line">|  2 | tom  |</span><br><span class="line">+----+------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h2 id="联合主键"><a href="#联合主键" class="headerlink" title="联合主键"></a>联合主键</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table user2(id int,name varchar(20),passward varchar(20),primary key(id,name));</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into user2 values (1,&#39;tom&#39;,&#39;123&#39;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into user2 values (2,&#39;tom&#39;,&#39;123&#39;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into user2 values (2,&#39;jerry&#39;,&#39;123&#39;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into user2 values (NULL,&#39;jerry&#39;,&#39;123&#39;);</span><br><span class="line">ERROR 1048 (23000): Column &#39;id&#39; cannot be null</span><br><span class="line">mysql&gt; select * from user2;</span><br><span class="line">+----+-------+----------+</span><br><span class="line">| id | name  | passward |</span><br><span class="line">+----+-------+----------+</span><br><span class="line">|  1 | tom   | 123      |</span><br><span class="line">|  2 | jerry | 123      |</span><br><span class="line">|  2 | tom   | 123      |</span><br><span class="line">+----+-------+----------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h2 id="自增约束"><a href="#自增约束" class="headerlink" title="自增约束"></a>自增约束</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table user3(id int primary key auto_increment,name varchar(20));</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into user3 (name) values(&#39;tom&#39;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into user3 (name) values(&#39;tom&#39;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from user3;</span><br><span class="line">+----+------+</span><br><span class="line">| id | name |</span><br><span class="line">+----+------+</span><br><span class="line">|  1 | tom  |</span><br><span class="line">|  2 | tom  |</span><br><span class="line">+----+------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h3 id="添加、删除主键约束"><a href="#添加、删除主键约束" class="headerlink" title="添加、删除主键约束"></a>添加、删除主键约束</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table user4 (id int,name varchar(20));</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line">mysql&gt; desc user4;</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field | Type        | Null | Key | Default | Extra |</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">| id    | int         | YES  |     | NULL    |       |</span><br><span class="line">| name  | varchar(20) | YES  |     | NULL    |       |</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; alter table user4 add primary key (id);</span><br><span class="line">Query OK, 0 rows affected (0.04 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; desc user4;</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field | Type        | Null | Key | Default | Extra |</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">| id    | int         | NO   | PRI | NULL    |       |</span><br><span class="line">| name  | varchar(20) | YES  |     | NULL    |       |</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; alter table user4 drop primary key;</span><br><span class="line">Query OK, 0 rows affected (0.04 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; desc user4;</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field | Type        | Null | Key | Default | Extra |</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">| id    | int         | NO   |     | NULL    |       |</span><br><span class="line">| name  | varchar(20) | YES  |     | NULL    |       |</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; alter table user4 modify id int primary key;</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; desc user4;</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field | Type        | Null | Key | Default | Extra |</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">| id    | int         | NO   | PRI | NULL    |       |</span><br><span class="line">| name  | varchar(20) | YES  |     | NULL    |       |</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h2 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h2><p>约束修饰的字段值不可以重复</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table user5(id int, name varchar(20));</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; alter table user5 add unique(name);</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; desc user5;</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field | Type        | Null | Key | Default | Extra |</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">| id    | int         | YES  |     | NULL    |       |</span><br><span class="line">| name  | varchar(20) | YES  | UNI | NULL    |       |</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into user5 values(1,&#39;tom&#39;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into user5 values(1,&#39;tom&#39;);</span><br><span class="line">ERROR 1062 (23000): Duplicate entry &#39;tom&#39; for key &#39;user5.name&#39;</span><br><span class="line">mysql&gt; insert into user5 values(1,&#39;jerry&#39;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from user5;</span><br><span class="line">+------+-------+</span><br><span class="line">| id   | name  |</span><br><span class="line">+------+-------+</span><br><span class="line">|    1 | tom   |</span><br><span class="line">|    1 | jerry |</span><br><span class="line">+------+-------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">unique(id,name)表示两个键一起不重复就可以</span><br></pre></td></tr></table></figure>
<h2 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table user7(id int, name varchar(20) not null);</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; desc user7;</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field | Type        | Null | Key | Default | Extra |</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">| id    | int         | YES  |     | NULL    |       |</span><br><span class="line">| name  | varchar(20) | NO   |     | NULL    |       |</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into user7 (id) values (1);</span><br><span class="line">ERROR 1364 (HY000): Field &#39;name&#39; doesn&#39;t have a default value</span><br><span class="line">mysql&gt; insert into user7 values (1,&#39;tom&#39;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into user7 (name) values(&#39;jerry&#39;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from user7;</span><br><span class="line">+------+-------+</span><br><span class="line">| id   | name  |</span><br><span class="line">+------+-------+</span><br><span class="line">|    1 | tom   |</span><br><span class="line">| NULL | jerry |</span><br><span class="line">+------+-------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h2 id="默认约束"><a href="#默认约束" class="headerlink" title="默认约束"></a>默认约束</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table user8(id int , name varchar(20),age int default 10);</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; desc user8;</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field | Type        | Null | Key | Default | Extra |</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">| id    | int         | YES  |     | NULL    |       |</span><br><span class="line">| name  | varchar(20) | YES  |     | NULL    |       |</span><br><span class="line">| age   | int         | YES  |     | 10      |       |</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into user8(name) values (&#39;tom&#39;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from user8;</span><br><span class="line">+------+------+------+</span><br><span class="line">| id   | name | age  |</span><br><span class="line">+------+------+------+</span><br><span class="line">| NULL | tom  |   10 |</span><br><span class="line">+------+------+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into user8 values (1,&#39;jerry&#39;,20);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from user8;</span><br><span class="line">+------+-------+------+</span><br><span class="line">| id   | name  | age  |</span><br><span class="line">+------+-------+------+</span><br><span class="line">| NULL | tom   |   10 |</span><br><span class="line">|    1 | jerry |   20 |</span><br><span class="line">+------+-------+------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h2 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table classes(id int primary key,name varchar(20));</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; create table students(id int primary key,name varchar(20),class_id int, foreign key (class_id) references classes(id));</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; desc classes;</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field | Type        | Null | Key | Default | Extra |</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">| id    | int         | NO   | PRI | NULL    |       |</span><br><span class="line">| name  | varchar(20) | YES  |     | NULL    |       |</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; desc students;</span><br><span class="line">+----------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field    | Type        | Null | Key | Default | Extra |</span><br><span class="line">+----------+-------------+------+-----+---------+-------+</span><br><span class="line">| id       | int         | NO   | PRI | NULL    |       |</span><br><span class="line">| name     | varchar(20) | YES  |     | NULL    |       |</span><br><span class="line">| class_id | int         | YES  | MUL | NULL    |       |</span><br><span class="line">+----------+-------------+------+-----+---------+-------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into classes values(1,&#39;一班&#39;);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into classes values(2,&#39;二班&#39;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into classes values(3,&#39;三班&#39;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into classes values(4,&#39;四班&#39;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from classes;</span><br><span class="line">+----+--------+</span><br><span class="line">| id | name   |</span><br><span class="line">+----+--------+</span><br><span class="line">|  1 | 一班   |</span><br><span class="line">|  2 | 二班   |</span><br><span class="line">|  3 | 三班   |</span><br><span class="line">|  4 | 四班   |</span><br><span class="line">+----+--------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into students values(1001,&#39;tom&#39;,1);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into students values(1002,&#39;tom&#39;,2);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into students values(1003,&#39;tom&#39;,3);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into students values(1004,&#39;tom&#39;,4);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from students;</span><br><span class="line">+------+------+----------+</span><br><span class="line">| id   | name | class_id |</span><br><span class="line">+------+------+----------+</span><br><span class="line">| 1001 | tom  |        1 |</span><br><span class="line">| 1002 | tom  |        2 |</span><br><span class="line">| 1003 | tom  |        3 |</span><br><span class="line">| 1004 | tom  |        4 |</span><br><span class="line">+------+------+----------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">主表classes中没有的数据值，在副表中是不可以使用的</span><br><span class="line">mysql&gt; insert into students values(1005,&#39;tom&#39;,5);</span><br><span class="line">ERROR 1452 (23000): Cannot add or update a child row: a foreign key constraint fails (&#96;test&#96;.&#96;students&#96;, CONSTRAINT &#96;students_ibfk_1&#96; FOREIGN KEY (&#96;class_id&#96;) REFERENCES &#96;classes&#96; (&#96;id&#96;))</span><br><span class="line"></span><br><span class="line">主表中的记录被副表引用，是不可以被删除的</span><br><span class="line">mysql&gt; delete from classes where id&#x3D;4;</span><br><span class="line">ERROR 1451 (23000): Cannot delete or update a parent row: a foreign key constraint fails (&#96;test&#96;.&#96;students&#96;, CONSTRAINT &#96;students_ibfk_1&#96; FOREIGN KEY (&#96;class_id&#96;) REFERENCES &#96;classes&#96; (&#96;id&#96;))</span><br></pre></td></tr></table></figure>
<h1 id="数据库三大范式"><a href="#数据库三大范式" class="headerlink" title="数据库三大范式"></a>数据库三大范式</h1><h2 id="第一范式-1NF"><a href="#第一范式-1NF" class="headerlink" title="第一范式 1NF"></a>第一范式 1NF</h2><p>数据表中的所有字段都是不可分割的原子值</p>
<h2 id="第二范式-2NF"><a href="#第二范式-2NF" class="headerlink" title="第二范式 2NF"></a>第二范式 2NF</h2><p>满足第一范式的前提下，除主键外的每一列都必须完全依赖于主键。如果出现不完全依赖，只可能发生在联合主键的情况下。</p>
<h2 id="第三范式-3NF"><a href="#第三范式-3NF" class="headerlink" title="第三范式 3NF"></a>第三范式 3NF</h2><p>满足第二范式的前提下，除主键列的其他列之间不能有传递依赖关系。</p>
<h1 id="Mysql查询"><a href="#Mysql查询" class="headerlink" title="Mysql查询"></a>Mysql查询</h1><h2 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create database selectTest;</span><br><span class="line">mysql&gt; use selecttest;</span><br><span class="line">Database changed</span><br><span class="line">SyntaxEditor Code Snippet</span><br><span class="line"></span><br><span class="line">create table student(</span><br><span class="line">	sno varchar(20) primary key,</span><br><span class="line">	sname varchar(20) not null,</span><br><span class="line">	ssex varchar(20) not null,</span><br><span class="line">	sbirthday datetime,</span><br><span class="line">	class varchar(20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table course(</span><br><span class="line">	cno varchar(20) primary key,</span><br><span class="line">	cname varchar(20) not null,</span><br><span class="line">	tno varchar(20) not null,</span><br><span class="line">	foreign key (tno) references teacher(tno)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table teacher(</span><br><span class="line">	tno varchar(20) primary key,</span><br><span class="line">	tname varchar(20) not null,</span><br><span class="line">	tsex varchar(10) not null,</span><br><span class="line">	tbirthday datetime,</span><br><span class="line">	prof varchar(20) not null,</span><br><span class="line">	depart varchar(20) not null</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table score(</span><br><span class="line">	sno varchar(20) not null,</span><br><span class="line">	cno varchar(20) not null,</span><br><span class="line">	degree decimal,</span><br><span class="line">	foreign key (sno) references student(sno),</span><br><span class="line">	foreign key (cno) references course(cno),</span><br><span class="line">	primary key(sno,cno)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">insert into student values(&#39;101&#39;,&#39;tom&#39;,&#39;male&#39;,&#39;1977-09-01&#39;,&#39;95033&#39;);</span><br><span class="line">insert into student values(&#39;102&#39;,&#39;tom1&#39;,&#39;male&#39;,&#39;1975-10-02&#39;,&#39;95031&#39;);</span><br><span class="line">insert into student values(&#39;103&#39;,&#39;tom2&#39;,&#39;male&#39;,&#39;1976-04-23&#39;,&#39;95033&#39;);</span><br><span class="line">insert into student values(&#39;104&#39;,&#39;tom3&#39;,&#39;famale&#39;,&#39;1977-09-01&#39;,&#39;95033&#39;);</span><br><span class="line">insert into student values(&#39;105&#39;,&#39;jerry&#39;,&#39;famale&#39;,&#39;1975-02-10&#39;,&#39;95031&#39;);</span><br><span class="line">insert into student values(&#39;106&#39;,&#39;jerry2&#39;,&#39;male&#39;,&#39;1974-06-03&#39;,&#39;95031&#39;);</span><br><span class="line">insert into student values(&#39;107&#39;,&#39;spike&#39;,&#39;male&#39;,&#39;1976-02-20&#39;,&#39;95033&#39;);</span><br><span class="line">insert into student values(&#39;108&#39;,&#39;spike2&#39;,&#39;famale&#39;,&#39;1975-02-10&#39;,&#39;95031&#39;);</span><br><span class="line">insert into student values(&#39;109&#39;,&#39;spike3&#39;,&#39;male&#39;,&#39;1974-06-03&#39;,&#39;95031&#39;);</span><br><span class="line"></span><br><span class="line">insert into teacher values(&#39;804&#39;,&#39;jack&#39;,&#39;male&#39;,&#39;1958-12-02&#39;,&#39;associate professor&#39;,&#39;cs&#39;);</span><br><span class="line">insert into teacher values(&#39;856&#39;,&#39;mike&#39;,&#39;male&#39;,&#39;1969-03-12&#39;,&#39;instructor&#39;,&#39;ee&#39;);</span><br><span class="line">insert into teacher values(&#39;825&#39;,&#39;rose&#39;,&#39;famale&#39;,&#39;1972-05-05&#39;,&#39;assistant professor&#39;,&#39;cs&#39;);</span><br><span class="line">insert into teacher values(&#39;831&#39;,&#39;amy&#39;,&#39;famale&#39;,&#39;1977-08-14&#39;,&#39;assistant professor&#39;,&#39;ee&#39;);</span><br><span class="line"></span><br><span class="line">insert into course values(&#39;3-105&#39;,&#39;aaa&#39;,&#39;825&#39;);</span><br><span class="line">insert into course values(&#39;3-245&#39;,&#39;bbb&#39;,&#39;804&#39;);</span><br><span class="line">insert into course values(&#39;6-166&#39;,&#39;ccc&#39;,&#39;856&#39;);</span><br><span class="line">insert into course values(&#39;9-888&#39;,&#39;ddd&#39;,&#39;831&#39;);</span><br><span class="line"></span><br><span class="line">insert into score values(&#39;103&#39;,&#39;3-245&#39;,&#39;86&#39;);</span><br><span class="line">insert into score values(&#39;105&#39;,&#39;3-245&#39;,&#39;75&#39;);</span><br><span class="line">insert into score values(&#39;109&#39;,&#39;3-245&#39;,&#39;68&#39;);</span><br><span class="line">insert into score values(&#39;103&#39;,&#39;3-105&#39;,&#39;92&#39;);</span><br><span class="line">insert into score values(&#39;105&#39;,&#39;3-105&#39;,&#39;88&#39;);</span><br><span class="line">insert into score values(&#39;109&#39;,&#39;3-105&#39;,&#39;76&#39;);</span><br><span class="line">insert into score values(&#39;103&#39;,&#39;6-166&#39;,&#39;85&#39;);</span><br><span class="line">insert into score values(&#39;105&#39;,&#39;6-166&#39;,&#39;79&#39;);</span><br><span class="line">insert into score values(&#39;109&#39;,&#39;6-166&#39;,&#39;81&#39;);</span><br><span class="line"></span><br><span class="line">mysql&gt; show tables;</span><br><span class="line">+----------------------+</span><br><span class="line">| Tables_in_selecttest |</span><br><span class="line">+----------------------+</span><br><span class="line">| course               |</span><br><span class="line">| score                |</span><br><span class="line">| student              |</span><br><span class="line">| teacher              |</span><br><span class="line">+----------------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line">mysql&gt; select * from student;</span><br><span class="line">+-----+--------+--------+---------------------+-------+</span><br><span class="line">| sno | sname  | ssex   | sbirthday           | class |</span><br><span class="line">+-----+--------+--------+---------------------+-------+</span><br><span class="line">| 101 | tom    | male   | 1977-09-01 00:00:00 | 95033 |</span><br><span class="line">| 102 | tom1   | male   | 1975-10-02 00:00:00 | 95031 |</span><br><span class="line">| 103 | tom2   | male   | 1976-04-23 00:00:00 | 95033 |</span><br><span class="line">| 104 | tom3   | famale | 1977-09-01 00:00:00 | 95033 |</span><br><span class="line">| 105 | jerry  | famale | 1975-02-10 00:00:00 | 95031 |</span><br><span class="line">| 106 | jerry2 | male   | 1974-06-03 00:00:00 | 95031 |</span><br><span class="line">| 107 | spike  | male   | 1976-02-20 00:00:00 | 95033 |</span><br><span class="line">| 108 | spike2 | famale | 1975-02-10 00:00:00 | 95031 |</span><br><span class="line">| 109 | spike3 | male   | 1974-06-03 00:00:00 | 95031 |</span><br><span class="line">+-----+--------+--------+---------------------+-------+</span><br><span class="line">9 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from course;</span><br><span class="line">+-------+-------+-----+</span><br><span class="line">| cno   | cname | tno |</span><br><span class="line">+-------+-------+-----+</span><br><span class="line">| 3-105 | aaa   | 825 |</span><br><span class="line">| 3-245 | bbb   | 804 |</span><br><span class="line">| 6-166 | ccc   | 856 |</span><br><span class="line">| 9-888 | ddd   | 831 |</span><br><span class="line">+-------+-------+-----+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from teacher;</span><br><span class="line">+-----+-------+--------+---------------------+---------------------+--------+</span><br><span class="line">| tno | tname | tsex   | tbirthday           | prof                | depart |</span><br><span class="line">+-----+-------+--------+---------------------+---------------------+--------+</span><br><span class="line">| 804 | jack  | male   | 1958-12-02 00:00:00 | associate professor | cs     |</span><br><span class="line">| 825 | rose  | famale | 1972-05-05 00:00:00 | assistant professor | cs     |</span><br><span class="line">| 831 | amy   | famale | 1977-08-14 00:00:00 | assistant professor | ee     |</span><br><span class="line">| 856 | mike  | male   | 1969-03-12 00:00:00 | instructor          | ee     |</span><br><span class="line">+-----+-------+--------+---------------------+---------------------+--------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from score;</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">| sno | cno   | degree |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">| 103 | 3-105 |     92 |</span><br><span class="line">| 103 | 3-245 |     86 |</span><br><span class="line">| 103 | 6-166 |     85 |</span><br><span class="line">| 105 | 3-105 |     88 |</span><br><span class="line">| 105 | 3-245 |     75 |</span><br><span class="line">| 105 | 6-166 |     79 |</span><br><span class="line">| 109 | 3-105 |     76 |</span><br><span class="line">| 109 | 3-245 |     68 |</span><br><span class="line">| 109 | 6-166 |     81 |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">9 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><h3 id="查询student表的所有记录"><a href="#查询student表的所有记录" class="headerlink" title="查询student表的所有记录"></a>查询student表的所有记录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from student;</span><br><span class="line">+-----+--------+--------+---------------------+-------+</span><br><span class="line">| sno | sname  | ssex   | sbirthday           | class |</span><br><span class="line">+-----+--------+--------+---------------------+-------+</span><br><span class="line">| 101 | tom    | male   | 1977-09-01 00:00:00 | 95033 |</span><br><span class="line">| 102 | tom1   | male   | 1975-10-02 00:00:00 | 95031 |</span><br><span class="line">| 103 | tom2   | male   | 1976-04-23 00:00:00 | 95033 |</span><br><span class="line">| 104 | tom3   | famale | 1977-09-01 00:00:00 | 95033 |</span><br><span class="line">| 105 | jerry  | famale | 1975-02-10 00:00:00 | 95031 |</span><br><span class="line">| 106 | jerry2 | male   | 1974-06-03 00:00:00 | 95031 |</span><br><span class="line">| 107 | spike  | male   | 1976-02-20 00:00:00 | 95033 |</span><br><span class="line">| 108 | spike2 | famale | 1975-02-10 00:00:00 | 95031 |</span><br><span class="line">| 109 | spike3 | male   | 1974-06-03 00:00:00 | 95031 |</span><br><span class="line">+-----+--------+--------+---------------------+-------+</span><br><span class="line">9 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h3 id="查询student表所有记录的sname-ssex-class列"><a href="#查询student表所有记录的sname-ssex-class列" class="headerlink" title="查询student表所有记录的sname,ssex,class列"></a>查询student表所有记录的sname,ssex,class列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select sname,ssex,class from student;</span><br><span class="line">+--------+--------+-------+</span><br><span class="line">| sname  | ssex   | class |</span><br><span class="line">+--------+--------+-------+</span><br><span class="line">| tom    | male   | 95033 |</span><br><span class="line">| tom1   | male   | 95031 |</span><br><span class="line">| tom2   | male   | 95033 |</span><br><span class="line">| tom3   | famale | 95033 |</span><br><span class="line">| jerry  | famale | 95031 |</span><br><span class="line">| jerry2 | male   | 95031 |</span><br><span class="line">| spike  | male   | 95033 |</span><br><span class="line">| spike2 | famale | 95031 |</span><br><span class="line">| spike3 | male   | 95031 |</span><br><span class="line">+--------+--------+-------+</span><br><span class="line">9 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h3 id="查询教师所有的单位即不重复的depart列"><a href="#查询教师所有的单位即不重复的depart列" class="headerlink" title="查询教师所有的单位即不重复的depart列"></a>查询教师所有的单位即不重复的depart列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select distinct depart from teacher;</span><br><span class="line">+--------+</span><br><span class="line">| depart |</span><br><span class="line">+--------+</span><br><span class="line">| cs     |</span><br><span class="line">| ee     |</span><br><span class="line">+--------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h3 id="查询score表中成绩在60-80之间的所有记录"><a href="#查询score表中成绩在60-80之间的所有记录" class="headerlink" title="查询score表中成绩在60-80之间的所有记录"></a>查询score表中成绩在60-80之间的所有记录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from score where degree between 60 and 80;</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">| sno | cno   | degree |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">| 105 | 3-245 |     75 |</span><br><span class="line">| 105 | 6-166 |     79 |</span><br><span class="line">| 109 | 3-105 |     76 |</span><br><span class="line">| 109 | 3-245 |     68 |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line">或者mysql&gt; select * from score where degree&gt;60 and degree&lt;80;</span><br></pre></td></tr></table></figure>
<h3 id="查询score表中成绩为85-86或88的记录"><a href="#查询score表中成绩为85-86或88的记录" class="headerlink" title="查询score表中成绩为85,86或88的记录"></a>查询score表中成绩为85,86或88的记录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from score where degree in(85,86,88);</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">| sno | cno   | degree |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">| 103 | 3-245 |     86 |</span><br><span class="line">| 103 | 6-166 |     85 |</span><br><span class="line">| 105 | 3-105 |     88 |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h3 id="查询student表中“95031”班或性别为女的同学记录"><a href="#查询student表中“95031”班或性别为女的同学记录" class="headerlink" title="查询student表中“95031”班或性别为女的同学记录"></a>查询student表中“95031”班或性别为女的同学记录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from student where class&#x3D;&#39;95031&#39; or ssex&#x3D;&#39;famale&#39;;</span><br><span class="line">+-----+--------+--------+---------------------+-------+</span><br><span class="line">| sno | sname  | ssex   | sbirthday           | class |</span><br><span class="line">+-----+--------+--------+---------------------+-------+</span><br><span class="line">| 102 | tom1   | male   | 1975-10-02 00:00:00 | 95031 |</span><br><span class="line">| 104 | tom3   | famale | 1977-09-01 00:00:00 | 95033 |</span><br><span class="line">| 105 | jerry  | famale | 1975-02-10 00:00:00 | 95031 |</span><br><span class="line">| 106 | jerry2 | male   | 1974-06-03 00:00:00 | 95031 |</span><br><span class="line">| 108 | spike2 | famale | 1975-02-10 00:00:00 | 95031 |</span><br><span class="line">| 109 | spike3 | male   | 1974-06-03 00:00:00 | 95031 |</span><br><span class="line">+-----+--------+--------+---------------------+-------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h3 id="以class降序查询student表的所有记录"><a href="#以class降序查询student表的所有记录" class="headerlink" title="以class降序查询student表的所有记录"></a>以class降序查询student表的所有记录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from student order by class desc;</span><br><span class="line">+-----+--------+--------+---------------------+-------+</span><br><span class="line">| sno | sname  | ssex   | sbirthday           | class |</span><br><span class="line">+-----+--------+--------+---------------------+-------+</span><br><span class="line">| 101 | tom    | male   | 1977-09-01 00:00:00 | 95033 |</span><br><span class="line">| 103 | tom2   | male   | 1976-04-23 00:00:00 | 95033 |</span><br><span class="line">| 104 | tom3   | famale | 1977-09-01 00:00:00 | 95033 |</span><br><span class="line">| 107 | spike  | male   | 1976-02-20 00:00:00 | 95033 |</span><br><span class="line">| 102 | tom1   | male   | 1975-10-02 00:00:00 | 95031 |</span><br><span class="line">| 105 | jerry  | famale | 1975-02-10 00:00:00 | 95031 |</span><br><span class="line">| 106 | jerry2 | male   | 1974-06-03 00:00:00 | 95031 |</span><br><span class="line">| 108 | spike2 | famale | 1975-02-10 00:00:00 | 95031 |</span><br><span class="line">| 109 | spike3 | male   | 1974-06-03 00:00:00 | 95031 |</span><br><span class="line">+-----+--------+--------+---------------------+-------+</span><br><span class="line">9 rows in set (0.00 sec)</span><br><span class="line">升序为 asc，默认为asc</span><br></pre></td></tr></table></figure>
<h3 id="以cno升序、degree降序查询score表的所有记录"><a href="#以cno升序、degree降序查询score表的所有记录" class="headerlink" title="以cno升序、degree降序查询score表的所有记录"></a>以cno升序、degree降序查询score表的所有记录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select *from score order by cno asc,degree desc;</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">| sno | cno   | degree |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">| 103 | 3-105 |     92 |</span><br><span class="line">| 105 | 3-105 |     88 |</span><br><span class="line">| 109 | 3-105 |     76 |</span><br><span class="line">| 103 | 3-245 |     86 |</span><br><span class="line">| 105 | 3-245 |     75 |</span><br><span class="line">| 109 | 3-245 |     68 |</span><br><span class="line">| 103 | 6-166 |     85 |</span><br><span class="line">| 109 | 6-166 |     81 |</span><br><span class="line">| 105 | 6-166 |     79 |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">9 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h3 id="查询“95031”班的学生人数"><a href="#查询“95031”班的学生人数" class="headerlink" title="查询“95031”班的学生人数"></a>查询“95031”班的学生人数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(*) from student where class&#x3D;&#39;95031&#39;;</span><br><span class="line">+----------+</span><br><span class="line">| count(*) |</span><br><span class="line">+----------+</span><br><span class="line">|        5 |</span><br><span class="line">+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h3 id="查询score表中的最高分的学生学号和课程号"><a href="#查询score表中的最高分的学生学号和课程号" class="headerlink" title="查询score表中的最高分的学生学号和课程号"></a>查询score表中的最高分的学生学号和课程号</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select sno,cno from score where degree&#x3D;(select max(degree) from score);</span><br><span class="line">+-----+-------+</span><br><span class="line">| sno | cno   |</span><br><span class="line">+-----+-------+</span><br><span class="line">| 103 | 3-105 |</span><br><span class="line">+-----+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select sno,cno from score order by degree desc limit 0,1;</span><br><span class="line">+-----+-------+</span><br><span class="line">| sno | cno   |</span><br><span class="line">+-----+-------+</span><br><span class="line">| 103 | 3-105 |</span><br><span class="line">+-----+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line">从0开始查1条</span><br></pre></td></tr></table></figure>
<h3 id="查询每门课的平均成绩"><a href="#查询每门课的平均成绩" class="headerlink" title="查询每门课的平均成绩"></a>查询每门课的平均成绩</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select avg(degree) from score where cno&#x3D;&#39;3-105&#39;;</span><br><span class="line">+-------------+</span><br><span class="line">| avg(degree) |</span><br><span class="line">+-------------+</span><br><span class="line">|     85.3333 |</span><br><span class="line">+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select cno,avg(degree) from score group by cno;</span><br><span class="line">+-------+-------------+</span><br><span class="line">| cno   | avg(degree) |</span><br><span class="line">+-------+-------------+</span><br><span class="line">| 3-105 |     85.3333 |</span><br><span class="line">| 3-245 |     76.3333 |</span><br><span class="line">| 6-166 |     81.6667 |</span><br><span class="line">+-------+-------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h3 id="查询score表中至少有2名学生选修并以3开头的课程的平均分数"><a href="#查询score表中至少有2名学生选修并以3开头的课程的平均分数" class="headerlink" title="查询score表中至少有2名学生选修并以3开头的课程的平均分数"></a>查询score表中至少有2名学生选修并以3开头的课程的平均分数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select cno,avg(degree),count(*) from score group by cno having count(cno)&gt;&#x3D;2 and cno like &#39;3%&#39;;</span><br><span class="line">+-------+-------------+----------+</span><br><span class="line">| cno   | avg(degree) | count(*) |</span><br><span class="line">+-------+-------------+----------+</span><br><span class="line">| 3-105 |     85.3333 |        3 |</span><br><span class="line">| 3-245 |     76.3333 |        3 |</span><br><span class="line">+-------+-------------+----------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h3 id="查询分数大于70小于90的sno列"><a href="#查询分数大于70小于90的sno列" class="headerlink" title="查询分数大于70小于90的sno列"></a>查询分数大于70小于90的sno列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select sno,degree from score where degree between 70 and 90;</span><br><span class="line">+-----+--------+</span><br><span class="line">| sno | degree |</span><br><span class="line">+-----+--------+</span><br><span class="line">| 103 |     86 |</span><br><span class="line">| 103 |     85 |</span><br><span class="line">| 105 |     88 |</span><br><span class="line">| 105 |     75 |</span><br><span class="line">| 105 |     79 |</span><br><span class="line">| 109 |     76 |</span><br><span class="line">| 109 |     81 |</span><br><span class="line">+-----+--------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br><span class="line">where degree&gt;70 and degree&lt;90</span><br></pre></td></tr></table></figure>
<h3 id="查询所有学生的sname-cno和degree列"><a href="#查询所有学生的sname-cno和degree列" class="headerlink" title="查询所有学生的sname,cno和degree列"></a>查询所有学生的sname,cno和degree列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select sname,cno,degree from  student,score where student.sno&#x3D;score.sno;</span><br><span class="line">+--------+-------+--------+</span><br><span class="line">| sname  | cno   | degree |</span><br><span class="line">+--------+-------+--------+</span><br><span class="line">| tom2   | 3-105 |     92 |</span><br><span class="line">| tom2   | 3-245 |     86 |</span><br><span class="line">| tom2   | 6-166 |     85 |</span><br><span class="line">| jerry  | 3-105 |     88 |</span><br><span class="line">| jerry  | 3-245 |     75 |</span><br><span class="line">| jerry  | 6-166 |     79 |</span><br><span class="line">| spike3 | 3-105 |     76 |</span><br><span class="line">| spike3 | 3-245 |     68 |</span><br><span class="line">| spike3 | 6-166 |     81 |</span><br><span class="line">+--------+-------+--------+</span><br><span class="line">9 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h3 id="查询所有学生的sno-cname和degree列"><a href="#查询所有学生的sno-cname和degree列" class="headerlink" title="查询所有学生的sno,cname和degree列"></a>查询所有学生的sno,cname和degree列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select sno,cname,degree from course,score where course.cno&#x3D;score.cno;</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">| sno | cname | degree |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">| 103 | aaa   |     92 |</span><br><span class="line">| 105 | aaa   |     88 |</span><br><span class="line">| 109 | aaa   |     76 |</span><br><span class="line">| 103 | bbb   |     86 |</span><br><span class="line">| 105 | bbb   |     75 |</span><br><span class="line">| 109 | bbb   |     68 |</span><br><span class="line">| 103 | ccc   |     85 |</span><br><span class="line">| 105 | ccc   |     79 |</span><br><span class="line">| 109 | ccc   |     81 |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">9 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h3 id="查询所有学生的sname-cname和degreee列"><a href="#查询所有学生的sname-cname和degreee列" class="headerlink" title="查询所有学生的sname,cname和degreee列"></a>查询所有学生的sname,cname和degreee列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select sname,cname,degree,student.sno,course.cno</span><br><span class="line">    -&gt; from student,course,score</span><br><span class="line">    -&gt; where student.sno&#x3D;score.sno</span><br><span class="line">    -&gt; and course.cno&#x3D;score.cno;</span><br><span class="line">+--------+-------+--------+-----+-------+</span><br><span class="line">| sname  | cname | degree | sno | cno   |</span><br><span class="line">+--------+-------+--------+-----+-------+</span><br><span class="line">| tom2   | aaa   |     92 | 103 | 3-105 |</span><br><span class="line">| tom2   | bbb   |     86 | 103 | 3-245 |</span><br><span class="line">| tom2   | ccc   |     85 | 103 | 6-166 |</span><br><span class="line">| jerry  | aaa   |     88 | 105 | 3-105 |</span><br><span class="line">| jerry  | bbb   |     75 | 105 | 3-245 |</span><br><span class="line">| jerry  | ccc   |     79 | 105 | 6-166 |</span><br><span class="line">| spike3 | aaa   |     76 | 109 | 3-105 |</span><br><span class="line">| spike3 | bbb   |     68 | 109 | 3-245 |</span><br><span class="line">| spike3 | ccc   |     81 | 109 | 6-166 |</span><br><span class="line">+--------+-------+--------+-----+-------+</span><br><span class="line">9 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select sname,cname,degree,student.sno as stu_sno,score.sno,course.cno as cou_cno,score.cno</span><br><span class="line">    -&gt; from student,course,score</span><br><span class="line">    -&gt; where student.sno&#x3D;score.sno</span><br><span class="line">    -&gt; and course.cno&#x3D;score.cno;</span><br><span class="line">+--------+-------+--------+---------+-----+---------+-------+</span><br><span class="line">| sname  | cname | degree | stu_sno | sno | cou_cno | cno   |</span><br><span class="line">+--------+-------+--------+---------+-----+---------+-------+</span><br><span class="line">| tom2   | aaa   |     92 | 103     | 103 | 3-105   | 3-105 |</span><br><span class="line">| tom2   | bbb   |     86 | 103     | 103 | 3-245   | 3-245 |</span><br><span class="line">| tom2   | ccc   |     85 | 103     | 103 | 6-166   | 6-166 |</span><br><span class="line">| jerry  | aaa   |     88 | 105     | 105 | 3-105   | 3-105 |</span><br><span class="line">| jerry  | bbb   |     75 | 105     | 105 | 3-245   | 3-245 |</span><br><span class="line">| jerry  | ccc   |     79 | 105     | 105 | 6-166   | 6-166 |</span><br><span class="line">| spike3 | aaa   |     76 | 109     | 109 | 3-105   | 3-105 |</span><br><span class="line">| spike3 | bbb   |     68 | 109     | 109 | 3-245   | 3-245 |</span><br><span class="line">| spike3 | ccc   |     81 | 109     | 109 | 6-166   | 6-166 |</span><br><span class="line">+--------+-------+--------+---------+-----+---------+-------+</span><br><span class="line">9 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h3 id="查询“95031”班学生每门课的平均分"><a href="#查询“95031”班学生每门课的平均分" class="headerlink" title="查询“95031”班学生每门课的平均分"></a>查询“95031”班学生每门课的平均分</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select cno,avg(degree) from score</span><br><span class="line">    -&gt; where sno in (</span><br><span class="line">    -&gt; select sno from student where class&#x3D;&#39;95031&#39;)</span><br><span class="line">    -&gt; group by cno;</span><br><span class="line">+-------+-------------+</span><br><span class="line">| cno   | avg(degree) |</span><br><span class="line">+-------+-------------+</span><br><span class="line">| 3-105 |     82.0000 |</span><br><span class="line">| 3-245 |     71.5000 |</span><br><span class="line">| 6-166 |     80.0000 |</span><br><span class="line">+-------+-------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h3 id="查询选修‘3-105’课程的成绩高于‘109’号同学的所有同学的记录"><a href="#查询选修‘3-105’课程的成绩高于‘109’号同学的所有同学的记录" class="headerlink" title="查询选修‘3-105’课程的成绩高于‘109’号同学的所有同学的记录"></a>查询选修‘3-105’课程的成绩高于‘109’号同学的所有同学的记录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from score where degree &gt;(select degree from score where sno&#x3D;&#39;109&#39;and cno&#x3D;&#39;3-105&#39;) and cno&#x3D;&#39;3-105&#39;;</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">| sno | cno   | degree |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">| 103 | 3-105 |     92 |</span><br><span class="line">| 105 | 3-105 |     88 |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from score</span><br><span class="line">    -&gt; where degree &gt;(</span><br><span class="line">    -&gt; select degree from score where sno&#x3D;&#39;109&#39;and cno&#x3D;&#39;3-105&#39;)</span><br><span class="line">    -&gt; and cno&#x3D;&#39;3-105&#39;;</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">| sno | cno   | degree |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">| 103 | 3-105 |     92 |</span><br><span class="line">| 105 | 3-105 |     88 |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h3 id="查询和学号为108-、101的同学同年出生的所有学生的sno、sname和sbirthday列"><a href="#查询和学号为108-、101的同学同年出生的所有学生的sno、sname和sbirthday列" class="headerlink" title="查询和学号为108,、101的同学同年出生的所有学生的sno、sname和sbirthday列"></a>查询和学号为108,、101的同学同年出生的所有学生的sno、sname和sbirthday列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from student</span><br><span class="line">    -&gt; where year(sbirthday)</span><br><span class="line">    -&gt; in (select year(sbirthday) from student where sno in (108,101));</span><br><span class="line">+-----+--------+--------+---------------------+-------+</span><br><span class="line">| sno | sname  | ssex   | sbirthday           | class |</span><br><span class="line">+-----+--------+--------+---------------------+-------+</span><br><span class="line">| 101 | tom    | male   | 1977-09-01 00:00:00 | 95033 |</span><br><span class="line">| 102 | tom1   | male   | 1975-10-02 00:00:00 | 95031 |</span><br><span class="line">| 104 | tom3   | famale | 1977-09-01 00:00:00 | 95033 |</span><br><span class="line">| 105 | jerry  | famale | 1975-02-10 00:00:00 | 95031 |</span><br><span class="line">| 108 | spike2 | famale | 1975-02-10 00:00:00 | 95031 |</span><br><span class="line">+-----+--------+--------+---------------------+-------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h3 id="查询’jack’老师任课的学生成绩"><a href="#查询’jack’老师任课的学生成绩" class="headerlink" title="查询’jack’老师任课的学生成绩"></a>查询’jack’老师任课的学生成绩</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select sno,degree from score where cno&#x3D;(</span><br><span class="line">    -&gt; select cno from course where tno&#x3D;(</span><br><span class="line">    -&gt; select tno from teacher where tname&#x3D;&#39;jack&#39;));</span><br><span class="line">+-----+--------+</span><br><span class="line">| sno | degree |</span><br><span class="line">+-----+--------+</span><br><span class="line">| 103 |     86 |</span><br><span class="line">| 105 |     75 |</span><br><span class="line">| 109 |     68 |</span><br><span class="line">+-----+--------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h3 id="查询选修某课程人数多于5人的教师姓名"><a href="#查询选修某课程人数多于5人的教师姓名" class="headerlink" title="查询选修某课程人数多于5人的教师姓名"></a>查询选修某课程人数多于5人的教师姓名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select tname from teacher where tno in (</span><br><span class="line">    -&gt; select tno from course where cno in(</span><br><span class="line">    -&gt; select cno from score group by cno</span><br><span class="line">    -&gt; having count(cno)&gt;&#x3D;2));</span><br><span class="line">+-------+</span><br><span class="line">| tname |</span><br><span class="line">+-------+</span><br><span class="line">| jack  |</span><br><span class="line">| rose  |</span><br><span class="line">| mike  |</span><br><span class="line">+-------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h3 id="查询‘cs’系教师所教课程的成绩表"><a href="#查询‘cs’系教师所教课程的成绩表" class="headerlink" title="查询‘cs’系教师所教课程的成绩表"></a>查询‘cs’系教师所教课程的成绩表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from score</span><br><span class="line">    -&gt; where cno in (</span><br><span class="line">    -&gt; select cno from course where tno in (</span><br><span class="line">    -&gt; select tno from teacher where depart&#x3D;&#39;cs&#39;));</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">| sno | cno   | degree |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">| 103 | 3-245 |     86 |</span><br><span class="line">| 105 | 3-245 |     75 |</span><br><span class="line">| 109 | 3-245 |     68 |</span><br><span class="line">| 103 | 3-105 |     92 |</span><br><span class="line">| 105 | 3-105 |     88 |</span><br><span class="line">| 109 | 3-105 |     76 |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h3 id="查询’cs’和’ee’系不同职称的教室的tname和prof"><a href="#查询’cs’和’ee’系不同职称的教室的tname和prof" class="headerlink" title="查询’cs’和’ee’系不同职称的教室的tname和prof"></a>查询’cs’和’ee’系不同职称的教室的tname和prof</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from teacher where depart&#x3D;&#39;cs&#39; and prof not in (</span><br><span class="line">    -&gt; select prof from teacher where depart&#x3D;&#39;ee&#39;)</span><br><span class="line">    -&gt; union</span><br><span class="line">    -&gt; select * from teacher where depart&#x3D;&#39;ee&#39; and prof not in (</span><br><span class="line">    -&gt; select prof from teacher where depart&#x3D;&#39;cs&#39;);</span><br><span class="line">+-----+-------+------+---------------------+---------------------+--------+</span><br><span class="line">| tno | tname | tsex | tbirthday           | prof                | depart |</span><br><span class="line">+-----+-------+------+---------------------+---------------------+--------+</span><br><span class="line">| 804 | jack  | male | 1958-12-02 00:00:00 | associate professor | cs     |</span><br><span class="line">| 856 | mike  | male | 1969-03-12 00:00:00 | instructor          | ee     |</span><br><span class="line">+-----+-------+------+---------------------+---------------------+--------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h3 id="查询选修‘3-105’且成绩至少高于选修‘3-245’的同学的cno、sno和degree，并按degree降序排列"><a href="#查询选修‘3-105’且成绩至少高于选修‘3-245’的同学的cno、sno和degree，并按degree降序排列" class="headerlink" title="查询选修‘3-105’且成绩至少高于选修‘3-245’的同学的cno、sno和degree，并按degree降序排列"></a>查询选修‘3-105’且成绩至少高于选修‘3-245’的同学的cno、sno和degree，并按degree降序排列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select *from score where cno&#x3D;&#39;3-105&#39;and degree&gt; any(</span><br><span class="line">    -&gt; select degree from score where cno&#x3D;&#39;3-245&#39;)</span><br><span class="line">    -&gt; order by degree desc;</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">| sno | cno   | degree |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">| 103 | 3-105 |     92 |</span><br><span class="line">| 105 | 3-105 |     88 |</span><br><span class="line">| 109 | 3-105 |     76 |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h3 id="查询选修‘3-105’且成绩高于选修‘3-245’的同学的cno、sno和degree"><a href="#查询选修‘3-105’且成绩高于选修‘3-245’的同学的cno、sno和degree" class="headerlink" title="查询选修‘3-105’且成绩高于选修‘3-245’的同学的cno、sno和degree"></a>查询选修‘3-105’且成绩高于选修‘3-245’的同学的cno、sno和degree</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select *from score where cno&#x3D;&#39;3-105&#39;and degree&gt; all(</span><br><span class="line">    -&gt; select degree from score where cno&#x3D;&#39;3-245&#39;);</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">| sno | cno   | degree |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">| 103 | 3-105 |     92 |</span><br><span class="line">| 105 | 3-105 |     88 |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h3 id="查询所有教师和同学的name、sex和birthday"><a href="#查询所有教师和同学的name、sex和birthday" class="headerlink" title="查询所有教师和同学的name、sex和birthday"></a>查询所有教师和同学的name、sex和birthday</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select tname as name,tsex as sex,tbirthday as birthday from teacher</span><br><span class="line">    -&gt; union</span><br><span class="line">    -&gt; select sname,ssex,sbirthday from student;</span><br><span class="line">+--------+--------+---------------------+</span><br><span class="line">| name   | sex    | birthday            |</span><br><span class="line">+--------+--------+---------------------+</span><br><span class="line">| jack   | male   | 1958-12-02 00:00:00 |</span><br><span class="line">| rose   | famale | 1972-05-05 00:00:00 |</span><br><span class="line">| amy    | famale | 1977-08-14 00:00:00 |</span><br><span class="line">| mike   | male   | 1969-03-12 00:00:00 |</span><br><span class="line">| tom    | male   | 1977-09-01 00:00:00 |</span><br><span class="line">| tom1   | male   | 1975-10-02 00:00:00 |</span><br><span class="line">| tom2   | male   | 1976-04-23 00:00:00 |</span><br><span class="line">| tom3   | famale | 1977-09-01 00:00:00 |</span><br><span class="line">| jerry  | famale | 1975-02-10 00:00:00 |</span><br><span class="line">| jerry2 | male   | 1974-06-03 00:00:00 |</span><br><span class="line">| spike  | male   | 1976-02-20 00:00:00 |</span><br><span class="line">| spike2 | famale | 1975-02-10 00:00:00 |</span><br><span class="line">| spike3 | male   | 1974-06-03 00:00:00 |</span><br><span class="line">+--------+--------+---------------------+</span><br><span class="line">13 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h3 id="查询成绩比该课程平均成绩低的同学的成绩表"><a href="#查询成绩比该课程平均成绩低的同学的成绩表" class="headerlink" title="查询成绩比该课程平均成绩低的同学的成绩表"></a>查询成绩比该课程平均成绩低的同学的成绩表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from score a where degree &lt; (</span><br><span class="line">    -&gt; select avg(degree) from score b</span><br><span class="line">    -&gt; where a.cno&#x3D;b.cno);</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">| sno | cno   | degree |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">| 105 | 3-245 |     75 |</span><br><span class="line">| 105 | 6-166 |     79 |</span><br><span class="line">| 109 | 3-105 |     76 |</span><br><span class="line">| 109 | 3-245 |     68 |</span><br><span class="line">| 109 | 6-166 |     81 |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h3 id="查询至少有2名男生的班号"><a href="#查询至少有2名男生的班号" class="headerlink" title="查询至少有2名男生的班号"></a>查询至少有2名男生的班号</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select class from student</span><br><span class="line">    -&gt; where ssex&#x3D;&#39;male&#39; group by class having count(*)&gt;&#x3D;2;</span><br><span class="line">+-------+</span><br><span class="line">| class |</span><br><span class="line">+-------+</span><br><span class="line">| 95033 |</span><br><span class="line">| 95031 |</span><br><span class="line">+-------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h3 id="查询不以jerry开头的学生"><a href="#查询不以jerry开头的学生" class="headerlink" title="查询不以jerry开头的学生"></a>查询不以jerry开头的学生</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select *from student where sname not like &#39;jerry%&#39;;</span><br><span class="line">+-----+--------+--------+---------------------+-------+</span><br><span class="line">| sno | sname  | ssex   | sbirthday           | class |</span><br><span class="line">+-----+--------+--------+---------------------+-------+</span><br><span class="line">| 101 | tom    | male   | 1977-09-01 00:00:00 | 95033 |</span><br><span class="line">| 102 | tom1   | male   | 1975-10-02 00:00:00 | 95031 |</span><br><span class="line">| 103 | tom2   | male   | 1976-04-23 00:00:00 | 95033 |</span><br><span class="line">| 104 | tom3   | famale | 1977-09-01 00:00:00 | 95033 |</span><br><span class="line">| 107 | spike  | male   | 1976-02-20 00:00:00 | 95033 |</span><br><span class="line">| 108 | spike2 | famale | 1975-02-10 00:00:00 | 95031 |</span><br><span class="line">| 109 | spike3 | male   | 1974-06-03 00:00:00 | 95031 |</span><br><span class="line">+-----+--------+--------+---------------------+-------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h3 id="查询每个学生的姓名和年龄"><a href="#查询每个学生的姓名和年龄" class="headerlink" title="查询每个学生的姓名和年龄"></a>查询每个学生的姓名和年龄</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select sname,year(now())-year(sbirthday) as &#39;age&#39;from student;</span><br><span class="line">+--------+------+</span><br><span class="line">| sname  | age  |</span><br><span class="line">+--------+------+</span><br><span class="line">| tom    |   43 |</span><br><span class="line">| tom1   |   45 |</span><br><span class="line">| tom2   |   44 |</span><br><span class="line">| tom3   |   43 |</span><br><span class="line">| jerry  |   45 |</span><br><span class="line">| jerry2 |   46 |</span><br><span class="line">| spike  |   44 |</span><br><span class="line">| spike2 |   45 |</span><br><span class="line">| spike3 |   46 |</span><br><span class="line">+--------+------+</span><br><span class="line">9 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h3 id="查询学生出生日期的最大最小值"><a href="#查询学生出生日期的最大最小值" class="headerlink" title="查询学生出生日期的最大最小值"></a>查询学生出生日期的最大最小值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select max(sbirthday)as &#39;max&#39;,min(sbirthday)as &#39;min&#39;from student;</span><br><span class="line">+---------------------+---------------------+</span><br><span class="line">| max                 | min                 |</span><br><span class="line">+---------------------+---------------------+</span><br><span class="line">| 1977-09-01 00:00:00 | 1974-06-03 00:00:00 |</span><br><span class="line">+---------------------+---------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h3 id="查询选修‘aaa’课程的男同学成绩"><a href="#查询选修‘aaa’课程的男同学成绩" class="headerlink" title="查询选修‘aaa’课程的男同学成绩"></a>查询选修‘aaa’课程的男同学成绩</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from score</span><br><span class="line">    -&gt; where cno&#x3D;(select cno from course where cname&#x3D;&#39;aaa&#39;)</span><br><span class="line">    -&gt; and sno in (select sno from student where ssex&#x3D;&#39;male&#39;);</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">| sno | cno   | degree |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">| 103 | 3-105 |     92 |</span><br><span class="line">| 109 | 3-105 |     76 |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h3 id="建立了grade表，查询所有同学的rank"><a href="#建立了grade表，查询所有同学的rank" class="headerlink" title="建立了grade表，查询所有同学的rank"></a>建立了grade表，查询所有同学的rank</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">create table grade(</span><br><span class="line">	low int(3),</span><br><span class="line">	up int(3),</span><br><span class="line">	grade char(1)</span><br><span class="line">);</span><br><span class="line">insert into grade values(90,100,&#39;A&#39;);</span><br><span class="line">insert into grade values(80,89,&#39;A&#39;);</span><br><span class="line">insert into grade values(70,79,&#39;A&#39;);</span><br><span class="line">insert into grade values(60,69,&#39;A&#39;);</span><br><span class="line">insert into grade values(0,59,&#39;A&#39;);</span><br><span class="line"></span><br><span class="line">mysql&gt; select sno,cno,grade from score,grade where degree between low and up;</span><br><span class="line">+-----+-------+-------+</span><br><span class="line">| sno | cno   | grade |</span><br><span class="line">+-----+-------+-------+</span><br><span class="line">| 103 | 3-105 | A     |</span><br><span class="line">| 103 | 3-245 | B     |</span><br><span class="line">| 103 | 6-166 | B     |</span><br><span class="line">| 105 | 3-105 | B     |</span><br><span class="line">| 105 | 3-245 | C     |</span><br><span class="line">| 105 | 6-166 | C     |</span><br><span class="line">| 109 | 3-105 | C     |</span><br><span class="line">| 109 | 3-245 | D     |</span><br><span class="line">| 109 | 6-166 | B     |</span><br><span class="line">+-----+-------+-------+</span><br><span class="line">9 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/10/27/mysql/" data-id="ckhq93pu7002ba0ve6kr6hh8t" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-c-primer-16-模板与泛型编程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/30/c-primer-16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/" class="article-date">
  <time datetime="2020-08-30T03:01:44.000Z" itemprop="datePublished">2020-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/30/c-primer-16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/">c++ primer 16 模板与泛型编程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="模板与泛型编程"><a href="#模板与泛型编程" class="headerlink" title="模板与泛型编程"></a>模板与泛型编程</h1><p>模板是泛型编程的基础。使用时提供足够的信息，将蓝图转换为特定的类或函数。转换发生在编译时</p>
<h2 id="定义模板"><a href="#定义模板" class="headerlink" title="定义模板"></a>定义模板</h2><h3 id="函数模板-function-template"><a href="#函数模板-function-template" class="headerlink" title="函数模板(function template)"></a>函数模板(function template)</h3><p>一个函数模板就是一个公式，可用来生成针对特定类型的函数版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">int compare(const T&amp; v1, const T&amp; v2) &#123;</span><br><span class="line">	if (v1 &lt; v2)return -1;</span><br><span class="line">	if (v2 &lt; v1)return 1;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以template开始，跟一个模板参数列表(template parameter list)，包括若干个逗号分隔的模板参数(template parameter)<br>使用模板时，指定模板实参，将其绑定到模板参数上</p>
<p>实例化函数模板<br>调用函数模板时，编译器用函数实参来推断模板实参<br>cout &lt;&lt; compare(1, 0) &lt;&lt; endl;<br>编译器用推断出的模板参数来实例化(instantiate)一个特点版本的函数</p>
<p>模板类型参数<br>可以将类型参数看做类型说明符，类型参数前必须使用关键字class或typename</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;正确：返回类型和参数类型相同</span><br><span class="line">template&lt;typename T&gt;T foo(T* p) &#123;</span><br><span class="line">	T tmp &#x3D; *p;	&#x2F;&#x2F;tmp的类型将是指针p指向的类型</span><br><span class="line">	return tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;错误：U之前必须加上class或typename</span><br><span class="line">template&lt;typename T, U&gt;T calc(const T&amp;, const T&amp;);</span><br><span class="line">在模板参数列表中这两个关键字的含义相同</span><br><span class="line">template&lt;typename T, class U&gt;calc(const T&amp;, const U&amp;);</span><br></pre></td></tr></table></figure>
<p>非类型模板参数(nontype parameter)<br>一个非类型模板参数表示一个值而非一个类型。通过一个特定的类型名关键字来指定非类型参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;模板参数表示数组的长度</span><br><span class="line">template&lt;unsigned N,unsigned M&gt;</span><br><span class="line">int compare(const char&amp; p1[n], const char&amp; p2[M]) &#123;</span><br><span class="line">	return strcmp(p1, p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用时：compare(“hi”, “hello”); 编译器会在字符串字面常量的末尾插入一个空字符作为终结符<br>int compare(const char(&amp;p1)[3], const char(&amp;p2)[6])<br>一个非类型参数可以是一个整型，或者一个指向对象或函数类型的指针或(左值)引用<br>绑定到非类型参数的实参必须是常量表达式；绑定到指针或引用的必须具有静态的生命周期，不能用普通(非静态)局部变量或动态对象作为指针或引用非类型模板参数的实参</p>
<p>模板函数可以声明为inline或constexpr的，说明符放在模板参数列表之后<br>template<typename T>inline T min(const T&amp;, const T&amp;);</p>
<p>模板中的函数参数是const的引用，保证了函数可以用于不能拷贝的类型(unique_ptr和IO类型等)</p>
<p>为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义，所以模板的头文件通常既包括声明也包括定义</p>
<p>模板直到实例化才会生成代码。编译器会在三个阶段报告错误：<br>·编译模板本身时。检查语法错误<br>·编译器遇到模板使用时。检查实参数目、类型等<br>·模板实例化时。大多数编译错误在实例化期间报告<br>if (v1 &lt; v2)return -1;<br>到实例化时才知道v1&lt;v2是否合法</p>
<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>编译器不能为类模板推断模板参数信息</p>
<p>定义类模板</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;class Blob &#123;</span><br><span class="line">public:</span><br><span class="line">	typedef T value_type;</span><br><span class="line">	typedef typename vector&lt;T&gt;::size_type size_type;</span><br><span class="line">	&#x2F;&#x2F;构造函数</span><br><span class="line">	Blob();</span><br><span class="line">	Blob(initializer_list&lt;T&gt; il);</span><br><span class="line">	&#x2F;&#x2F;Blob中元素数目</span><br><span class="line">	size_type size() const &#123; return data-&gt;size(); &#125;</span><br><span class="line">	bool empty() const &#123; return data-&gt;empty(); &#125;</span><br><span class="line">	&#x2F;&#x2F;删除和添加元素</span><br><span class="line">	void push_back(const T&amp; t) &#123; data-&gt;push_back(t); &#125;</span><br><span class="line">	&#x2F;&#x2F;移动版本</span><br><span class="line">	void push_back(T&amp;&amp; t) &#123; data-&gt;push_back(move(t)); &#125;</span><br><span class="line">	void pop_back();</span><br><span class="line">	&#x2F;&#x2F;元素访问</span><br><span class="line">	T&amp; back();</span><br><span class="line">	T&amp; operator[](size_type i);</span><br><span class="line">private:</span><br><span class="line">	shared_ptr&lt;vector&lt;T&gt;&gt;data;</span><br><span class="line">	&#x2F;&#x2F;若data[i]无效，抛出msg</span><br><span class="line">	void check(size_type i, const string&amp; msg)const;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>实例化类模板<br>提供显示模板实参(explicit template argument)列表，他们被绑定到模板参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Blob&lt;int&gt; ia;					&#x2F;&#x2F;空Blob&lt;int&gt;</span><br><span class="line">Blob&lt;int&gt; ia2 &#x3D; &#123; 0,1,2,3,4 &#125;;	&#x2F;&#x2F;有5个元素的Blob&lt;int&gt;</span><br></pre></td></tr></table></figure>
<p>编译器会实例出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">template&lt;&gt;class Blob&lt;int&gt; &#123;</span><br><span class="line">	typedef typename vector&lt;int&gt;::size_type size_type;</span><br><span class="line">	Blob();</span><br><span class="line">	Blob(initializer_list&lt;int&gt; il);</span><br><span class="line">	&#x2F;&#x2F;...</span><br><span class="line">	int&amp; operator[](size_type i);</span><br><span class="line">private:</span><br><span class="line">	shared_ptr&lt;vector&lt;int&gt;&gt; data;</span><br><span class="line">	void check(size_type i, const string&amp; msg)const;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一个类模板的每个实例都形成一个独立的类。Blob<int>与其他Bolb类没有关联</p>
<p>类模板的成员函数<br>定义在类模板内的成员喊被隐式声明为内联函数<br>定义在类模板之外的成员函数就必须以关键字template开始，后接类模板参数列表</p>
<p>check和元素访问成员</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void Blob&lt;T&gt;::check(size_type i, const string&amp; msg)const &#123;</span><br><span class="line">	if (i &gt;&#x3D; data-&gt;size())</span><br><span class="line">		throw out_of_range(msg);</span><br><span class="line">&#125;</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">T&amp; Blog&lt;T&gt;::back() &#123;</span><br><span class="line">	check(0, &quot;back on empty Blob&quot;);</span><br><span class="line">	return data-&gt;check();</span><br><span class="line">&#125;</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">T&amp; Blob&lt;T&gt;::operator[](size_type i) &#123;</span><br><span class="line">	check(i, &quot;subscript out of range&quot;);</span><br><span class="line">	return (*data)[i];</span><br><span class="line">&#125;</span><br><span class="line">返回一个引用，指向用来实例化BLob的类型</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void Blob&lt;T&gt;::pop_back() &#123;</span><br><span class="line">	check(0, &quot;pop_back on empty Blob&quot;);</span><br><span class="line">	data-&gt;pop_back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Blob构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">Blob&lt;T&gt;::Blob() :data(make_shared&lt;vector&lt;T&gt;&gt;()) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数分配一个空vector，并将指向vector的指针保存在data中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">Blob&lt;T&gt;::Blob(initializer_list&lt;T&gt; il) : data(make_shared&lt;vector&lt;T&gt;&gt;(il)) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>为了使用这个构造函数，必须传给它一个initializer_list</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Blob&lt;string&gt;articals &#x3D; &#123; &quot;a&quot;,&quot;an&quot;,&quot;the&quot; &#125;;</span><br></pre></td></tr></table></figure>
<p>列表中每个字符串字面常量隐式地转换为一个string</p>
<p>类模板成员函数的实例化<br>默认情况下，一个类模板的成员函数只有当程序用到它时才进行实例化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;实例化Blob&lt;int&gt;和接受initializer_list&lt;int&gt;的构造函数</span><br><span class="line">Blob&lt;int&gt;squares &#x3D; &#123; 0,1,2,3,4,5,6,7,8,9 &#125;;</span><br><span class="line">&#x2F;&#x2F;实例化Blob&lt;int&gt;::size()const</span><br><span class="line">for (size_t i &#x3D; 0; i !&#x3D; squares.size(); ++i)</span><br><span class="line">	squares[i] &#x3D; i * i;		&#x2F;&#x2F;实例化Blob&lt;int&gt;::operator[](size_t)</span><br></pre></td></tr></table></figure>
<p>这一特性使得即使某种类型不能完全符合模板操作的要求，扔能用该类型实例化类</p>
<p>在类代码内简化模板类名的使用<br>在类模板自己的作用域中，可以直接使用模板名而不提供实参</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;class BlobPtr &#123;</span><br><span class="line">public:</span><br><span class="line">	BlobPtr() :curr(0) &#123;&#125;</span><br><span class="line">	BlobPtr(Blob&lt;T&gt;&amp; a, size_t sz &#x3D; 0) :wptr(a.data), curr(sz) &#123;&#125;</span><br><span class="line">	T&amp; operator*()const &#123;</span><br><span class="line">		auto p &#x3D; check(curr, &quot;dereference past end&quot;);</span><br><span class="line">		return (*p)[curr];	&#x2F;&#x2F;(*p)为本对象指向的vector</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;递增和递减</span><br><span class="line">	BlobPtr&amp; operator++();	&#x2F;&#x2F;前置运算符</span><br><span class="line">	BlobPtr&amp; operator--();</span><br><span class="line">private:</span><br><span class="line">	&#x2F;&#x2F;若检查成功，返回一个指向vector的shared_ptr</span><br><span class="line">	shared_ptr&lt;vector&lt;T&gt;&gt;check(size_t, const string&amp;)const;</span><br><span class="line">	&#x2F;&#x2F;保存一个weak_ptr，表示底层vector可能被销毁</span><br><span class="line">	weak_ptr&lt;vector&lt;T&gt;&gt;wptr;</span><br><span class="line">	size_t curr;	&#x2F;&#x2F;数组中的当前位置</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在类模板外使用类模板名<br>在类模板外定义成员时，直到遇到类名才表示进入类的作用域</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;后置：递增&#x2F;递减对象但返回原值</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">BlobPtr&lt;T&gt; BlobPtr&lt;T&gt;::operator(int) &#123;</span><br><span class="line">	&#x2F;&#x2F;无需检查，调用前置时会检查</span><br><span class="line">	BlobPtr ret &#x3D; *this;</span><br><span class="line">	++* this;</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ret的定义与BlobPtr<int>ret = *this等价</p>
<p>类模板和友元<br>类包含友元声明是，类与友元各自是否是模板是无关的<br>类模板包含一个非模板友元，则友元被授权访问所有模板实例<br>友元自身是模板，类可以授权给所有友元模板实例，也可以授权给特定的</p>
<p>一对一友好关系<br>类模板与另一个(类或函数)模板间友好关系的最常见形式是建立对应实例及其友元间的友好关系</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;前置声明，在Blob中声明友元所需要的</span><br><span class="line">template&lt;typename T&gt;class BlobPtr;</span><br><span class="line">template&lt;typename T&gt;class Blob;	&#x2F;&#x2F;运算符&#x3D;&#x3D;中的参数所需要的</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">bool operator&#x3D;&#x3D;(const Blob&lt;T&gt;&amp;, const Blob&lt;T&gt;&amp;);</span><br><span class="line">template&lt;typename T&gt;class Blob &#123;</span><br><span class="line">	&#x2F;&#x2F;每个Blob实例将访问权限授予用相同类型实例化的BlobPtr和相等运算符</span><br><span class="line">	friend class BlobPtr&lt;T&gt;;</span><br><span class="line">	friend bool operator&#x3D;&#x3D;&lt;T&gt;(const Blob&lt;T&gt;&amp;, const Blob&lt;T&gt;&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>友元的声明用Blob的模板形参作为他们自己的模板实参。因此，友好关系被限定在用相同类型实例化的Blob与BlobPtr相等运算符之间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Blob&lt;char&gt;ca;	&#x2F;&#x2F;BlobPtr&lt;char&gt;和operator&#x3D;&#x3D;&lt;char&gt;都是本对象的友元</span><br><span class="line">Blob&lt;int&gt;ia;	&#x2F;&#x2F;BlobPtr&lt;int&gt;和operator&#x3D;&#x3D;&lt;int&gt;都是本对象的友元</span><br></pre></td></tr></table></figure>
<p>BlobPtr<char>的成员可以访问ca(或任何其他BlobPtr<char>对象)的非public部分，但ca对ia或Blob的任何其他实例都没有特殊访问权限</p>
<p>通用和特定的模板友好关系<br>一个类可以将另一个模板的每个实例都声明为自己的友元，或限定特定的实例为友元</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;class Pal;</span><br><span class="line">class C &#123;	&#x2F;&#x2F;C是一个普通非模板类</span><br><span class="line">	friend class Pal&lt;C&gt;;	&#x2F;&#x2F;用类C实例化的Pal是C的一个友元</span><br><span class="line">	&#x2F;&#x2F;Pal2的所实例都是C的友元</span><br><span class="line">	template&lt;typename T&gt;friend class Pal2;</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;typename T&gt; class C2 &#123;</span><br><span class="line">	&#x2F;&#x2F;C2的每个实例将相同实例化的Pal声明为友元</span><br><span class="line">	friend class Pal&lt;T&gt;;	&#x2F;&#x2F;Pal的模板声明必须在作用域之内</span><br><span class="line">	&#x2F;&#x2F;Pal2的所有实例都是iC2的每个实例的友元，不需要前置声明</span><br><span class="line">	template&lt;typename X&gt;friend class Pal2;</span><br><span class="line">	&#x2F;&#x2F;Pal3是一个非模板类，它是C2所有实例的友元</span><br><span class="line">	friend class Pal3;		&#x2F;&#x2F;不需要Pal3的前置声明</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为了让所有实例成为友元，友元声明中必须使用与类模板本身不同的模板参数</p>
<p>令模板自己的类型参数为友元</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;class Bar &#123;</span><br><span class="line">	friend Type;	&#x2F;&#x2F;将访问权限授予用来实例化Bar的类型</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于某个类型名Foo，Foo将成为Bar<Foo>的友元</p>
<p>模板类型别名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;using twin &#x3D; pair&lt;T, T&gt;;</span><br><span class="line">twin&lt;string&gt; authors;	&#x2F;&#x2F;authors是一个pair&lt;string,string&gt;</span><br><span class="line">也可以固定一个或多个模板参数</span><br><span class="line">template&lt;typename T&gt;using partNo &#x3D; pair&lt;T, unsigned&gt;;</span><br><span class="line">partNo&lt;string&gt;books;	&#x2F;&#x2F;books是一个pair&lt;string,unsigned&gt;</span><br><span class="line">partNo&lt;Vehicle&gt;cars;	&#x2F;&#x2F;cars是一个pair&lt;Vehicle,unsigned&gt;</span><br></pre></td></tr></table></figure>
<p>类模板的static成员</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;class Foo &#123;</span><br><span class="line">public:</span><br><span class="line">	static size_t count() &#123; return ctr; &#125;</span><br><span class="line">private:</span><br><span class="line">	static size_t ctr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对任意给定类型X，都有一个Foo<X>::ctr和一个Foo<X>::count成员<br>所有Foo<X>类型对象共享相同的ctr对象和count函数<br>将static数据成员也定义成模板</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt; size_t Foo&lt;T&gt;::ctr &#x3D; 0;	&#x2F;&#x2F;定义并初始化str</span><br></pre></td></tr></table></figure>
<p>一个static成员函数只有在使用时才会实例化</p>
<h3 id="模板参数"><a href="#模板参数" class="headerlink" title="模板参数"></a>模板参数</h3><p>一个模板参数名的可用范围是在其声明之后至模板声明或定义结束之前<br>模板参数会隐藏外层作用域中声明的相同名字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef double A;</span><br><span class="line">template&lt;typename A, typename B&gt;void f(A a, B b) &#123;</span><br><span class="line">	A tmp &#x3D; a;	&#x2F;&#x2F;tmp的类型为模板参数A的类型而非double</span><br><span class="line">	double B;	&#x2F;&#x2F;错误：重声明模板参数B</span><br><span class="line">&#125;</span><br><span class="line">template&lt;typename V,typename V&gt;&#x2F;&#x2F;错误：只能出现一次</span><br></pre></td></tr></table></figure>
<p>模板声明<br>模板声明必须包含模板参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;声明但不定义</span><br><span class="line">template&lt;typename T&gt;int compare(const T&amp;, const T&amp;);</span><br><span class="line">template&lt;typename T&gt;class Blob;</span><br><span class="line">声明中的模板参数的名字不必与定义中相同</span><br><span class="line">&#x2F;&#x2F;指向相同的函数模板</span><br><span class="line">template&lt;typename T&gt;T calc(const T&amp;, constT&amp;);</span><br><span class="line">template&lt;typename U&gt;U calc(const U&amp;, constU&amp;);</span><br></pre></td></tr></table></figure>
<p>使用类的类型成员<br>假定T是一个类型参数的名字，编译器遇到T::size_t*p时，需要知道是定义还是相乘<br>默认情况下，c++假定通过作用域运算符访问的名字不是类型。因此希望使用一个模板类型参数的类型成员，<br>必须显式地告诉编译器该名字是一个类型。 通过关键字typename</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">typename T::value_type top(const T&amp; c) &#123;</span><br><span class="line">	if (!c.empty())return c.back();</span><br><span class="line">	else return typename T::value_type();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认模板实参<br>compare有一个默认模板实参less<T>和一个默认函数实参F()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T,typename F&#x3D;less&lt;T&gt;&gt;</span><br><span class="line">int compare(const T&amp; v1, const T&amp; v2, F f &#x3D; F()) &#123;</span><br><span class="line">	if (f(v1, v2))return -1;</span><br><span class="line">	if (f(v2, v1))return 1;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认模板实参指出compare将使用标准库中的less函数对象类，它是使用与compare一样的类型参数实例化的<br>默认函数实参指出f将是类型F的一个默认初始化对象<br>调用compare时，可以提供自己的比较操作，但不是必须的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bool i &#x3D; compare(0, 42);</span><br><span class="line">&#x2F;&#x2F;结果依赖于item1和item2中的isbn</span><br><span class="line">Sales_data item1(cin), item2(cin);</span><br><span class="line">bool j &#x3D; compare(item1, item2, compareIsbn);</span><br></pre></td></tr></table></figure>
<p>对于一个模板参数，只有当它右侧的所有参数都有默认实参时，它才可以有默认实参</p>
<p>模板默认实参与类模板<br>一个类模板为其所有模板参数都提供了默认实参，而且我们希望使用这些默认实参，就必须在模板名之后跟一个空尖括号对</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T &#x3D; int&gt;class Numbers &#123;</span><br><span class="line">public:</span><br><span class="line">	Numbers(T v &#x3D; 0) :val(v) &#123;&#125;</span><br><span class="line">private:</span><br><span class="line">	T val;</span><br><span class="line">&#125;;</span><br><span class="line">Numbers&lt;long long&gt;lots_of_precision;</span><br><span class="line">Numbers&lt;&gt;avertage_precision;	&#x2F;&#x2F;空&lt;&gt;表示使用默认类型</span><br></pre></td></tr></table></figure>
<h3 id="成员模板-member-template"><a href="#成员模板-member-template" class="headerlink" title="成员模板(member template)"></a>成员模板(member template)</h3><p>一个类可以包含本身是模板的成员函数，被称为成员模板。成员模板不能是虚函数</p>
<p>普通类的成员模板</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class DebugDelete &#123;</span><br><span class="line">public:</span><br><span class="line">	DebugDelete(ostream&amp; s &#x3D; cerr) :os(s) &#123;&#125;</span><br><span class="line">	template&lt;typename T&gt;void operator()(T* p)const &#123;</span><br><span class="line">		os &lt;&lt; &quot;deleting unique_ptr&quot; &lt;&lt; endl;</span><br><span class="line">		delete p;</span><br><span class="line">	&#125;</span><br><span class="line">private:ostream&amp; os;</span><br><span class="line">&#125;;</span><br><span class="line">double* p &#x3D; new double;</span><br><span class="line">DebugDelete d;	&#x2F;&#x2F;可像delete表达式一样使用对象</span><br><span class="line">d(p);			&#x2F;&#x2F;调用DebugDelete::operator()(double*),释放p</span><br><span class="line">int* ip &#x3D; new int;</span><br><span class="line">&#x2F;&#x2F;在一个临时DebugDelete对象上调用operator()(int*)</span><br><span class="line">DebugDelete()(ip);</span><br><span class="line">调用一个DebugDelete对象会delete其指针，可以将其用作unique_ptr的删除器</span><br><span class="line">为了重载unique_ptr的删除器，在尖括号内给出</span><br><span class="line">&#x2F;&#x2F;销毁p指向的对象</span><br><span class="line">&#x2F;&#x2F;实例化DebugDelete::operator()&lt;int*&gt;(int*)</span><br><span class="line">unique_ptr&lt;int, DebugDelete&gt;p(new int, DebugDelete());</span><br><span class="line">&#x2F;&#x2F;销毁sp指向的对象</span><br><span class="line">&#x2F;&#x2F;实例化DebugDelete::operator()&lt;string&gt;(string*)</span><br><span class="line">unique_ptr&lt;string, DebugDelete&gt;sp(new string, DebugDelete());</span><br><span class="line">unique_ptr的析构函数会调用DebugDelete的调用运算符。unique_ptr的析构函数实例化时，DebugDelete的调用运算符会实例化</span><br><span class="line">void DebugDelete::operator()(int* p)const &#123; delete p; &#125;</span><br><span class="line">void DebugDelete::operator()(string* p)const &#123; delete p; &#125;</span><br></pre></td></tr></table></figure>
<p>类模板的成员模板<br>类和成员各有自己的、独立的模板参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;class Blob &#123;</span><br><span class="line">	template&lt;typename It&gt;Blob(It b, It e);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在类模板外定义时</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;	&#x2F;&#x2F;类的类型参数</span><br><span class="line">template&lt;typename It&gt;	&#x2F;&#x2F;构造函数的类型参数</span><br><span class="line">Blob&lt;T&gt;::Blob(It b, It e) :data(make_shared&lt;vector&lt;T&gt;&gt;(b, e)) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>实例化与成员模板<br>实例化一个类模板的成员模板，必须同时提供类和函数模板的实参</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int ia[] &#x3D; &#123; 1,2,3,4,5 &#125;;</span><br><span class="line">vector&lt;int&gt;vi &#x3D; &#123; 1,2,3,4,5 &#125;;</span><br><span class="line">list&lt;const char*&gt;w &#x3D; &#123; &quot;now&quot;,&quot;is&quot;,&quot;the&quot;,&quot;time&quot; &#125;;</span><br><span class="line">&#x2F;&#x2F;实例化Blob&lt;int&gt;类及接受两个int*参数的构造函数</span><br><span class="line">Blob&lt;int&gt;a1(begin(ia), end(ia));</span><br><span class="line">&#x2F;&#x2F;实例化Blob&lt;int&gt;类的接受两个vector&lt;long&gt;::iterator的构造参数</span><br><span class="line">Blob&lt;int&gt;a2(vi.begin(), vi.end());</span><br><span class="line">Blob&lt;string&gt;a3(w.begin(), w.end());</span><br><span class="line">a1实例化了Blob&lt;int&gt;::Blob(int*, int*);</span><br><span class="line">a2使用了已经实例化的Blob&lt;int&gt;类，并用vector&lt;short&gt;::iterator替换It来实例化构造函数</span><br><span class="line">a3的定义(显式地)实例化了一个string版本的Blob，并(隐式地)实例化了该类成员模板构造函数，其模板参数绑定到list&lt;const char*&gt;</span><br></pre></td></tr></table></figure>
<h3 id="控制实例化"><a href="#控制实例化" class="headerlink" title="控制实例化"></a>控制实例化</h3><p>模板被使用才会实例化，所以相同的实例可能出现在多个对象文件中<br>可以通过显式实例化(explicit instantiation)来避免这种开销</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extern template declaration;	&#x2F;&#x2F;实例化声明</span><br><span class="line">template declaratino;			&#x2F;&#x2F;实例化定义</span><br><span class="line">declaration中所有模板参数已被替换为模板实参</span><br><span class="line">extern template class Blob&lt;string&gt;;				&#x2F;&#x2F;声明</span><br><span class="line">template int compare(const int&amp;, const int&amp;);	&#x2F;&#x2F;定义</span><br></pre></td></tr></table></figure>
<p>编译器遇到extern时，不会在本文件中生成实例化代码。extern表示承诺在程序其他位置有该实例化的一个非extern声明<br>extern声明必须出现在任何使用此实例化版本的代码之前</p>
<p>实例化定义会实例化该模板的所有成员</p>
<h3 id="效率与灵活性"><a href="#效率与灵活性" class="headerlink" title="效率与灵活性"></a>效率与灵活性</h3><p>shared_ptr共享指针所有权；unique_ptr独占指针<br>重载shared_ptr删除器只需要创建或rest指针时传递给它一个可调用对象即可；<br>删除器的类型是unique_ptr对象的一部分，必须在定义unique_ptr时以显式模板实参形式提供删除器的类型</p>
<p>在运行时绑定删除器<br>shared_ptr删除器的类型知道运行时才会知道。假定shared_ptr将它管理的指针保存在成员p中，删除器是通过del成员来访问的<br>则析构函数必须包含：del ? del(p) : delete p; 调用del(p)需要一次运行时的跳转操作，转到del中保存的地址来执行对应代码</p>
<p>unique_ptr在编译时绑定删除器</p>
<h2 id="模板实参推断"><a href="#模板实参推断" class="headerlink" title="模板实参推断"></a>模板实参推断</h2><p>从函数实参来确定模板实参的过程被称为模板实参推断(template argument deduction)</p>
<h3 id="类型转换与模板类型参数"><a href="#类型转换与模板类型参数" class="headerlink" title="类型转换与模板类型参数"></a>类型转换与模板类型参数</h3><p>类型转换中，能在调用中应用于模板函数的：<br>·const转换：将一个非const对象的引用或指针传递给一个const的引用或指针形参<br>·数组或函数指针转换：如果函数形参不是引用类型，可以对数组或函数类型的实参应用正常的指针转换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;T fobj(T, T);	&#x2F;&#x2F;实参被拷贝</span><br><span class="line">template&lt;typename T&gt;T fref(const T&amp;, const T&amp;);	&#x2F;&#x2F;引用</span><br><span class="line">string s1(&quot;a value&quot;);</span><br><span class="line">const string s2(&quot;another value&quot;);</span><br><span class="line">fobj(s1, s2);	&#x2F;&#x2F;调用fobj(string,string) const被忽略</span><br><span class="line">fref(s1, s2);	&#x2F;&#x2F;调用fref(const string&amp;,const string&amp;) 将s1转换为const是允许的</span><br><span class="line">int a[10],b[42];</span><br><span class="line">fobj(a, b);	&#x2F;&#x2F;调用fobj(int*,int*)</span><br><span class="line">fref(a, b);	&#x2F;&#x2F;错误：数组类型不匹配</span><br></pre></td></tr></table></figure>
<p>如果形参是一个引用，则数组不会转换为指针</p>
<p>使用相同模板参数类型的函数形参</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">long lng;</span><br><span class="line">compare(lng, 1024);	&#x2F;&#x2F;错误：不能实例化compare(long,int)</span><br></pre></td></tr></table></figure>
<p>传递给compare的实参类型不同</p>
<p>正常类型转换应用于普通函数实参</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt; ostream&amp; print(ostream&amp; os, const T&amp; obj) &#123;</span><br><span class="line">	return os &lt;&lt; obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>os的类型是固定的，调用print时，传递给它的实参会进行正常的类型转换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(cout, 42);	&#x2F;&#x2F;实例化print(ostream&amp;,int)</span><br><span class="line">ofstream f(&quot;output&quot;);</span><br><span class="line">print(f, 10);		&#x2F;&#x2F;使用print(ostream&amp;,int) 将f转换为ostream&amp;</span><br></pre></td></tr></table></figure>
<p>第二个中，第一个参数的类型不依赖于模板参数，因此编译器会将f隐式转换为ostream&amp;</p>
<h3 id="函数模板显式实参"><a href="#函数模板显式实参" class="headerlink" title="函数模板显式实参"></a>函数模板显式实参</h3><p>指定显式模板实参(explicit template argument)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T1, typename T2, typename T3&gt;T1 sum(T2, T3);</span><br></pre></td></tr></table></figure>
<p>每次调用必须为T1提供一个显示模板实参</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto val3 &#x3D; sum&lt;long long&gt;(i, lng);	&#x2F;&#x2F;long long sum(int,long)</span><br></pre></td></tr></table></figure>
<p>显式模板实参按照由左至右的顺序与对应的模板参数匹配<br>只有尾部(最右)参数的显示模板实参才可以忽略</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T1,typename T2,typename T3&gt;</span><br><span class="line">T3 alternative_sum(T2, T1);</span><br></pre></td></tr></table></figure>
<p>用户必须制定所有三个模板参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;错误：不能推断前几个模板参数</span><br><span class="line">auto val3 &#x3D; alternative_sum&lt;long long&gt;(i, lng);</span><br><span class="line">&#x2F;&#x2F;正确：显式指定了所有三个参数</span><br><span class="line">auto val2 &#x3D; alternativa_sum&lt;long long, int, long&gt;(i, lng);</span><br></pre></td></tr></table></figure>
<p>正常类型转换应用于显式指定的实参</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">long lng;</span><br><span class="line">compare(lng, 1024);		&#x2F;&#x2F;错误：模板参数不匹配</span><br><span class="line">compare&lt;long&gt;(lng, 1024);	&#x2F;&#x2F;正确：实例化compare(long,long)</span><br><span class="line">compare&lt;int&gt;(lng, 1024);	&#x2F;&#x2F;正确：实例化compare(int,int)</span><br></pre></td></tr></table></figure>
<h3 id="尾置返回类型与类型转换"><a href="#尾置返回类型与类型转换" class="headerlink" title="尾置返回类型与类型转换"></a>尾置返回类型与类型转换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename It&gt; ? ? ? &amp;fcn(It beg, It end) &#123;</span><br><span class="line">	&#x2F;&#x2F;...</span><br><span class="line">	return *beg;	&#x2F;&#x2F;返回序列中一个元素的引用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并不知道返回结果的准确类型，但知道所需类型是所处理的序列的元素类型<br>使用尾置返回类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename It&gt;</span><br><span class="line">auto fcn(It beg, It end)-&gt;decltype(*beg) &#123;</span><br><span class="line">	&#x2F;&#x2F;...</span><br><span class="line">	return *beg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通知编译器fcn的返回类型与解引用beg参数的结果类型相同。解引用运算符返回一个左值，<br>因此通过decltype推断的类型为beg表示的元素的类型的引用</p>
<p>进行类型转换的标准库模板类<br>标准库的类型转换(type transformation)定义在头文件type_traits中<br>————————————————————————606</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename It&gt;</span><br><span class="line">auto fcn2(It beg, It end)-&gt;typename remove_reference&lt;decltype(*beg)&gt;::type &#123;</span><br><span class="line">	&#x2F;&#x2F;...</span><br><span class="line">	return *beg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回beg引用的元素的类型</p>
<h3 id="函数指针和实参推断"><a href="#函数指针和实参推断" class="headerlink" title="函数指针和实参推断"></a>函数指针和实参推断</h3><p>用函数模板初始化一个函数指针或为一个函数指针赋值时，编译器使用指针的类型来推断模板实参</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;int compare(const T&amp;, const T&amp;);</span><br><span class="line">int (*pf1)(const int&amp;, const int&amp;) &#x3D; compare;</span><br><span class="line">pf1指向实例int compare(const int&amp;, const int&amp;)</span><br><span class="line">pf1中的参数类型决定了T的模板参数类型</span><br><span class="line">&#x2F;&#x2F;func的重载版本，每个版本接受一个不同的函数指针类型</span><br><span class="line">void func(int(*)(const string&amp;, const string&amp;));</span><br><span class="line">void func(int(*)(const int&amp;, const int&amp;));</span><br><span class="line">func(compare)	&#x2F;&#x2F;错误</span><br><span class="line">通过func的参数类型无法确定模板实参的唯一类型</span><br><span class="line">&#x2F;&#x2F;正确：显式指出实例化哪个compare版本</span><br><span class="line">func(compare&lt;int&gt;);	&#x2F;&#x2F;传递compare(const int&amp;,const int&amp;)</span><br></pre></td></tr></table></figure>
<h3 id="模板实参推断和引用"><a href="#模板实参推断和引用" class="headerlink" title="模板实参推断和引用"></a>模板实参推断和引用</h3><p>template<typename T>void f(T&amp; p);<br>编译器会应用正常的引用绑定规则；const是底层的，不是顶层的</p>
<p>从左值引用函数参数推断类型<br>函数参数是模板类型参数的一个普通引用时(T&amp;)，只能传给它一个左值(变量或返回引用类型的表达式)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;void f1(T&amp;);	&#x2F;&#x2F;实参必须是一个左值</span><br><span class="line">f1(i);	&#x2F;&#x2F;i是一个int，模板参数类型T是int</span><br><span class="line">f1(ci);	&#x2F;&#x2F;ci是一个const int，T是const int</span><br><span class="line">f1(5);	&#x2F;&#x2F;错误：传递给一个&amp;参数的实参必须是左值</span><br></pre></td></tr></table></figure>
<p>如果函数参数类型是const T&amp; ，可以给它传递一个对象(const或非const)、一个临时对象或是字面常量值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;void f2(const T&amp;);	&#x2F;&#x2F;可以接受一个右值</span><br><span class="line">f2(i);	&#x2F;&#x2F;i是int，T是int</span><br><span class="line">f2(ci);	&#x2F;&#x2F;ci是const int，T是int</span><br><span class="line">f2(5);	&#x2F;&#x2F;T是int</span><br></pre></td></tr></table></figure>
<p>从右值引用函数参数推断参数类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;void f3(T&amp;&amp;);</span><br><span class="line">f3(42);	&#x2F;&#x2F;实参是一个int类型的右值，T是int</span><br></pre></td></tr></table></figure>
<p>引用折叠和右值引用<br>可以允许f3(i)，即将一个右值引用绑定到一个左值i上。只有2种情况<br>·将左值i传递给函数的右值引用参数，且此右值引用指向模板类型参数(T&amp;&amp;)时，编译器推断T的类型为int&amp; ，而非int<br>通常不能直接定义一个引用的引用，但通过类型别名或通过模板类型参数间接定义是可以的<br>·间接创建一个引用的引用，这些引用形成了折叠。除右值引用的右值引用外，引用会折叠成一个普通的左值引用<br>X&amp;&amp;, X&amp;&amp;&amp;, X&amp;&amp;&amp; 都折叠成X&amp; ；X&amp;&amp;&amp;&amp; 折叠成X&amp;&amp;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f3(i);	&#x2F;&#x2F;实参是一个左值，T是int&amp;</span><br><span class="line">f3(ci);	&#x2F;&#x2F;实参是一个左值，T是const int&amp;</span><br></pre></td></tr></table></figure>
<p>·如果一个函数参数是一个指向模板类型参数的右值引用(T&amp;&amp;)，则它可以被绑定到一个左值，且<br>·如果实参是一个左值，则推断出的模板实参类型是一个左值引用，且函数参数将被实例化为一个左值引用参数(T&amp;)</p>
<p>编写接受右值引用参数的模板函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;void f3(T&amp;&amp; val) &#123;</span><br><span class="line">	T t &#x3D; val;	&#x2F;&#x2F;拷贝还是绑定一个引用？</span><br><span class="line">	t &#x3D; fcn(t);	&#x2F;&#x2F;赋值是只改变t还是也改变val？</span><br><span class="line">	if(val&#x3D;&#x3D;t)&#123;&#x2F;*........*&#x2F; &#125;	&#x2F;&#x2F;若T是引用类型则一直为true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="理解std-move"><a href="#理解std-move" class="headerlink" title="理解std::move"></a>理解std::move</h3><p>定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">typename remove_reference&lt;T&gt;::type&amp;&amp; move(type&amp;&amp; t) &#123;</span><br><span class="line">	return static_cast&lt;typename remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br><span class="line">string s1(&quot;hi&quot;), s2;</span><br><span class="line">s2 &#x3D; move(string(&quot;bye&quot;));	&#x2F;&#x2F;正确：从一个右值移动数据</span><br><span class="line">s2 &#x3D; move(s1);				&#x2F;&#x2F;正确：但赋值后s1的值是不确定的</span><br></pre></td></tr></table></figure>
<p>第一个中传递给s2的实参是string构造函数的右值结果，因此在move(string(“bye”))中<br>T的类型为string；remove_reference用string实例化；remove_reference<string>的type成员是string<br>move的返回类型是string&amp;&amp; ；move的函数参数t类型为string&amp;&amp;<br>因此string&amp;&amp; move(string&amp;&amp; t)<br>函数体返回castic_cast&lt;string&amp;&amp;&gt;(t)，t的类型是string&amp;&amp; ，于是转换什么也不做<br>第二个中传递给move的实参是一个左值<br>推断出T类型是string&amp; ；remove_reference用string&amp; 实例化；<br>remove_reference&lt;string&amp;&gt;的type成员是string；move返回类型仍是string&amp;&amp; ；<br>move的函数参数t实例化为string&amp;&amp;&amp; ，折叠为string&amp;<br>因此string&amp;&amp; move(string&amp; t)<br>即将右值引用绑定到左值</p>
<p>从一个左值static_cast到一个右值引用是允许的<br>虽然不能隐式地将一个左值转换为右值引用，但可以用static_cast显式地将左值转换为右值引用</p>
<h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T,typename T1,typename T2&gt;</span><br><span class="line">void flip1(F f, T1 t1, T2 t2)&#123;</span><br><span class="line">	f(t2, t1);</span><br><span class="line">&#125;</span><br><span class="line">void f(int v1, int&amp; v2) &#123;</span><br><span class="line">	cout &lt;&lt; v1 &lt;&lt; &quot; &quot; &lt;&lt; ++v2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">f(42, i);			&#x2F;&#x2F;f改变了实参i</span><br><span class="line">flip1(f, j, 42);	&#x2F;&#x2F;通过flip1调用f不会改变j</span><br></pre></td></tr></table></figure>
<p>j被传递给flip1的参数t1，此参数是个普通的、非引用的类型int，而非int&amp; ，flip1实例化为<br>void flip1(void(*fcn)(int, int&amp;), int t1, int t2);<br>j的值被拷贝到t1中，f中的引用参数绑定到t1，而非j</p>
<p>定义能保持类型信息的函数参数<br>通过将函数参数定义为一直指向模板类型的右值引用，可以保持其实参类型信息；使用引用可以保持const属性<br>因为在引用类型中const是底层的，右值引用通过折叠可以保持实参的左右值属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename F,typename T1,typename T2&gt;</span><br><span class="line">void flip2(F f, T1&amp;&amp; t1, T2&amp;&amp; t2) &#123;</span><br><span class="line">	f(t2, t1);</span><br><span class="line">&#125;</span><br><span class="line">但不能用于接受右值引用参数的函数</span><br><span class="line">void g(int&amp;&amp; i, int&amp; j) &#123; cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl; &#125;</span><br><span class="line">通过flip2调用g，则t2将被传递给g的右值引用参数</span><br><span class="line">flip2(g, i, 42);	&#x2F;&#x2F;错误：不能从一个左值实例化int&amp;&amp;</span><br></pre></td></tr></table></figure>
<p>使用std::forward保持类型信息<br>forward定义在头文件utility中，必须通过显式模板实参来调用，返回该实参类型的右值引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename Type&gt;intermediary(Type&amp;&amp; arg) &#123;</span><br><span class="line">	finalFcn(forward&lt;Type&gt;(arg));</span><br><span class="line">&#125;</span><br><span class="line">当用于一个模板参数类型的右值引用函数参数(T&amp;&amp;)时，forward会保持实参类型的所有细节</span><br><span class="line">template&lt;typename F,typename T1,typename T2&gt;</span><br><span class="line">void flip(F f, T1 t1, T2 t2) &#123;</span><br><span class="line">	f(forward&lt;T2&gt;(t2), forward&lt;T1&gt;(t1));</span><br><span class="line">&#125;</span><br><span class="line">调用flip(g,i,42),i将以int&amp;类型传递给g，42将以int&amp;&amp;类型传递给g</span><br></pre></td></tr></table></figure>
<h2 id="重载与模板"><a href="#重载与模板" class="headerlink" title="重载与模板"></a>重载与模板</h2><p>函数模板可以被另一个模板或普通非模板函数重载<br>匹配规则：<br>·对于一个调用，其候选函数包括所有模板实参推断成功的函数模板实例<br>·候选的函数模板总是可行的，因为模板实参推断会排除任何不可行的模板<br>·可行函数(模板与非模板)按类型转换(如果需要)来排序<br>·如果恰有一个函数提供比其他任何函数都更好的匹配，则选择此函数。但是，<br>如果有多个函数提供同样好的匹配，则：<br>– 如果同样好的函数中只有一个是非模板函数，则选择此函数<br>– 如果没有非模板函数，而有多个模板，且其中一个模板比其他的更特例话，则选此<br>– 否则调用有歧义</p>
<p>编写重载模板</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;string debug_rep(const T&amp; t) &#123;</span><br><span class="line">	ostringstream ret;</span><br><span class="line">	ret &lt;&lt; t;	&#x2F;&#x2F;使用T的输出运算符打印t的一个表示形式</span><br><span class="line">	return ret.str();	&#x2F;&#x2F;返回ret绑定的string的一个副本</span><br><span class="line">&#125;</span><br><span class="line">此函数生成一个对象对应的string表示，该对象可以是任意具备输出运算符的类型</span><br><span class="line">打印指针的版本</span><br><span class="line">&#x2F;&#x2F;打印指针的值，后跟指针指向的对象</span><br><span class="line">template&lt;typename T&gt;string debug_rep(T* p) &#123;</span><br><span class="line">	ostringstream ret;</span><br><span class="line">	ret &lt;&lt; &quot;pointer: &quot; &lt;&lt; p;	&#x2F;&#x2F;打印指针本身的值</span><br><span class="line">	if (p)ret &lt;&lt; &quot; &quot; &lt;&lt; debug_rep(*p);&#x2F;&#x2F;打印p指向的值</span><br><span class="line">	else ret &lt;&lt; &quot; null pointer&quot;;	&#x2F;&#x2F;或指出p为空</span><br><span class="line">	return ret.str();		&#x2F;&#x2F;返回ret绑定的string的一个副本</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成一个string，包含指针本身的值和调用debug_rep获得的指针指向的值<br>不能打印字符指针，因为IO库为char* 定义了一个 &lt;&lt; 版本，假定指针表示一个空字符结尾的字符数组，<br>打印数组的内容而非地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s(&quot;hi&quot;);</span><br><span class="line">cout &lt;&lt; debug_rep(s) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>只有第一个版本的debug_rep是可行的。第二个要求一个指针参数，但传递了非指针对象。<br>编译器无法从一个非指针参数实例化一个期望指针类型参数的函数模板，实参推断失败</p>
<p>若cout &lt;&lt; debug_rep(&amp;s) &lt;&lt; endl; 则两个函数都生成可行的实例<br>·debug_rep(const string<em>&amp;), T被绑定到string</em><br>·debug_rep(string*), T被绑定到string<br>第二个是精确匹配，第一个需要普通指针到const指针的转换</p>
<p>多个可行模板<br>const string* sp = &s;<br>cout &lt;&lt; debug_rep(sp) &lt;&lt; endl;<br>两个都可行，都是精确匹配<br>·debug_rep(const string<em>&amp;),T被绑定到string</em><br>·debug_rep(const string<em>),T被绑定到string<br>第二个是更特例化的版本，被解析为debug_rep(T</em>)</p>
<p>模板重载和类型转换</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/30/c-primer-16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/" data-id="ckhq93ptv000za0veen5u7fu6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-primer/" rel="tag">c++ primer</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-c-primer-15-面向对象程序设计" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/30/c-primer-15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" class="article-date">
  <time datetime="2020-08-30T02:55:38.000Z" itemprop="datePublished">2020-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/30/c-primer-15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">c++ primer 15 面向对象程序设计</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h1><h2 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h2><p>面向对象程序设计(object-oriented programming)的核心思想是数据抽象、继承和动态绑定<br>数据抽象：将类的接口与实现分离<br>继承：可以定义相似的类型并对其相似关系建模<br>动态绑定：可以在一定程度上忽略相似类型的区别，以统一的方式使用它们的对象</p>
<p>继承<br>层次关系的根部有一个基类(base class)，其他为派生类(derived class)。<br>基类负责定义所有类共有的成员，派生类定义各自特有的成员<br>对于某些函数，基类希望它的派生类个自定义合适自身的版本，则将其声明成虚函数(virtuan function)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Quote &#123;</span><br><span class="line">public:</span><br><span class="line">	string isbn() const;</span><br><span class="line">	virtual double net_price(size_t n)const;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>派生类必须通过类派生列表(class derivation list)明确指出是从哪基类继承而来的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Bulk_quote :public Quote &#123;</span><br><span class="line">public:</span><br><span class="line">	double net_price(size_t)const override;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>派生类必须在其内部对所有重新定义的虚函数进行声明</p>
<p>动态绑定<br>通过动态绑定可以用同一段代码分别处理Quote和Bulk_quote的对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">double print_total(ostream&amp; os, const Quote&amp; item, size_t n) &#123;</span><br><span class="line">	&#x2F;&#x2F;根据传入item形参的对象类型调用Quote::net_price或者Bulk_quote::net_price</span><br><span class="line">	double ret &#x3D; item.net_price(n);</span><br><span class="line">	os &lt;&lt; item.isbn() &lt;&lt; &quot; &quot; &lt;&lt; n &lt;&lt; &quot; &quot; &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据实际传入print_total的对象类型决定执行net_price的哪个版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print_total(cout, basic, 20);	&#x2F;&#x2F;调用Quote的net_price</span><br><span class="line">print_total(cout, bulk, 20);	&#x2F;&#x2F;调用Bulk_quote的net_price</span><br></pre></td></tr></table></figure>
<p>当我们使用基类的引用(或指针)调用一个虚函数时将发生动态绑定</p>
<h2 id="定义基类和派生类"><a href="#定义基类和派生类" class="headerlink" title="定义基类和派生类"></a>定义基类和派生类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Quote &#123;</span><br><span class="line">public:</span><br><span class="line">	Quote() &#x3D; default;</span><br><span class="line">	Quote(const string&amp; book, double sales_price) :bookNo(book), price(sales_price) &#123;&#125;</span><br><span class="line">	string isbn()const &#123; return bookNo; &#125;</span><br><span class="line">	&#x2F;&#x2F;返回给定数量书籍的总销售额  派生类负责改写并使用不同的折扣计算法</span><br><span class="line">	virtual double net_price(size_t n)const &#123; return n * price; &#125;</span><br><span class="line">	virtual ~Quote() &#x3D; default;	&#x2F;&#x2F;对析构函数进行动态绑定</span><br><span class="line">private:</span><br><span class="line">	string bookNo;	&#x2F;&#x2F;书籍的isbn编号</span><br><span class="line">protected:</span><br><span class="line">	double price &#x3D; 0.0;	&#x2F;&#x2F;代表普通状态下不打折的价格</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>成员函数与继承<br>基类将希望其派生类进行覆盖的函数定义为虚函数。当使用指针或引用调用虚函数时，该调用将被动态绑定。<br>根据所绑定对象的版本来调用对应执行的版本<br>构造函数之外的非静态函数都可以是虚函数。关键字virtual只能出现在类内部的声明语句之前不能用于外部定义</p>
<h3 id="定义派生类"><a href="#定义派生类" class="headerlink" title="定义派生类"></a>定义派生类</h3><p>派生类必须将其继承而来的成员函数中需要覆盖的那些重新声明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Bulk_quote :public Quote &#123;</span><br><span class="line">public;</span><br><span class="line">	Bulk_quote() &#x3D; default;</span><br><span class="line">	Bulk_quote(const string&amp;, double, size_t, double);</span><br><span class="line">	&#x2F;&#x2F;覆盖基类的函数版本以实现基于大量购买的折扣政策</span><br><span class="line">	double net_price(size_t)const override;</span><br><span class="line">private:</span><br><span class="line">	size_t min_qty &#x3D; 0;		&#x2F;&#x2F;使用折扣政策的最低购买量</span><br><span class="line">	double discount &#x3D; 0.0;	&#x2F;&#x2F;以小数表示折扣额</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他普通成员，派生类会直接继承其在基类中的版本</p>
<p>派生类对象及派生类向基类的类型转换<br>一个派生类的对象包含：含有派生类自己定义的(非静态)成员的子对象及与该派生类继承的基类对应的子对象<br>可以把派生类的对象当成基类对象来使用，也可以把基类的指针或引用绑定到派生类对象中的基类部分上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Quote item;			&#x2F;&#x2F;基类对象</span><br><span class="line">Bulk_quote bulk;	&#x2F;&#x2F;派生类对象</span><br><span class="line">Quote* p &#x3D; &amp;item;	&#x2F;&#x2F;p指向Quote对象</span><br><span class="line">p &#x3D; &amp;bulk;			&#x2F;&#x2F;p指向bulk的Quote部分</span><br><span class="line">Quote&amp; r &#x3D; bulk;	&#x2F;&#x2F;r绑定到bulk的Quote部分</span><br></pre></td></tr></table></figure>
<p>Bulk_quote的构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bulk_quote(const string&amp; book, double p, size_t qty, double disc) :Quote(book, p), min_qty(qty), discount(disc) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>该函数将它前两个参数传递给Quote的构造函数，由Quote的构造函数负责初始化Bulk_quote的基类部分<br>接下来由派生类直接定义其它的成员，最后运行Bulk_quote构造函数的函数体</p>
<p>派生类可以访问基类的公有成员和受保护成员</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">double Bulk_quote::net_price(size_t cnt)const &#123;</span><br><span class="line">	if (cnt &gt;&#x3D; min_qty)</span><br><span class="line">		return cnt * (1 - discount) * price;</span><br><span class="line">	else</span><br><span class="line">		return cnt * price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继承与静态成员<br>如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">public:</span><br><span class="line">	static void statmem();</span><br><span class="line">&#125;;</span><br><span class="line">class Derived :public Base &#123;</span><br><span class="line">	void f(const Derived&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>假设某静态成员是可以访问的，就既能通过基类使用它也能通过派生类使用它</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void Derived::f(const Derived&amp; derived_obj) &#123;</span><br><span class="line">	Base::statmem();		&#x2F;&#x2F;正确：Base定义了statmem</span><br><span class="line">	Derived::statmem();		&#x2F;&#x2F;正确：Derived继承了statmem</span><br><span class="line">	&#x2F;&#x2F;正确：派生类的对象能访问基类的静态成员</span><br><span class="line">	derived_obj.statmem();	&#x2F;&#x2F;通过Derived对象访问</span><br><span class="line">	statmem();				&#x2F;&#x2F;通过this对象访问</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>派生类声明中包含类名但不包含它的派生列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Bulk_quote :public Quote;	&#x2F;&#x2F;错误</span><br><span class="line">class Bulk_quote;				&#x2F;&#x2F;正确</span><br></pre></td></tr></table></figure>
<p>想将有个类用作基类，必须已经定义而非仅仅声明</p>
<p>防止基类发生<br>在类名后跟一个关键字final</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class NoDerived final &#123;&#125;;</span><br><span class="line">class Base &#123;&#125;;</span><br><span class="line">class Last final :Base &#123;&#125;;</span><br><span class="line">class Bad :NeDerived &#123;&#125;;	&#x2F;&#x2F;错误：NoDerived是final的</span><br><span class="line">class Bad2 :Last &#123;&#125;;		&#x2F;&#x2F;错误：Last是final的</span><br></pre></td></tr></table></figure>
<h3 id="类型转换与继承"><a href="#类型转换与继承" class="headerlink" title="类型转换与继承"></a>类型转换与继承</h3><p>可以将基类的指针或引用绑定到派生类对象上<br>当使用基类的引用或指针时，实际上我们并不清楚该引用或指针所绑定对象的真实类型<br>基类的指针或引用的静态类型可能与其动态类型不一致</p>
<p>不存在基类向派生类的隐式类型转换<br>一个基类的对象可能是派生类对象的一部分，也可能不是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Quote base;</span><br><span class="line">Bulk_quote* bulkP &#x3D; &amp;base;	&#x2F;&#x2F;错误</span><br><span class="line">Bulk_quote&amp; bulkR &#x3D; base;	&#x2F;&#x2F;错误</span><br></pre></td></tr></table></figure>
<p>如果上述是合法的，则可能用其访问base中不存在的成员<br>即使一个基类指针或引用绑定在派生类对象上，也不能执行从基类向派生类的转换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bulk_quote bulk;</span><br><span class="line">Quote* itemP &#x3D; &amp;bulk;		&#x2F;&#x2F;正确：动态类型是Bulk_quote</span><br><span class="line">Bulk_quote* bulkP &#x3D; itemP;	&#x2F;&#x2F;错误：不能将基类转换成派生类</span><br></pre></td></tr></table></figure>
<p>派生类向基类的自动类型转换至针对指针或引用类型有效<br>当用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，派生类部分将被忽略掉</p>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>使用基类的引用或指针调用一个虚成员函数时会执行动态绑定。虚函数都必须有定义</p>
<p>对虚函数的调用可能在运行时才被解析<br>被调用的函数是与绑定到指针或引用上的对象的动态类型匹配的那个</p>
<p>引用或指针的静态类型与动态类型不听这一事实是c++语言支持多态性的根本所在<br>使用基类的引用或指针调用基类中定义的一个函数时，并不知道该函数真正作用的对象是什么类型，可能是基类的对象也可能是派生类的对象<br>如果该函数是虚函数，知道运行时才会决定到底执行那个版本，判断的依据是引用或指针所绑定对象的真实类型<br>对非虚函数的调用在编译时进行绑定。通过对象进行的函数调用也在编译时绑定。对象的类型是确定不变的，不可能动态类型和静态类型不一致</p>
<p>当且仅当通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有这种情况下对象的动态类型才可能与静态类型不同</p>
<p>派生类中的虚函数<br>一旦某个函数被声明为虚函数，则在所有的派生类中都是虚函数<br>一个派生类的函数如果覆盖了某个继承来的虚函数，它的形参类型必须与被覆盖的基类函数完全一致<br>派生类中虚函数的返回类型也必须与基类函数匹配。有一例外：当类的虚函数返回类型是类本身的指针或引用时。不过要求派生类到基类的类型转换是可以访问的</p>
<p>可以使用override关键字来说明派生类中的虚函数<br>可以使程序员的意图更清晰，也可以让编译器为我们发现错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct B &#123;</span><br><span class="line">	virtual void f1(int)const;</span><br><span class="line">	virtual void f2();</span><br><span class="line">	void f3();</span><br><span class="line">&#125;;</span><br><span class="line">struct D1 :B &#123;</span><br><span class="line">	void f1(int)const override;	&#x2F;&#x2F;正确：f1与基类中f1匹配</span><br><span class="line">	void f2(int) override;		&#x2F;&#x2F;错误：B没有形如f2(int)的函数</span><br><span class="line">	void f3() override;			&#x2F;&#x2F;错误：f3不是虚函数</span><br><span class="line">	void f4() override;			&#x2F;&#x2F;错误：B没有f4</span><br><span class="line">&#125;;</span><br><span class="line">struct D2 :B &#123;</span><br><span class="line">	void f1(int)const final;	&#x2F;&#x2F;不允许后续的其他类覆盖f1(int)</span><br><span class="line">&#125;;</span><br><span class="line">struct D3 :D2 &#123;</span><br><span class="line">	void f2();			&#x2F;&#x2F;正确：覆盖从间接基类B继承而来的f2</span><br><span class="line">	void f1(int)const;	&#x2F;&#x2F;错误：D2已将f1(int)声明成final</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>虚函数与默认实参<br>如果某次函数调用使用了默认实参，则该实参值由本次调用的静态类型决定<br>如果通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即使实际中运行的是派生类中的版本也是如此<br>此时传入派生类函数的将是基类函数定义的默认实参，如果派生类函数依赖不同的实参，则结果将与我们的预期不符</p>
<p>回避虚函数的机制<br>希望对虚函数的调用不要进行动态绑定，强迫执行虚函数的某个特定版本，使用作用域运算符来实现<br>double undiscounted = baseP-&gt;Quote::net_price(42);<br>该调用将在编译时完成解析</p>
<h2 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h2><p>纯虚函数(pure virtual)，无须定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;用于保存折扣值和购买量的类，派生类使用这些数据可以实现不同的价格策略</span><br><span class="line">class Disc_quote :public Quote &#123;</span><br><span class="line">public:</span><br><span class="line">	Disc_quote() &#x3D; default;</span><br><span class="line">	Disc_quote(const string&amp; book, double price, size_t qty, double disc) :</span><br><span class="line">		Quote(book, price), quantity(qty), discount(disc) &#123;&#125;</span><br><span class="line">	double net_price(size_t)const &#x3D; 0;</span><br><span class="line">protected:</span><br><span class="line">	size_t quantity &#x3D; 0;	&#x2F;&#x2F;折扣适用的购买量</span><br><span class="line">	double discount &#x3D; 0.0;	&#x2F;&#x2F;表示折扣的小数值</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以为纯虚函数提供定义，不过函数体必须定义在类的外部</p>
<p>含有纯虚函数的类是抽象基类(abstract base class)<br>抽象基类负责定义接口，不能直接创建一个抽象基类的对象<br>派生类必须给出自己的net_price定义，否则他们仍是抽象基类</p>
<p>派生类构造函数只初始化它的直接基类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Bulk_quote :public Disc_quote &#123;</span><br><span class="line">public:</span><br><span class="line">	Bulk_quote() &#x3D; default;</span><br><span class="line">	Bulk_quote(const string&amp; book, double price, size_t qty, double disc) :</span><br><span class="line">		Disc_quote(book, price, qyt, disc) &#123;&#125;</span><br><span class="line">	&#x2F;&#x2F;覆盖基类中的函数版本以实现一种新的折扣策略</span><br><span class="line">	double net_price(size_t)const override;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>重构负责重新设计类的体系以便将操作和 / 或数据从一个类移动到另一个类中</p>
<h2 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h2><p>受保护的成员<br>一个类使用protected关键字来声明那些它希望与派生类分享但是不想被其它公共访问的成员<br>·受保护的成员对于类的用户来说是不可访问的<br>·受保护的成员也对于派生类的成员和友元来说是可访问的<br>·派生类的成员和或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问特权</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">protected:</span><br><span class="line">	int prot_mem;</span><br><span class="line">&#125;;</span><br><span class="line">class Sneaky :public Base &#123;</span><br><span class="line">	friend void clobber(Sneaky&amp;);	&#x2F;&#x2F;能访问Sneaky::prot_mem</span><br><span class="line">	friend void clobber(Base&amp;);		&#x2F;&#x2F;能访问Base::prot_mem</span><br><span class="line">	int j;							&#x2F;&#x2F;j默认是private</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;正确：clobber能访问Sneaky对象的private和protected成员</span><br><span class="line">void clobber(Sneaky&amp; s) &#123; s.j &#x3D; s.prot_mem &#x3D; 0; &#125;</span><br><span class="line">&#x2F;&#x2F;错误：clobber不能访问Base的protected成员</span><br><span class="line">void clovver(Base&amp; b) &#123; b.prot_mem &#x3D; 0; &#125;</span><br></pre></td></tr></table></figure>
<p>公有、私有和受保护继承</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">public:</span><br><span class="line">	void pub_mem();</span><br><span class="line">protected:</span><br><span class="line">	int prot_mem;</span><br><span class="line">private:</span><br><span class="line">	char priv_mem;</span><br><span class="line">&#125;;</span><br><span class="line">struct Pub_Derv :public Base &#123;</span><br><span class="line">	&#x2F;&#x2F;正确：派生类能访问protected成员</span><br><span class="line">	int f() &#123; return prot_mem; &#125;</span><br><span class="line">	&#x2F;&#x2F;错误：private成员对于派生类是不可访问的</span><br><span class="line">	char g() &#123; return priv_mem; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">struct Priv_Derv :private Base &#123;</span><br><span class="line">	&#x2F;&#x2F;private不影响派生类的访问权限</span><br><span class="line">	int f1() &#123; return prot_mem; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>派生类访问说明符对于派生类的成员(及友元)能否访问其直接基类的成员没什么影响，对于基类成员的访问权限只与基类中的访问说明符有关<br>派生访问说明符的目的是控制派生类用户(包括派生类的派生类)对于基类成员的访问权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Pub_Derv d1;	&#x2F;&#x2F;继承自Base的成员是public的</span><br><span class="line">Priv_Derv d2;	&#x2F;&#x2F;继承自Base的成员是private的</span><br><span class="line">d1.pub_mem();	&#x2F;&#x2F;正确：pub_mem在派生类中是public的</span><br><span class="line">d2.pub_mem();	&#x2F;&#x2F;错误：pub_mem在派生类中是private的</span><br></pre></td></tr></table></figure>
<p>派生访问说明符还可以控制继承自派生类的新类的访问权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct Derived_from_Public :public Pub_Derv &#123;</span><br><span class="line">	&#x2F;&#x2F;正确：Base::prot_mem在Pub_Derv中仍然是protected的</span><br><span class="line">	int use_base() &#123; return prot_mem; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">struct Derived_from_Prevate :public Priv_Derv &#123;</span><br><span class="line">	&#x2F;&#x2F;错误：Base::prot_mem在PrivDerv中是private的</span><br><span class="line">	int use_base() &#123; return prot_mem; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>派生类向基类转换的可访问性<br>·只有当D公有地继承B时，用户代码才能使用派生类向基类的转换<br>·无论什么方式继承，D的成员函数和友元都能使用派生类向基类的转换<br>·如果继承方式是公有或者受保护的，则D的派生类的成员和友元可以使用D向B的类型转换</p>
<p>友元与继承<br>友元关系不能继承。基类的友元访问派生类成员时不具有特殊性，派生类的友元也不能随意访问基类的成员</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">	friend class Pal;</span><br><span class="line">&#125;;</span><br><span class="line">class Pal &#123;</span><br><span class="line">public:</span><br><span class="line">	int f(Base b) &#123; return b.prot_mem; &#125;	&#x2F;&#x2F;正确：pal是Base的友元</span><br><span class="line">	int f2(Sneaky s) &#123; return s.j; &#125;		&#x2F;&#x2F;错误：Pal不是Sneaky的友元</span><br><span class="line">	&#x2F;&#x2F;对基类的访问权限由基类本身控制，即使对于派生类的基类部分也是如此</span><br><span class="line">	int f3(Sneaky s) &#123; return s.prot_mem; &#125;	&#x2F;&#x2F;正确：Pal是Base的友元</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当一个类将另一个类声明为友元时，这种友元关系只能对做出声明的类有效。对于原来那个类来说，其友元的基类或者派生类不具有特殊的访问能力</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class D2 :public Pal &#123;</span><br><span class="line">public:</span><br><span class="line">	int mem(Base b) &#123; return b.prot_mem; &#125;	&#x2F;&#x2F;错误：友元关系不能继承</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>改变个别成员的可访问性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">public:</span><br><span class="line">	size_t size()const &#123; return n; &#125;</span><br><span class="line">protected:</span><br><span class="line">	size_t n;</span><br><span class="line">&#125;;</span><br><span class="line">class Derived :private Base &#123;</span><br><span class="line">public:</span><br><span class="line">	using Base::size;</span><br><span class="line">protected:</span><br><span class="line">	using Base::n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>默认情况下，class关键字定义的派生类是私有继承；struct是公有继承<br>class和struct唯一的差别就是默认成员访问说明符和默认派生访问说明符</p>
<h2 id="继承中的作用域"><a href="#继承中的作用域" class="headerlink" title="继承中的作用域"></a>继承中的作用域</h2><p>派生类的做哟用于嵌套在其基类的作用域之内。如果一个名字在派生类的作用域内无法解析，则编译器将继续在外层的基类作用域中寻找该名字的定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bulk_quote bulk;</span><br><span class="line">cout &lt;&lt; bulk.isbn();</span><br><span class="line">isbn()先在Bulk_quote中查找，再在Disc_quote中找，最后在Quote中找</span><br></pre></td></tr></table></figure>
<p>一个对象、引用或指针的静态类型决定了该对象的哪些成员是可见的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Disc_quote :public Quote &#123;</span><br><span class="line">public:</span><br><span class="line">	pair&lt;size_t, double&gt;discount_policy()const &#123; return &#123; quantity,discount &#125;; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>只能通过Disc_quote及其派生类的对象、引用或指针使用discount_policy</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Bulk_quote bulk;</span><br><span class="line">Bulk_quote* bulkP &#x3D; &amp;bulk;	&#x2F;&#x2F;静态类型与动态类型一直</span><br><span class="line">Quote* itemP &#x3D; &amp;bulk;		&#x2F;&#x2F;静态类型与动态类型不一致</span><br><span class="line">bulkP-&gt;discount_policy();	&#x2F;&#x2F;正确：bulkP的类型是Bulk_quote*</span><br><span class="line">itemP-&gt;discount_policy();	&#x2F;&#x2F;错误：itemP的类型是Quote*</span><br></pre></td></tr></table></figure>
<p>名字冲突与继承</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct Base &#123;</span><br><span class="line">	Base() :mem(0) &#123;&#125;</span><br><span class="line">protected:</span><br><span class="line">	int mem;</span><br><span class="line">&#125;;</span><br><span class="line">struct Derived :Base &#123;</span><br><span class="line">	Derived(int i) :mem(i) &#123;&#125;		&#x2F;&#x2F;用i初始化Derived::mem， Base::mem进行默认初始化</span><br><span class="line">	int get_mem() &#123; return mem; &#125;	&#x2F;&#x2F;返回Derived::mem</span><br><span class="line">protected:</span><br><span class="line">	int mem;						&#x2F;&#x2F;隐藏基类中的mem</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过作用域运算符来使用隐藏的成员</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct Derived :Base &#123;</span><br><span class="line">	int get_base_mem() &#123; return Base::mem; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>函数调用的解析过程，调用p-&gt;mem()：<br>·先确定p的静态类型<br>·在p的静态类型对象的类中查找mem。找不到则在其基类中继续。扔找不到则编译器报错<br>·一旦找到mem则进行常规的类型检查，确认对于当前找到的mem，本次调用是否合法<br>·假设调用合法，编译器根据是否是虚函数而产生不同代码：<br>–是虚函数且通过引用或指针进行的调用，则编译器产生的代码将在运行时确定运行该虚函数的哪个版本，依据是对象动态类型<br>–反之则产生一个常规函数调用</p>
<p>如果派生类的成员与基类的某个成员同名，则派生类在其作用域内隐藏掉该基类成员，即使形参列表不一致</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct Base &#123;</span><br><span class="line">	int memfcn();</span><br><span class="line">&#125;;</span><br><span class="line">struct Derived :Base &#123;</span><br><span class="line">	int memfcn(int);</span><br><span class="line">&#125;;</span><br><span class="line">Derived d; Base b;</span><br><span class="line">b.memfcn();			&#x2F;&#x2F;调用Base::memfcn</span><br><span class="line">d.memfcn(10);		&#x2F;&#x2F;调用Derived::memfcn</span><br><span class="line">d.memfcn();			&#x2F;&#x2F;错误：参数列表为空的memfcn被隐藏了</span><br><span class="line">d.Base::memfcn();	&#x2F;&#x2F;正确：调用Base::memfcn</span><br></pre></td></tr></table></figure>
<p>虚函数与作用域<br>如果基类与派生类的虚函数接受的实参不同，则无法通过基类的引用或指针调用派生类的虚函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">public:</span><br><span class="line">	virtual int fcn();</span><br><span class="line">&#125;;</span><br><span class="line">class D1 :public Base &#123;</span><br><span class="line">public:</span><br><span class="line">	&#x2F;&#x2F;隐藏基类的fcn，这个fcn不是虚函数</span><br><span class="line">	int fcn(int);		&#x2F;&#x2F;形参列表与Base中的不一致</span><br><span class="line">	virtual void f2();	&#x2F;&#x2F;是一个新的虚函数，Base中不存在</span><br><span class="line">&#125;;</span><br><span class="line">class D2 :public D1 &#123;</span><br><span class="line">public:</span><br><span class="line">	int fcn(int);	&#x2F;&#x2F;一个非虚函数，隐藏了D1::fcn(int)</span><br><span class="line">	int fcn();		&#x2F;&#x2F;覆盖了Base中的虚函数fcn</span><br><span class="line">	void f2();		&#x2F;&#x2F;覆盖了D1中的虚函数f2</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过基类调用隐藏的虚函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Base bobj; D1 d1obj; D2 d2obj;</span><br><span class="line">Base* bp1 &#x3D; &amp;bobj, * bp2 &#x3D; &amp;d1obj, * bp3 &#x3D; &amp;d2obj;</span><br><span class="line">bp1-&gt;fcn();	&#x2F;&#x2F;虚调用，将在运行时调用Base::fcn</span><br><span class="line">bp2-&gt;fcn(); &#x2F;&#x2F;虚调用，将在运行时调用Base::fcn</span><br><span class="line">bp3-&gt;fcn();	&#x2F;&#x2F;&#x2F;虚调用，将在运行时调用D2::fcn</span><br><span class="line"></span><br><span class="line">D1* d1p &#x3D; &amp;d1obj; D2* d2p &#x3D; &amp;d2obj;</span><br><span class="line">bp2-&gt;f2();	&#x2F;&#x2F;错误：Base没有名为f2的成员</span><br><span class="line">d1p-&gt;f2(); &#x2F;&#x2F;虚调用，将在运行时调用D1::f2()</span><br><span class="line">d2p-&gt;f2(); &#x2F;&#x2F;虚调用，将在运行时调用D2::f2()</span><br><span class="line"></span><br><span class="line">Base* p1 &#x3D; &amp;d2obj; D1* p2 &#x3D; &amp;d2obj; D2* p3 &#x3D; &amp;d2obj;</span><br><span class="line">p1-&gt;fcn(42);	&#x2F;&#x2F;错误：Base中没有fcn(int)</span><br><span class="line">p2-&gt;fcn(42);	&#x2F;&#x2F;正确：调用D1:fcn(int)</span><br><span class="line">p3-&gt;fcn(42);	&#x2F;&#x2F;正确：调用D2:fcn(int)</span><br></pre></td></tr></table></figure>
<h2 id="构造函数与拷贝控制"><a href="#构造函数与拷贝控制" class="headerlink" title="构造函数与拷贝控制"></a>构造函数与拷贝控制</h2><h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p>通常基类应该定义一个虚析构函数，这样就能动态分配继承体系中的对象了<br>如果delete一个Quote* 类型的指针，该指针实际指向了一个Bulk_quote类型的对象。编译器就必须要清楚它应该执行Bulk_quote的析构函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Quote &#123;</span><br><span class="line">public:</span><br><span class="line">	virtual ~Quote() &#x3D; default;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>析构函数的虚属性会被继承</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Quote* itemP &#x3D; new Quote;	&#x2F;&#x2F;静态类型与动态类型一致</span><br><span class="line">delete itemP;				&#x2F;&#x2F;调用Quote的析构函数</span><br><span class="line">itemp &#x3D; new Bulk_quote;		&#x2F;&#x2F;静态类型与动态类型不一致</span><br><span class="line">delete itemP;				&#x2F;&#x2F;调用Bulk_quote的析构函数</span><br></pre></td></tr></table></figure>
<p>如果基类的析构函数不是虚函数，则delete一个指向派生类对象的指针将产生未定义的行为</p>
<p>如果一个类定义了析构函数，则编译器不会为这个类合成移动操作，因此移动基类对象时，实际使用的是合成和拷贝的操作</p>
<h3 id="合成拷贝控制与继承"><a href="#合成拷贝控制与继承" class="headerlink" title="合成拷贝控制与继承"></a>合成拷贝控制与继承</h3><p>基类或派生类的合成拷贝控制成员的行为：对类本身的成员依次进行初始化、赋值或销毁的操作，还负责使用直接基类中对应的操作对一个对象的直接基类部分进行初始化、赋值或销毁的操作<br>·合成的Bulk_quote默认构造函数运行Disc_quote的默认构造函数，后又运行Quote的默认构造函数<br>·Quote的默认构造函数将bookNo成员默认初始化为空字符串，同时使用类内初始值将price初始化为0<br>·Quote的构造函数完成后，继续执行Disc_quote的构造函数，使用类内初始值初始化qty和discount<br>·继续执行Bulk_quote的构造函数，但它什么也不做</p>
<p>派生类中删除的拷贝控制与基类的关系<br>·如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的函数或不可访问，则派生类中对象的成员将是被删除的，<br>原因是编译器不能使用基类成员来执行派生类对象基类部分的构造赋值或销毁操作<br>·如果在基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认和拷贝构造函数将是被删除的，因为编译器无法销毁派生类对象的基类部分<br>·编译器将不会合成一个删除掉的操作。当使用 = default请求一个移动操作时，如果基类中的对应操作是删除的或不可访问的，<br>那么派生类中该函数将是被删除的，因为派生类对象的基类部分不可移动。同样，基类的析构函数是删除的或不可访问的，<br>则派生类的移动构造函数也是被删除的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class B &#123;</span><br><span class="line">public:</span><br><span class="line">	B();</span><br><span class="line">	B(const&amp;) &#x3D; delete;</span><br><span class="line">&#125;;</span><br><span class="line">class D :public B &#123;</span><br><span class="line">	&#x2F;&#x2F;没有声明任何构造函数</span><br><span class="line">&#125;;</span><br><span class="line">D d;			&#x2F;&#x2F;正确：D的合成默认构造函数使用B的默认构造函数</span><br><span class="line">D d2(d);		&#x2F;&#x2F;错误：D的合成拷贝构造函数是被删除的</span><br><span class="line">D d3(move(d));	&#x2F;&#x2F;错误：隐式地使用D的被删除的拷贝构造函数</span><br></pre></td></tr></table></figure>
<p>因为定义了拷贝构造函数，所以编译器不会为B合成一个移动构造函数，因此既不能拷贝也不能移动B的对象</p>
<p>移动操作与继承<br>大多数基类会定义一个虚析构函数，因此在默认情况下基类通常不含有合成的移动操作，而且派生类中也没有<br>所以需要执行移动时应首先在基类中进行定义，一旦定义了自己的移动操作，又必须显式地定义拷贝操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Quote &#123;</span><br><span class="line">public:</span><br><span class="line">	Quote(); &#x3D; default;</span><br><span class="line">	Quote(const Quote&amp;) &#x3D; default;</span><br><span class="line">	Quote(Quote&amp;&amp;) &#x3D; default;</span><br><span class="line">	Quote&amp; operator&#x3D;(const Quote&amp;) &#x3D; default;</span><br><span class="line">	Quote&amp; operator(Quote&amp;&amp;) &#x3D; default;</span><br><span class="line">	virtual ~Quote() &#x3D; default;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="派生类的拷贝控制成员"><a href="#派生类的拷贝控制成员" class="headerlink" title="派生类的拷贝控制成员"></a>派生类的拷贝控制成员</h3><p>派生类的拷贝和移动构造函数在拷贝和移动自有成员的同时，也要拷贝和移动基类部分的成员<br>析构函数只负责销毁派生类自己分配的资源</p>
<p>定义派生类的拷贝或移动构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;&#x2F;* *&#x2F; &#125;;</span><br><span class="line">class D :public Base &#123;</span><br><span class="line">public:</span><br><span class="line">	&#x2F;&#x2F;默认情况下，基类的默认构造函数初始化对象的基类部分</span><br><span class="line">	&#x2F;&#x2F;想要使用拷贝或移动构造函数，必须在构造函数初始值列表中显式地调用该构造函数</span><br><span class="line">	D(const D&amp; d) :Base(d)&#x2F;*D成员的初始值*&#x2F; &#123;&#125;</span><br><span class="line">	D(D&amp;&amp; d) :Base(move(d))&#x2F;*D成员的初始值*&#x2F; &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>派生类赋值运算符<br>派生类的赋值运算符也必须显式地为其基类部分赋值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Base::operator&#x3D;(const Base&amp;)不会被自动调用</span><br><span class="line">D&amp; D::operator&#x3D;(const D&amp; rhs) &#123;</span><br><span class="line">	Base::operator(rhs);&#x2F;&#x2F;为基类部分赋值</span><br><span class="line">	return*this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先显式调用基类赋值运算符，令其为派生类对象的基类部分赋值。</p>
<p>派生类析构函数<br>派生类析构函数只负责销毁由派生类自己分配的资源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class D :public Base &#123;</span><br><span class="line">	public;</span><br><span class="line">	&#x2F;&#x2F;Base::~Base被自动调用执行</span><br><span class="line">	~D() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对象销毁的顺序与创建的相反：派生类析构函数首先执行，然后是基类的析构函数</p>
<h3 id="继承的构造函数"><a href="#继承的构造函数" class="headerlink" title="继承的构造函数"></a>继承的构造函数</h3><p>通过注明了基类名的using声明语句来为派生类继承基类构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Bulk_quote :public Disc_quote &#123;</span><br><span class="line">	public;</span><br><span class="line">	using Disc_quote::Disc_quote;	&#x2F;&#x2F;继承Disc_quote的构造函数</span><br><span class="line">	double net_price(size_t)const;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>编译器生成的构造函数形如：<br>derived(parms) :base(args) {}<br>Bulk_quote类中继承的构造函数等价于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bulk_quote(const string&amp; book, double price, size_t qty, double disc) : Disc_quote(book, price, qty, disc) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>如果派生类含有自己的数据成员，则这些成员将被默认初始化</p>
<p>继承的构造函数的特点<br>一个构造函数的using声明不会改变该构造函数的访问级别。基类的私有构造函数在派生类中还是一个私有构造函数<br>一个using声明语句不能指定explicit或constexpr<br>当一个基类构造函数含有默认实参时，这些实参不会被继承。相反，派生类将会获得多个继承的构造函数，每个构造函数分别省略掉一个含有默认实参的形参<br>派生类可以继承一部分构造函数，而为其它的构造函数定义自己的版本。如果派生类定义的构造函数与基类的有相同的参数列表，则该构造函数不会被继承<br>默认、拷贝和移动构造函数不会被继承。继承的构造函数不会被作为用户定义的构造函数来使用，如果一个类只含有继承的构造函数，它也将拥有合成的默认构造函数</p>
<h2 id="容器与继承"><a href="#容器与继承" class="headerlink" title="容器与继承"></a>容器与继承</h2><p>当使用容器存放继承体系中的对象时，必须采用简洁储存的方式。不允许在容器中保存不同类型的元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;Quote&gt;basket;</span><br><span class="line">basket.push_back(Quote(&quot;999-99&quot;, 50);</span><br><span class="line">&#x2F;&#x2F;正确：但只能把对象的Quote部分拷贝给basket</span><br><span class="line">basket.push_balk(Bulk_quote(&quot;999-9999&quot;, 50, 10, .25));</span><br><span class="line">&#x2F;&#x2F;调用Quote定义的版本，打印750</span><br><span class="line">cout &lt;&lt; basket.back().net_price(15) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>在容器中放置(智能)指针而非对象<br>当我们希望在容器中存放具有继承关系的对象时，实际上存放的通常是基类的指针。这些指针所指的对象的动态类型可能是基类或者派生类类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;shared_ptr&lt;Quote&gt;&gt;basket;</span><br><span class="line">basket.push_back(make_shared&lt;Quote&gt;(&quot;999-99&quot;, 50);</span><br><span class="line">basket.push_back(make_shared&lt;Bulk_quote&gt;(&quot;999-9999&quot;, 50, 10, .25));</span><br><span class="line">cout &lt;&lt; basket.back()-&gt;net_price(15) &lt;&lt; endl;	&#x2F;&#x2F;打印562.5，即15*50*.75</span><br></pre></td></tr></table></figure>
<p>实际调用的net_price版本依赖于指针所指对象的动态类型<br>在第二个push_back中，我们可以把一个派生类的智能指针转换成基类的智能指针<br>make_shared<Bulk_quote>返回一个shared_ptr<Bulk_quote>对象。调用push_back时该对象被转换成shared_ptr<Quote></p>
<h3 id="编写Basket类"><a href="#编写Basket类" class="headerlink" title="编写Basket类"></a>编写Basket类</h3><p>对于c++面向对象编程来说，一个悖论是无法直接使用对象进行面向对象编程。必须使用指针和引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Basket &#123;</span><br><span class="line">public:</span><br><span class="line">	&#x2F;&#x2F;Basket使用合成的默认构造函数和拷贝控制成员</span><br><span class="line">	void add_item(const shared_ptr&lt;Quote&gt;&amp; sale) &#123; items.insert(sale); &#125;</span><br><span class="line">	double total_receipt(ostream&amp;)const;</span><br><span class="line">private:</span><br><span class="line">	static bool compare(const shared_ptr&lt;Quote&gt;&amp; lhs, const shared_ptr&lt;Quote&gt;&amp; rhs) &#123;</span><br><span class="line">		return lhs-&gt;isbn() &lt; rhs-&gt;isbn();</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;multiset保存多个报价，按照compare成员排序</span><br><span class="line">	multiset&lt;shared_ptr&lt;Quote&gt;, decltype(compare)*&gt;items&#123; compare &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>定义了一个指向Quote的shared_ptr的multiset。这个multiset将使用一个与compare成员类型相同的函数来对其中的元素进行排序。<br>multiset成员的名字是items，初始化items并令其使用我们的compare函数</p>
<p>定义Basket的成员<br>total_receipt成员负责量购物篮的内容逐项打印成清单，然后返回购物篮中所有物品的总价格</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">double Basket::total_receipt(ostream&amp; os)const &#123;</span><br><span class="line">	double sum &#x3D; 0.0;</span><br><span class="line">	&#x2F;&#x2F;iter指向ISBN相同的一批元素的第一个</span><br><span class="line">	&#x2F;&#x2F;uooer_bound返回一个迭代器，指向这批元素的尾后位置</span><br><span class="line">	for (auto iter &#x3D; items.cbegin(); iter !&#x3D; items.cend(); iter &#x3D; items.upper_bound(*iter)) &#123;</span><br><span class="line">		&#x2F;&#x2F;在当前的Basket中至少有一个该关键字的元素，打印该书籍对应的项目</span><br><span class="line">		sum +&#x3D; print_total(os, **iter, items.count(*iter));</span><br><span class="line">	&#125;</span><br><span class="line">	os &lt;&lt; &quot;Total Sale: &quot; &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">	return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用upper_bound函数可以令我们跳过与当前关键字相同的所有元素<br>它返回的是一个迭代器，指向所有与iter关键字相等的元素中最后一个元素的下一位置<br>解引用iter后将得到一个准备打印对象的shared_ptr，所以需要再解引用该shared_ptr。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">** iter是一个Quote对象(或QUote的派生类的对象)</span><br><span class="line">print_total调用了虚函数net_price，因此最终的计算结果依赖于** iter的动态类型</span><br></pre></td></tr></table></figure>
<p>隐藏指针<br>Basket用户需要处理动态内存，add_item需要接受一个shared_ptr参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Basket bsk;</span><br><span class="line">bsk.add_item(make_shared&lt;Quote&gt;(&quot;999-99&quot;, 45));</span><br><span class="line">bsk.add_item(make_shared&lt;Bulk_quote&gt;(&quot;999-9999&quot;, 50, 10, .25));</span><br><span class="line">重新定义add_item，使得它接受一个Quote对象，而非shared_ptr</span><br><span class="line">void add_item(const Quote&amp; sale);	&#x2F;&#x2F;拷贝给定对象</span><br><span class="line">void add_item(Quote&amp;&amp; sale);		&#x2F;&#x2F;移动给定对象</span><br></pre></td></tr></table></figure>
<p>但add_item不知道要分配的类型，进行内存分配时，某处可能会有：new Quote(sale)。但sale指向Bulk_quote对象时，会被迫切掉一部分</p>
<p>模拟虚拷贝<br>所以给Quote添加一个虚函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Quote &#123;</span><br><span class="line">	&#x2F;&#x2F;该虚函数返回当前对象的一份动态分配的拷贝</span><br><span class="line">	virtual Quote* clone()const&amp; &#123; return new Quote(*this); &#125;</span><br><span class="line">	virtual Quote* clone()&amp;&amp; &#123; return new Quote(move(*this)); &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Bulk_quote :public Quote &#123;</span><br><span class="line">	Bulk_quote* clone()const&amp; &#123; return new Bulk_quote(*this); &#125;</span><br><span class="line">	Bulk_quote* clone()&amp;&amp; &#123; return new Bulk_quote(move(*this)); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>const左值引用成员将它自己拷贝给新分配的对象；右值引用成员将自己移动到新数据中<br>新版本add_item：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Basket &#123;</span><br><span class="line">public:</span><br><span class="line">	void add_item(const Quote&amp; sale) &#123; items.insert(shared_ptr&lt;Quote&gt;(sale.clone())); &#125;	&#x2F;&#x2F;拷贝给定的对象</span><br><span class="line">	void add_item(Quote&amp;&amp; sale) &#123; items.insert(shared_ptr&lt;Quote&gt;(move(sale).clone())); &#125;&#x2F;&#x2F;移动给定的对象</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>clone函数是一个虚函数。sale的动态类型决定了运行Quote的函数还是Bulk_quote的函数。clone返回一个新分配对象的指针，<br>该对象与clone所属的类型一致。把一个shared_ptr绑定到这个对象上，调用insert将新分配对象添加到items中。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/30/c-primer-15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" data-id="ckhq93ptt000ta0ved8b97u7h" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-primer/" rel="tag">c++ primer</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-c-primer-14-重载运算符与类型转换" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/30/c-primer-14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" class="article-date">
  <time datetime="2020-08-30T02:51:40.000Z" itemprop="datePublished">2020-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/30/c-primer-14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/">c++ primer 14 重载运算符与类型转换</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>重载运算符与类型转换</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>重载的运算符是具有特殊名字的函数：名字由关键字operator和其后要定义的运算符号共同组成。包含返回类型、参数列表、函数体<br>对于二元运算符，左侧运算对象传递给第一个参数，右侧传递给第二个。除重载的函数调用运算符operator()外，不能含有默认实参<br>若为成员函数，左侧运算对象绑定到隐式的this指针上，所以显式参数数量比运算符的运算对象总少一个<br>不能重载内置类型的运算符    不能发明新符号<br>———————————————————— - 491</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data1 + data2;			&#x2F;&#x2F;普通的表达式</span><br><span class="line">operator+(data1, data2);&#x2F;&#x2F;等价的函数调用</span><br><span class="line"></span><br><span class="line">data1 +&#x3D; data2;			&#x2F;&#x2F;基于&quot;调用&quot;的表达式</span><br><span class="line">data1.operator+&#x3D;(data2);&#x2F;&#x2F;对成员运算符函数的等价调用</span><br></pre></td></tr></table></figure>
<p>选择作为成员或非成员<br>·赋值(= ), 下标([]), 调用(()), 和成员访问箭头(-&gt;)运算符必须是成员<br>·复合赋值运算符一般来说应该是成员<br>·改变对象状态的或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常应该是成员<br>·具有对称性的运算符可能转换任意一端的运算对象，如算术、相等性、关系和位运算符等，通常应该是普通的非成员函数<br>当把运算符定义为成员函数时，左侧运算对象必须是运算符所属类的一个对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s &#x3D; &quot;world&quot;;</span><br><span class="line">string t &#x3D; s + &quot;!&quot;;	&#x2F;&#x2F;正确：把一个const char*加到一个string对象中</span><br><span class="line">strign u &#x3D; &quot;hi&quot; + s;&#x2F;&#x2F;如果&quot;+&quot;是string成员，则错误</span><br></pre></td></tr></table></figure>
<h2 id="输入和输出运算符"><a href="#输入和输出运算符" class="headerlink" title="输入和输出运算符"></a>输入和输出运算符</h2><h3 id="重载输出运算符-lt-lt"><a href="#重载输出运算符-lt-lt" class="headerlink" title="重载输出运算符&lt;&lt;"></a>重载输出运算符&lt;&lt;</h3><p>通常情况下，输出运算符第一个形参是一个非常量ostream对象的引用<br>非常量：向流写入会改变其状态；引用：无法直接复制一个ostream对象<br>第二个参数一般是一个常量引用<br>常量：打印对象不会改变内容；引用：避免赋值实参<br>一般返回ostream形参</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ostream&amp; operator&lt;&lt;(ostream&amp; os, const Sales_data&amp; item) &#123;</span><br><span class="line">	os &lt;&lt; item.isbn() &lt;&lt; &quot; &quot; &lt;&lt; item.units_sold &lt;&lt; &quot; &quot; &lt;&lt; item.revenue &lt;&lt; &quot; &quot; &lt;&lt; item.avg_price;</span><br><span class="line">	return os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入输出运算符必须是非成员函数，否则它左侧运算对象将是我们类的一个对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sales_data data;</span><br><span class="line">data &lt;&lt; cout;</span><br></pre></td></tr></table></figure>
<p>一般被声明成友元</p>
<h3 id="重载输入运算符-gt-gt"><a href="#重载输入运算符-gt-gt" class="headerlink" title="重载输入运算符&gt;&gt;"></a>重载输入运算符&gt;&gt;</h3><p>通常情况下，第一个形参是运算符将要读取的流的引用，第二个是将要读入到的(非常量)对象的引用。通常会返回某个给定流的引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">istream&amp; operator&gt;&gt;(istream&amp; is, Sales_data&amp; item) &#123;</span><br><span class="line">	double price;	&#x2F;&#x2F;不需要初始化</span><br><span class="line">	is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;</span><br><span class="line">	if (is)</span><br><span class="line">		item.revenue &#x3D; item.units_sold * price;</span><br><span class="line">	else</span><br><span class="line">		item &#x3D; Sales_data(); &#x2F;&#x2F;输入失败：对象被赋予默认的状态</span><br><span class="line">	return is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输入时的错误：<br>当流含有错误类型的数据是读取操作可能失败；当读取操作到达文件末尾或者遇到输入流的其他错误</p>
<h2 id="算术和关系运算符"><a href="#算术和关系运算符" class="headerlink" title="算术和关系运算符"></a>算术和关系运算符</h2><p>通常定义为非成员函数，形参是常量引用<br>如果同时定义了算术运算符合相关的复合赋值运算符，通常应该用复合赋值来实现算术运算符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sales_data operator+(const Sales_data&amp; lhs, const Sales_data&amp; rhs) &#123;</span><br><span class="line">	Sales_data sum &#x3D; lhs;</span><br><span class="line">	sum +&#x3D; rhs;</span><br><span class="line">	return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="相等运算符"><a href="#相等运算符" class="headerlink" title="相等运算符"></a>相等运算符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bool operator&#x3D;&#x3D;(const Sales_data&amp; lhs, const Sales_data&amp; rhs) &#123;</span><br><span class="line">	return lhs.isbn() &#x3D;&#x3D; rhs.isbn() &amp;&amp; lhs.units_sold &#x3D;&#x3D; rhs.units_sold &amp;&amp; lhs.revenue &#x3D;&#x3D; rhs.revenue;</span><br><span class="line">&#125;</span><br><span class="line">bool operator!&#x3D;(const Sales_data&amp; lhs, const Sales_data&amp; rhs) &#123;</span><br><span class="line">	return !(lhs &#x3D;&#x3D; rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>如果存在唯一一种逻辑可靠的&lt;定义，则应该考虑为这个类定义&lt;运算符。如果类同时还包含==，则当且仅当&lt;的定义和==产生的结果一致时才定义&lt;运算符</p>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class StrVec &#123;</span><br><span class="line">public:</span><br><span class="line">	StrVec&amp; operator&#x3D;(initialized_list&lt;string&gt;);</span><br><span class="line">&#125;;</span><br><span class="line">StrVec&amp; StrVec::operator&#x3D;(initialized_list&lt;string&gt; il) &#123;</span><br><span class="line">	&#x2F;&#x2F;alloc_n_copy分配内存空间并从给定范围内拷贝元素</span><br><span class="line">	auto data &#x3D; alloc_n_copy(il.begin(), il.end());</span><br><span class="line">	free();					&#x2F;&#x2F;销毁对象中的元素并释放内存空间</span><br><span class="line">	elements &#x3D; data.first;	&#x2F;&#x2F;更新数据成员并使其指向新内存空间</span><br><span class="line">	first_free &#x3D; cap &#x3D; data.second;</span><br><span class="line">	return*this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>赋值运算符必须定义成类的成员，复合赋值运算符通常也是。两种都返回左侧运算符对象的引用</p>
<h2 id="下标运算符"><a href="#下标运算符" class="headerlink" title="下标运算符"></a>下标运算符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class StrVec &#123;</span><br><span class="line">public:</span><br><span class="line">	string&amp; operator[](size_t n) &#123;</span><br><span class="line">		return elements[n];</span><br><span class="line">	&#125;</span><br><span class="line">	const string&amp; operator[](size_t n)const &#123;</span><br><span class="line">		return elements[n];</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	string* elements;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通常定义返回普通引用和作为常量成员且返回常量引用，两个版本。返回元素的引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const StrVec cvec &#x3D; svec;</span><br><span class="line">if (svec.size() &amp;&amp; svec[0].empty()) &#123;</span><br><span class="line">	svec[0] &#x3D; &quot;zero&quot;;	&#x2F;&#x2F;正确：下标运算符返回string的引用</span><br><span class="line">	cvec[0] &#x3D; &quot;zip&quot;;	&#x2F;&#x2F;错误：对cvec取下标返回的是常量引用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="递增和递减运算符"><a href="#递增和递减运算符" class="headerlink" title="递增和递减运算符"></a>递增和递减运算符</h2><p>它们改变的正好是操作对象的状态，所以建议将其设为成员函数</p>
<p>前置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class StrBlobPtr &#123;</span><br><span class="line">public:</span><br><span class="line">	StrBlobPtr&amp; operator++();</span><br><span class="line">	StrBlobPtr&amp; operator--();</span><br><span class="line">&#125;;</span><br><span class="line">StrBlobPtr&amp; StrBlobPtr::operator++() &#123;</span><br><span class="line">	&#x2F;&#x2F;如果已经指向容器尾后，则无法递增</span><br><span class="line">	check(curr, &quot;increment past end of StrBlobPtr&quot;);</span><br><span class="line">	++curr;</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br><span class="line">StrBlobPtr&amp; StrBlobPtr::operator--() &#123;</span><br><span class="line">	--curr;</span><br><span class="line">	check(curr, &quot;decrement past begin of StrBlobPtr&quot;);</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>区分前置后置<br>后置版本接受一个额外的(不被使用)int类型的形参。使用时编译器为这个形参提供一个值为0的实参</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class StrBlobPtr &#123;</span><br><span class="line">public:</span><br><span class="line">	StrBlobPtr operator++(int);</span><br><span class="line">	StrBlobPtr operator--(int);</span><br><span class="line">&#125;;</span><br><span class="line">StrBlobPtr StrBlobPtr::operator++(int) &#123;</span><br><span class="line">	StrBlobPtr ret &#x3D; *this;	&#x2F;&#x2F;记录当前值</span><br><span class="line">	++* this;				&#x2F;&#x2F;向前移动一个元素，前置++需要检查递增的有效性</span><br><span class="line">	return ret;				&#x2F;&#x2F;返回之前记录的状态</span><br><span class="line">&#125;</span><br><span class="line">StrBlobPtr StrBlobPtr::operator--(int) &#123;</span><br><span class="line">	StrBlobPtr ret &#x3D; *this;	&#x2F;&#x2F;记录当前值</span><br><span class="line">	--* this;				&#x2F;&#x2F;向后移动一个元素，前置--需要检查递增的有效性</span><br><span class="line">	return ret;				&#x2F;&#x2F;返回之前记录的状态</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后置运算符调用各自的前置版本来完成实际的工作</p>
<p>显式调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StrBlobPtr p(a1);</span><br><span class="line">p.operator++(0);	&#x2F;&#x2F;后置</span><br><span class="line">p.operator++();		&#x2F;&#x2F;前置</span><br></pre></td></tr></table></figure>
<h2 id="成员访问运算符"><a href="#成员访问运算符" class="headerlink" title="成员访问运算符"></a>成员访问运算符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class StrBlobPtr &#123;</span><br><span class="line">public:</span><br><span class="line">	string&amp; operator*()const &#123;</span><br><span class="line">		auto p &#x3D; check(curr, &quot;dereference past end&quot;);</span><br><span class="line">		return (*p)[curr];	&#x2F;&#x2F;(*p)是对象所指的vector</span><br><span class="line">	&#125;</span><br><span class="line">	string* operator-&gt;()const &#123;</span><br><span class="line">		return&amp;this-&gt;operator*();	&#x2F;&#x2F;实际将工作委托给解引用运算符</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>解引用运算符首先检查curr是否仍在作用范围内，是则返回curr所指元素的一个引用<br>箭头运算符不执行任何自己的操作，而是调用解引用运算符并返回解引用结果元素的地址<br>箭头运算符必须是类的成员，解引用通常也是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StrBlob a1 &#x3D; &#123; &quot;hi&quot;,&quot;bye&quot;,&quot;now&quot; &#125;;</span><br><span class="line">StrBlobPtr p(a1);		&#x2F;&#x2F;p指向a1中的vector</span><br><span class="line">*p &#x3D; &quot;okay&quot;;			&#x2F;&#x2F;给a1的首元素赋值</span><br><span class="line">cout &lt;&lt; p-&gt;size();		&#x2F;&#x2F;打印4，a1首元素的大小</span><br><span class="line">cout &lt;&lt; (*p).size();	&#x2F;&#x2F;等价于p-&gt;size()</span><br></pre></td></tr></table></figure>
<p>箭头运算符永远不能丢掉成员访问这个最基本的含义<br>point-&gt;men分别等价于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(*point).mem;			&#x2F;&#x2F;point是一个内置的指针类型</span><br><span class="line">point.operator()-&gt;mem;	&#x2F;&#x2F;point是一个类的对象</span><br></pre></td></tr></table></figure>
<h2 id="函数调用运算符"><a href="#函数调用运算符" class="headerlink" title="函数调用运算符"></a>函数调用运算符</h2><p>如果类重载了函数调用运算符，则可以像使用函数一样使用该类的对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct absInt &#123;</span><br><span class="line">	int operator()(int val)const &#123;</span><br><span class="line">		return val &gt; 0 ? val : -val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int i &#x3D; 42;</span><br><span class="line">absInt absObj;		&#x2F;&#x2F;含有函数调用运算符的对象</span><br><span class="line">int ui &#x3D; absObj(i);	&#x2F;&#x2F;将i传递给absObj.operator()</span><br></pre></td></tr></table></figure>
<p>即使absObj只是一个对象而非函数，也能”调用”该对象。实际上是运行重载的调用运算符<br>如果类定义了调用运算符，则该类的对象称作函数对象(function object)。这些对象的行为像函数一样</p>
<p>含有状态的函数对象类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class PrintString &#123;</span><br><span class="line">public;</span><br><span class="line">	PrintString(ostream&amp; o &#x3D; cout, char c &#x3D; &#39; &#39;) :os(o), sep(c) &#123; &#125;</span><br><span class="line">	void operator()(const string&amp; s)const &#123; os &lt;&lt; s &lt;&lt; sep; &#125;</span><br><span class="line">private:</span><br><span class="line">	ostream&amp; os;	&#x2F;&#x2F;用于写入目的的流</span><br><span class="line">	char sep;		&#x2F;&#x2F;用于将不同输出隔开的字符</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>定义PringString对象时，分隔符及输出流可以使用默认也可以提供自己的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PrintString printer;			&#x2F;&#x2F;使用默认值，打印到cout</span><br><span class="line">printer(s);						&#x2F;&#x2F;在cout中打印s后跟空格</span><br><span class="line">PrintString errors(cerr, &#39;\n&#39;);	</span><br><span class="line">errors(s);						&#x2F;&#x2F;在cerr中打印s后跟换行符</span><br></pre></td></tr></table></figure>
<p>函数对象也作为泛型算法的实参<br>for_each(vs.begin(), vs.end(), PrintString(cerr, ‘\n’));</p>
<h3 id="lambda是函数对象"><a href="#lambda是函数对象" class="headerlink" title="lambda是函数对象"></a>lambda是函数对象</h3><p>当编写了一个lambda后，编译器将该表达式翻译成一个未命名类的未命名对象。在lambda表达式产生的类中含有一个重载的函数调用运算符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stable_sort(words.begin(), words.end(), [](const string&amp; a, const string&amp; b) &#123;return a.size() &lt; b.size(); &#125;);</span><br></pre></td></tr></table></figure>
<p>其行为类似：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class ShorterString &#123;</span><br><span class="line">public:</span><br><span class="line">	bool operator()(const string&amp; a, const string&amp; b)const &#123; return a.size() &lt; b.size(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>默认情况下，lambda不能改变它捕获的变量，所以产生的类当中的函数调用运算符是一个const成员函数；若lambda声明为可变的，则不是const<br>stable_sort(words.begin(), words.end(), ShorterString());</p>
<p>表示lambda及相应捕获行为的类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto wc &#x3D; find_if(words.begin(), words.end(), [sz](const string &amp; a) &#123;return a.size() &gt;&#x3D; sz; &#125;)</span><br></pre></td></tr></table></figure>
<p>lambda产生的类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class SizeComp &#123;</span><br><span class="line">public:</span><br><span class="line">	SizeComp(size_t n) :sz(n) &#123;&#125;</span><br><span class="line">	bool operator()(const string&amp; a)const &#123; return s.size() &gt;&#x3D; sz; &#125;</span><br><span class="line">private:</span><br><span class="line">	size_t sz;</span><br><span class="line">&#125;;</span><br><span class="line">auto wc &#x3D; find_if(words.begin(), words.end(), SizeComp(sz));</span><br></pre></td></tr></table></figure>
<h3 id="标准库定义的函数对象"><a href="#标准库定义的函数对象" class="headerlink" title="标准库定义的函数对象"></a>标准库定义的函数对象</h3><p>——————————————————510</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plus&lt;int&gt; intAdd;</span><br><span class="line">negate&lt;int&gt; intNegate;</span><br><span class="line">&#x2F;&#x2F;使用intAdd::operator(int,int)求和</span><br><span class="line">int sum &#x3D; intAdd(10, 20);		&#x2F;&#x2F;sum&#x3D;30</span><br><span class="line">sum &#x3D; intNegate(intAdd(10, 20));&#x2F;&#x2F;sum&#x3D;-30</span><br><span class="line">sum &#x3D; intAdd(10, intNegate(10));&#x2F;&#x2F;sum&#x3D;0</span><br></pre></td></tr></table></figure>
<p>传入一个临时函数对象用于执行两个string对象&gt;比较运算<br>sort(svec.begin(), svec.end(), greater<string>());    //降序</p>
<p>比较两个无关指针将产生未定义的行为。通过比较指针的内存地址来sort指针的vector</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string*&gt;nameTable;</span><br><span class="line">&#x2F;&#x2F;错误：nameTable中的指针彼此没有联系，&lt;将产生未定义的行为</span><br><span class="line">sort(nameTable.begin(), nameTable.end(), [](string* a, string* b) &#123;return a &lt; b; &#125;);</span><br><span class="line">&#x2F;&#x2F;正确：标准库规定指针的less是定义良好的</span><br><span class="line">sort(nameTable.begin(), nameTable.end(), less&lt;string*&gt;());</span><br></pre></td></tr></table></figure>
<h3 id="可调用对象与function"><a href="#可调用对象与function" class="headerlink" title="可调用对象与function"></a>可调用对象与function</h3><p>c++中可调用对象：函数、函数指针、lambda表达式、bind创建的对象以及冲在了函数调用运算符的类<br>调用形式(call signature)指明了调用返回的类型以及传递给调用的实参类型。一种调用形式对应一个函数类型</p>
<p>不同类型可能具有相同的调用形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;普通函数</span><br><span class="line">int add(int i, int j) &#123; return i + j; &#125;</span><br><span class="line">&#x2F;&#x2F;lambda，产生一个未命名的函数对象类</span><br><span class="line">auto mod &#x3D; [](int i, int j) &#123;return i % j; &#125;;</span><br><span class="line">&#x2F;&#x2F;函数对象类</span><br><span class="line">struct divide &#123;</span><br><span class="line">	int operator()(int denominator, int divisor) &#123;</span><br><span class="line">		return denominator &#x2F; divisor;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这些共享一种调用形式：int(int, int)</p>
<p>定义一个函数表(function table)用于储存指向这些可调用对象的”指针”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;构建从运算符到函数指针的映射关系</span><br><span class="line">map&lt;string, int(*)(int, int)&gt;binops;</span><br><span class="line">&#x2F;&#x2F;正确：add是一个指向正确类型的函数指针</span><br><span class="line">binops.insert(&#123; &#39;+&#39;,add &#125;);</span><br></pre></td></tr></table></figure>
<p>但不能将mod或者divide存入binops，因为mod不是一个函数指针<br>可以通过function新标准库类型来解决<br>——————————————————————– - 512<br>function是一个模板</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function&lt;int(int, int)&gt;, 声明了一个function类型，表示一个接受两个int，返回一个int的可调用对象</span><br><span class="line">function&lt;int(int, int)&gt;f1 &#x3D; add;				&#x2F;&#x2F;函数指针</span><br><span class="line">function&lt;int(int, int)&gt;f2 &#x3D; divide();			&#x2F;&#x2F;函数对象类的对象</span><br><span class="line">function&lt;int(int, int)&gt;f3 &#x3D; [](int i, int j) &#123;	&#x2F;&#x2F;lambda</span><br><span class="line">	return i * j;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>利用function可以重新定义map</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, function&lt;int(int, int)&gt;&gt;binops &#x3D; &#123;</span><br><span class="line">	&#123;&quot;+&quot;,add&#125;,</span><br><span class="line">	&#123;&quot;-&quot;,minus&lt;int&gt;()&#125;,</span><br><span class="line">	&#123;&quot;&#x2F;&quot;,divide()&#125;,</span><br><span class="line">	&#123;&quot;*&quot;,[](int i,int j) &#123;return i * j; &#125;&#125;,</span><br><span class="line">	&#123;&quot;%&quot;,mod&#125;</span><br><span class="line">&#125;</span><br><span class="line">binops[&quot;+&quot;](10, 5);</span><br></pre></td></tr></table></figure>
<p>重载的函数与function<br>不能直接将重载函数的名字存入function类型的对象中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int add(int i, int j) &#123; return i + j; &#125;</span><br><span class="line">Sales_data add(const Sales_data&amp;, const Sales_data%);</span><br><span class="line">map&lt;string, function&lt;int(int, int)&gt;&gt;binops;</span><br><span class="line">binpos.insert(&#123; &quot;+&quot;,add &#125;);	&#x2F;&#x2F;错误：哪个？</span><br></pre></td></tr></table></figure>
<p>可以通过存储函数指针而非函数名字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int (*fp)(int, int) &#x3D; add;	&#x2F;&#x2F;指针所指的add是接受两个int的版本</span><br><span class="line">binops.insert(&#123; &quot;+&quot;,fp &#125;);	&#x2F;&#x2F;正确：fp指向一个正确的add版本</span><br><span class="line">也可以通过lambda来消除二义性</span><br><span class="line">binops.insert(&#123; &quot;+&quot;,[](int a,int b) &#123;return a + b; &#125; &#125;);</span><br></pre></td></tr></table></figure>
<h2 id="重载、类型转换与运算符"><a href="#重载、类型转换与运算符" class="headerlink" title="重载、类型转换与运算符"></a>重载、类型转换与运算符</h2><h3 id="类型转换运算符-conversion-operator"><a href="#类型转换运算符-conversion-operator" class="headerlink" title="类型转换运算符(conversion operator)"></a>类型转换运算符(conversion operator)</h3><p>是类的一种特殊成员函数，负责将一个类类型的值转换成其他类型<br>operator type() const;<br>类型转换运算符可以面向任意类型(void除外)进行定义，只要该类型能作为函数的返回类型。所以不允许转换成数组或者函数<br>可以转换成指针或者引用<br>类型转换运算符没有显式的返回类型，也没有形参，一般是const成员</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class SmallInt &#123;</span><br><span class="line">public:</span><br><span class="line">	SmallInt(int i &#x3D; 0) :val(i) &#123;</span><br><span class="line">		if (i &lt; 0 || i&gt;255)throw out_of_range(&quot;bad smallInt value&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	operator int() const &#123; return val; &#125;</span><br><span class="line">private:</span><br><span class="line">	size_t val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>构造函数将算术类型的值转换为SmallInt对象，而类型转换运算符将SmallInt对象转换为int</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SmallInt si;</span><br><span class="line">si &#x3D; 4;	&#x2F;&#x2F;首先将4隐式地转换成SmallInt，然后调用operator &#x3D;</span><br><span class="line">si + 3;	&#x2F;&#x2F;首先将si隐式地转换成int，然后进行加法</span><br></pre></td></tr></table></figure>
<p>显式的类型转换运算符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class SmallInt &#123;</span><br><span class="line">public:</span><br><span class="line">	explicit operator int() const &#123; return val; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>编译器不会将一个显式的类型转换运算符用于隐式的类型转换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SmallInt si &#x3D; 3;			&#x2F;&#x2F;正确：SmallInt的构造函数不是显式的</span><br><span class="line">si + 3;						&#x2F;&#x2F;错误：此处需要隐式的类型转换，但类的运算符是显式的</span><br><span class="line">static_cast&lt;int&gt;(si) + 3;	&#x2F;&#x2F;正确：显式地请求类型转换</span><br></pre></td></tr></table></figure>
<p>例外：以下位置将隐式的进行<br>·if,while,do语句的条件部分<br>·for语句头的条件表达式<br>·逻辑非！、逻辑或运算符||、逻辑与运算符&amp;&amp;的运算对象<br>·条件运算符?:的条件表达式</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/30/c-primer-14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" data-id="ckhq93ptu000xa0ve4cqnc0p2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-primer/" rel="tag">c++ primer</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/02-cpp-primer/" rel="tag">02 cpp primer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c-primer/" rel="tag">c++ primer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cocos2d-x/" rel="tag">cocos2d-x</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpp-notes/" rel="tag">cpp notes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/problem-library/" rel="tag">problem library</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reading-notes-DS/" rel="tag">reading notes DS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%82%93%E4%BF%8A%E8%BE%89/" rel="tag">数据结构 邓俊辉</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/02-cpp-primer/" style="font-size: 14px;">02 cpp primer</a> <a href="/tags/c-primer/" style="font-size: 16px;">c++ primer</a> <a href="/tags/cocos2d-x/" style="font-size: 12px;">cocos2d-x</a> <a href="/tags/cpp-notes/" style="font-size: 20px;">cpp notes</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/problem-library/" style="font-size: 16px;">problem library</a> <a href="/tags/reading-notes-DS/" style="font-size: 10px;">reading notes DS</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%82%93%E4%BF%8A%E8%BE%89/" style="font-size: 18px;">数据结构 邓俊辉</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/11/19/ncpp-06/">第6章 函数</a>
          </li>
        
          <li>
            <a href="/2020/11/18/ncpp-05/">第5章 语句</a>
          </li>
        
          <li>
            <a href="/2020/11/17/ncpp-04/">第4章 表达式</a>
          </li>
        
          <li>
            <a href="/2020/11/16/%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/">操作方法</a>
          </li>
        
          <li>
            <a href="/2020/11/16/ncpp-03/">第3章 字符串、向量和数组</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>